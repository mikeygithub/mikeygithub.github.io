

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <meta name="referrer" content="no-referrer"/>
  <link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/favicon.png">
  <link rel="icon" href="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Mikey">
  <meta name="keywords" content="">
  
    <meta name="description" content="必备知识遍历方式 在树的题目当中主要围绕着,前序、中序、后续、广度、深度遍历来进行解题，所以掌握其十分重要，直接上迭代版本，递归太简单就不上了  前序遍历-通过栈实现(先压入右结点) 1234567891011121314151617181920class Solution &amp;#123;  public List&lt;Integer&gt; preorderTraversal(TreeNode">
<meta property="og:type" content="article">
<meta property="og:title" content="算法笔记-二叉树&#x2F;线段树&#x2F;排序树">
<meta property="og:url" content="https://mikeygithub.github.io/2019/10/10/yuque/ubx7qo/index.html">
<meta property="og:site_name" content="麦奇">
<meta property="og:description" content="必备知识遍历方式 在树的题目当中主要围绕着,前序、中序、后续、广度、深度遍历来进行解题，所以掌握其十分重要，直接上迭代版本，递归太简单就不上了  前序遍历-通过栈实现(先压入右结点) 1234567891011121314151617181920class Solution &amp;#123;  public List&lt;Integer&gt; preorderTraversal(TreeNode">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/2630542/1673112982757-5ae72879-a909-4654-a75e-8c64152f29ca.png">
<meta property="article:published_time" content="2019-10-10T09:24:22.000Z">
<meta property="article:modified_time" content="2023-03-30T11:31:36.087Z">
<meta property="article:author" content="Mikey">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2023/png/2630542/1673112982757-5ae72879-a909-4654-a75e-8c64152f29ca.png">
  
  
<!--    <meta name="referrer" content="no-referrer-when-downgrade">-->
  
  
  <title>算法笔记-二叉树/线段树/排序树 - 麦奇</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"mikeygithub.github.io","root":"/","version":"1.9.1","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":200}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"74301a15e5497361e93588eeee69f4b2","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="麦奇" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>麦奇</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/photo/">
                <i class="iconfont icon-image"></i>
                照片
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/music/">
                <i class="iconfont icon-music"></i>
                音乐
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/atom.xml">
                <i class="iconfont icon-rss"></i>
                RSS
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="算法笔记-二叉树/线段树/排序树"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Mikey
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2019-10-10 17:24" pubdate>
          2019年10月10日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          59k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          494 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">算法笔记-二叉树/线段树/排序树</h1>
            
            <div class="markdown-body">
              
              <p><img src="https://cdn.nlark.com/yuque/0/2023/png/2630542/1673112982757-5ae72879-a909-4654-a75e-8c64152f29ca.png#averageHue=%23fdfdfc&clientId=uaecdb1ff-7638-4&from=paste&height=428&id=u5d0a3bd0&name=image.png&originHeight=1374&originWidth=2166&originalType=binary&ratio=1&rotation=0&showTitle=false&size=537603&status=done&style=none&taskId=u48106a76-0c9c-47a3-907c-cc0d562e68f&title=&width=675" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h1 id="必备知识"><a href="#必备知识" class="headerlink" title="必备知识"></a>必备知识</h1><h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><blockquote>
<p>在树的题目当中主要围绕着,前序、中序、后续、广度、深度遍历来进行解题，所以掌握其十分重要，直接上迭代版本，递归太简单就不上了</p>
</blockquote>
<h3 id="前序遍历-通过栈实现"><a href="#前序遍历-通过栈实现" class="headerlink" title="前序遍历-通过栈实现"></a>前序遍历-通过栈实现</h3><p>(先压入右结点)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>      <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>          Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>          stack.push(root);<br>          <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>              <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> stack.pop();<br>              list.add(tmp.val);<br>              <span class="hljs-keyword">if</span> (tmp.right != <span class="hljs-literal">null</span>)<br>                  stack.push(tmp.right);<br>              <span class="hljs-keyword">if</span> (tmp.left != <span class="hljs-literal">null</span>)<br>                  stack.push(tmp.left);<br>          &#125;<br>          <span class="hljs-keyword">return</span> list;<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="中序遍历-通过栈实现"><a href="#中序遍历-通过栈实现" class="headerlink" title="中序遍历-通过栈实现"></a>中序遍历-通过栈实现</h3><p>(一路向左把沿途结点压入栈)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>      <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>          List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>          <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>              <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">// 一路向左把沿途结点压入栈</span><br>                  stack.push(root);<br>                  root = root.left;<br>              &#125;<br>              <span class="hljs-keyword">if</span> (!stack.isEmpty()) &#123;<br>                  root = stack.pop();<span class="hljs-comment">// 弹出栈</span><br>                  list.add(root.val);<br>                  root = root.right;<span class="hljs-comment">// 转向右节点</span><br>              &#125;<br>          &#125;<br>          <span class="hljs-keyword">return</span> list;<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="后序遍历-通过栈实现"><a href="#后序遍历-通过栈实现" class="headerlink" title="后序遍历-通过栈实现"></a>后序遍历-通过栈实现</h3><p>(前序先push-left再reverse)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTreversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>      <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>          Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>          stack.push(root);<br>          <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>              <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> stack.pop();<br>              list.add(tmp.val);<br>              <span class="hljs-keyword">if</span> (tmp.left != <span class="hljs-literal">null</span>) &#123;<br>                  stack.push(tmp.left);<br>              &#125;<br>              <span class="hljs-keyword">if</span> (tmp.right != <span class="hljs-literal">null</span>) &#123;<br>                  stack.push(tmp.right);<br>              &#125;<br>          &#125;<br>          Collections.reverse(list);<br>          <span class="hljs-keyword">return</span> list;<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="广度优先-通过队列实现"><a href="#广度优先-通过队列实现" class="headerlink" title="广度优先-通过队列实现"></a>广度优先-通过队列实现</h3><blockquote>
<p>借助队列</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">BFS</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (!Objects.isNull(root)) queue.add(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<span class="hljs-comment">//出队</span><br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) queue.add(node.left);<br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) queue.add(node.right);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="深度优先-通过栈实现"><a href="#深度优先-通过栈实现" class="headerlink" title="深度优先-通过栈实现"></a>深度优先-通过栈实现</h3><blockquote>
<p>借助栈</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">DFS</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack.push(root);<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> stack.pop();<br>            list.add(tmp.val);<br>            <span class="hljs-keyword">if</span> (tmp.left != <span class="hljs-literal">null</span>) stack.push(tmp.left);<br>            <span class="hljs-keyword">if</span> (tmp.right != <span class="hljs-literal">null</span>) stack.push(tmp.right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="数类型"><a href="#数类型" class="headerlink" title="数类型"></a>数类型</h2><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p>是一种非常灵活的数据结构，它可以用于解决多种范围查询问题，比如在对数时间内从数组中找到最小值、最大值、总和、最大公约数、最小公倍数等。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1646919487723-b343306d-daae-4322-ab9e-607c0e518ae6.png#averageHue=%23fbfbfb&clientId=u84969e76-747b-4&from=paste&id=u3f1a9bf6&originHeight=1002&originWidth=1180&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1fe01559-f200-48df-84ee-6564bb5b9fa&title=" srcset="/img/loading.gif" lazyload><br>数组 A[0,1,…,n−1] 的线段树是一个二叉树，其中每个节点都包含数组的一个子范围 [i…j] 上的聚合信息（最小值、最大值、总和等），其左、右子节点分别包含范围 <img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1646921361294-7dbfaf2a-3516-4491-a663-457f82672b31.png#averageHue=%23f2f2f1&clientId=u84969e76-747b-4&from=paste&height=39&id=u5ec9d6e1&name=image.png&originHeight=78&originWidth=344&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17873&status=done&style=none&taskId=ue3e6af41-e7df-48b3-918d-7262f59dafc&title=&width=172" srcset="/img/loading.gif" lazyload alt="image.png">上的信息。</p>
<p>线段树既可以用数组也可以用树来实现。对于数组实现，如果索引 i 处的元素不是一个叶节点，那么其左子节点和右子节点分别存储在索引为 2i 和 2i+1 的元素处。</p>
<p>在上图所给出的示例中，每个叶节点都包含初始的数组元素 {2,4,5,7,8,9}。内部节点包含范围内相应元素的总和 - (11) 是从索引 0 到索引 2 的元素之和。而根节点 (35) 是它的两个子节点 (6) 和 (29) 的和,也是整个数组的和。</p>
<p>线段树可以分为以下三个步骤：</p>
<p>1.从给定数组构建线段树的预处理步骤。<br>2.修改元素时更新线段树。<br>3.使用线段树进行区域和检索。</p>
<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h4 id="平衡二叉树-简单"><a href="#平衡二叉树-简单" class="headerlink" title="平衡二叉树(简单)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof">平衡二叉树(简单)</a></h4><p>判断是否是平衡二叉树</p>
<blockquote>
<p>判断树是否为平衡二叉树</p>
</blockquote>
<p>测试用例<br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/balance_binary_tree.jpg#id=HNXny&originHeight=221&originWidth=342&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="/img/loading.gif" lazyload><br>输入：root = [3,9,20,null,null,15,7]<br>输出：true<br>解题思路</p>
<blockquote>
<p>平衡二叉树：左右子树高度差不超过一，根据这一特点，递归判断各个节点的子树是否符合条件，不满足则直接返回false,直到递归完成。</p>
</blockquote>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断是否为平衡二叉树(自顶向下O(n^2))</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> Math.abs(height(root.left) - height(root.right)) &lt;= <span class="hljs-number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取当前节点树高度</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">height</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> Math.max(height(root.left), height(root.right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//自底向上</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> depth(root)&gt;=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">depth</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> depth(root.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> depth(root.right);<br>        <span class="hljs-keyword">if</span>(left==-<span class="hljs-number">1</span>||right==-<span class="hljs-number">1</span>||Math.abs(left-right)&gt;<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> Math.max(left,right)+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="特定深度节点链表-中等"><a href="#特定深度节点链表-中等" class="headerlink" title="特定深度节点链表(中等)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/list-of-depth-lcci">特定深度节点链表(中等)</a></h4><p>特定深度节点链表<br>题目描述</p>
<blockquote>
<p>给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 D，则会创建出 D 个链表）。返回一个包含所有深度的链表的数组。</p>
</blockquote>
<p>示例<br>输入：[1,2,3,4,5,null,7,8]</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">    <span class="hljs-number">1</span><br>   /  <span class="hljs-string">\</span> <br>  <span class="hljs-number">2</span>    <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span>    <span class="hljs-string">\</span> <br><span class="hljs-number">4</span>   <span class="hljs-number">5</span>    <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>
<p>/ 8<br>输出：[[1],[2,3],[4,5,7],[8]]<br>实现思路</p>
<blockquote>
<p>通过广度优先遍历对树进行逐层遍历构造链表，通过每一次获取当前队列长度读取当前层的元素个数(关键)</p>
</blockquote>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode[] listOfDepth(TreeNode tree) &#123;<br><br>        List&lt;ListNode&gt; listNodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//广度优先遍历</span><br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.add(tree);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<span class="hljs-comment">//队列大小（核心）</span><br>            ListNode head, tmp;<br>            head = tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//链表临时头节点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<span class="hljs-comment">//循环当前层元素</span><br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">treeNode</span> <span class="hljs-operator">=</span> queue.poll();<span class="hljs-comment">//从对头取当前元素</span><br>                <span class="hljs-comment">//构建链表</span><br>                tmp.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(treeNode.val);<br>                tmp = tmp.next;<br>                <span class="hljs-comment">//将下一层元素压入队列</span><br>                <span class="hljs-keyword">if</span> (treeNode.left != <span class="hljs-literal">null</span>) queue.add(treeNode.left);<br>                <span class="hljs-keyword">if</span> (treeNode.right != <span class="hljs-literal">null</span>) queue.add(treeNode.right);<br>            &#125;<br>            <span class="hljs-comment">//将每一条链表添加到list中</span><br>            listNodes.add(head.next);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> listNodes.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>[]&#123;&#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="N叉树的前序遍历-简单"><a href="#N叉树的前序遍历-简单" class="headerlink" title="N叉树的前序遍历(简单)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal">N叉树的前序遍历(简单)</a></h4><p>N叉树的前序遍历<br>题目描述<br>给定一个 N 叉树，返回其节点值的前序遍历。<br>例如，给定一个 3叉树 :<br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/n-tree.png#id=bgaBV&originHeight=502&originWidth=781&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="/img/loading.gif" lazyload><br>返回其前序遍历: [1,3,5,6,2,4]。<br>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tree</span> &#123;<br>   List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>   <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorder</span><span class="hljs-params">(Node root)</span> &#123;<br>       list.add(root.val);<br>       <span class="hljs-comment">//遍历子节点</span><br>       root.children.forEach(v -&gt; &#123;<br>           preorder(v);<br>       &#125;);<br>       <span class="hljs-keyword">return</span> list;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorder</span><span class="hljs-params">(Node root)</span> &#123;<br>       <span class="hljs-comment">//容器</span><br>       List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>       Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>       <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> list;<br>       &#125;<br>       <span class="hljs-comment">//首个节点</span><br>       stack.push(root);<br>       <span class="hljs-comment">//迭代</span><br>       <span class="hljs-keyword">while</span> (!stack.empty()) &#123;<br>           <span class="hljs-type">Node</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> stack.pop();<span class="hljs-comment">//出栈</span><br>           list.add(tmp.val);<span class="hljs-comment">//插入值</span><br>           Collections.reverse(tmp.children);<span class="hljs-comment">//将子节点进行反转</span><br>           tmp.children.forEach(v -&gt; stack.push(v));<span class="hljs-comment">//压栈</span><br>       &#125;<br>       <span class="hljs-comment">//返回结果</span><br>       <span class="hljs-keyword">return</span> list;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>递归版</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorder</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        ans.add(root.val);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;root.children.size();i++)&#123;<br>            preorder(root.children.get(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="559-N-叉树的最大深度"><a href="#559-N-叉树的最大深度" class="headerlink" title="559. N 叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(Node node:root.children)&#123;<br>            max = Math.max(max,maxDepth(node));<br>        &#125;<br>        <span class="hljs-keyword">return</span> max + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="429-N-叉树的层序遍历（mid）"><a href="#429-N-叉树的层序遍历（mid）" class="headerlink" title="429. N 叉树的层序遍历（mid）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/">429. N 叉树的层序遍历</a>（mid）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//BFS</span><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(Node root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> ret;<br>        LinkedList&lt;Node&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.pop();<br>                list.add(node.val);<br>                <span class="hljs-keyword">if</span>(node.children!=<span class="hljs-literal">null</span>&amp;&amp;node.children.size()&gt;<span class="hljs-number">0</span>)queue.addAll(node.children);<br>            &#125;<br>            ret.add(list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="最大二叉树-中等"><a href="#最大二叉树-中等" class="headerlink" title="最大二叉树(中等)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-binary-tree">最大二叉树(中等)</a></h4><p>最大二叉树<br>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：<br>二叉树的根是数组中的最大元素。 左子树是通过数组中最大值左边部分构造出的最大二叉树。 右子树是通过数组中最大值右边部分构造出的最大二叉树。 通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p>
<p>示例 ：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入：[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>]<br>输出：返回下面这棵树的根节点：<br><br>      <span class="hljs-number">6</span><br>    /   <span class="hljs-string">\</span><br>   <span class="hljs-number">3</span>     <span class="hljs-number">5</span><br>    <span class="hljs-string">\</span>    / <br>     <span class="hljs-number">2</span>  <span class="hljs-number">0</span>   <br>       <span class="hljs-string">\</span><br>        <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>提示：给定的数组的大小在 [1, 1000] 之间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">constructMaximumBinaryTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">return</span> build(nums,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-keyword">if</span>(start&gt;end)<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxIndex</span> <span class="hljs-operator">=</span> start;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start+<span class="hljs-number">1</span>;i&lt;=end;i++)<span class="hljs-keyword">if</span>(nums[i]&gt;nums[maxIndex])maxIndex=i;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(nums[maxIndex]);<br>        ret.left = build(nums,start,maxIndex-<span class="hljs-number">1</span>);<br>        ret.right = build(nums,maxIndex+<span class="hljs-number">1</span>,end);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="最大二叉树-II-中等"><a href="#最大二叉树-II-中等" class="headerlink" title="最大二叉树 II(中等)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-binary-tree-ii">最大二叉树 II(中等)</a></h4><p>最大树定义：一个树，其中每个节点的值都大于其子树中的任何其他值。<br>给出最大树的根节点 root。<br>就像之前的问题那样，给定的树是从表 A（root = Construct(A)）递归地使用下述 Construct(A) 例程构造的：<br>如果 A 为空，返回 null 否则，令 A[i] 作为 A 的最大元素。创建一个值为 A[i] 的根节点 root root 的左子树将被构建为 Construct([A[0], A[1], …, A[i-1]])<br>root 的右子树将被构建为 Construct([A[i+1], A[i+2], …, A[A.length - 1]])<br>返回 root 请注意，我们没有直接给定 A，只有一个根节点 root = Construct(A).<br>假设 B 是 A 的副本，并附加值 val。保证 B 中的值是不同的。<br>返回 Construct(B)。</p>
<p>示例 1：<br>输入：root = [4,1,3,null,null,2], val = 5 输出：[5,4,null,1,3,null,null,2]<br>解释：A = [1,4,2,3], B = [1,4,2,3,5]<br>示例 2：<br>输入：root = [5,2,4,null,1], val = 3 输出：[5,2,4,null,1,null,3]<br>解释：A = [2,1,5,4], B = [2,1,5,4,3]<br>示例 3：<br>输入：root = [5,2,3,null,1], val = 4 输出：[5,2,4,null,1,3]<br>解释：A = [2,1,5,3], B = [2,1,5,3,4]<br>提示：<br>1 &lt;= B.length &lt;= 100</p>
<h4 id="二叉搜索树的第k大节点-简单"><a href="#二叉搜索树的第k大节点-简单" class="headerlink" title="二叉搜索树的第k大节点(简单)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof">二叉搜索树的第k大节点(简单)</a></h4><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs livescript">示例 <span class="hljs-number">1</span>:<br><br>输入: root = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>], k = <span class="hljs-number">1</span><br>   <span class="hljs-number">3</span><br>  / <span class="hljs-string">\</span><br> <span class="hljs-number">1</span>   <span class="hljs-number">4</span><br>  <span class="hljs-string">\</span><br>   <span class="hljs-number">2</span><br>输出: <span class="hljs-number">4</span><br>示例 <span class="hljs-number">2</span>:<br><br>输入: root = [<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">3</span><br>       <span class="hljs-number">5</span><br>      / <span class="hljs-string">\</span><br>     <span class="hljs-number">3</span>   <span class="hljs-number">6</span><br>    / <span class="hljs-string">\</span><br>   <span class="hljs-number">2</span>   <span class="hljs-number">4</span><br>  /<br> <span class="hljs-number">1</span><br>输出: <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>
<p>限制： 1 ≤ k ≤ 二叉搜索树元素个数<br>解题思路</p>
<blockquote>
<p>二叉搜索树、通过中许遍历得到递增序列、那么优先改变一下，从右子树先遍历即可得到递减序列</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//递归中序</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthLargest</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// clarification:  root == null?   k &lt;= 1?</span><br>        helper(root, k);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) helper(root.right, k);<br>        <span class="hljs-keyword">if</span> (++count == k) &#123;<br>            ans = root.val;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) helper(root.left, k);<br>    &#125;<br>    <span class="hljs-comment">//中序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthLargest</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> k)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(root!=<span class="hljs-literal">null</span>||!stack.isEmpty())&#123;<br>            <span class="hljs-keyword">while</span>(root!=<span class="hljs-literal">null</span>)&#123;<br>                stack.push(root);<br>                root = root.left;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!stack.isEmpty())&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> stack.pop();<br>                list.add(p.val);<br>                root = p.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list.get(list.size()-k);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="230-二叉搜索树中第K小的元素（mid）"><a href="#230-二叉搜索树中第K小的元素（mid）" class="headerlink" title="230. 二叉搜索树中第K小的元素（mid）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a>（mid）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//思路：中序遍历得出递增序列</span><br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthSmallest</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> k)</span> &#123;<br>        dfs(root,k);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root,<span class="hljs-type">int</span> k)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root.left!=<span class="hljs-literal">null</span>)dfs(root.left,k);<br>        <span class="hljs-keyword">if</span>(++count==k)&#123;<br>            ret = root.val;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.right!=<span class="hljs-literal">null</span>)dfs(root.right,k);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="好叶子节点对的数量-中等"><a href="#好叶子节点对的数量-中等" class="headerlink" title="好叶子节点对的数量(中等)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-good-leaf-nodes-pairs/">好叶子节点对的数量(中等)</a></h4><p>给你二叉树的根节点 root 和一个整数 distance 。<br>如果二叉树中两个 叶 节点之间的 最短路径长度 小于或者等于 distance ，那它们就可以构成一组 好叶子节点对 。<br>返回树中 好叶子节点对的数量 。<br>示例</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs latex">输入: root = [1,2,3,null,4], distance = 3<br>       1<br>      / <span class="hljs-keyword">\</span><br><span class="hljs-keyword"></span>     2   3<br>      <span class="hljs-keyword">\</span><br><span class="hljs-keyword"></span>       4<br>输出: 1<br>解释：树的叶节点是 3 和 4 ，它们之间的最短路径的长度是 3 。这是唯一的好叶子节点对。<br></code></pre></td></tr></table></figure>
<p>解题思路</p>
<blockquote>
<p>父节点和子节点的距离是 1</p>
</blockquote>
<blockquote>
<p>对树后序遍历 ，需要返回这个节点到其下方所有叶子节点的距离</p>
</blockquote>
<blockquote>
<p>这样就可以将这个节点的左子树所有叶子节点和右子树所有叶子节点都凑个对</p>
</blockquote>
<blockquote>
<p>然后将所有叶子节点不超过距离的弄到一起返回</p>
</blockquote>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//计数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPairs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> distance)</span> &#123;<br>        dfs(root, distance);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">//后续遍历</span><br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> distance)</span> &#123;<br>        <span class="hljs-comment">//当前节点为空返回空</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-comment">//叶子节点</span><br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>            list.add(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> list;<br>        &#125;<br>        <span class="hljs-comment">//</span><br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-comment">//左叶子节点的距离</span><br>        List&lt;Integer&gt; left = dfs(root.left, distance);<br>        <span class="hljs-comment">//判断是否超过distance</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> it : left) &#123;<br>            <span class="hljs-keyword">if</span> (++it &gt; distance)<br>                <span class="hljs-keyword">continue</span>;<br>            list.add(it);<br>        &#125;<br>        <span class="hljs-comment">//右叶子节点的距离</span><br>        List&lt;Integer&gt; right = dfs(root.right, distance);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> it : right) &#123;<br>            <span class="hljs-keyword">if</span> (++it &gt; distance)<br>                <span class="hljs-keyword">continue</span>;<br>            list.add(it);<br>        &#125;<br>        <span class="hljs-comment">//</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l : left) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r : right) &#123;<br>                <span class="hljs-keyword">if</span> (l + r + <span class="hljs-number">2</span> &lt;= distance)<br>                    ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="具有所有最深节点的最小子树-中等"><a href="#具有所有最深节点的最小子树-中等" class="headerlink" title="具有所有最深节点的最小子树(中等)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes">具有所有最深节点的最小子树(中等)</a></h4><p>题目描述</p>
<blockquote>
<p>给定一个根为 root 的二叉树，每个节点的深度是 该节点到根的最短距离 。 如果一个节点在 整个树 的任意节点之间具有最大的深度，则该节点是 最深的 。 一个节点的 子树 是该节点加上它的所有后代的集合。 返回能满足 以该节点为根的子树中包含所有最深的节点 这一条件的具有最大深度的节点。</p>
</blockquote>
<p><code>说的云里雾里，人话：最深叶子节点的最近公共祖先</code><br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/sketch1.png#id=SBTR5&originHeight=614&originWidth=722&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>输入：root = [3,5,1,6,2,0,8,null,null,7,4]<br>输出：[2,7,4]<br>解释： 我们返回值为 2 的节点，在图中用黄色标记。 在图中用蓝色标记的是树的最深的节点。 注意，节点 5、3 和 2 包含树中最深的节点，但节点 2 的子树最小，因此我们返回它。</p>
</blockquote>
<p>解题思路</p>
<blockquote>
<p>对于一个节点，如果左子树高度==右子树高度，这个节点就是答案，如果左子树高度&lt;右子树高度，查找右子树，否则查找左子树</p>
</blockquote>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">subtreeWithAllDeepest</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//为空返回</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ldep</span> <span class="hljs-operator">=</span> maxDepth(root.left), rdep = maxDepth(root.right);<span class="hljs-comment">//获取左右最大深度</span><br>            <span class="hljs-keyword">if</span> (ldep == rdep) <span class="hljs-keyword">return</span> root;<span class="hljs-comment">//相等返回</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ldep &gt; rdep) <span class="hljs-keyword">return</span> subtreeWithAllDeepest(root.left);<span class="hljs-comment">//左边深度大、查找左边</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> subtreeWithAllDeepest(root.right);<span class="hljs-comment">//右边深度大、查找右边</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<span class="hljs-comment">//获取当前节点的最大深度</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="求和路径-中等"><a href="#求和路径-中等" class="headerlink" title="求和路径(中等)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/paths-with-sum-lcci/">求和路径(中等)</a></h4><p>题目描述<br>给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。<br>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">      5<br>     / \<br>   <span class="hljs-number"> 4 </span>  8<br>   /   / \<br> <span class="hljs-number"> 11 </span><span class="hljs-number"> 13 </span> 4<br> /  \    / \<br>7   <span class="hljs-number"> 2 </span><span class="hljs-number"> 5 </span>  1<br></code></pre></td></tr></table></figure>
<p>返回:3 解释：和为 22 的路径有：[5,4,11,2], [5,8,4,5], [4,11,7]<br>提示：节点总数 &lt;= 10000<br>解题思路</p>
<blockquote>
<p>求出当前节点为根路径是否满足，递归判断每个节点</p>
</blockquote>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> sum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        helper(root, sum);<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) pathSum(root.left, sum);<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) pathSum(root.right, sum);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> sum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (sum == node.val) count++;<br>        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) helper(node.left, sum - node.val);<br>        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) helper(node.right, sum - node.val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="二叉树的层序遍历-中等"><a href="#二叉树的层序遍历-中等" class="headerlink" title="二叉树的层序遍历(中等)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal">二叉树的层序遍历(中等)</a></h4><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p>解题思路</p>
<blockquote>
<p>广度优先遍历，采用队列获取其每层的长度</p>
</blockquote>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        List&lt;Integer&gt; list;<br>        <span class="hljs-keyword">if</span> (!Objects.isNull(root)) queue.add(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                list.add(node.val);<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) queue.add(node.left);<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) queue.add(node.right);<br>            &#125;<br>            result.add(list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="107-二叉树的层序遍历-II"><a href="#107-二叉树的层序遍历-II" class="headerlink" title="107. 二叉树的层序遍历 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//bfs</span><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrderBottom</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> ret;<br>        LinkedList&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> queue.pop();<br>                list.add(p.val);<br>                <span class="hljs-keyword">if</span>(p.left!=<span class="hljs-literal">null</span>)queue.offer(p.left);<br>                <span class="hljs-keyword">if</span>(p.right!=<span class="hljs-literal">null</span>)queue.offer(p.right);<br>            &#125;<br>            ret.add(list);<br>        &#125;<br>        Collections.reverse(ret);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="二叉树的最近公共祖先-中等"><a href="#二叉树的最近公共祖先-中等" class="headerlink" title="二叉树的最近公共祖先(中等)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree">二叉树的最近公共祖先(中等)</a></h4><p>解题思路</p>
<blockquote>
<p>对树DFS判断其目标节点是否存在，如果存在返回true寻找另一个节点，当两个节点都找到，递归返回获得其第一个公共节点</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span> || p == root || q == root)<span class="hljs-keyword">return</span> root;<span class="hljs-comment">//递归结束条件</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.left,p,q);<span class="hljs-comment">//深度优先遍历左子树</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.right,p,q);<span class="hljs-comment">//深度优先遍历右子树</span><br>        <span class="hljs-keyword">if</span>(left!=<span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> root;<span class="hljs-comment">//找到节点将其返回</span><br>        <span class="hljs-keyword">return</span> left == <span class="hljs-literal">null</span> ? right : left;<span class="hljs-comment">//否则返回已查询到的节点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="235-二叉搜索树的最近公共祖先（easy"><a href="#235-二叉搜索树的最近公共祖先（easy" class="headerlink" title="235. 二叉搜索树的最近公共祖先（easy)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a>（easy)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//根据二叉搜索树的性质root.left&lt;root&lt;root.right,可知父节点为root.val</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">ancestor</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (p.val &lt; ancestor.val &amp;&amp; q.val &lt; ancestor.val) &#123;<span class="hljs-comment">//pq都小于root在左子树</span><br>                ancestor = ancestor.left;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.val &gt; ancestor.val &amp;&amp; q.val &gt; ancestor.val) &#123;<span class="hljs-comment">//pq都大于root在右子树</span><br>                ancestor = ancestor.right;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//等于其中一个或者呈递增序列则直接返回</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ancestor;<br>    &#125;<br>    <span class="hljs-comment">//直接搜索</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor0</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root==q||root==p||root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.left,p,q);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.right,p,q);<br>        <span class="hljs-keyword">if</span>(left!=<span class="hljs-literal">null</span>&amp;&amp;right!=<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">return</span> left!=<span class="hljs-literal">null</span>?left:right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="二叉树的直径-容易"><a href="#二叉树的直径-容易" class="headerlink" title="二叉树的直径(容易)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diameter-of-binary-tree">二叉树的直径(容易)</a></h4><p>题目描述</p>
<blockquote>
<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
</blockquote>
<p>示例 :<br>给定二叉树</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">    <span class="hljs-number">1</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>   <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span>     <br><span class="hljs-number">4</span>   <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>
<p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。<br>注意：两结点之间的路径长度是以它们之间边的数目表示。<br>解题思路</p>
<blockquote>
<p>深度优先搜索，分别递归计算每个节点的左右子树的路径之和，默认值为1超过则更新，递归向上执行</p>
</blockquote>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> ans;<span class="hljs-comment">//记录最大路径</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<span class="hljs-comment">//方法入口</span><br>        ans = <span class="hljs-number">1</span>;<br>        depth(root);<br>        <span class="hljs-keyword">return</span> ans - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//深度优先遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">depth</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 访问到空节点了，返回0</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">L</span> <span class="hljs-operator">=</span> depth(node.left); <span class="hljs-comment">// 左儿子为根的子树的深度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">R</span> <span class="hljs-operator">=</span> depth(node.right); <span class="hljs-comment">// 右儿子为根的子树的深度</span><br>        ans = Math.max(ans, L + R + <span class="hljs-number">1</span>); <span class="hljs-comment">// 计算d_node即L+R+1 并更新ans</span><br>        <span class="hljs-keyword">return</span> Math.max(L, R) + <span class="hljs-number">1</span>; <span class="hljs-comment">// 返回该节点为根的子树的深度</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="二叉树的锯齿形层次遍历-中等"><a href="#二叉树的锯齿形层次遍历-中等" class="headerlink" title="二叉树的锯齿形层次遍历(中等)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal">二叉树的锯齿形层次遍历(中等)</a></h4><p>题目描述</p>
<blockquote>
<p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
</blockquote>
<p>例如： 给定二叉树 [3,9,20,null,null,15,7],</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"> <span class="hljs-number">3</span><br>/ <span class="hljs-string">\</span><br><span class="hljs-number">9</span> <span class="hljs-number">20</span> <br> /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span> <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>
<p>返回锯齿形层次遍历如下：<br>[<br>[3],<br>[20,9],<br>[15,7]<br>]<br>解题思路</p>
<blockquote>
<p>广度优先遍历，每次将当前层元素出队，使用一个全局变量判断方向，调用addLast或者addFirst。</p>
</blockquote>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">DFS</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> level, List&lt;List&lt;Integer&gt;&gt; results)</span> &#123;<br>        <span class="hljs-keyword">if</span> (level &gt;= results.size()) &#123;<br>            LinkedList&lt;Integer&gt; newLevel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>            newLevel.add(node.val);<br>            results.add(newLevel);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (level % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>                results.get(level).add(node.val);<br>            <span class="hljs-keyword">else</span><br>                results.get(level).add(<span class="hljs-number">0</span>, node.val);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) DFS(node.left, level + <span class="hljs-number">1</span>, results);<br>        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) DFS(node.right, level + <span class="hljs-number">1</span>, results);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">zigzagLevelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>        &#125;<br>        List&lt;List&lt;Integer&gt;&gt; results = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>        DFS(root, <span class="hljs-number">0</span>, results);<br>        <span class="hljs-keyword">return</span> results;<br>    &#125;<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">zigzagLevelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; ant = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> ant;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                list.add(node.val);<br>                <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-literal">null</span>)queue.offer(node.left);<br>                <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-literal">null</span>)queue.offer(node.right);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)<br>            Collections.reverse(list);<br>            ant.add(list);<br>            flag=!flag;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ant;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="二叉树的最大深度-简单"><a href="#二叉树的最大深度-简单" class="headerlink" title="二叉树的最大深度(简单)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree">二叉树的最大深度(简单)</a></h4><p>解题思路</p>
<blockquote>
<p>递归每次递归返回+1,返回左右节点较大的值。</p>
</blockquote>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (Objects.isNull(root)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="二叉树的最小深度（easy"><a href="#二叉树的最小深度（easy" class="headerlink" title="二叉树的最小深度（easy)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">二叉树的最小深度</a>（easy)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// null节点不参与比较</span><br>    <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + minDepth(root.right);<br>    &#125;<br>    <span class="hljs-comment">// null节点不参与比较</span><br>    <span class="hljs-keyword">if</span> (root.right == <span class="hljs-literal">null</span> &amp;&amp; root.left != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + minDepth(root.left);<br>    &#125;<br>    	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + Math.min(minDepth(root.left), minDepth(root.right));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>


<h4 id="验证二叉搜索树-中等"><a href="#验证二叉搜索树-中等" class="headerlink" title="验证二叉搜索树(中等)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree">验证二叉搜索树(中等)</a></h4><p>题目描述</p>
<blockquote>
<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
</blockquote>
<p>假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含小于当前节点的数。</li>
<li>节点的右子树只包含大于当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p>示例 1:</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入:<br>     <span class="hljs-number">2</span><br>    / <span class="hljs-string">\</span><br>   <span class="hljs-number">1</span>   <span class="hljs-number">3</span><br>输出: <span class="hljs-literal">true</span><br>示例 <span class="hljs-number">2</span>:<br> <br>输入:<br>     <span class="hljs-number">5</span><br>    / <span class="hljs-string">\</span><br>   <span class="hljs-number">1</span>   <span class="hljs-number">4</span><br>      / <span class="hljs-string">\</span><br>     <span class="hljs-number">3</span>   <span class="hljs-number">6</span><br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>
<p>解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。<br>解题思路</p>
<blockquote>
<p>获取左右子书的边界值，递归判断每一个节点是否满足条件</p>
</blockquote>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(root,Long.MAX_VALUE,Long.MIN_VALUE);<br>    &#125;<br>    <span class="hljs-comment">//左子树小于max,右子树都要大于min,注意使用long</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root,<span class="hljs-type">long</span> max,<span class="hljs-type">long</span> min)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(root.val&gt;=max||root.val&lt;=min)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> dfs(root.left,root.val,min) &amp;&amp; dfs(root.right,max,root.val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="二叉树中的最大路径和-困难"><a href="#二叉树中的最大路径和-困难" class="headerlink" title="二叉树中的最大路径和(困难)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum">二叉树中的最大路径和(困难)</a></h4><p>题目描述</p>
<blockquote>
<p>给定一个非空二叉树，返回其最大路径和。</p>
</blockquote>
<p>思路</p>
<blockquote>
<p>后序递归遍历，判断其左右子树最大值，依此递归</p>
</blockquote>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//思路：自底向上（后序）递归的计算左右子树和根节点的和，记录其大小</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<span class="hljs-comment">//记录结果</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxPathSum</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        max(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">//后序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (Objects.isNull(root)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//递归结束</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> Math.max(max(root.left), <span class="hljs-number">0</span>);<span class="hljs-comment">//左子树最大值（负数直接不取，所以和0比较）</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> Math.max(max(root.right), <span class="hljs-number">0</span>);<span class="hljs-comment">//右子树最大值（负数直接不取，所以和0比较）</span><br>        ans = Math.max(ans, left + right + root.val);<span class="hljs-comment">//是否大于当前的最大值</span><br>        <span class="hljs-keyword">return</span> Math.max(left, right) + root.val;<span class="hljs-comment">//返回最大值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="从前序与中序遍历序列构造二叉树-中等"><a href="#从前序与中序遍历序列构造二叉树-中等" class="headerlink" title="从前序与中序遍历序列构造二叉树(中等)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从前序与中序遍历序列构造二叉树(中等)</a></h4><blockquote>
<p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
</blockquote>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs latex">preorder = [3,9,20,15,7]<br>inorder = [9,3,15,20,7]<br>首先根据 preorder 找到根节点是 3<br>    <br>然后根据根节点将 inorder 分成左子树和右子树<br>左子树<br>inorder [9]<br><br>右子树<br>inorder [15,20,7]<br><br>把相应的前序遍历的数组也加进来<br>左子树<br>preorder[9] <br>inorder [9]<br><br>右子树<br>preorder[20 15 7] <br>inorder [15,20,7]<br><br>现在我们只需要构造左子树和右子树即可，成功把大问题化成了小问题<br>然后重复上边的步骤继续划分，直到 preorder 和 inorder 都为空，返回 null 即可<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<span class="hljs-comment">//存储值对应的下标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; i++)map.put(inorder[i], i);<span class="hljs-comment">//存入map</span><br>        <span class="hljs-keyword">return</span> buildTree(preorder,<span class="hljs-number">0</span>,preorder.length-<span class="hljs-number">1</span>,inorder,<span class="hljs-number">0</span>,inorder.length-<span class="hljs-number">1</span>,map);<span class="hljs-comment">//递归调用</span><br>    &#125;<br>    <span class="hljs-comment">//构建</span><br>    TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span> preStart, <span class="hljs-type">int</span> preEnd,<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> inStart, <span class="hljs-type">int</span> inEnd, Map&lt;Integer, Integer&gt; inMap)</span> &#123;<br>        <span class="hljs-keyword">if</span>(preStart &gt; preEnd || inStart &gt; inEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//下标超过则停止(递归结束条件)</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[preStart]);<span class="hljs-comment">//构建结点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">inRoot</span> <span class="hljs-operator">=</span> inMap.get(root.val);<span class="hljs-comment">//根结点下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">numsLeft</span> <span class="hljs-operator">=</span> inRoot - inStart;<span class="hljs-comment">//重新定义左边(左子树有多少个节点)</span><br>        root.left = buildTree(preorder, preStart + <span class="hljs-number">1</span>, preStart + numsLeft,inorder, inStart, inRoot - <span class="hljs-number">1</span>, inMap);<span class="hljs-comment">//递归调用</span><br>        root.right = buildTree(preorder, preStart + numsLeft + <span class="hljs-number">1</span>, preEnd,inorder, inRoot + <span class="hljs-number">1</span>, inEnd, inMap);<span class="hljs-comment">//递归调用</span><br>        <span class="hljs-keyword">return</span> root;<span class="hljs-comment">//返回根节点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">从中序与后序遍历序列构造二叉树</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sql">class Solution &#123;<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>思路：递归<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>遍历指的是根节点遍历的顺序<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>后序中最后一个节点为根节点，中序根节点左边全部为根节点左子树，递归缩小范围<br>    public TreeNode buildTree(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span>[] postorder) &#123;<br>        Map<span class="hljs-operator">&lt;</span><span class="hljs-type">Integer</span>,<span class="hljs-type">Integer</span><span class="hljs-operator">&gt;</span> map <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> HashMap<span class="hljs-operator">&lt;&gt;</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i<span class="hljs-operator">=</span><span class="hljs-number">0</span>;i<span class="hljs-operator">&lt;</span>inorder.length;i<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)map.put(inorder[i],i);<br>        <span class="hljs-keyword">return</span> buildTree(inorder,<span class="hljs-number">0</span>,inorder.length<span class="hljs-number">-1</span>,postorder,<span class="hljs-number">0</span>,postorder.length<span class="hljs-number">-1</span>,map);<br>    &#125;<br>    public TreeNode buildTree(<span class="hljs-type">int</span>[] inorder,<span class="hljs-type">int</span> inStart,<span class="hljs-type">int</span> inEnd, <span class="hljs-type">int</span>[] postorder,<span class="hljs-type">int</span> postStart,<span class="hljs-type">int</span> postEnd,Map<span class="hljs-operator">&lt;</span><span class="hljs-type">Integer</span>,<span class="hljs-type">Integer</span><span class="hljs-operator">&gt;</span> map)&#123;<br>        if(inStart<span class="hljs-operator">&gt;</span>inEnd<span class="hljs-operator">||</span>postStart<span class="hljs-operator">&gt;</span>postEnd)<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        TreeNode node <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> TreeNode(postorder[postEnd]);<br>        <span class="hljs-type">int</span> index <span class="hljs-operator">=</span> map.get(node.val);<span class="hljs-operator">/</span><span class="hljs-operator">/</span>获取当前根节点所在中序数组的位置<br>        <span class="hljs-type">int</span> num <span class="hljs-operator">=</span> index <span class="hljs-operator">-</span> inStart;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>当前左子树的节点数量<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>递归构建左子树: <br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>此时中序范围为inStart到当前节点在中序数组中的位置减一,即[inStart,index<span class="hljs-number">-1</span>]<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>因为后续遍历最后一个值为根节点，此时后续范围开始下标为postStart,结束下标为当前后续开始下标<span class="hljs-operator">+</span>左子树还有的节点数量<span class="hljs-number">-1</span>,即[postStart,postStart<span class="hljs-operator">+</span>num<span class="hljs-number">-1</span>]<br>        node.left <span class="hljs-operator">=</span> buildTree(inorder,inStart,index<span class="hljs-number">-1</span>,postorder,postStart,postStart<span class="hljs-operator">+</span>num<span class="hljs-number">-1</span>,map);<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>递归构建右子树:<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>此时中序范围为当前节点在中序数组中的位置加一到inEnd,即[index<span class="hljs-operator">+</span><span class="hljs-number">1</span>,inEnd]<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>此时后续遍历的开始为上面左子树的结束<span class="hljs-operator">+</span><span class="hljs-number">1</span>,即 postStart<span class="hljs-operator">+</span>num ,结束为postEnd<span class="hljs-number">-1</span>,减一是因为当前节点已经作为根节点使用<br>        node.right <span class="hljs-operator">=</span> buildTree(inorder,index<span class="hljs-operator">+</span><span class="hljs-number">1</span>,inEnd,postorder,postStart<span class="hljs-operator">+</span>num,postEnd<span class="hljs-number">-1</span>,map);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="889-根据前序和后序遍历构造二叉树"><a href="#889-根据前序和后序遍历构造二叉树" class="headerlink" title="889. 根据前序和后序遍历构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889. 根据前序和后序遍历构造二叉树</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">constructFromPrePost</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] postorder)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> preorder.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> postorder.length;<br>        Map&lt;Integer,Integer&gt; postMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) postMap.put(postorder[i],i);<br>        <span class="hljs-keyword">return</span> buildTree(preorder,<span class="hljs-number">0</span>,m-<span class="hljs-number">1</span>,postorder,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>,postMap);<br>    &#125;<br>    <span class="hljs-comment">//preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]</span><br>    <span class="hljs-comment">//root=1  root.left=2 [4,5]  root.right=3 [6,7]</span><br>    <span class="hljs-comment">//先序: 根左右</span><br>    <span class="hljs-comment">//后序: 左右根</span><br>    <span class="hljs-comment">//思路：每次获取先序数组第一个节点作为根节点root</span><br>    <span class="hljs-comment">//因为先序是[根左右],所以先序的列表中顺数第二个节点必定为当前根节点左子树节点left,所以在后序列表中left所在位置左边都是left的左子树</span><br>    <span class="hljs-comment">//因为后序是[左右根],所以在后序列表中倒数第二个节点必定为当前根节点右子树节点right,所以在先序列表中right所在位置右边都是right的左子树</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder,<span class="hljs-type">int</span> preStart,<span class="hljs-type">int</span> preEnd, <span class="hljs-type">int</span>[] postorder,<span class="hljs-type">int</span> postStart,<span class="hljs-type">int</span> postEnd,Map&lt;Integer,Integer&gt; postMap)</span>&#123;<br>        <span class="hljs-keyword">if</span> (preStart&gt;preEnd||postStart&gt;postEnd)<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[preStart]);<br>        <span class="hljs-keyword">if</span> (preStart==preEnd)<span class="hljs-keyword">return</span> newNode;<span class="hljs-comment">//相等没有左右子树</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> postMap.get(preorder[preStart+<span class="hljs-number">1</span>]);<span class="hljs-comment">//当前newNode的左子树在后序中的位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> index-postStart;<span class="hljs-comment">//newNode的左子树的个数</span><br>        newNode.left = buildTree(preorder,preStart+<span class="hljs-number">1</span>,preStart+num+<span class="hljs-number">1</span>,postorder,postStart,index,postMap);<br>        newNode.right = buildTree(preorder,preStart+num+<span class="hljs-number">2</span>,preEnd,postorder,index+<span class="hljs-number">1</span>,postEnd-<span class="hljs-number">1</span>,postMap);<br>        <span class="hljs-keyword">return</span> newNode;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="不同的二叉搜索树-II-中等"><a href="#不同的二叉搜索树-II-中等" class="headerlink" title="不同的二叉搜索树 II(中等)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">不同的二叉搜索树 II(中等)</a></h4><p>解题思路</p>
<blockquote>
<p>回溯</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;TreeNode&gt; <span class="hljs-title function_">generateTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;();<br>        &#125;<br>        <span class="hljs-keyword">return</span> generateTrees(<span class="hljs-number">1</span>, n);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;TreeNode&gt; <span class="hljs-title function_">generateTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        List&lt;TreeNode&gt; allTrees = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;();<br>        <span class="hljs-keyword">if</span> (start &gt; end) &#123;<br>            allTrees.add(<span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">return</span> allTrees;<br>        &#125;<br><br>        <span class="hljs-comment">// 枚举可行根节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end; i++) &#123;<br>            <span class="hljs-comment">// 获得所有可行的左子树集合</span><br>            List&lt;TreeNode&gt; leftTrees = generateTrees(start, i - <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 获得所有可行的右子树集合</span><br>            List&lt;TreeNode&gt; rightTrees = generateTrees(i + <span class="hljs-number">1</span>, end);<br>            <span class="hljs-comment">// 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上</span><br>            <span class="hljs-keyword">for</span> (TreeNode left : leftTrees) &#123;<br>                <span class="hljs-keyword">for</span> (TreeNode right : rightTrees) &#123;<br>                    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">currTree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(i);<br>                    currTree.left = left;<br>                    currTree.right = right;<br>                    allTrees.add(currTree);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> allTrees;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//bfs取每一层的最右边节点</span><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">rightSideView</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">null</span>)queue.offer(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-keyword">if</span>(i==size-<span class="hljs-number">1</span>)ans.add(node.val);<br>                <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-literal">null</span>)queue.offer(node.left);<br>                <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-literal">null</span>)queue.offer(node.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="求根节点到叶节点数字之和"><a href="#求根节点到叶节点数字之和" class="headerlink" title="求根节点到叶节点数字之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/">求根节点到叶节点数字之和</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumNumbers</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(root, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> prevSum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> prevSum * <span class="hljs-number">10</span> + root.val;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> sum;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> dfs(root.left, sum) + dfs(root.right, sum);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="路径总和-easy"><a href="#路径总和-easy" class="headerlink" title="路径总和(easy)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum/">路径总和</a>(easy)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//思路：dfs</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(root,targetSum);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(root.left==<span class="hljs-literal">null</span>&amp;&amp;root.right==<span class="hljs-literal">null</span>&amp;&amp;targetSum-root.val==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> dfs(root.left,targetSum-root.val)||dfs(root.right,targetSum-root.val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="路径总和-II"><a href="#路径总和-II" class="headerlink" title="路径总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-ii/">路径总和 II</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//思路:dfs</span><br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        dfs(root,targetSum,<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum,LinkedList&lt;Integer&gt; path)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span>;<br>        path.add(root.val);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> targetSum-root.val;<br>        <span class="hljs-keyword">if</span>(root.left==<span class="hljs-literal">null</span>&amp;&amp;root.right==<span class="hljs-literal">null</span>&amp;&amp;val==<span class="hljs-number">0</span>)&#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(path));<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.left!=<span class="hljs-literal">null</span>)&#123;<br>            dfs(root.left,val,path);<br>            path.removeLast();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.right!=<span class="hljs-literal">null</span>)&#123;<br>            dfs(root.right,val,path);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//前缀和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        HashMap&lt;Long, Integer&gt; prefix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        prefix.put(<span class="hljs-number">0L</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(root, prefix, <span class="hljs-number">0</span>, targetSum);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, Map&lt;Long, Integer&gt; prefix, <span class="hljs-type">long</span> curr, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        curr += root.val;<br>        ret = prefix.getOrDefault(curr - targetSum, <span class="hljs-number">0</span>);<br>        prefix.put(curr, prefix.getOrDefault(curr, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        ret += dfs(root.left, prefix, curr, targetSum);<br>        ret += dfs(root.right, prefix, curr, targetSum);<br>        prefix.put(curr, prefix.getOrDefault(curr, <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-comment">//思路:dfs</span><br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSumDFS</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> ret;<br>        dfs(root,<span class="hljs-number">0</span>,targetSum);<br>        pathSum(root.left,targetSum);<br>        pathSum(root.right,targetSum);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> targetSum)</span>&#123;<br>        v+=root.val;<br>        <span class="hljs-keyword">if</span>(v==targetSum)ret++;<br>        <span class="hljs-keyword">if</span>(root.left!=<span class="hljs-literal">null</span>)dfs(root.left,v,targetSum);<br>        <span class="hljs-keyword">if</span>(root.right!=<span class="hljs-literal">null</span>)dfs(root.right,v,targetSum);       <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="翻转二叉树（easy）"><a href="#翻转二叉树（easy）" class="headerlink" title="翻转二叉树（easy）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/invert-binary-tree/">翻转二叉树</a>（easy）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//思路：递归翻转左右子树</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>||(root.left==<span class="hljs-literal">null</span>&amp;&amp;root.right==<span class="hljs-literal">null</span>))<span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> root.left;<br>        root.left = invertTree(root.right);<br>        root.right = invertTree(left);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">对称二叉树</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//思路:递归交替判断</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(root.left,root.right);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode left,TreeNode right)</span>&#123;<br>        <span class="hljs-keyword">if</span>(left==<span class="hljs-literal">null</span>&amp;&amp;right==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(left==<span class="hljs-literal">null</span>||right==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> left.val==right.val &amp;&amp; dfs(left.right,right.left) &amp;&amp; dfs(left.left,right.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">二叉搜索树与双向链表</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs sql">class Solution &#123;<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>思路：中序遍历<br>    Node pre, head;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>记录前置节点和头结点<br>    public Node treeToDoublyList(Node root) &#123;<br>        if(root <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>空直接返回<br>        dfs(root);<span class="hljs-operator">/</span><span class="hljs-operator">/</span><br>        head.left <span class="hljs-operator">=</span> pre;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>处理头结点<br>        pre.right <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>dfs(cur): 递归法中序遍历；<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>终止条件： 当节点 cur 为空，代表越过叶节点，直接返回；<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>递归左子树，即 dfs(cur.left) <br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>构建链表：<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>当 pre 为空时： 代表正在访问链表头节点，记为 head <br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>当 pre 不为空时： 修改双向节点引用，即 pre.right <span class="hljs-operator">=</span> cur ， cur.left <span class="hljs-operator">=</span> pre <br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>保存 cur ： 更新 pre <span class="hljs-operator">=</span> cur ，即节点 cur 是后继节点的 pre <br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>递归右子树，即 dfs(cur.right) <br>    void dfs(Node cur) &#123;<br>        if(cur <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>        dfs(cur.left);<span class="hljs-operator">/</span><span class="hljs-operator">/</span>先遍历左结点<br>        if(pre <span class="hljs-operator">!=</span> <span class="hljs-keyword">null</span>) pre.right <span class="hljs-operator">=</span> cur;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>如果有前驱节点则前驱节点<span class="hljs-keyword">right</span>(下一个节点)执行当前节点<br>        <span class="hljs-keyword">else</span> head <span class="hljs-operator">=</span> cur;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>记录头结点<br>        cur.left <span class="hljs-operator">=</span> pre;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>当前节点的<span class="hljs-keyword">left</span>指向pre<br>        pre <span class="hljs-operator">=</span> cur;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>更新前驱节点<br>        dfs(cur.right);<span class="hljs-operator">/</span><span class="hljs-operator">/</span>后遍历右边节点<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="二叉树的完全性检验"><a href="#二叉树的完全性检验" class="headerlink" title="二叉树的完全性检验"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/">二叉树的完全性检验</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql">class Solution &#123;<br>     <span class="hljs-operator">/</span><span class="hljs-operator">/</span>完全二叉树bfs时<span class="hljs-keyword">null</span>总会在队尾,如果存在队列中间有<span class="hljs-keyword">null</span>则非完全二叉树<br>    public <span class="hljs-type">boolean</span> isCompleteTree(TreeNode root) &#123;<br>        LinkedList<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> q <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> LinkedList<span class="hljs-operator">&lt;&gt;</span>();<br>        TreeNode cur;<br>        q.addLast(root);<br>        while ((cur <span class="hljs-operator">=</span> q.removeFirst()) <span class="hljs-operator">!=</span> <span class="hljs-keyword">null</span>) &#123;<br>        		<span class="hljs-operator">/</span><span class="hljs-operator">/</span>无需做判断是空，方便后面判断<br>            q.addLast(cur.left);<br>            q.addLast(cur.right);<br>        &#125;<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>如果是完全二叉树此时queue尾部装都为<span class="hljs-keyword">null</span><br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>非完全会出现[node1,node2,<span class="hljs-keyword">null</span>,node3]的情况<br>        while (<span class="hljs-operator">!</span>q.isEmpty()) &#123;<br>            if (q.removeLast() <span class="hljs-operator">!=</span> <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="实现-Trie-前缀树"><a href="#实现-Trie-前缀树" class="headerlink" title="实现 Trie (前缀树)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">实现 Trie (前缀树)</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs sql">class Trie &#123;<br>    class TrieNode&#123;<br>        TrieNode[] next <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> TrieNode[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">boolean</span> isEnd <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    TrieNode root;<br><br>    public Trie() &#123;<br>        root <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> TrieNode();<br>    &#125;<br>    <br>    public void <span class="hljs-keyword">insert</span>(String word) &#123;<br>        TrieNode cur <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i<span class="hljs-operator">=</span><span class="hljs-number">0</span>;i<span class="hljs-operator">&lt;</span>word.length();i<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)&#123;<br>            <span class="hljs-type">int</span> index <span class="hljs-operator">=</span> word.charAt(i)<span class="hljs-operator">-</span><span class="hljs-string">&#x27;a&#x27;</span>;<br>            if(cur.next[index]<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-keyword">null</span>)&#123;<br>                cur.next[index] <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> TrieNode();<br>            &#125;<br>            cur <span class="hljs-operator">=</span> cur.next[index];<br>        &#125;<br>        cur.isEnd <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    public <span class="hljs-type">boolean</span> <span class="hljs-keyword">search</span>(String word) &#123;<br>        TrieNode cur <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i<span class="hljs-operator">=</span><span class="hljs-number">0</span>;i<span class="hljs-operator">&lt;</span>word.length();i<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)&#123;<br>            <span class="hljs-type">int</span> index <span class="hljs-operator">=</span> word.charAt(i)<span class="hljs-operator">-</span><span class="hljs-string">&#x27;a&#x27;</span>;<br>            if(cur.next[index]<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            cur <span class="hljs-operator">=</span> cur.next[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur.isEnd;<br>    &#125;<br>    <br>    public <span class="hljs-type">boolean</span> startsWith(String prefix) &#123;<br>        TrieNode cur <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i<span class="hljs-operator">=</span><span class="hljs-number">0</span>;i<span class="hljs-operator">&lt;</span>prefix.length();i<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)&#123;<br>            <span class="hljs-type">int</span> index <span class="hljs-operator">=</span> prefix.charAt(i)<span class="hljs-operator">-</span><span class="hljs-string">&#x27;a&#x27;</span>;<br>            if(cur.next[index]<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            cur <span class="hljs-operator">=</span> cur.next[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="二叉树最大宽度"><a href="#二叉树最大宽度" class="headerlink" title="二叉树最大宽度"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-width-of-binary-tree/">二叉树最大宽度</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs sql">class Solution &#123;<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>思路：BFS<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 完全二叉树的性质）：对于一颗完全二插树，如果按照从上至下，从左往右对所有节点从零开始顺序编号<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 则父节点的左孩子节点的序号：<span class="hljs-number">2</span><span class="hljs-operator">*</span>i<span class="hljs-operator">+</span><span class="hljs-number">1</span>   父节点的左孩子节点的序号：<span class="hljs-number">2</span><span class="hljs-operator">*</span>i<span class="hljs-operator">+</span><span class="hljs-number">2</span>;<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 所以每层的宽度就可以使用：每层最后一个节点的值减去最后一个节点的值<span class="hljs-operator">+</span><span class="hljs-number">1</span><br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>       <span class="hljs-number">1</span><br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>     <span class="hljs-operator">/</span>   \<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>    <span class="hljs-number">2</span>     <span class="hljs-number">3</span><br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>   <span class="hljs-operator">/</span> \   <span class="hljs-operator">/</span> \<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>  <span class="hljs-number">4</span>   <span class="hljs-number">5</span> <span class="hljs-number">6</span>   <span class="hljs-number">7</span><br>    public <span class="hljs-type">int</span> widthOfBinaryTree(TreeNode root) &#123;<br>        <span class="hljs-type">int</span> ret <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        LinkedList<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> queue <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> LinkedList<span class="hljs-operator">&lt;&gt;</span>();<br>        root.val<span class="hljs-operator">=</span><span class="hljs-number">0</span>;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>关键<br>        queue.offer(root);<br>        while(<span class="hljs-operator">!</span>queue.isEmpty())&#123;<br>            <span class="hljs-type">int</span> size <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span>当前这层的宽度<br>            <span class="hljs-type">int</span> width <span class="hljs-operator">=</span> queue.getLast().val<span class="hljs-operator">-</span>queue.getFirst().val<span class="hljs-operator">+</span><span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i<span class="hljs-operator">=</span><span class="hljs-number">0</span>;i<span class="hljs-operator">&lt;</span>size;i<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)&#123;<br>                TreeNode node <span class="hljs-operator">=</span> queue.pop();<br>                if(node.left<span class="hljs-operator">!=</span><span class="hljs-keyword">null</span>)&#123;<br>                    node.left.val <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-operator">*</span> node.val<span class="hljs-operator">+</span><span class="hljs-number">1</span>;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>左子树编号<br>                    queue.offer(node.left);<br>                &#125;<br>                if(node.right<span class="hljs-operator">!=</span><span class="hljs-keyword">null</span>)&#123;<br>                    node.right.val <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-operator">*</span> node.val<span class="hljs-operator">+</span><span class="hljs-number">2</span>;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>右子树编号<br>                    queue.offer(node.right);<br>                &#125;<br>            &#125;<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span>更新宽度<br>            ret<span class="hljs-operator">=</span>Math.<span class="hljs-built_in">max</span>(ret,width);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>  	<span class="hljs-operator">/</span><span class="hljs-operator">/</span>DFS<br>		Map<span class="hljs-operator">&lt;</span><span class="hljs-type">Integer</span>, <span class="hljs-type">Integer</span><span class="hljs-operator">&gt;</span> levelMin <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> HashMap<span class="hljs-operator">&lt;</span><span class="hljs-type">Integer</span>, <span class="hljs-type">Integer</span><span class="hljs-operator">&gt;</span>();<br>    public <span class="hljs-type">int</span> widthOfBinaryTree(TreeNode root) &#123;<br>        <span class="hljs-keyword">return</span> dfs(root, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    &#125;<br>    public <span class="hljs-type">int</span> dfs(TreeNode node, <span class="hljs-type">int</span> depth, <span class="hljs-type">int</span> index) &#123;<br>        if (node <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        levelMin.putIfAbsent(depth, index); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 每一层最先访问到的节点会是最左边的节点，即每一层编号的最小值<br>        <span class="hljs-keyword">return</span> Math.<span class="hljs-built_in">max</span>(index <span class="hljs-operator">-</span> levelMin.get(depth) <span class="hljs-operator">+</span> <span class="hljs-number">1</span>, <br>        Math.<span class="hljs-built_in">max</span>(dfs(node.left, depth <span class="hljs-operator">+</span> <span class="hljs-number">1</span>, index <span class="hljs-operator">*</span> <span class="hljs-number">2</span>), <br>        dfs(node.right, depth <span class="hljs-operator">+</span> <span class="hljs-number">1</span>, index <span class="hljs-operator">*</span> <span class="hljs-number">2</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span>)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="二叉树的序列化与反序列化"><a href="#二叉树的序列化与反序列化" class="headerlink" title="二叉树的序列化与反序列化"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">二叉树的序列化与反序列化</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs sql">public class Codec &#123;<br>    StringBuilder sb;<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>DFS遍历成字符串,当节点<span class="hljs-keyword">left</span>和<span class="hljs-keyword">right</span>为空记录为<span class="hljs-keyword">NULL</span><br>    public String serialize(TreeNode root) &#123;<br>        sb <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">return</span> reserialize(root);<br>    &#125;<br>    public String reserialize(TreeNode root) &#123;<br>        if(root<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-keyword">null</span>)sb.append(&quot;NULL,&quot;);<br>        <span class="hljs-keyword">else</span>&#123;<br>            sb.append(root.val).append(&quot;,&quot;);<br>            reserialize(root.left);<br>            reserialize(root.right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br><br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>递归解析树<br>    public TreeNode deserialize(String data) &#123;<br>        String[] nodes <span class="hljs-operator">=</span> data.split(&quot;,&quot;);<br>        List<span class="hljs-operator">&lt;</span>String<span class="hljs-operator">&gt;</span> list <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> LinkedList<span class="hljs-operator">&lt;&gt;</span>(Arrays.asList(nodes));<br>        <span class="hljs-keyword">return</span> deserialize(list);<br>    &#125;<br><br>    public TreeNode deserialize(List<span class="hljs-operator">&lt;</span>String<span class="hljs-operator">&gt;</span> list) &#123;<br>        if(&quot;NULL&quot;.<span class="hljs-keyword">equals</span>(list.get(<span class="hljs-number">0</span>)))&#123;<br>            list.remove(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        TreeNode node <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> TreeNode(Integer.valueOf(list.get(<span class="hljs-number">0</span>)));<br>        list.remove(<span class="hljs-number">0</span>);<br>        node.left <span class="hljs-operator">=</span> deserialize(list);<br>        node.right <span class="hljs-operator">=</span> deserialize(list);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="449-序列化和反序列化二叉搜索树（mid）"><a href="#449-序列化和反序列化二叉搜索树（mid）" class="headerlink" title="449. 序列化和反序列化二叉搜索树（mid）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/serialize-and-deserialize-bst/">449. 序列化和反序列化二叉搜索树</a>（mid）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br>  <span class="hljs-comment">// Encodes a tree to a list.</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postorder</span><span class="hljs-params">(TreeNode root, StringBuilder sb)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    postorder(root.left, sb);<br>    postorder(root.right, sb);<br>    sb.append(intToString(root.val));<br>  &#125;<br><br>  <span class="hljs-comment">// Encodes integer to bytes string</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">intToString</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-type">char</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">4</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &gt; -<span class="hljs-number">1</span>; --i) &#123;<br>      bytes[<span class="hljs-number">3</span> - i] = (<span class="hljs-type">char</span>) (x &gt;&gt; (i * <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes);<br>  &#125;<br><br>  <span class="hljs-comment">// Encodes a tree to a single string.</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">serialize</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    postorder(root, sb);<br>    <span class="hljs-keyword">return</span> sb.toString();<br>  &#125;<br><br>  <span class="hljs-comment">// Decodes list to tree.</span><br>  <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">helper</span><span class="hljs-params">(Integer lower, Integer upper, ArrayDeque&lt;Integer&gt; nums)</span> &#123;<br>    <span class="hljs-keyword">if</span> (nums.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> nums.getLast();<br>    <span class="hljs-keyword">if</span> (val &lt; lower || val &gt; upper) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>    nums.removeLast();<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>    root.right = helper(val, upper, nums);<br>    root.left = helper(lower, val, nums);<br>    <span class="hljs-keyword">return</span> root;<br>  &#125;<br><br>  <span class="hljs-comment">// Decodes bytes string to integer</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">stringToInt</span><span class="hljs-params">(String bytesStr)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> b : bytesStr.toCharArray()) &#123;<br>      result = (result &lt;&lt; <span class="hljs-number">8</span>) + (<span class="hljs-type">int</span>)b;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br><br>  <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>  <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deserialize</span><span class="hljs-params">(String data)</span> &#123;<br>    ArrayDeque&lt;Integer&gt; nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> data.length();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; (<span class="hljs-type">int</span>)(n / <span class="hljs-number">4</span>); ++i) &#123;<br>      nums.add(stringToInt(data.substring(<span class="hljs-number">4</span> * i, <span class="hljs-number">4</span> * i + <span class="hljs-number">4</span>)));<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> helper(Integer.MIN_VALUE, Integer.MAX_VALUE, nums);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">二叉树的镜像</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">class Solution &#123;<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>思路:dfs递归交换左右节点<br>    public TreeNode mirrorTree(TreeNode root) &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    public TreeNode dfs(TreeNode root)&#123;<br>        if(root<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span> root;<br>        TreeNode <span class="hljs-keyword">left</span> <span class="hljs-operator">=</span> dfs(root.left);<br>        TreeNode <span class="hljs-keyword">right</span> <span class="hljs-operator">=</span> dfs(root.right);<br>        root.left <span class="hljs-operator">=</span> <span class="hljs-keyword">right</span>;<br>        root.right <span class="hljs-operator">=</span> <span class="hljs-keyword">left</span>;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//直接回溯</span><br>    List&lt;String&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">binaryTreePaths</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> ret;<br>        backtrack(root,<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;());<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(TreeNode root,LinkedList&lt;Integer&gt; path)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span>;<br>        path.add(root.val);<br>        <span class="hljs-keyword">if</span>(root.left==<span class="hljs-literal">null</span>&amp;&amp;root.right==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;path.size();i++)&#123;<br>                sb.append(path.get(i));<br>                <span class="hljs-keyword">if</span>(i!=path.size()-<span class="hljs-number">1</span>)sb.append(<span class="hljs-string">&quot;-&gt;&quot;</span>);<br>            &#125;<br>            ret.add(sb.toString());<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.left!=<span class="hljs-literal">null</span>)&#123;<br>            backtrack(root.left,path);<br>            path.removeLast();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.right!=<span class="hljs-literal">null</span>)&#123;<br>            backtrack(root.right,path);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="另一棵树的子树"><a href="#另一棵树的子树" class="headerlink" title="另一棵树的子树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subtree-of-another-tree/">另一棵树的子树</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs sql">class Solution &#123;<br>    public <span class="hljs-type">boolean</span> isSubtree(TreeNode root, TreeNode subRoot) &#123;<br>        <span class="hljs-type">boolean</span> ret <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        if(root<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        if(root.val<span class="hljs-operator">=</span><span class="hljs-operator">=</span>subRoot.val)ret <span class="hljs-operator">=</span> compare(root,subRoot);<br>        <span class="hljs-keyword">return</span> ret <span class="hljs-operator">||</span> isSubtree(root.left,subRoot)<span class="hljs-operator">||</span>isSubtree(root.right,subRoot);<br>    &#125;<br>    public <span class="hljs-type">boolean</span> compare(TreeNode p,TreeNode q)&#123;<br>        if(p<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-keyword">null</span><span class="hljs-operator">||</span>q<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span> p<span class="hljs-operator">=</span><span class="hljs-operator">=</span>q;<br>        if(p.val<span class="hljs-operator">!=</span>q.val)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> compare(p.left,q.left)<span class="hljs-operator">&amp;&amp;</span>compare(p.right,q.right);<br>    &#125;<br>&#125;<br><br>class Solution &#123;<br>    private <span class="hljs-type">boolean</span> isMatch;<br>    public <span class="hljs-type">boolean</span> isSubtree(TreeNode root, TreeNode subRoot) &#123;<br>        if(root.val<span class="hljs-operator">=</span><span class="hljs-operator">=</span>subRoot.val)&#123;<br>            if(dfs(root,subRoot))<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        if(root.left<span class="hljs-operator">!=</span><span class="hljs-keyword">null</span>)isSubtree(root.left,subRoot);<br>        if(root.right<span class="hljs-operator">!=</span><span class="hljs-keyword">null</span>)isSubtree(root.right,subRoot);<br>        <span class="hljs-keyword">return</span> isMatch;<br>    &#125;<br>    public <span class="hljs-type">boolean</span> dfs(TreeNode root, TreeNode subRoot)&#123;<br>        if(root<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-keyword">null</span><span class="hljs-operator">&amp;&amp;</span>subRoot<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        if((root<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-keyword">null</span><span class="hljs-operator">&amp;&amp;</span>subRoot<span class="hljs-operator">!=</span><span class="hljs-keyword">null</span>)<span class="hljs-operator">||</span>(root<span class="hljs-operator">!=</span><span class="hljs-keyword">null</span><span class="hljs-operator">&amp;&amp;</span>subRoot<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-keyword">null</span>)<span class="hljs-operator">||</span>root.val<span class="hljs-operator">!=</span>subRoot.val)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> dfs(root.left,subRoot.left) <span class="hljs-operator">&amp;&amp;</span> dfs(root.right,subRoot.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="440-字典序的第K小数字（hard"><a href="#440-字典序的第K小数字（hard" class="headerlink" title="440. 字典序的第K小数字（hard)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/">440. 字典序的第K小数字</a>（hard)</h4><blockquote>
<p>给定整数 n 和 k，返回  [1, n] 中字典序第 k 小的数字。</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1644420574100-53f34a99-0a43-4386-8829-2cc9da8ca3a4.png#averageHue=%23fefdf7&clientId=ufe8c1909-d4f7-4&from=paste&height=124&id=uced68394&name=image.png&originHeight=248&originWidth=1048&originalType=binary&ratio=1&rotation=0&showTitle=false&size=70342&status=done&style=none&taskId=uf51635d0-e4c7-4493-bd77-9cc9f87305f&title=&width=524" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<blockquote>
<p>不难发现其实字典序就是对这棵十叉树进行<strong>先序遍历</strong>得出，1，10，100，101….,110,111,……，先序遍历到k-n节点即是目标值。</p>
</blockquote>
<p>实际上我们求出第k小的数需要解决的问题如下：</p>
<p>1.怎么确定一个前缀下所有子节点的个数？<br>2.如果第 k 个数在当前的前缀下，怎么继续往下面的子节点找？<br>3.如果第 k 个数不在当前的前缀，即当前的前缀比较小，如何扩大前缀，增大寻找的范围？</p>
<blockquote>
<p>其实就是需要确定往数的下走还是右走，从而确定目标值的位置</p>
</blockquote>
<p>1.怎么确定一个前缀下所有子节点的个数？通过上图我们可以发现</p>
<blockquote>
<p>1为前缀所有节点计算方式=(第1层nextPrefix-prifix)+(第2层nextPrefix-prifix)+…+(第n层nextPrefix-prifix)</p>
</blockquote>
<p>那么问题又来了我怎么确定他是第几层呢？其实题目给我们的n就是说一共有n个字段序的数，那我们查找的前缀节点的值自然只能小于等于n，所以当我们的prifix大于n时我们就需要跳出层级节点计算了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>计算prefix下的节点个数<br>public <span class="hljs-type">int</span> getCount(<span class="hljs-type">int</span> prefix,<span class="hljs-type">int</span> n)&#123;<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>记录当前前缀<br>    long curr <span class="hljs-operator">=</span> prefix;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>注意需要使用long来接收<br>    long next <span class="hljs-operator">=</span> prefix <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>下一个节点的前缀<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>记录峰头之间的累加<br>    <span class="hljs-type">int</span> count <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    while(curr<span class="hljs-operator">&lt;=</span>n)&#123;<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>累加每层之间的差值<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>特别的 如果next已经大于n了的时候，因为要包含n 所以取n<span class="hljs-operator">+</span><span class="hljs-number">1</span>个数<br>        count<span class="hljs-operator">+</span><span class="hljs-operator">=</span>Math.<span class="hljs-built_in">min</span>(next,n<span class="hljs-operator">+</span><span class="hljs-number">1</span>)<span class="hljs-operator">-</span>curr;<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>进入下一层<br>        curr<span class="hljs-operator">*</span><span class="hljs-operator">=</span><span class="hljs-number">10</span>;<br>        next<span class="hljs-operator">*</span><span class="hljs-operator">=</span><span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>2.如果第 k 个数在当前的前缀下，怎么继续往下面的子节点找？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-type">int</span> count <span class="hljs-operator">=</span> getCount(prefix,n);<span class="hljs-operator">/</span><span class="hljs-operator">/</span>当前前缀下节点数<br>prefix<span class="hljs-operator">*</span><span class="hljs-operator">=</span><span class="hljs-number">10</span>;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>下沉一层<br>res<span class="hljs-operator">+</span><span class="hljs-operator">+</span>;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>记录走过根节点<br></code></pre></td></tr></table></figure>
<p>3.如果第 k 个数不在当前的前缀，即当前的前缀比较小，如何扩大前缀，增大寻找的范围？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-type">int</span> count <span class="hljs-operator">=</span> getCount(prefix,n);<span class="hljs-operator">/</span><span class="hljs-operator">/</span>当前前缀下节点数<br>prefix<span class="hljs-operator">+</span><span class="hljs-operator">+</span>;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>前缀右移，<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3.</span>..<br>res<span class="hljs-operator">+</span><span class="hljs-operator">=</span>getCount<span class="hljs-operator">/</span><span class="hljs-operator">/</span>走过当前前缀下所有节点<br></code></pre></td></tr></table></figure>
<p>完整的代码</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs sql">class Solution &#123;<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>思路：构建为十叉树<br>    public <span class="hljs-type">int</span> findKthNumber(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>初始化的时候包含<span class="hljs-number">1</span>节点的，所以数量是<span class="hljs-number">1</span><br>        <span class="hljs-type">int</span> res <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>默认是从<span class="hljs-number">1</span>节点开始遍历，所以是<span class="hljs-number">1</span><br>        <span class="hljs-type">int</span> prefix <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        while(res<span class="hljs-operator">&lt;</span>k)&#123;<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span>计算当前分支下，如果跳到下一个峰，有多少节点数<br>            <span class="hljs-type">int</span> count <span class="hljs-operator">=</span> getCount(prefix,n);<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span>如果加上跨越到下一个峰的数量大于了目标k，则不能跳跃<br>            if(res<span class="hljs-operator">+</span>count<span class="hljs-operator">&gt;</span>k)&#123;<br>                <span class="hljs-operator">/</span><span class="hljs-operator">/</span>走到下一层<br>                prefix<span class="hljs-operator">*</span><span class="hljs-operator">=</span><span class="hljs-number">10</span>;<br>                <span class="hljs-operator">/</span><span class="hljs-operator">/</span>因为走过了根节点，所以需要加一<br>                res<span class="hljs-operator">+</span><span class="hljs-operator">+</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-operator">/</span><span class="hljs-operator">/</span>如果不大于的话直接加上走下一个分支<br>                res<span class="hljs-operator">+</span><span class="hljs-operator">=</span>count;<br>                prefix<span class="hljs-operator">+</span><span class="hljs-operator">+</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prefix;<br>    &#125;<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>计算<br>    public <span class="hljs-type">int</span> getCount(<span class="hljs-type">int</span> prefix,<span class="hljs-type">int</span> n)&#123;<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>记录当前前缀<br>        long curr <span class="hljs-operator">=</span> prefix;<br>        long next <span class="hljs-operator">=</span> prefix <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>下一个节点的前缀<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>记录峰头之间的累加<br>        <span class="hljs-type">int</span> count <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        while(curr<span class="hljs-operator">&lt;=</span>n)&#123;<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span>累加每层之间的差值<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span>特别的 如果next已经大于n了的时候，因为要包含n 所以取n<span class="hljs-operator">+</span><span class="hljs-number">1</span>个数<br>            count<span class="hljs-operator">+</span><span class="hljs-operator">=</span>Math.<span class="hljs-built_in">min</span>(next,n<span class="hljs-operator">+</span><span class="hljs-number">1</span>)<span class="hljs-operator">-</span>curr;<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span>进入下一层<br>            curr<span class="hljs-operator">*</span><span class="hljs-operator">=</span><span class="hljs-number">10</span>;<br>            next<span class="hljs-operator">*</span><span class="hljs-operator">=</span><span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">删除二叉搜索树中的节点</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs sql">class Solution &#123;<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>节点在的位置可能性<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">1.</span>根节点()<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">2.</span>叶子节点（直接删掉）<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">3.</span>待删除的节点无左子树，有右子树<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">4.</span>待删除的节点有左子树，无右子树<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">5.</span>待删除的节点有左子树、右子树(左子树作为新的代替节点，右子树插入左子树最右边的节点)<br>    public TreeNode deleteNode(TreeNode root, <span class="hljs-type">int</span> key) &#123;<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">1</span><br>        if(root<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span> root;<br>        if(root.val<span class="hljs-operator">&gt;</span>key)&#123;<br>            root.left <span class="hljs-operator">=</span> deleteNode(root.left,key);<br>        &#125;<span class="hljs-keyword">else</span> if(root.val<span class="hljs-operator">&lt;</span>key)&#123;<br>            root.right <span class="hljs-operator">=</span> deleteNode(root.right,key);<br>        &#125;<span class="hljs-keyword">else</span> if(root.val <span class="hljs-operator">=</span><span class="hljs-operator">=</span> key)&#123;<br>            if(root.left<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-keyword">null</span><span class="hljs-operator">&amp;&amp;</span>root.right<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">2</span><br>            if(root.left<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-keyword">null</span><span class="hljs-operator">&amp;&amp;</span>root.right<span class="hljs-operator">!=</span><span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span> root.right;<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">3</span><br>            if(root.left<span class="hljs-operator">!=</span><span class="hljs-keyword">null</span><span class="hljs-operator">&amp;&amp;</span>root.right<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span> root.left;<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">4</span><br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">5</span><br>            if(root.left<span class="hljs-operator">!=</span><span class="hljs-keyword">null</span><span class="hljs-operator">&amp;&amp;</span>root.right<span class="hljs-operator">!=</span><span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-operator">/</span><span class="hljs-operator">/</span>获取左子树的最右边节点<br>                TreeNode <span class="hljs-keyword">left</span> <span class="hljs-operator">=</span> root.left;<br>                while(left.right<span class="hljs-operator">!=</span><span class="hljs-keyword">null</span>)<span class="hljs-keyword">left</span> <span class="hljs-operator">=</span> left.right;<br>                left.right <span class="hljs-operator">=</span> root.right;<br>                <span class="hljs-keyword">return</span> root.left;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">二叉树展开为链表</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs sql">class Solution &#123;<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>思路：递归先遍历左子树,设置其<span class="hljs-keyword">right</span>,再返回其左子树最大节点<br>    public void flatten(TreeNode root) &#123;<br>        if(root<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span>;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>特殊条件<br>        recursion(root);<span class="hljs-operator">/</span><span class="hljs-operator">/</span>开始递归<br>    &#125;<br>    public TreeNode recursion(TreeNode root) &#123;<br>        TreeNode <span class="hljs-keyword">right</span> <span class="hljs-operator">=</span> root.right;<br>        TreeNode <span class="hljs-keyword">left</span> <span class="hljs-operator">=</span> root.left;<br>        if(root.left<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-keyword">null</span><span class="hljs-operator">&amp;&amp;</span>root.right<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span> root;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>左子树最后一个节点直接返回<br>        TreeNode ret <span class="hljs-operator">=</span> <span class="hljs-keyword">null</span>;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>返回回来的最大节点<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>左子树还有节点优先进入递归<br>        if(root.left<span class="hljs-operator">!=</span><span class="hljs-keyword">null</span>)&#123;<br>            root.right <span class="hljs-operator">=</span> root.left;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>可设置root.right为左子树<br>            ret <span class="hljs-operator">=</span> recursion(<span class="hljs-keyword">left</span>);<br>        &#125;<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>如果当前节点有左右子树，需要将左子树返回回来的节点作为最大节点设置<span class="hljs-keyword">right</span><br>        if(ret<span class="hljs-operator">!=</span><span class="hljs-keyword">null</span> <span class="hljs-operator">&amp;&amp;</span> <span class="hljs-keyword">right</span><span class="hljs-operator">!=</span><span class="hljs-keyword">null</span>)&#123;<br>            ret.right <span class="hljs-operator">=</span> <span class="hljs-keyword">right</span>;<br>            recursion(<span class="hljs-keyword">right</span>);<br>        &#125;<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>如果当前节点只要右子树，直接进入右子树递归<br>        if(<span class="hljs-keyword">right</span><span class="hljs-operator">!=</span><span class="hljs-keyword">null</span>)ret <span class="hljs-operator">=</span> recursion(<span class="hljs-keyword">right</span>);<br>        root.left <span class="hljs-operator">=</span> <span class="hljs-keyword">null</span>;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>左子树置空<br>        <span class="hljs-keyword">return</span> ret;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>返回<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="相同的树-easy"><a href="#相同的树-easy" class="headerlink" title="相同的树(easy)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/same-tree/">相同的树</a>(easy)</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">class Solution &#123;<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>递归遍历树<br>    public <span class="hljs-type">boolean</span> isSameTree(TreeNode p, TreeNode q) &#123;<br>        if(p<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-keyword">null</span><span class="hljs-operator">||</span>q<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span> p<span class="hljs-operator">=</span><span class="hljs-operator">=</span>q;<br>        if(p.val<span class="hljs-operator">!=</span>q.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> isSameTree(p.left,q.left)<span class="hljs-operator">&amp;&amp;</span>isSameTree(p.right,q.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="113-二叉树中和为某一值的路径"><a href="#113-二叉树中和为某一值的路径" class="headerlink" title="113. 二叉树中和为某一值的路径"></a>113. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">二叉树中和为某一值的路径</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//思路：回溯</span><br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; ret;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> target)</span> &#123;<br>        ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> ret;<br>        backtrack(root,<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(),target);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(TreeNode root,LinkedList&lt;Integer&gt; path, <span class="hljs-type">int</span> target)</span>&#123;<br>        path.add(root.val);<br>        target-=root.val;<br>        <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>&amp;&amp;root.left==<span class="hljs-literal">null</span>&amp;&amp;root.right==<span class="hljs-literal">null</span>)&#123;<br>            ret.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.left!=<span class="hljs-literal">null</span>)&#123;<br>            backtrack(root.left,path,target);<br>            path.removeLast();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.right!=<span class="hljs-literal">null</span>)&#123;<br>            backtrack(root.right,path,target);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//思路：递归每次取数组中间节点作为根节点，当left&gt;right递归结束</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">return</span> helper(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 总是选择中间位置左边的数字作为根节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(nums[mid]);<br>        root.left = helper(nums, left, mid - <span class="hljs-number">1</span>);<br>        root.right = helper(nums, mid + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="99-恢复二叉搜索树"><a href="#99-恢复二叉搜索树" class="headerlink" title="99. 恢复二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/recover-binary-search-tree/">99. 恢复二叉搜索树</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//O(n)中序遍历判断不是升序的两个节点进行交换</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recoverTreeOn</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span>;<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        List&lt;TreeNode&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(root!=<span class="hljs-literal">null</span>||!stack.isEmpty())&#123;<br>            <span class="hljs-keyword">while</span>(root!=<span class="hljs-literal">null</span>)&#123;<br>                stack.push(root);<br>                root = root.left;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!stack.isEmpty())&#123;<br>                root = stack.pop();<br>                list.add(root);<br>                root = root.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//从前向后查找递减的那个数</span><br>        TreeNode val1=<span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;list.size();i++)&#123;<br>            <span class="hljs-keyword">if</span>(list.get(i).val&gt;list.get(i+<span class="hljs-number">1</span>).val)&#123;<br>                val1=list.get(i);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//从后向前查找递减的那个数</span><br>        TreeNode val2=<span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=list.size()-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(list.get(i).val&lt;list.get(i-<span class="hljs-number">1</span>).val)&#123;<br>                val2=list.get(i);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> val1.val;<br>        val1.val = val2.val;<br>        val2.val = tmp;<br>    &#125;<br>    <span class="hljs-comment">//O(1) Morris 中序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recoverTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, y = <span class="hljs-literal">null</span>, pred = <span class="hljs-literal">null</span>, predecessor = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止</span><br>                predecessor = root.left;<br>                <span class="hljs-keyword">while</span> (predecessor.right != <span class="hljs-literal">null</span> &amp;&amp; predecessor.right != root) &#123;<br>                    predecessor = predecessor.right;<br>                &#125;<br>                <span class="hljs-comment">// 让 predecessor 的右指针指向 root，继续遍历左子树</span><br>                <span class="hljs-keyword">if</span> (predecessor.right == <span class="hljs-literal">null</span>) &#123;<br>                    predecessor.right = root;<br>                    root = root.left;<br>                &#125;<br>                <span class="hljs-comment">// 说明左子树已经访问完了，我们需要断开链接</span><br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span> &amp;&amp; root.val &lt; pred.val) &#123;<br>                        y = root;<br>                        <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>) &#123;<br>                            x = pred;<br>                        &#125;<br>                    &#125;<br>                    pred = root;<br>                    predecessor.right = <span class="hljs-literal">null</span>;<br>                    root = root.right;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 如果没有左孩子，则直接访问右孩子</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span> &amp;&amp; root.val &lt; pred.val) &#123;<br>                    y = root;<br>                    <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>) &#123;<br>                        x = pred;<br>                    &#125;<br>                &#125;<br>                pred = root;<br>                root = root.right;<br>            &#125;<br>        &#125;<br>        swap(x, y);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(TreeNode x, TreeNode y)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> x.val;<br>        x.val = y.val;<br>        y.val = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="116-填充每个节点的下一个右侧节点指针（mid）"><a href="#116-填充每个节点的下一个右侧节点指针（mid）" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针（mid）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a>（mid）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//dfs</span><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">connect</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>            root.left.next = root.right;<br>            <span class="hljs-keyword">if</span> (root.next != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//跨父右节点next=父节点next左边节点</span><br>                root.right.next = root.next.left;<br>            &#125;<br>        &#125;<br>        connect(root.left);<br>        connect(root.right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-comment">//bfs</span><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">connectbfs</span><span class="hljs-params">(Node root)</span> &#123;<br>        LinkedList&lt;Node&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> root;<br>        queue.offer(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.pop();<br>                <span class="hljs-keyword">if</span>(prev!=<span class="hljs-literal">null</span>)prev.next = node;<br>                <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-literal">null</span>)queue.offer(node.left);<br>                <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-literal">null</span>)queue.offer(node.right);<br>                prev = node;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="117-填充每个节点的下一个右侧节点指针-II（mid）"><a href="#117-填充每个节点的下一个右侧节点指针-II（mid）" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II（mid）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a>（mid）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, nextStart = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">connect</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (start != <span class="hljs-literal">null</span>) &#123;<br>            last = <span class="hljs-literal">null</span>;<br>            nextStart = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> start; p != <span class="hljs-literal">null</span>; p = p.next) &#123;<br>                <span class="hljs-keyword">if</span> (p.left != <span class="hljs-literal">null</span>) handle(p.left);<br>                <span class="hljs-keyword">if</span> (p.right != <span class="hljs-literal">null</span>) handle(p.right);<br>            &#125;<br>            start = nextStart;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Node p)</span> &#123;<br>        <span class="hljs-keyword">if</span> (last != <span class="hljs-literal">null</span>) last.next = p;<br>        <span class="hljs-keyword">if</span> (nextStart == <span class="hljs-literal">null</span>) nextStart = p;<br>        last = p;<br>    &#125;<br>    <span class="hljs-comment">//BFS</span><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">connect</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> root;<br>        LinkedList&lt;Node&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.pop();<br>                <span class="hljs-keyword">if</span>(prev!=<span class="hljs-literal">null</span>)prev.next = node;<br>                <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-literal">null</span>)queue.offer(node.left);<br>                <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-literal">null</span>)queue.offer(node.right);<br>                prev = node;<br>            &#125;<br>            prev.next = <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1646617888088-613499a3-8504-4623-81d1-df0a8f46efff.png#averageHue=%23b9b9b8&clientId=u726be2da-ada0-4&from=paste&height=470&id=u1d396d4a&name=image.png&originHeight=939&originWidth=2000&originalType=binary&ratio=1&rotation=0&showTitle=false&size=341299&status=done&style=none&taskId=u4bfcf93c-d4f5-440d-a9c0-1d38f6bca10&title=&width=1000" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//O(1)解法</span><br>    <span class="hljs-comment">//n层完全二叉树每层最多节点:1 2 4 8 = 2^n (下标从0开始)</span><br>    <span class="hljs-comment">//1 3 7 15 = [2^n,2^(n+1)-1]</span><br>    <span class="hljs-comment">//思路：通过二分查找，其节点值必在[2^n,2^(n+1)-1]区间内</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNodes</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (node.left != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//因为完全二叉树的节点主要集中在左边，可以通过遍历左子树确定层数</span><br>            level++;<br>            node = node.left;<br>        &#125;<br>        <span class="hljs-comment">//二分查找</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; level, high = (<span class="hljs-number">1</span> &lt;&lt; (level + <span class="hljs-number">1</span>)) - <span class="hljs-number">1</span>;<span class="hljs-comment">//[2^n,2^(n+1)-1]</span><br>        <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (high - low + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + low;<br>            <span class="hljs-keyword">if</span> (exists(root, level, mid)) &#123;<span class="hljs-comment">//mid存在靠右</span><br>                low = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//否则在左区间</span><br>                high = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> low;<br>    &#125;<br>    <span class="hljs-comment">//判断节点是否存在</span><br>    <span class="hljs-comment">//     1            h = 0</span><br>    <span class="hljs-comment">//    / \</span><br>    <span class="hljs-comment">//   2   3          h = 1</span><br>    <span class="hljs-comment">//  / \  /\</span><br>    <span class="hljs-comment">// 4  5 6  7        h = 2</span><br>    <span class="hljs-comment">//现在这个树中的值都是节点的编号，最底下的一层的编号是[2^h ，2^h - 1]，现在h = 2，也就是4, 5, 6, 7。</span><br>    <span class="hljs-comment">//4, 5, 6, 7对应二进制分别为 100 101 110 111 不看最左边的1，从第二位开始，0表示向左，1表示向右，正好可以表示这个节点相对于根节点的位置。</span><br>    <span class="hljs-comment">//比如4的 00 就表示从根节点 向左 再向左。6的 10 就表示从根节点 向右 再向左</span><br><br>    <span class="hljs-comment">//那么想访问最后一层的节点就可以从节点的编号的二进制入手。从第二位开始的二进制位表示了最后一层的节点相对于根节点的位置。</span><br>    <span class="hljs-comment">//那么就需要一个bits = 2^(h - 1) 上面例子中的bits就是2，对应二进制为010。这样就可以从第二位开始判断。（树三层高，需要向左或向右走两次才能到叶子）</span><br>    <span class="hljs-comment">//比如看5这个节点存不存在，先通过位运算找到编号为5的节点相对于根节点的位置。010 &amp; 101 发现第二位是0，说明从根节点开始，第一步向左走。</span><br>    <span class="hljs-comment">//之后将bit右移一位，变成001。001 &amp; 101 发现第三位是1，那么第二步向右走。</span><br>    <span class="hljs-comment">//最后bit为0，说明已经找到编号为5的这个节点相对于根节点的位置，看这个节点是不是空，不是说明存在，exist返回真</span><br>    <span class="hljs-comment">//编号为5的节点存在，说明总节点数量一定大于等于5。所以二分那里low = mid</span><br><br>    <span class="hljs-comment">//再比如看7存不存在，010 &amp; 111 第二位为1，第一部从根节点向右；001 &amp; 111 第三位也为1，第二步继续向右。</span><br>    <span class="hljs-comment">//然后判断当前节点是不是null，发现是null，exist返回假。</span><br>    <span class="hljs-comment">//编号为7的节点不存在，说明总节点数量一定小于7。所以high = mid - 1</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exists</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bits</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; (level - <span class="hljs-number">1</span>);<span class="hljs-comment">//最多有2^(n+1)-1</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span> &amp;&amp; bits &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((bits &amp; k) == <span class="hljs-number">0</span>) &#123;<br>                node = node.left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                node = node.right;<br>            &#125;<br>            bits &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//O(n)解法</span><br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNodesOn</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> countNodes(root.left)+countNodes(root.right)+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-iii/">337. 打家劫舍 III</a></h4><h4 id="863-二叉树中所有距离为-K-的结点"><a href="#863-二叉树中所有距离为-K-的结点" class="headerlink" title="863. 二叉树中所有距离为 K 的结点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/">863. 二叉树中所有距离为 K 的结点</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//思路：子树距离等于k可以很方便判断出，但是难点在通过父节点进行判断，所以通过map存储数节点的父节点</span><br>    <span class="hljs-comment">//1.先序遍历得到target节点，查找其子树距离k的节点，在查找父亲节点距离k</span><br>    List&lt;Integer&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Map&lt;Integer,TreeNode&gt; parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">distanceK</span><span class="hljs-params">(TreeNode root, TreeNode target, <span class="hljs-type">int</span> k)</span> &#123;<br>        setParent(root);<br>        findAns(target,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>,k);<span class="hljs-comment">//直接从目标节点进行遍历</span><br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setParent</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root.left!=<span class="hljs-literal">null</span>)&#123;<br>            parent.put(root.left.val,root);<br>            setParent(root.left);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.right!=<span class="hljs-literal">null</span>)&#123;<br>            parent.put(root.right.val,root);<br>            setParent(root.right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">findAns</span><span class="hljs-params">(TreeNode root,TreeNode from,<span class="hljs-type">int</span> depth,<span class="hljs-type">int</span> k)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(depth==k)&#123;ret.add(root.val);<span class="hljs-keyword">return</span>;&#125;<br>        <span class="hljs-comment">//左右子节点</span><br>        <span class="hljs-keyword">if</span>(root.left!=from)findAns(root.left,root,depth+<span class="hljs-number">1</span>,k);<br>        <span class="hljs-keyword">if</span>(root.right!=from)findAns(root.right,root,depth+<span class="hljs-number">1</span>,k);<br>        <span class="hljs-comment">//父亲节点</span><br>        <span class="hljs-keyword">if</span>(parent.get(root.val)!=from)findAns(parent.get(root.val),root,depth+<span class="hljs-number">1</span>,k);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">//初始化 dp 数组</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//初始化0个节点和1个节点的情况</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>                <span class="hljs-comment">//对于第i个节点，需要考虑1作为根节点直到i作为根节点的情况，所以需要累加</span><br>                <span class="hljs-comment">//一共i个节点，对于根节点j时,左子树的节点个数为j-1，右子树的节点个数为i-j</span><br>                dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i - j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//思路：记录深度，更新最新值</span><br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-type">int</span> maxDepth;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findBottomLeftValue</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        ret = root.val;<br>        dfs(root,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root,<span class="hljs-type">int</span> dpeth)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(dpeth&gt;maxDepth)&#123;<br>            <span class="hljs-keyword">if</span>(root.left!=<span class="hljs-literal">null</span>)&#123;<br>                ret=root.left.val;<br>                maxDepth = dpeth;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.right!=<span class="hljs-literal">null</span>) &#123;<br>                ret=root.right.val;<br>                maxDepth = dpeth;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.left!=<span class="hljs-literal">null</span>)dfs(root.left,dpeth+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(root.right!=<span class="hljs-literal">null</span>)dfs(root.right,dpeth+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="700-二叉搜索树中的搜索（easy）"><a href="#700-二叉搜索树中的搜索（easy）" class="headerlink" title="700. 二叉搜索树中的搜索（easy）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a>（easy）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//迭代</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">searchBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">while</span>(root!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(root.val==val)<span class="hljs-keyword">return</span> root;<br>            root = root.val&gt;val ? root.left:root.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//递归</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">searchBST0</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(root.val==val)<span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">return</span> root.val&gt;val ? searchBST(root.left,val): searchBST(root.right,val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="404-左叶子之和（easy）"><a href="#404-左叶子之和（easy）" class="headerlink" title="404. 左叶子之和（easy）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-left-leaves/">404. 左叶子之和</a>（easy）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//左且叶子节点</span><br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root.left!=<span class="hljs-literal">null</span>&amp;&amp;root.left.left==<span class="hljs-literal">null</span>&amp;&amp;root.left.right==<span class="hljs-literal">null</span>)ret+=root.left.val;<br>        <span class="hljs-keyword">if</span>(root.left!=<span class="hljs-literal">null</span>)sumOfLeftLeaves(root.left);<br>        <span class="hljs-keyword">if</span>(root.right!=<span class="hljs-literal">null</span>)sumOfLeftLeaves(root.right);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="617-合并二叉树（easy）"><a href="#617-合并二叉树（easy）" class="headerlink" title="617. 合并二叉树（easy）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a>（easy）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mergeTrees</span><span class="hljs-params">(TreeNode t1, TreeNode t2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> t2;<br>        <span class="hljs-keyword">if</span> (t2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> t1;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">merged</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(t1.val + t2.val);<br>        merged.left = mergeTrees(t1.left, t2.left);<br>        merged.right = mergeTrees(t1.right, t2.right);<br>        <span class="hljs-keyword">return</span> merged;<br>    &#125;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mergeTrees0</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root1==<span class="hljs-literal">null</span>&amp;&amp;root2==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(root1==<span class="hljs-literal">null</span>)root1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>();<br>        root1.val+=root2==<span class="hljs-literal">null</span>?<span class="hljs-number">0</span>:root2.val;<br>        <span class="hljs-keyword">if</span>(root1.left==<span class="hljs-literal">null</span>&amp;&amp;root2!=<span class="hljs-literal">null</span>&amp;&amp;root2.left!=<span class="hljs-literal">null</span>)root1.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>();<br>        <span class="hljs-keyword">if</span>(root1.right==<span class="hljs-literal">null</span>&amp;&amp;root2!=<span class="hljs-literal">null</span>&amp;&amp;root2.right!=<span class="hljs-literal">null</span>)root1.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>();<br>        <span class="hljs-keyword">if</span>(root2!=<span class="hljs-literal">null</span>)mergeTrees(root1.left,root2.left);<br>        <span class="hljs-keyword">if</span>(root2!=<span class="hljs-literal">null</span>)mergeTrees(root1.right,root2.right);<br>        <span class="hljs-keyword">return</span> root1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//基于二叉搜索树的性质可知中序遍历后呈递增序列</span><br>    <span class="hljs-comment">//通过pre记录前一个节点的值即可与当前节点计算差值</span><br>    <span class="hljs-type">int</span> pre;<br>    <span class="hljs-type">int</span> ans;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMinimumDifference</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        ans = Integer.MAX_VALUE;<br>        pre = -<span class="hljs-number">1</span>;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        dfs(root.left);<br>        <span class="hljs-keyword">if</span> (pre == -<span class="hljs-number">1</span>) &#123;<br>            pre = root.val;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans = Math.min(ans, root.val - pre);<br>            pre = root.val;<br>        &#125;<br>        dfs(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="173-二叉搜索树迭代器"><a href="#173-二叉搜索树迭代器" class="headerlink" title="173. 二叉搜索树迭代器"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-search-tree-iterator/">173. 二叉搜索树迭代器</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BSTIterator</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> index;<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; data;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BSTIterator</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//中序遍历</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(root!=<span class="hljs-literal">null</span>||!stack.isEmpty())&#123;<br>            <span class="hljs-keyword">while</span>(root!=<span class="hljs-literal">null</span>)&#123;<br>                stack.push(root);<br>                root = root.left;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!stack.isEmpty())&#123;<br>                root = stack.pop();<br>                data.add(root.val);<br>                root = root.right;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> data.get(index++);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> index&lt;data.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//二叉搜索树性质：root.left&lt;root&lt;root.right</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)root=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>        <span class="hljs-keyword">if</span> (val&gt;root.val)&#123;<br>            <span class="hljs-keyword">if</span>(root.right==<span class="hljs-literal">null</span>)root.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>            <span class="hljs-keyword">else</span> insertIntoBST(root.right,val);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (val&lt;root.val)&#123;<br>            <span class="hljs-keyword">if</span> (root.left==<span class="hljs-literal">null</span>)root.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>            <span class="hljs-keyword">else</span> insertIntoBST(root.left,val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubStructure</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> &#123;<br>        <span class="hljs-keyword">if</span>(A==<span class="hljs-literal">null</span>||B==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(A.val==B.val &amp;&amp; compare(A,B))<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> isSubStructure(A.left,B)|| isSubStructure(A.right,B);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(TreeNode t1,TreeNode t2)</span>&#123;<br>        <span class="hljs-keyword">if</span>(t1==<span class="hljs-literal">null</span>&amp;&amp;t2==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(t1==<span class="hljs-literal">null</span>&amp;&amp;t2!=<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(t1!=<span class="hljs-literal">null</span>&amp;&amp;t2==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(t1.val!=t2.val)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> compare(t1.left,t2.left) &amp;&amp; compare(t1.right,t2.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="二叉树的下一个节点"><a href="#二叉树的下一个节点" class="headerlink" title="二叉树的下一个节点"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/9023a0c988684a53960365b889ceaf5e">二叉树的下一个节点</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeLinkNode <span class="hljs-title function_">GetNext</span><span class="hljs-params">(TreeLinkNode pNode)</span> &#123;<br>        <span class="hljs-comment">//1.空直接返回</span><br>        <span class="hljs-keyword">if</span>(pNode==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//2.右子树为空需要分为两种情况</span><br>        <span class="hljs-keyword">if</span>(pNode.right==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(pNode.next==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">//1.pNode是父节点的左子树，则返回父节点</span><br>            <span class="hljs-keyword">if</span>(pNode.next.left==pNode)<span class="hljs-keyword">return</span> pNode.next;<br>            <span class="hljs-comment">//2.pNode是父节点的右子树，则一直往上查找当当前节点是父节点的左子树，返回父节点</span><br>            <span class="hljs-keyword">while</span>(pNode.next!=<span class="hljs-literal">null</span>&amp;&amp;pNode.next.left!=pNode)pNode=pNode.next;<br>            <span class="hljs-keyword">return</span> pNode.next;<br>        &#125;<br>        <span class="hljs-comment">//3.右子树不为空则查找右子树最左的值</span><br>        <span class="hljs-keyword">return</span> dfs(pNode.right);<br>    &#125;<br>    <span class="hljs-keyword">public</span> TreeLinkNode <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeLinkNode pNode)</span> &#123;<br>        <span class="hljs-keyword">if</span>(pNode.left!=<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> dfs(pNode.left);<br>        <span class="hljs-keyword">return</span> pNode;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="1339-分裂二叉树的最大乘积（mid"><a href="#1339-分裂二叉树的最大乘积（mid" class="headerlink" title="1339. 分裂二叉树的最大乘积（mid)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-of-splitted-binary-tree/">1339. 分裂二叉树的最大乘积</a>（mid)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">long</span> sum;<br>    <span class="hljs-type">long</span> best;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProduct</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        sum(root);<br>        dfs(root);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> best * (sum - best);<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(l % <span class="hljs-number">1000000007</span>);<br>    &#125;<br>    <span class="hljs-comment">//分割子树</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dfs(root.left)+dfs(root.right)+root.val;<br>        <span class="hljs-keyword">if</span>(Math.abs(cur*<span class="hljs-number">2</span>-sum)&lt;Math.abs(best*<span class="hljs-number">2</span>-sum))best=cur;<span class="hljs-comment">//均值差值越小则乘积越大</span><br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>    <span class="hljs-comment">//计算所有节点和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span>;<br>        sum+=root.val;<br>        sum(root.left);<br>        sum(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="1302-层数最深叶子节点的和（mid）"><a href="#1302-层数最深叶子节点的和（mid）" class="headerlink" title="1302. 层数最深叶子节点的和（mid）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/deepest-leaves-sum/">1302. 层数最深叶子节点的和</a>（mid）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> layer;<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-comment">//思路：注意是层数最深的节点，dfs判断层数和累计最深层节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deepestLeavesSum</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root,<span class="hljs-type">int</span> lay,<span class="hljs-type">int</span> sum)</span>&#123;   <br>        <span class="hljs-keyword">if</span>(lay==layer)ret+=root.val;     <br>        <span class="hljs-keyword">if</span>(lay&gt;layer)&#123;<br>            layer=lay;<br>            ret = root.val;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(root.left!=<span class="hljs-literal">null</span>)dfs(root.left,lay+<span class="hljs-number">1</span>,sum+root.val);<br>        <span class="hljs-keyword">if</span>(root.right!=<span class="hljs-literal">null</span>)dfs(root.right,lay+<span class="hljs-number">1</span>,sum+root.val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="589-N-叉树的前序遍历（easy）"><a href="#589-N-叉树的前序遍历（easy）" class="headerlink" title="589. N 叉树的前序遍历（easy）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/">589. N 叉树的前序遍历</a>（easy）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;Integer&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorder0</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> ret;<br>        ret.add(root.val);<br>        <span class="hljs-keyword">for</span>(Node node:root.children)preorder(node);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorder</span><span class="hljs-params">(Node root)</span> &#123;<br>        List&lt;Integer&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> ret;<br>        Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack.push(root);<br>        <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stack.pop();<br>            ret.add(node.val);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> node.children.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>                stack.push(node.children.get(i));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="307-区域和检索-数组可修改（mid）"><a href="#307-区域和检索-数组可修改（mid）" class="headerlink" title="307. 区域和检索 - 数组可修改（mid）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改</a>（mid）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br>    <span class="hljs-comment">//线段数（叶子节点都是数组的元素）</span><br>    <span class="hljs-comment">//[1,3,5]       [1,3,5,7]        ......</span><br>    <span class="hljs-comment">//      9           16</span><br>    <span class="hljs-comment">//     / \         /  \</span><br>    <span class="hljs-comment">//    4   5       4    12</span><br>    <span class="hljs-comment">//   / \         / \   / \</span><br>    <span class="hljs-comment">//  1   3       1   3 5   7      ......</span><br>    <span class="hljs-comment">// n=3 node=6   n=4 node=7     n=5 node=9  n=6 node=12  node&lt;=2*n</span><br>    <span class="hljs-type">int</span>[] tree;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        n = nums.length;<br>        tree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>*n];<br>        buildTree(nums);<br>    &#125;<br>    <span class="hljs-comment">//构建线段树</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span>&#123;<br>        <span class="hljs-comment">//nums=[1,3,5,7] tree = [0,0,0,0,1,3,5,7] </span><br>        <span class="hljs-comment">//将所有叶子节点放置在[n,2n)数组中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n, j = <span class="hljs-number">0</span>;  i &lt; <span class="hljs-number">2</span> * n; i++,  j++)tree[i] = nums[j];<br>        <span class="hljs-comment">//tree = [0,16,4,12,1,3,5,7] </span><br>        <span class="hljs-comment">//把父节点放置在[1,n)数组中 , tree[i] = tree[i * 2] + tree[i * 2 + 1]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i)tree[i] = tree[i * <span class="hljs-number">2</span>] + tree[i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">//更新某个下标同时需要更新其父节点的值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> &#123;<br>        index+=n;<span class="hljs-comment">//下标的位置,n+下标</span><br>        tree[index] = val;<br>        <span class="hljs-comment">//更新父亲节点,因为tree[i] = tree[i * 2] + tree[i * 2 + 1];所以index如果是奇数则为右子树，index是偶数则为左子树</span><br>        <span class="hljs-keyword">while</span>(index&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> index;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> index;<br>            <span class="hljs-keyword">if</span>(index % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) right = index+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> left = index - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//更新父节点值</span><br>            tree[index / <span class="hljs-number">2</span>] = tree[left] + tree[right];<br>            <span class="hljs-comment">//更新下标</span><br>            index /= <span class="hljs-number">2</span>;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-comment">//求和只需要获取其父节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-comment">//确认在数组中的下标</span><br>        left+=n;<br>        right+=n;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//[1,3,5,7]</span><br>        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>            <span class="hljs-comment">//1.如果left是左子树可以直接取根节点,如果是右子树那只取右节点</span><br>            <span class="hljs-keyword">if</span>(left % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> )&#123;<br>                ret+=tree[left];<br>                left++;<br>            &#125;<br>            <span class="hljs-comment">//2.如果right是右子树可以直接取根节点,如果是左子树那只取左节点</span><br>            <span class="hljs-keyword">if</span>(right % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> )&#123;<br>                ret+=tree[right];<br>                right--;<br>            &#125;<br>            left/=<span class="hljs-number">2</span>;<br>            right/=<span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="951-翻转等价二叉树（mid）"><a href="#951-翻转等价二叉树（mid）" class="headerlink" title="951. 翻转等价二叉树（mid）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flip-equivalent-binary-trees/">951. 翻转等价二叉树</a>（mid）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//递归交互左右子树判断</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">flipEquiv</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root1 == root2)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (root1 == <span class="hljs-literal">null</span> || root2 == <span class="hljs-literal">null</span> || root1.val != root2.val)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> (flipEquiv(root1.left, root2.left) &amp;&amp; flipEquiv(root1.right, root2.right) || flipEquiv(root1.left, root2.right) &amp;&amp; flipEquiv(root1.right, root2.left));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="538-把二叉搜索树转换为累加树（mid）"><a href="#538-把二叉搜索树转换为累加树（mid）" class="headerlink" title="538. 把二叉搜索树转换为累加树（mid）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a>（mid）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//中序遍历:右-根-左</span><br>    <span class="hljs-type">int</span> sum;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">convertBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span>(root.right!=<span class="hljs-literal">null</span>)convertBST(root.right);<br>        sum+=root.val;<br>        root.val = sum;<br>        <span class="hljs-keyword">if</span>(root.left!=<span class="hljs-literal">null</span>)convertBST(root.left);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="814-二叉树剪枝（mid）"><a href="#814-二叉树剪枝（mid）" class="headerlink" title="814. 二叉树剪枝（mid）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-pruning/">814. 二叉树剪枝</a>（mid）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//dfs</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">pruneTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> root!=<span class="hljs-literal">null</span>&amp;&amp;root.left==<span class="hljs-literal">null</span>&amp;&amp;root.right==<span class="hljs-literal">null</span>&amp;&amp;root.val==<span class="hljs-number">0</span>?<span class="hljs-literal">null</span>:root;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>,right = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(root.left!=<span class="hljs-literal">null</span>)left = dfs(root.left);<br>        <span class="hljs-keyword">if</span>(root.right!=<span class="hljs-literal">null</span>)right = dfs(root.right);<br>        <span class="hljs-comment">//左右节点都是0才能移除</span><br>        <span class="hljs-keyword">if</span>(left)root.left = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(right)root.right = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> left &amp;&amp; right &amp;&amp; root.val==<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="669-修剪二叉搜索树（mid）"><a href="#669-修剪二叉搜索树（mid）" class="headerlink" title="669. 修剪二叉搜索树（mid）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a>（mid）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//思路：基于二叉搜索树，其左子树都小于根节点，右子树都大于根节点</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">trimBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span> (root.val &gt; R) <span class="hljs-keyword">return</span> trimBST(root.left, L, R);<span class="hljs-comment">//去除右子树</span><br>        <span class="hljs-keyword">if</span> (root.val &lt; L) <span class="hljs-keyword">return</span> trimBST(root.right, L, R);<span class="hljs-comment">//去除左子树</span><br>        <span class="hljs-comment">//如果root.val在区[L,R]区间,则递归判断其左右子树</span><br>        root.left = trimBST(root.left, L, R);<br>        root.right = trimBST(root.right, L, R);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="1325-删除给定值的叶子节点（mid）"><a href="#1325-删除给定值的叶子节点（mid）" class="headerlink" title="1325. 删除给定值的叶子节点（mid）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-leaves-with-a-given-value/">1325. 删除给定值的叶子节点</a>（mid）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//思路：自底向上删除</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">removeLeafNodes</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span>(root.left!=<span class="hljs-literal">null</span>)removeLeafNodes(root.left,target);<br>        <span class="hljs-keyword">if</span>(root.right!=<span class="hljs-literal">null</span>)removeLeafNodes(root.right,target);<br>        <span class="hljs-keyword">if</span>(root.left!=<span class="hljs-literal">null</span>&amp;&amp;root.left.val==target&amp;&amp;root.left.left==<span class="hljs-literal">null</span>&amp;&amp;root.left.right==<span class="hljs-literal">null</span>)root.left=<span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(root.right!=<span class="hljs-literal">null</span>&amp;&amp;root.right.val==target&amp;&amp;root.right.left==<span class="hljs-literal">null</span>&amp;&amp;root.right.right==<span class="hljs-literal">null</span>)root.right=<span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> root.left==<span class="hljs-literal">null</span>&amp;&amp;root.right==<span class="hljs-literal">null</span>&amp;&amp;root.val==target?<span class="hljs-literal">null</span>:root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="1026-节点与其祖先之间的最大差值（mid）"><a href="#1026-节点与其祖先之间的最大差值（mid）" class="headerlink" title="1026. 节点与其祖先之间的最大差值（mid）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-difference-between-node-and-ancestor/">1026. 节点与其祖先之间的最大差值</a>（mid）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxAncestorDiff</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root,<span class="hljs-number">0</span>,<span class="hljs-number">100000</span>);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root,<span class="hljs-type">int</span> max,<span class="hljs-type">int</span> min)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span>;<br>        max=Math.max(max,root.val);<br>        min=Math.min(min,root.val);<br>        ret=Math.max(ret,max-min);<br>        <span class="hljs-keyword">if</span>(root.left!=<span class="hljs-literal">null</span>)dfs(root.left,max,min);<br>        <span class="hljs-keyword">if</span>(root.right!=<span class="hljs-literal">null</span>)dfs(root.right,max,min);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="687-最长同值路径（mid"><a href="#687-最长同值路径（mid" class="headerlink" title="687. 最长同值路径（mid)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-univalue-path/">687. 最长同值路径</a>（mid)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//思路:dfs遍历每次返回左右子树最大的值，ret取的是max(左右子树路径,左右子树路径最大值+根)</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestUnivaluePath</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        dfs(root,root.val);<br>        <span class="hljs-keyword">if</span>(root.left!=<span class="hljs-literal">null</span>)longestUnivaluePath(root.left);<br>        <span class="hljs-keyword">if</span>(root.right!=<span class="hljs-literal">null</span>)longestUnivaluePath(root.right);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root,<span class="hljs-type">int</span> target)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>||root.val!=target)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> dfs(root.left,target);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> dfs(root.right,target);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Math.max(l,r)+<span class="hljs-number">1</span>;<br>        ret=Math.max(Math.max(l+r,c-<span class="hljs-number">1</span>),ret);<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="979-在二叉树中分配硬币（mid）"><a href="#979-在二叉树中分配硬币（mid）" class="headerlink" title="979. 在二叉树中分配硬币（mid）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/distribute-coins-in-binary-tree/">979. 在二叉树中分配硬币</a>（mid）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从后序遍历的第一个叶子节点开始，假设自己有x个金币，剩余x-1个金币都还给父节点，x-1可能为负数、0、正数</span><br><span class="hljs-comment">     * x-1 &lt; 0说明不够金币，需要从父节点获得，因此子节点有|x-1|个入方向的操作，次数加上|x-1|</span><br><span class="hljs-comment">     * x-1 == 0说明刚好，无需与父节点有金币的交换，次数加0</span><br><span class="hljs-comment">     * x-1 &gt; 0 说明有多余的金币，需要交给父节点，因此子节点有x-1个出方向的操作，次数加上|x-1|</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// 移动次数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">distributeCoins</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        lrd(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lrd</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root.left != <span class="hljs-literal">null</span>)&#123;<br>            root.val += lrd(root.left);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.right != <span class="hljs-literal">null</span>)&#123;<br>            root.val += lrd(root.right);<br>        &#125;<br>        ans += Math.abs(root.val - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> root.val - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="715-Range-模块（hard）"><a href="#715-Range-模块（hard）" class="headerlink" title="715. Range 模块（hard）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-module/">715. Range 模块</a>（hard）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">class RangeModule &#123;<br>        private TreeMap&lt;Integer,Integer&gt; map;<br>        public RangeModule() &#123;<br>            this.map = new TreeMap&lt;&gt;();<br>        &#125;<br>        public void addRange(int left, int right) &#123;<br>            int actualLeft = left,actualRight = right;<br>            //1.向左边检查是否有可以覆盖的<br>            Integer leftFloorKey = map.floorKey(left);<br>            //如果有个区间已经包含当前需要新增的区间则无需改动<br>            if (leftFloorKey!=null &amp;&amp;leftFloorKey&lt;=left&amp;&amp;map.get(leftFloorKey)&gt;=right)return;<br>            while (leftFloorKey!= null &amp;&amp; map.get(leftFloorKey)&gt;=left)&#123;<br>                actualLeft = leftFloorKey;<br>                map.remove(leftFloorKey);<br>                leftFloorKey = map.floorKey(leftFloorKey);<br>            &#125;<br>            //2.向右边检查是否有可以覆盖的<br>            Integer leftCeilKey = map.ceilingKey(left);<br>            while (leftCeilKey!= null &amp;&amp; map.get(leftCeilKey)&lt;=right)&#123;<br>                map.remove(leftCeilKey);<br>                leftCeilKey = map.ceilingKey(leftCeilKey);<br>            &#125;<br>            //3.确定最终right<br>            if (leftCeilKey!= null &amp;&amp; leftCeilKey&lt;=right)&#123;<br>                actualRight = map.get(leftCeilKey);<br>                map.remove(leftCeilKey);<br>            &#125;<br>            //确保[actualLeft,actualRight]没有值<br>            Integer remove = map.ceilingKey(actualLeft);<br>            while (remove!=null&amp;&amp;map.get(remove)&lt;actualRight)&#123;<br>                map.remove(remove);<br>                remove = map.ceilingKey(actualLeft);<br>            &#125;<br>            map.put(actualLeft,actualRight);<br>        &#125;<br><br>        public boolean queryRange(int left, int right) &#123;<br>            Integer floorKey = map.floorKey(left);<br>            if (floorKey==null&amp;&amp;map.get(left)==null)return false;<br>            Integer floorValue = map.get(floorKey);<br>            if (floorValue&gt;=right)return true;<br>            return false;<br>        &#125;<br><br>        public void removeRange(int left, int right) &#123;<br>            //左边区间去掉相交部分<br>            Integer floorKey = map.floorKey(left);<br>            if (floorKey!=null)&#123;<br>                Integer floorValue = map.get(floorKey);<br>                if (floorValue&gt;left)map.put(floorKey,left);<br>                if (floorValue&gt;right)map.put(right,floorValue);<br>            &#125;<br>            //中间区间全部去除<br>            Integer leftCeilKey = map.ceilingKey(left);<br>            while (leftCeilKey!= null &amp;&amp; leftCeilKey&lt;right)&#123;<br>                Integer leftCeilValue = map.get(leftCeilKey);<br>                if (leftCeilValue&gt;right)&#123;<br>                    map.put(right,leftCeilValue);<br>                &#125;<br>                map.remove(leftCeilKey);<br>                leftCeilKey = map.ceilingKey(leftCeilKey);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h4 id="834-树中距离之和（hard）"><a href="#834-树中距离之和（hard）" class="headerlink" title="834. 树中距离之和（hard）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-distances-in-tree/">834. 树中距离之和</a>（hard）</h4><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1>
              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" class="category-chain-item">算法相关</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>算法笔记-二叉树/线段树/排序树</div>
      <div>https://mikeygithub.github.io/2019/10/10/yuque/ubx7qo/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Mikey</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2019年10月10日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2019/11/19/yuque/xd5zoq/" title="算法笔记-双指针/窗口滑动">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">算法笔记-双指针/窗口滑动</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2019/09/20/yuque/wvtf2p/" title="Hyperledger Caliper 性能测试工具配置">
                        <span class="hidden-mobile">Hyperledger Caliper 性能测试工具配置</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'mikeygithub/commit-utterance');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  





  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.13.10/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});
  });
</script>




  <!-- Custom -->
  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" lazyload class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       Copyright © 麦奇 Powered by <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> and <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> core on github page 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      桂ICP备2020009931号-1
    </a>
  </span>
  
    
      <span>
        <a
          href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=2020009931"
          rel="nofollow noopener"
          class="beian-police"
          target="_blank"
        >
          
            <span style="visibility: hidden; width: 0">|</span>
            <img src="/img/police_beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
          
          <span>桂公网安备2020009931号</span>
        </a>
      </span>
    
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?74301a15e5497361e93588eeee69f4b2";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  

  

  

  

  

  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        MathJax = {
          tex    : {
            inlineMath: { '[+]': [['$', '$']] }
          },
          loader : {
            load: ['ui/lazy']
          },
          options: {
            renderActions: {
              findScript    : [10, doc => {
                document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                  const display = !!node.type.match(/; *mode=display/);
                  const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                  const text = document.createTextNode('');
                  node.parentNode.replaceChild(text, node);
                  math.start = { node: text, delim: '', n: 0 };
                  math.end = { node: text, delim: '', n: 0 };
                  doc.math.push(math);
                });
              }, '', false],
              insertedScript: [200, () => {
                document.querySelectorAll('mjx-container').forEach(node => {
                  let target = node.parentNode;
                  if (target.nodeName.toLowerCase() === 'li') {
                    target.parentNode.classList.add('has-jax');
                  }
                });
              }, '', false]
            }
          }
        };
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.0/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
