

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <meta name="referrer" content="no-referrer"/>
  <link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/favicon.png">
  <link rel="icon" href="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Mikey">
  <meta name="keywords" content="">
  
    <meta name="description" content="简介java.util.concurrent（JUC）  本篇文章仅仅是对JUC包下的工具做一些简单的阐述，其每一项都可以更加的具体深入理解。  该包下是在并发编程中常用的实用程序类。这个包包括一些小型的标准化可扩展框架，以及一些提供有用功能的类。  Atomic（原子类） 该包下主要提供一些数据类型的原子类，如AtomicBoolean、AtomicInteger、AtomicIntegerA">
<meta property="og:type" content="article">
<meta property="og:title" content="并发笔记- 并发工具之JUC包">
<meta property="og:url" content="https://mikeygithub.github.io/2022/04/27/yuque/nmh349/index.html">
<meta property="og:site_name" content="麦奇">
<meta property="og:description" content="简介java.util.concurrent（JUC）  本篇文章仅仅是对JUC包下的工具做一些简单的阐述，其每一项都可以更加的具体深入理解。  该包下是在并发编程中常用的实用程序类。这个包包括一些小型的标准化可扩展框架，以及一些提供有用功能的类。  Atomic（原子类） 该包下主要提供一些数据类型的原子类，如AtomicBoolean、AtomicInteger、AtomicIntegerA">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/2630542/1655110886658-ced74253-3f21-4aba-8cfd-84c82b8d25a3.png">
<meta property="article:published_time" content="2022-04-27T09:24:22.000Z">
<meta property="article:modified_time" content="2023-05-14T16:04:58.390Z">
<meta property="article:author" content="Mikey">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2022/png/2630542/1655110886658-ced74253-3f21-4aba-8cfd-84c82b8d25a3.png">
  
  
<!--    <meta name="referrer" content="no-referrer-when-downgrade">-->
  
  
  <title>并发笔记- 并发工具之JUC包 - 麦奇</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"mikeygithub.github.io","root":"/","version":"1.9.1","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":200}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"74301a15e5497361e93588eeee69f4b2","google":"G-NCN3Z5PSLJ","gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="麦奇" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>麦奇</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/photo/">
                <i class="iconfont icon-image"></i>
                照片
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/music/">
                <i class="iconfont icon-music"></i>
                音乐
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/atom.xml">
                <i class="iconfont icon-rss"></i>
                RSS
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="并发笔记- 并发工具之JUC包"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Mikey
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-04-27 17:24" pubdate>
          2022年4月27日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          66k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          553 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">并发笔记- 并发工具之JUC包</h1>
            
            <div class="markdown-body">
              
              <p><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1655110886658-ced74253-3f21-4aba-8cfd-84c82b8d25a3.png#averageHue=%234162e8&clientId=u0ddc5a62-58fa-4&errorMessage=unknown%20error&from=paste&height=564&id=ufaa7991d&originHeight=564&originWidth=900&originalType=binary&ratio=1&rotation=0&showTitle=false&size=180109&status=error&style=none&taskId=u253749fb-b081-4c55-acdb-3e51d629efd&title=&width=900" srcset="/img/loading.gif" lazyload alt="R-C.png"></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>java.util.concurrent（JUC）</p>
<blockquote>
<p>本篇文章仅仅是对JUC包下的工具做一些简单的阐述，其每一项都可以更加的具体深入理解。</p>
</blockquote>
<p>该包下是在并发编程中常用的实用程序类。这个包包括一些小型的标准化可扩展框架，以及一些提供有用功能的类。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/2630542/1653832379760-fb4e89d7-4bc8-4b18-9a09-1e01975291fa.jpeg" srcset="/img/loading.gif" lazyload></p>
<h1 id="Atomic（原子类）"><a href="#Atomic（原子类）" class="headerlink" title="Atomic（原子类）"></a>Atomic（原子类）</h1><blockquote>
<p>该包下主要提供一些数据类型的原子类，如AtomicBoolean、AtomicInteger、AtomicIntegerArray、AtomicIntegerFieldUpdater、AtomicLong、AtomicLongArray、AtomicLongFieldUpdater、AtomicMarkableReference、AtomicReference、AtomicReferenceArray、AtomicReferenceFieldUpdater、AtomicStampedReference。这些原子类全部依托与底层的Unsafe类实现CAS的操作保证其原子性。</p>
</blockquote>
<h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><blockquote>
<p>AtomicInteger的主要方法如下图所示</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1651055732522-1c54be02-55a6-46cd-a55d-1a25361ed2e5.png#averageHue=%23568f41&clientId=ub4006a1f-84d6-4&errorMessage=unknown%20error&from=paste&height=484&id=ub352b364&originHeight=1334&originWidth=1328&originalType=binary&ratio=1&rotation=0&showTitle=false&size=204624&status=error&style=none&taskId=ua6a50300-313b-4297-8e7c-baf7cafb097&title=&width=482" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>JUC包下的相关原子类都是基于Unsafe类来进行CAS实现，Unsafe通过JDNI调用本地接口来操作内存实现我们加/解锁、</p>
<p>Unsafe类 see: <a href="https://mikeygithub.github.io/2022/05/25/yuque/eff1dm/">https://mikeygithub.github.io/2022/05/25/yuque/eff1dm/</a></p>
<p>使用案例</p>
<p>1.基于AtomicInteger实现线程交替打印AB</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<br>            () -&gt; &#123;<br>                <span class="hljs-keyword">while</span> (atomicInteger.get() &lt;= <span class="hljs-number">1000</span> )<br>                    <span class="hljs-keyword">while</span> ( atomicInteger.get() % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                    System.out.println(Thread.currentThread().getName() + atomicInteger.intValue());<br>                    atomicInteger.getAndIncrement();<br>                &#125;<br>            &#125;<br>            , <span class="hljs-string">&quot;Thread A &quot;</span>).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<br>            () -&gt; &#123;<br>                <span class="hljs-keyword">while</span> (atomicInteger.get() &lt;= <span class="hljs-number">1000</span> )<br>                    <span class="hljs-keyword">while</span> ( atomicInteger.get() % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>                    System.out.println(Thread.currentThread().getName() + atomicInteger.intValue());<br>                    atomicInteger.getAndIncrement();<br>                &#125;<br>            &#125;<br>            , <span class="hljs-string">&quot;Thread B &quot;</span>).start();<br>    Thread.sleep(<span class="hljs-number">3000</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>2.基于AtomicInteger实现多线程打印ABCD</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">dd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<br>            () -&gt; &#123;<br>                <span class="hljs-keyword">while</span> (aa.get() &lt; count )<br>                    <span class="hljs-keyword">while</span> ( dd.get() == aa.get()) &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;A&quot;</span>);<br>                    aa.getAndIncrement();<br>                &#125;<br>            &#125;<br>            , <span class="hljs-string">&quot;Thread A &quot;</span>).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<br>            () -&gt; &#123;<br>                <span class="hljs-keyword">while</span> (bb.get() &lt; count )<br>                    <span class="hljs-keyword">while</span> ( bb.get() &lt; aa.get()) &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;B&quot;</span>);<br>                    bb.getAndIncrement();<br>                &#125;<br>            &#125;<br>            , <span class="hljs-string">&quot;Thread B &quot;</span>).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<br>            () -&gt; &#123;<br>                <span class="hljs-keyword">while</span> (cc.get() &lt; count )<br>                    <span class="hljs-keyword">while</span> ( cc.get() &lt; bb.get()) &#123;<br>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;C&quot;</span>);<br>                        cc.getAndIncrement();<br>                    &#125;<br>            &#125;<br>            , <span class="hljs-string">&quot;Thread C &quot;</span>).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<br>            () -&gt; &#123;<br>                <span class="hljs-keyword">while</span> (dd.get() &lt; count )<br>                    <span class="hljs-keyword">while</span> ( dd.get() &lt; cc.get()) &#123;<br>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;D&quot;</span>);<br>                        dd.getAndIncrement();<br>                    &#125;<br>            &#125;<br>            , <span class="hljs-string">&quot;Thread D &quot;</span>).start();<br>    Thread.sleep(<span class="hljs-number">3000</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h2><p>基于性能考虑。AtomicLong的incrementAndGet()方法在高并发场景下，多个线程竞争修改共享资源value,会造成循环耗时过长（一直自旋CAS），进而导致性能问题，这个时候LongAdder应运而生。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LongAdder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Striped64</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span><br></code></pre></td></tr></table></figure>
<p>可以看到LongAdder继承的是Striped64，其核心操作和属性也是在Striped64中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//cells数组存放每个value的值</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Cell[] cells;<span class="hljs-comment">//2的幂次方和hashmap原理一样，通过位运算提高效率</span><br><span class="hljs-comment">//基本值，主要在没有竞争时使用，但在表初始化竞争期间也用作回退。通过CAS更新</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> base;<br><span class="hljs-comment">//Cells的锁标记，当Cells数组初始化，创建元素或者扩容的时候为1，否则为0</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> cellsBusy;<br><br><span class="hljs-meta">@sun</span>.misc.Contended<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cell</span> &#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> value;<span class="hljs-comment">//由volatile修饰的long value</span><br>    <span class="hljs-comment">//类的构造函数</span><br>    Cell(<span class="hljs-type">long</span> x) &#123;<br>        value = x;<br>    &#125;<br>    <span class="hljs-comment">//cas函数</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cas</span><span class="hljs-params">(<span class="hljs-type">long</span> cmp, <span class="hljs-type">long</span> val)</span> &#123;<br>        <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapLong(<span class="hljs-built_in">this</span>, valueOffset, cmp, val);<br>    &#125;<br>    <span class="hljs-comment">// Unsafe mechanics</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> sun.misc.Unsafe UNSAFE;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> valueOffset;<span class="hljs-comment">//value的内存偏移量</span><br>    <br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//初始化类时获取必要字段信息</span><br>            UNSAFE = sun.misc.Unsafe.getUnsafe();<br>            Class&lt;?&gt; ak = Cell.class;<br>            valueOffset = UNSAFE.objectFieldOffset(ak.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//对base值进行cas修改，成功返回true</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">casBase</span><span class="hljs-params">(<span class="hljs-type">long</span> cmp, <span class="hljs-type">long</span> val)</span> &#123;<br>    <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapLong(<span class="hljs-built_in">this</span>, BASE, cmp, val);<br>&#125;<br><span class="hljs-comment">//返回当前线程的探测值。由于打包限制，已从ThreadLocalRandom复制。可以理解为hashmap h值</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getProbe</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> UNSAFE.getInt(Thread.currentThread(), PROBE);<br>&#125;<br><span class="hljs-comment">//对cellsBusy进行cas修改，cellsBusy表示创建元素或者扩容的时候为1，否则为0</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">casCellsBusy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, CELLSBUSY, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    &#125;<br><span class="hljs-comment">//如果下面代码中的3修改失败，进入当前方法，x为需要增加的值，fn为操作符，wasUncontended为是否无竞争</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">longAccumulate</span><span class="hljs-params">(<span class="hljs-type">long</span> x, LongBinaryOperator fn, <span class="hljs-type">boolean</span> wasUncontended)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-comment">//获取当前线程的probe，如果值为0，说明未初始化，则重新获取</span><br>    <span class="hljs-keyword">if</span> ((h = getProbe()) == <span class="hljs-number">0</span>) &#123;<br>        ThreadLocalRandom.current(); <span class="hljs-comment">//强制初始化</span><br>        h = getProbe();<br>        wasUncontended = <span class="hljs-literal">true</span>;<span class="hljs-comment">//未初始化是没有产生竞争的</span><br>    &#125;<br>    <span class="hljs-comment">//是否发生碰撞，即多个线程hash到同一个Cell元素位置</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">collide</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">// 如果最后一个插槽非空，则为True</span><br>    <span class="hljs-keyword">for</span> (; ; ) &#123;<br>        Cell[] as;<br>        Cell a;<br>        <span class="hljs-type">int</span> n;<br>        <span class="hljs-type">long</span> v;<br>        <span class="hljs-comment">//判断cells数组是否已经初始化</span><br>        <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//如果当前线程hash对应到的桶下标为空，</span><br>            <span class="hljs-keyword">if</span> ((a = as[(n - <span class="hljs-number">1</span>) &amp; h]) == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//尝试创建新的cell（扩容），前面提到，如果cellsBusy==0表示没有其他线程在创建新的cell项</span><br>                <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span>) &#123;       <span class="hljs-comment">// Try to attach new Cell</span><br>                    <span class="hljs-comment">//新扩容的项</span><br>                    <span class="hljs-type">Cell</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>(x);   <span class="hljs-comment">// Optimistically create</span><br>                    <span class="hljs-comment">//尝试修改cellsBusy值</span><br>                    <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;<br>                        <span class="hljs-type">boolean</span> <span class="hljs-variable">created</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">try</span> &#123;               <span class="hljs-comment">// Recheck under lock</span><br>                            Cell[] rs;<br>                            <span class="hljs-type">int</span> m, j;<br>                            <span class="hljs-keyword">if</span> ((rs = cells) != <span class="hljs-literal">null</span> &amp;&amp;<br>                                    (m = rs.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>                                    rs[j = (m - <span class="hljs-number">1</span>) &amp; h] == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//再次取桶下标</span><br>                                rs[j] = r;<span class="hljs-comment">//赋值给当前桶</span><br>                                created = <span class="hljs-literal">true</span>;<span class="hljs-comment">//创建完成</span><br>                            &#125;<br>                        &#125; <span class="hljs-keyword">finally</span> &#123;<br>                            <span class="hljs-comment">//设置为0表示当前没有线程在扩容</span><br>                            cellsBusy = <span class="hljs-number">0</span>;<br>                        &#125;<br>                        <span class="hljs-comment">//如果已经创建完成则退出循环</span><br>                        <span class="hljs-keyword">if</span> (created)<span class="hljs-keyword">break</span>;<br>                        <span class="hljs-comment">//否则进行for循环尝试</span><br>                        <span class="hljs-keyword">continue</span>;           <span class="hljs-comment">// Slot is now non-empty</span><br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">//未碰撞</span><br>                collide = <span class="hljs-literal">false</span>;<br>            &#125; <br>            <span class="hljs-comment">//如果取的桶下标对应的cell不为空且wasUncontended=false则说明cas失败有竞争</span><br>            <span class="hljs-comment">// 重置wasUncontended，通过下面的advanceProbe()重新hash，找到新的位置进行下一轮重试</span><br>            <span class="hljs-comment">// 之所以重置wasUncontended，是为了下一轮重试时走下面cas分支，尝试对该位置元素进行值的修改</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!wasUncontended)       <span class="hljs-comment">// CAS already known to fail</span><br>                wasUncontended = <span class="hljs-literal">true</span>;      <span class="hljs-comment">// Continue after rehash</span><br>            <span class="hljs-comment">//尝试进行cas更新，fn是操作符（缺省是加操作）</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.cas(v = a.value, ((fn == <span class="hljs-literal">null</span>) ? v + x :<br>                    fn.applyAsLong(v, x))))<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//如果n（cells长度）大于但其机器cpu可用核心数 或 cells已经扩容</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt;= NCPU || cells != as) collide = <span class="hljs-literal">false</span>;            <span class="hljs-comment">// At max size or stale</span><br>            <span class="hljs-comment">//否则就是发生了碰撞,设置碰撞表示为true</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!collide) collide = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//碰撞失败尝试修改cellsBusy值</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (cells == as) &#123;      <span class="hljs-comment">// Expand table unless stale</span><br>                        Cell[] rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>[n &lt;&lt; <span class="hljs-number">1</span>];<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>                            rs[i] = as[i];<br>                        cells = rs;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    cellsBusy = <span class="hljs-number">0</span>;<br>                &#125;<br>                collide = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">continue</span>;                   <span class="hljs-comment">// Retry with expanded table</span><br>            &#125;<br>            h = advanceProbe(h);<br>        &#125; <br>        <span class="hljs-comment">//否则cells为空则进行casbase</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">init</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;                           <span class="hljs-comment">// Initialize table</span><br>                <span class="hljs-keyword">if</span> (cells == as) &#123;<br>                    <span class="hljs-comment">//初始化值为2</span><br>                    Cell[] rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>[<span class="hljs-number">2</span>];<br>                    rs[h &amp; <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>(x);<span class="hljs-comment">//确定对应的桶下标</span><br>                    cells = rs;<br>                    init = <span class="hljs-literal">true</span>;<span class="hljs-comment">//初始化完成</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                cellsBusy = <span class="hljs-number">0</span>;<span class="hljs-comment">//释放锁</span><br>            &#125;<br>            <span class="hljs-comment">//跳出死循环</span><br>            <span class="hljs-keyword">if</span> (init) <span class="hljs-keyword">break</span>;<br>        &#125; <br>        <span class="hljs-comment">//如果不满足上一个if则说明有其他线程获取锁正在初始化，尝试x添加到base上</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (casBase(v = base, ((fn == <span class="hljs-literal">null</span>) ? v + x :<br>                fn.applyAsLong(v, x))))<br>            <span class="hljs-keyword">break</span>;                          <span class="hljs-comment">// Fall back on using base</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//当前线程的ThreadLocalRandom</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadLocalRandom <span class="hljs-title function_">current</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (UNSAFE.getInt(Thread.currentThread(), PROBE) == <span class="hljs-number">0</span>)localInit();<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>下面我们来看看LongAdder的相关方法，可以看到其increment和decrement都调用了add方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//核心方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">long</span> x)</span> &#123;<br>    Cell[] as;<span class="hljs-comment">// Striped64对内部类数组</span><br>    <span class="hljs-type">long</span> b, v; <br>    <span class="hljs-type">int</span> m; <br>    Cell a;<br>    <span class="hljs-comment">//1.将cells赋值给当前as局部变量，如果as不是null说明初始化过，满足第一个条件直接往下执行</span><br>    <span class="hljs-comment">//2.如果as是空，说明没有初始化过，则进入第二个条件判断，对base值进行修改（没有竞争对base进行修改，有竞争cells才起作用），</span><br>    <span class="hljs-comment">//	2.1如果修改成功返回true则执行结束</span><br>    <span class="hljs-comment">//	2.2如果修改失败则说明有另外一个线程在竞争，进入if代码块</span><br>    <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-literal">null</span> || !casBase(b = base, b + x)) &#123;<br>        <span class="hljs-comment">//如果进入代码块则说明有竞争uncontended=true</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">uncontended</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (as == <span class="hljs-literal">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||<span class="hljs-comment">//1.判断cells是否已经初始化过</span><br>            (a = as[getProbe() &amp; m]) == <span class="hljs-literal">null</span> ||<span class="hljs-comment">//2.进入这里说明cells已经初始化，通过位运算确定当前修改的桶下标</span><br>            !(uncontended = a.cas(v = a.value, v + x)))<span class="hljs-comment">//3.此时a已经赋值好，尝试cas修改a的值为a.value+x，如果修改成功返回true,取反为false直接结束</span><br>            <span class="hljs-comment">//如果3修改失败，进入longAccumulate详细见上面的分析</span><br>            longAccumulate(x, <span class="hljs-literal">null</span>, uncontended);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//增加</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>    add(<span class="hljs-number">1L</span>);<br>&#125;<br><span class="hljs-comment">//减少</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span> &#123;<br>    add(-<span class="hljs-number">1L</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结论：</p>
<blockquote>
<p><strong>内部维护了多个Cell变量，每个Cell里面有一个初始值为0的long型变量，这样同时争取一个变量的线程就变少了，而是分散成对多个变量的竞争，减少了失败次数。如果竞争某个Cell变量失败，它不会一直在这个Cell变量上自旋CAS重试，而是尝试在其他的Cell变量上进行CAS尝试，这个改变增加了当前线程重试CAS成功的可能性。最后，在获取LongAdder当前值时，是把所有Cell变量的value值累加后再加上base返回的，即：它的 sum 是 base + 各个 Cell 中 value 的总和</strong></p>
</blockquote>
<p>LongAdder的原理就是降低对value更新的并发数，也就是将对单一value的变更压力分散到多个value值上，降低单个value的竞争。</p>
<h2 id="LongAccumulator"><a href="#LongAccumulator" class="headerlink" title="LongAccumulator"></a>LongAccumulator</h2><p>它是把LongAdder的(v + x)操作换成一个LongBinaryOperator，即用户可以自定义累加操作的逻辑，其他地方都是一样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">LongAccumulator</span><span class="hljs-params">(LongBinaryOperator accumulatorFunction,  <span class="hljs-type">long</span> identity)</span> &#123;     <br>    <span class="hljs-built_in">this</span>.function = accumulatorFunction;  base = <span class="hljs-built_in">this</span>.identity = identity; <br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Striped64"><a href="#Striped64" class="headerlink" title="Striped64"></a>Striped64</h2><p>分散热点，将value值分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。如果要获取真正的long值，只要将各个槽中的变量值累加返回。</p>
<h1 id="Executors（执行器）"><a href="#Executors（执行器）" class="headerlink" title="Executors（执行器）"></a>Executors（执行器）</h1><blockquote>
<p>此包中定义的Executor、ExecutorService、ScheduledExecutorService、ThreadFactory和可调用类的工厂和实用程序方法。此类支持以下类型的方法：</p>
<ul>
<li>创建并返回使用常用配置设置设置设置的ExecutorService的方法。</li>
<li>创建并返回使用常用配置设置设置设置的ScheduledExecutorService。</li>
<li>创建并返回“包装的”ExecutorService，该服务通过使特定于实现的方法不可访问来禁用重新配置。</li>
<li>创建并返回将新创建的线程设置为已知状态的线程工厂。</li>
</ul>
</blockquote>
<p>这些方法从其他类似闭包的表单中创建并返回可调用的，因此可以在需要可调用的执行方法中使用。</p>
<h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><blockquote>
<p>该类为执行器的统一抽象接口，只规范了一个execute方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Executor</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Executes the given command at some time in the future.  The command</span><br><span class="hljs-comment">     * may execute in a new thread, in a pooled thread, or in the calling</span><br><span class="hljs-comment">     * thread, at the discretion of the &#123;<span class="hljs-doctag">@code</span> Executor&#125; implementation.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> command the runnable task</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> RejectedExecutionException if this task cannot be</span><br><span class="hljs-comment">     * accepted for execution</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NullPointerException if command is null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><blockquote>
<p>executorService是统一任务或者线程执行服务规范定义</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Executor</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span>;<span class="hljs-comment">//关闭当前执行服务</span><br>    List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isShutdown</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTerminated</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitTermination</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><span class="hljs-keyword">throws</span> InterruptedException;<br>    &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span>;<span class="hljs-comment">//Callable接口任务</span><br>    &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span>;<span class="hljs-comment">//Runnable接口任务</span><br>    Future&lt;?&gt; submit(Runnable task);<span class="hljs-comment">//单个Runnable接口任务</span><br>    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br>    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span>  <span class="hljs-keyword">throws</span> InterruptedException;<br>    &lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br>    &lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h3><blockquote>
<p>一种线程池执行器，可以另外安排命令在给定延迟后运行，或定期执行。当需要多个工作线程时，或者当需要ThreadPoolExecutor（该类扩展）的额外灵活性或功能时，该类比Timer更可取。</p>
</blockquote>
<h4 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduledThreadPoolExecutorExample</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getDate</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> sdf.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    &#125;<br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">ScheduledThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<span class="hljs-number">2</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy());<br>        <span class="hljs-comment">//延迟执行任务</span><br>        executor.schedule(()-&gt; System.out.println(String.format(<span class="hljs-string">&quot;线程 %s 当前时间 %s&quot;</span>,Thread.currentThread().getName(),getDate())),<span class="hljs-number">3</span>, TimeUnit.SECONDS);<br>        <span class="hljs-comment">//周期性执行</span><br>        executor.scheduleWithFixedDelay(()-&gt; System.out.println(String.format(<span class="hljs-string">&quot;线程%s 当前时间%s&quot;</span>,Thread.currentThread().getName(),getDate())),<span class="hljs-number">3</span>,<span class="hljs-number">3</span>, TimeUnit.SECONDS);<br>        Thread.sleep(<span class="hljs-number">30000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h3><p>ForkJoinPool旨在用于 <strong>CPU 密集型</strong>工作负载。ForkJoinPool 中的默认线程数等于系统上的 CPU 数。如果任何线程由于在某个其他 ForkJoinTask 上调用 join() 而进入等待状态，则会启动一个新的补偿线程以利用系统的所有 CPU。ForkJoinPool 有一个公共池，可以通过调用ForkJoinPool.commonPool()静态方法获得。此设计的目的是在系统中仅使用一个 ForkJoinPool，线程数等于系统上的处理器数。如果所有 ForkJoinTask 都在进行计算密集型任务，则它可以利用系统的全部计算能力。</p>
<p>但在现实生活场景中，任务是 CPU 和 IO 密集型任务的混合。IO 密集型任务对于 ForkJoinPool 来说是一个糟糕的选择。您应该使用 Executor 服务来执行 IO 密集型任务。在 ExecutorService 中，您可以根据系统的 IO 容量而不是系统的 CPU 容量来设置线程数。</p>
<p>如果要从 ForkJoinTask 调用 IO 密集型操作，则应创建一个实现ForkJoinPool.ManagedBlocker接口的类，并在block()方法中执行 IO 密集型操作。您需要使用静态方法ForkJoinPool.managedBlock()调用您的ForkJoinPool.ManagedBlocker实现。此方法在调用 block() 方法之前创建补偿线程。block() 方法应该进行 IO 操作并将结果存储在某个实例变量中。调用ForkJoinPool.managedBlock()后你应该调用你的业务方法来获取 IO 操作的结果。通过这种方式，你可以将 CPU 密集型操作与 IO 密集型操作混合使用。</p>
<p>ForkJoinPool不同于其他类型的ExecutorService，主要是因为它采用了<strong>工作窃取</strong>：池中的所有线程都试图查找并执行提交给池和/或其他活动任务创建的任务（如果不存在，则最终阻止等待工作）。当大多数任务产生其他子任务时（就像大多数ForkJoinTasks一样），以及当许多小任务从外部客户端提交到池时，这可以实现高效处理。尤其是在构造函数中将asyncMode设置为true时，ForkJoinPools可能也适合用于从未加入的事件样式任务。</p>
<p>静态commonPool（）适用于大多数应用程序。公共池由未显式提交到指定池的任何ForkJoinTask使用。使用公共池通常会减少资源使用（其线程在不使用期间缓慢回收，并在后续使用时恢复）。</p>
<p>对于需要单独或自定义池的应用程序，可以使用给定的目标并行级别构造ForkJoinPool；默认情况下，等于可用处理器的数量。池尝试通过动态添加、挂起或恢复内部工作线程来维护足够的活动（或可用）线程，即使某些任务在等待加入其他任务时暂停。但是，面对阻塞的I/O或其他非托管同步，无法保证进行此类调整。嵌套的ForkJoinPool。ManagedBlocker接口支持扩展所适应的同步类型。</p>
<p>除了执行和生命周期控制方法外，此类还提供状态检查方法（例如getStealCount），用于帮助开发、调优和监视fork/join应用程序。此外，方法toString以一种方便的形式返回池状态的指示，以便进行非正式监视。</p>
<p><strong>Fork</strong>：Fork步骤将任务拆分为更小的子任务，这些任务同时执行。<br><strong>Join</strong>：在执行子任务之后，任务可以将所有结果加入到一个结果中。</p>
<p>如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1653806345672-66b46c94-7454-489d-b319-dc0ec5a9ec32.png#averageHue=%23eeeeee&clientId=ub25a4e4a-a3e3-4&errorMessage=unknown%20error&from=paste&height=233&id=Z5RqF&originHeight=466&originWidth=1000&originalType=binary&ratio=1&rotation=0&showTitle=false&size=52916&status=error&style=none&taskId=udde2de15-6912-40cd-9f8a-5ee04e69177&title=&width=500" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="工作窃取（work-stealing）"><a href="#工作窃取（work-stealing）" class="headerlink" title="工作窃取（work-stealing）"></a>工作窃取（work-stealing）</h4><p>工作窃取是指当某个线程的任务队列中没有可执行任务的时候，从其他线程的任务队列中窃取任务来执行，以充分利用工作线程的计算能力，减少线程由于获取不到任务而造成的空闲浪费。</p>
<p>参考：<a target="_blank" rel="noopener" href="http://research.sun.com/scalable/pubs/index.html">http://research.sun.com/scalable/pubs/index.html</a></p>
<p>在ForkJoinpool中，工作任务的队列都采用双端队列Deque容器。我们知道，在通常使用队列的过程中，我们都在队尾插入，而在队头消费以实现FIFO。而为了实现工作窃取。一般我们会改成工作线程在工作队列上LIFO,而窃取其他线程的任务的时候，从队列头部取获取。示意图如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/2630542/1653816786326-3a28417a-dd03-4afe-b51f-82d79d157f56.jpeg" srcset="/img/loading.gif" lazyload><br>工作线程worker1、worker2以及worker3都从taskQueue的尾部popping获取task，而任务也从尾部Pushing，当worker3队列中没有任务的时候，就会从其他线程的队列中取stealing，这样就使得worker3不会由于没有任务而空闲。</p>
<h4 id="使用案例-1"><a href="#使用案例-1" class="headerlink" title="使用案例"></a>使用案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NewTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveAction</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">Load</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NewTask</span><span class="hljs-params">(<span class="hljs-type">long</span> Load)</span> &#123; <span class="hljs-built_in">this</span>.Load = Load; &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// fork tasks into smaller subtasks</span><br>        List&lt;NewTask&gt; subtasks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;NewTask&gt;();<br>        subtasks.addAll(createSubtasks());<br>        <span class="hljs-keyword">for</span> (RecursiveAction subtask : subtasks) &#123;<br>            subtask.fork();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// function to create and add subtasks</span><br>    <span class="hljs-keyword">private</span> List&lt;NewTask&gt; <span class="hljs-title function_">createSubtasks</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// create subtasks</span><br>        List&lt;NewTask&gt; subtasks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;NewTask&gt;();<br>        <span class="hljs-type">NewTask</span> <span class="hljs-variable">subtask1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NewTask</span>(<span class="hljs-built_in">this</span>.Load / <span class="hljs-number">2</span>);<br>        <span class="hljs-type">NewTask</span> <span class="hljs-variable">subtask2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NewTask</span>(<span class="hljs-built_in">this</span>.Load / <span class="hljs-number">2</span>);<br>        <span class="hljs-type">NewTask</span> <span class="hljs-variable">subtask3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NewTask</span>(<span class="hljs-built_in">this</span>.Load / <span class="hljs-number">2</span>);<br>        <span class="hljs-comment">// to add the subtasks</span><br>        subtasks.add(subtask1);<br>        subtasks.add(subtask2);<br>        subtasks.add(subtask3);<br>        <span class="hljs-keyword">return</span> subtasks;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String[] arguments)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// get no. of available core available</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">proc</span> <span class="hljs-operator">=</span> Runtime.getRuntime().availableProcessors();<br>        System.out.println(<span class="hljs-string">&quot;Number of available core in the processor is: &quot;</span> + proc);<br>        <span class="hljs-comment">// get no. of threads active</span><br>        <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">Pool</span> <span class="hljs-operator">=</span> ForkJoinPool.commonPool();<br>        System.out.println(<span class="hljs-string">&quot;Number of active thread before invoking: &quot;</span> + Pool.getActiveThreadCount());<br>        <span class="hljs-type">NewTask</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NewTask</span>(<span class="hljs-number">400</span>);<br>        Pool.invoke(t);<br>        System.out.println(<span class="hljs-string">&quot;Number of active thread after invoking: &quot;</span> + Pool.getActiveThreadCount());<br>        System.out.println(<span class="hljs-string">&quot;Common Pool Size is: &quot;</span> + Pool.getPoolSize());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJoinPoolExample</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fibonacci</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> n;<br>        Fibonacci(<span class="hljs-type">int</span> n) &#123;<br>            <span class="hljs-built_in">this</span>.n = n;<br>        &#125;<br>        <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>            <span class="hljs-type">Fibonacci</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fibonacci</span>(n - <span class="hljs-number">1</span>);<br>            f1.fork();<span class="hljs-comment">//分解为子任务n-1</span><br>            <span class="hljs-type">Fibonacci</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fibonacci</span>(n - <span class="hljs-number">2</span>);<span class="hljs-comment">//分解为子任务n-2</span><br>            <span class="hljs-keyword">return</span> f2.compute() + f1.join();<span class="hljs-comment">//当前子任务n-2 + 子任务n-1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">Pool</span> <span class="hljs-operator">=</span> ForkJoinPool.commonPool();<br>        <span class="hljs-type">Fibonacci</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fibonacci</span>(<span class="hljs-number">10</span>);<br>        Pool.invoke(t);<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> t.get();<br>        System.out.println(<span class="hljs-string">&quot;ret : &quot;</span> + ret);<br>        Thread.sleep(<span class="hljs-number">5000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="DelegatedExecutorService"><a href="#DelegatedExecutorService" class="headerlink" title="DelegatedExecutorService"></a>DelegatedExecutorService</h3><blockquote>
<p><strong>仅公开ExecutorService实现</strong>的ExecutorService方法的<strong>包装类</strong>。Delegate（委托、委派）。</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1653877851560-180a131c-e192-40fc-9325-5b751711b16b.png#averageHue=%23f7f7f7&clientId=u634b6551-9098-4&errorMessage=unknown%20error&from=paste&height=312&id=u187d6b9a&originHeight=312&originWidth=532&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9061&status=error&style=none&taskId=ue65fef17-13d2-441a-bafe-90cc00c6cd8&title=&width=532" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelegatedExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExecutorService</span> &#123;<br>    <span class="hljs-comment">//执行器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ExecutorService e;<br>    <span class="hljs-comment">//构造方法</span><br>    DelegatedExecutorService(ExecutorService executor) &#123; e = executor; &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123; e.execute(command); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123; e.shutdown(); &#125;<br>    <span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> e.shutdownNow(); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isShutdown</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> e.isShutdown(); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTerminated</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> e.isTerminated(); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitTermination</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">return</span> e.awaitTermination(timeout, unit);<br>    &#125;<br>    <span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br>        <span class="hljs-keyword">return</span> e.submit(task);<br>    &#125;<br>    <span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> &#123;<br>        <span class="hljs-keyword">return</span> e.submit(task);<br>    &#125;<br>    <span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span> &#123;<br>        <span class="hljs-keyword">return</span> e.submit(task, result);<br>    &#125;<br>    <span class="hljs-keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">return</span> e.invokeAll(tasks);<br>    &#125;<br>    <span class="hljs-keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">return</span> e.invokeAll(tasks, timeout, unit);<br>    &#125;<br>    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;<br>        <span class="hljs-keyword">return</span> e.invokeAny(tasks);<br>    &#125;<br>    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;<br>        <span class="hljs-keyword">return</span> e.invokeAny(tasks, timeout, unit);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="使用案例-2"><a href="#使用案例-2" class="headerlink" title="使用案例"></a>使用案例</h4><blockquote>
<p>通过调用unconfigurableExecutorService方法可直接获取DelegatedExecutorService的实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelegatedExecutorServiceExample</span> &#123;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.unconfigurableExecutorService(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingDeque</span>&lt;&gt;()));<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            executorService.submit(() -&gt; System.out.println(Thread.currentThread().getName()+ <span class="hljs-string">&quot; &quot;</span>+DateUtils.getDate()));<br>        &#125;<br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>        executorService.shutdown();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>


<h3 id="DelegatedScheduledExecutorService"><a href="#DelegatedScheduledExecutorService" class="headerlink" title="DelegatedScheduledExecutorService"></a>DelegatedScheduledExecutorService</h3><blockquote>
<p>DelegatedScheduledExecutorService是Executors的一个内部类，仅供<strong>ScheduledExecutorService</strong>实现的ScheduledExecutorService方法的包装类。用于任务调度的线程池服务。</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1653876543266-8956e2c1-767f-4223-ba62-3ea3d5869bba.png#averageHue=%23f6f6c1&clientId=u634b6551-9098-4&errorMessage=unknown%20error&from=paste&height=285&id=u70a34d1c&originHeight=285&originWidth=844&originalType=binary&ratio=1&rotation=0&showTitle=false&size=56879&status=error&style=none&taskId=u1ca746ee-67d5-4a91-8473-3108b833a0b&title=&width=844" srcset="/img/loading.gif" lazyload alt="image.png"><br>该类的源码较少，直接是对DelegatedExecutorService进行继承，实现ScheduledExecutorService接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelegatedScheduledExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DelegatedExecutorService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ScheduledExecutorService</span> &#123;<br>    <span class="hljs-comment">//其核心是通过ScheduledExecutorService接口来进行实现操作</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ScheduledExecutorService e;<br>    <br>    DelegatedScheduledExecutorService(ScheduledExecutorService executor) &#123;<br>        <span class="hljs-built_in">super</span>(executor);<br>        e = executor;<br>    &#125;<br>    <span class="hljs-comment">//Runnable接口执行，delay延迟执行时间</span><br>    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="hljs-type">long</span> delay, TimeUnit unit) &#123;<br>        <span class="hljs-keyword">return</span> e.schedule(command, delay, unit);<br>    &#125;<br>    <span class="hljs-keyword">public</span> &lt;V&gt; ScheduledFuture&lt;V&gt; <span class="hljs-title function_">schedule</span><span class="hljs-params">(Callable&lt;V&gt; callable, <span class="hljs-type">long</span> delay, TimeUnit unit)</span> &#123;<br>        <span class="hljs-keyword">return</span> e.schedule(callable, delay, unit);<br>    &#125;<br>    <span class="hljs-comment">//每隔period毫秒重复执行task</span><br>    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="hljs-type">long</span> initialDelay, <span class="hljs-type">long</span> period, TimeUnit unit) &#123;<br>        <span class="hljs-keyword">return</span> e.scheduleAtFixedRate(command, initialDelay, period, unit);<br>    &#125;<br>    <span class="hljs-comment">//initialDelay初始化时间</span><br>    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="hljs-type">long</span> initialDelay, <span class="hljs-type">long</span> delay, TimeUnit unit) &#123;<br>        <span class="hljs-keyword">return</span> e.scheduleWithFixedDelay(command, initialDelay, delay, unit);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="使用案例-3"><a href="#使用案例-3" class="headerlink" title="使用案例"></a>使用案例</h4><blockquote>
<p>通过newSingleThreadScheduledExecutor方法可直接获取单线程的线程池时间调度执行器</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title function_">newSingleThreadScheduledExecutor</span><span class="hljs-params">()</span> &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelegatedScheduledExecutorService</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelegatedScheduledExecutorServiceExample</span>  &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">scheduledExecutorService</span> <span class="hljs-operator">=</span> Executors.newSingleThreadScheduledExecutor();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            scheduledExecutorService.schedule(() -&gt; System.out.println(Thread.currentThread().getName()+ <span class="hljs-string">&quot; &quot;</span>+DateUtils.getDate()),<span class="hljs-number">2</span>,TimeUnit.SECONDS);<br>        &#125;<br>        Thread.sleep(<span class="hljs-number">5000</span>);<br>        scheduledExecutorService.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="FinalizableDelegatedExecutorService"><a href="#FinalizableDelegatedExecutorService" class="headerlink" title="FinalizableDelegatedExecutorService"></a>FinalizableDelegatedExecutorService</h3><blockquote>
<p>FinalizableDelegatedExecutorService的结构非常简单，继承DelegatedExecutorService类，重写了finalize在回收当前类的时候对线程池进行关闭操作</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DelegatedExecutorService</span> &#123;<br>    FinalizableDelegatedExecutorService(ExecutorService executor) &#123;<br>        <span class="hljs-built_in">super</span>(executor);<br>    &#125;<br>    <span class="hljs-comment">//关闭线程池</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="使用案例-4"><a href="#使用案例-4" class="headerlink" title="使用案例"></a>使用案例</h4><blockquote>
<p>FinalizableDelegatedExecutorService的获取可以通过Executors.newSingleThreadExecutor方法获取</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalizableDelegatedExecutorServiceExample</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            executorService.submit(() -&gt; System.out.println(Thread.currentThread().getName()+ <span class="hljs-string">&quot; &quot;</span>+ DateUtils.getDate()));<br>        &#125;<br>        Thread.sleep(<span class="hljs-number">3000</span>);<br>        executorService.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><blockquote>
<p>ThreadPoolExecutor类是线程池的根基类，上面提到的ScheduledExecutorService、五种ExecutorService都是基于ThreadPoolExecutor进行实现的。</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1653882196407-c7dfed70-7a2c-4c9f-9d20-204d3ba33d2e.png#averageHue=%23f7f8d4&clientId=u634b6551-9098-4&errorMessage=unknown%20error&from=paste&height=366&id=uc55821db&originHeight=366&originWidth=775&originalType=binary&ratio=1&rotation=0&showTitle=false&size=80724&status=error&style=none&taskId=u61ca372d-1174-478a-ad09-5c1e7e521c3&title=&width=775" srcset="/img/loading.gif" lazyload alt="image.png"><br>详细分析参考：<a href="https://mikeygithub.github.io/2022/05/30/yuque/ymxl5b/">https://mikeygithub.github.io/2022/05/30/yuque/ymxl5b/</a>  在本篇中不再做详细概述。</p>
<h4 id="使用案例-5"><a href="#使用案例-5" class="headerlink" title="使用案例"></a>使用案例</h4><blockquote>
<p>直接通过构造函数使用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*	core:核心线程数</span><br><span class="hljs-comment">*   max:最大线程数</span><br><span class="hljs-comment">*   多少时间内没有任务回收大于core的线程</span><br><span class="hljs-comment">*   时间单位</span><br><span class="hljs-comment">* 	阻塞队列</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(core, max, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br></code></pre></td></tr></table></figure>


<h3 id="RejectedExecutionHandler"><a href="#RejectedExecutionHandler" class="headerlink" title="RejectedExecutionHandler"></a>RejectedExecutionHandler</h3><blockquote>
<p>当我们任务过多超出阻塞队列的长度时，会根据我们配置的拒绝策略来决定新任务的去向，RejectedExecutionHandler定义了拒绝策略的统一标准，JDK提供有四个实现类CallerRunsPolicy、CallerRunsPolicy、DiscardPolicy、DiscardOldestPolicy</p>
</blockquote>
<h4 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h4><blockquote>
<p>AbortPolicy，缺省策略，处理程序在拒绝时抛出runtime RejectedExecutionException。</p>
</blockquote>
<h4 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h4><blockquote>
<p>CallerRunPolicy，调用自身执行的线程运行任务。这提供了一种简单的反馈控制机制，可以降低提交新任务的速度。</p>
</blockquote>
<h4 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h4><blockquote>
<p>DiscardPolicy，将简单地删除无法执行的任务。</p>
</blockquote>
<h4 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h4><blockquote>
<p>DiscardOldestPolicy，如果未关闭执行器，将丢弃工作队列头部的任务，然后重试执行（可能再次失败，导致重复执行）</p>
</blockquote>
<p> </p>
<h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><blockquote>
<p>线程执行的异步任务结果，Future作为任务执行结果的顶层接口。</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1653894105142-2df9cc88-9b76-4271-9e99-d6984df8a7d0.png#averageHue=%23f7f8dc&clientId=u634b6551-9098-4&errorMessage=unknown%20error&from=paste&height=313&id=ub97aea4e&originHeight=313&originWidth=629&originalType=binary&ratio=1&rotation=0&showTitle=false&size=65935&status=error&style=none&taskId=u8c261422-7f35-4b59-9d1f-178a9dd33e5&title=&width=629" srcset="/img/loading.gif" lazyload alt="image.png"><br>Future表示异步计算的结果。提供了检查计算是否完成、等待其完成以及检索计算结果的方法。只有在计算完成后，才能使用方法get检索结果，如有必要，请阻塞，直到它准备就绪。通过cancel方法执行取消。还提供了其他方法来确定任务是正常完成还是取消。一旦计算完成，就不能取消计算。如果为了可取消性而想使用Future，但没有提供可用的结果，则可以声明Future表单的类型并作为基础任务的结果返回null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Future</span>&lt;V&gt; &#123;<br>    <span class="hljs-comment">//取消操作</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span>;<br>    <span class="hljs-comment">//是否已经取消</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//是否已经完成</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//获取结果</span><br>    V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br>    <span class="hljs-comment">//带超时时间获取结果</span><br>    V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1653896484130-5079749e-0bae-4cc1-b0c4-dbb4dd9240b3.png#averageHue=%232d2f2c&clientId=u634b6551-9098-4&errorMessage=unknown%20error&from=paste&height=1026&id=u14027a6f&originHeight=1026&originWidth=2638&originalType=binary&ratio=1&rotation=0&showTitle=false&size=380314&status=error&style=none&taskId=ue52843be-02a3-4d1c-8167-de07f2449fd&title=&width=2638" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ul>
<li>FutureTask：最基础的Future接口实现</li>
<li>ForkJoinTask：提供可拆分和汇总结果的任务类型，作用于ForkJoin线程池</li>
<li>RecursiveTask：ForkJoinTask的子抽象类用于带返回值的任务结果执行</li>
<li>RecursiveAction：ForkJoinTask的子抽象类用于不带返回值的任务结果执行</li>
<li>CompletableFuture：可以显式完成（设置其值和状态）的Future，可以用作CompletionStage，支持在完成时触发的依赖函数和操作。当两个或多个线程尝试完成、异常完成或取消可完成的未来时，只有一个线程成功。</li>
<li>CountedCompleter：ForkJoinTask的子抽象类，一个ForkJoinTask在触发时执行完成操作，并且没有剩余的待处理操作。与其他形式的 ForkJoinTask 相比，CountedCompleter 通常在存在子任务停顿和阻塞的情况下更加健壮，但编程起来不太直观。CountedCompleter 的使用类似于其他基于完成的组件（例如CompletionHandler），除了可能需要多个待处理的完成来触发完成操作onCompletion(CountedCompleter)，而不仅仅是一个。除非另外初始化，否则挂起的计数从零开始，但可以使用方法setPendingCount(int)、addToPendingCount(int)和 （原子地）更改compareAndSetPendingCount(int, int)。在调用tryComplete()，如果挂起的动作计数不为零，则递减；否则，执行完成动作，如果这个完成者本身有一个完成者，则使用它的完成者继续该过程。与相关同步组件的情况一样，例如Phaser和 Semaphore，这些方法只影响内部计数；他们没有建立任何进一步的内部簿记。特别是，未维护待处理任务的身份</li>
</ul>
<h1 id="Queues-（阻塞队列）"><a href="#Queues-（阻塞队列）" class="headerlink" title="Queues （阻塞队列）"></a>Queues （阻塞队列）</h1><blockquote>
<p>JUC包下提供了六种同步队列，分别为 ConcurrentLinkedDeque、LinkedBlockingQueue、ArrayBlockingQueue、SynchronousQueue、PriorityBlockingQueue、DelayQueue</p>
</blockquote>
<h2 id="ConcurrentLinkedDeque"><a href="#ConcurrentLinkedDeque" class="headerlink" title="ConcurrentLinkedDeque"></a>ConcurrentLinkedDeque</h2><blockquote>
<p>ConcurrentLinkedDeque是基于链表的无界限线程安全双端队列。</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1653898363515-dbcb7296-efe7-44a3-ac63-75740c3c97f6.png#averageHue=%23f7f8d1&clientId=u634b6551-9098-4&errorMessage=unknown%20error&from=paste&height=445&id=ufccb8122&originHeight=297&originWidth=1694&originalType=binary&ratio=1&rotation=0&showTitle=false&size=123524&status=error&style=none&taskId=udf92a855-974c-48ed-991a-aba35511e26&title=&width=2540.999924272301" srcset="/img/loading.gif" lazyload alt="image.png"><br>此队列对元素进行 FIFO（先进先出）排序。队列的头部是在队列中时间最长的元素。队列的尾部是在队列中时间最短的元素。新元素被插入到队列的尾部，队列检索操作获取队列头部的元素。ConcurrentLinkedQueue当许多线程将共享对公共集合的访问时，A是一个合适的选择。此队列不允许null元素。<br>该实现采用了一种高效的“无等待”算法，该算法基于Maged M. Michael 和 Michael L. Scott在<a target="_blank" rel="noopener" href="http://www.cs.rochester.edu/u/michael/PODC96.html">Simple、Fast、Practical Non-Blocking 和 Blocking Concurrent Queue Algorithms中描述的算法。</a>注意，与大多数集合不同，该size方法不是恒定时间操作。由于这些队列的异步特性，确定当前元素的数量需要遍历元素。</p>
<h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><blockquote>
<p>基于链表的可选有界 BlockingQueue 阻塞队列</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1653899756965-12f434b7-1746-47f0-a509-56c267930284.png#averageHue=%23f6f7ca&clientId=u634b6551-9098-4&errorMessage=unknown%20error&from=paste&height=469&id=u8f45534d&originHeight=313&originWidth=1220&originalType=binary&ratio=1&rotation=0&showTitle=false&size=98148&status=error&style=none&taskId=u6a285c33-846d-4db0-ac6f-fd1d0fcd8ab&title=&width=1829.9999454617516" srcset="/img/loading.gif" lazyload alt="image.png"><br>此队列对元素进行 FIFO（先进先出）排序。队列的头部是在队列中时间最长的元素。队列的尾部是在队列中时间最短的元素。新元素被插入到队列的尾部，队列检索操作获取队列头部的元素。链接队列通常比基于数组的队列具有更高的吞吐量，但在大多数并发应用程序中性能更不可预测。<br>可选的容量绑定构造函数参数用作防止过度队列扩展的一种方式。容量（如果未指定）等于<strong>Integer.MAX_VALUE</strong>。链接节点在每次插入时动态创建，除非这会使队列超出容量。</p>
<h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><blockquote>
<p>基于数组的阻塞队列</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1653901573825-3a81cf59-650f-4052-90bd-d1662ce3f68d.png#averageHue=%23f6f7ca&clientId=u634b6551-9098-4&errorMessage=unknown%20error&from=paste&height=486&id=u252f0f41&originHeight=324&originWidth=1153&originalType=binary&ratio=1&rotation=0&showTitle=false&size=97599&status=error&style=none&taskId=u3b9ff68e-abe9-4e1c-9839-e10267f5306&title=&width=1729.499948456885" srcset="/img/loading.gif" lazyload alt="image.png"><br>由数组支持的有界阻塞队列。此队列对元素FIFO进行排序（先进先出）。队列的头是在队列上停留时间最长的元素。队列的尾部是在队列上停留时间最短的元素。新元素插入到队列的尾部，队列检索操作获取队列头部的元素。<br>这是一个经典的“有界缓冲区”，其中固定大小的数组保存生产者插入的元素和消费者提取的元素。一旦创建，容量就无法更改。尝试将元素放入完整队列将导致操作阻塞；尝试从空队列中获取元素也会被类似地阻止。<br>此类支持一个可选的公平策略，用于排序等待的生产者线程和消费者线程。默认情况下，不保证此顺序。然而，公平性设置为true的队列以FIFO顺序授予线程访问权限。公平性通常会降低吞吐量，但会减少可变性并避免饥饿。</p>
<h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><blockquote>
<p>一个 BlockingQueue 阻塞队列，其中每个都put必须等待 take，反之亦然。</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1653903348475-cde90586-325e-4a3f-b985-84f10b3d8922.png#averageHue=%23f6f7cb&clientId=u634b6551-9098-4&errorMessage=unknown%20error&from=paste&height=492&id=u5f55fc91&originHeight=328&originWidth=1162&originalType=binary&ratio=1&rotation=0&showTitle=false&size=96694&status=error&style=none&taskId=u923f45ec-3dce-4fbb-84c6-e8159299c79&title=&width=1742.9999480545537" srcset="/img/loading.gif" lazyload alt="image.png"><br>同步队列没有任何内部容量，甚至没有一个容量。您不能peek在同步队列中，因为一个元素仅在您尝试获取它时才存在；除非另一个线程试图删除它，否则您不能添加元素（使用任何方法）；你不能迭代，因为没有什么可以迭代的。队列的头部是第一个排队线程试图添加到队列中的元素；如果没有排队的线程，则没有添加任何元素并且头部是null. 对于其他Collection方法（例如contains）， aSynchronousQueue充当空集合。此队列不允许null元素。<br>同步队列类似于 CSP 和 Ada 中使用的集合通道。它们非常适合切换设计，其中一个线程中运行的对象必须与另一个线程中运行的对象同步，以便将一些信息、事件或任务交给它。<br>此类支持对等待的生产者和消费者线程进行排序的可选公平策略。默认情况下，不保证此排序。但是，使用公平设置构造的队列以trueFIFO 顺序授予线程访问权限。公平性通常会降低吞吐量，但会降低可变性并避免饥饿。</p>
<h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><blockquote>
<p>优先阻塞队列（堆），一个无界的 BlockingQueue 阻塞队列，它使用与类PriorityQueue 相同的排序规则并提供阻塞检索操作。</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1653903503915-8dc5cb08-af49-4d3b-8ac6-6d6c3b4f1d7b.png#averageHue=%23f6f7c9&clientId=u634b6551-9098-4&errorMessage=unknown%20error&from=paste&height=462&id=u92b7e478&originHeight=308&originWidth=1188&originalType=binary&ratio=1&rotation=0&showTitle=false&size=95967&status=error&style=none&taskId=u97514f4b-06b0-4462-9610-3c4ffd8b96b&title=&width=1781.999946892263" srcset="/img/loading.gif" lazyload alt="image.png"><br>虽然此队列在逻辑上是无界的，但尝试添加可能会由于资源耗尽（导致OutOfMemoryError）而失败。此类不允许null元素。依赖于自然排序的优先级队列也不允许插入不可比较的对象（这样做会导致ClassCastException）。<br>此类实现了Collection和Iterator接口的所有可选方法。<br>方法iterator()中提供的 Iterator不能保证以任何特定顺序遍历 PriorityBlockingQueue 的元素。如果您需要有序遍历，请考虑使用<a target="_blank" rel="noopener" href="https://people.apache.org/~tellison/classlib_doc/html/classjava_1_1util_1_1Arrays.html#83ba1036fd90bae741780481a84f228e">Arrays.sort</a>(pq.toArray()).<br>此类是Java Collections Framework的成员。</p>
<h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><blockquote>
<p>元素的无界 BlockingQueue 阻塞队列 Delayed，其中一个元素只有在其延迟到期时才能被取出。</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1653903706281-52d66358-5f3a-4656-b4ea-c6eb07025a97.png#averageHue=%23f6f6c5&clientId=u634b6551-9098-4&errorMessage=unknown%20error&from=paste&height=459&id=ua9b84543&originHeight=306&originWidth=1042&originalType=binary&ratio=1&rotation=0&showTitle=false&size=90907&status=error&style=none&taskId=uf057bb2d-9986-470f-be08-865ee8a767f&title=&width=1562.9999534189715" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>队列 的头部Delayed是过去延迟过期最远的元素——如果没有延迟过期，则没有头部并且poll将返回null。此队列不允许null元素。</p>
<h1 id="Concurrent-Collections-（并发容器）"><a href="#Concurrent-Collections-（并发容器）" class="headerlink" title="Concurrent Collections （并发容器）"></a>Concurrent Collections （并发容器）</h1><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><blockquote>
<p>并发的HashMap，采用segments对区间内的桶进行加锁，降低锁的范围，增加锁的细粒度，从而提高效率。</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1653904392136-ac06bfdb-dcb9-4291-a820-070930f96422.png#averageHue=%23f6f7cd&clientId=u634b6551-9098-4&errorMessage=unknown%20error&from=paste&height=406&id=u20b7f8ce&originHeight=271&originWidth=957&originalType=binary&ratio=1&rotation=0&showTitle=false&size=74982&status=error&style=none&taskId=ue62c08af-1601-4c2c-8814-acdf0702f25&title=&width=1435.4999572187676" srcset="/img/loading.gif" lazyload alt="image.png"><br>检索操作（包括get）一般不会阻塞，因此可能与更新操作（包括put 、 remove）重叠。检索反映了最近完成的更新操作在其开始时保持的结果。putAll对于和等聚合操作clear，并发检索可能仅反映插入或删除某些条目。类似地，迭代器和枚举返回反映哈希表在创建迭代器/枚举时或之后的某个时间点的状态的元素。他们不会抛出ConcurrentModificationException。但是，迭代器被设计为一次只能由一个线程使用。</p>
<p>更新操作之间允许的并发性由可选的concurrencyLevel构造函数参数（默认为 16）指导，该参数用作内部大小调整的提示。该表是内部分区的，以尝试允许指定数量的并发无争用更新。因为哈希表中的放置本质上是随机的，所以实际的并发性会有所不同。理想情况下，您应该选择一个值来容纳尽可能多的线程同时修改表。使用显着高于您需要的值会浪费空间和时间，而显着降低的值会导致线程争用。但是一个数量级内的高估和低估通常不会产生太大的影响。当已知只有一个线程会修改而所有其他线程只会读取时，值 1 是合适的。</p>
<h2 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h2><blockquote>
<p>并发的<a href="https://mikeygithub.github.io/2022/02/20/yuque/pea42q/">跳表</a>Map，基于ConcurrentNavigableMap（）接口实现。ConcurrentSkipListMap其核心思想是基于跳表CAS更新达到线程安全的效果。</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1653907592381-fff04b4b-a702-4a50-87ce-a5c835112308.png#averageHue=%23fbf9f0&clientId=u634b6551-9098-4&errorMessage=unknown%20error&from=paste&height=882&id=u54e0784f&originHeight=1051&originWidth=1368&originalType=binary&ratio=1&rotation=0&showTitle=false&size=108296&status=error&style=none&taskId=u51ca2684-c016-4d77-bd59-b11f3894017&title=&width=1148" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>跳表参考：<a href="https://mikeygithub.github.io/2022/02/20/yuque/pea42q/">https://mikeygithub.github.io/2022/02/20/yuque/pea42q/</a></p>
<p>ConcurrentSkipListMap内部关键的类如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span>&lt;K,V&gt; &#123;<br>        <span class="hljs-keyword">final</span> Node&lt;K,V&gt; node;<br>        <span class="hljs-keyword">final</span> Index&lt;K,V&gt; down;<br>        <span class="hljs-keyword">volatile</span> Index&lt;K,V&gt; right;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Creates index node with given values.</span><br><span class="hljs-comment">         */</span><br>        Index(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right) &#123;<br>            <span class="hljs-built_in">this</span>.node = node;<br>            <span class="hljs-built_in">this</span>.down = down;<br>            <span class="hljs-built_in">this</span>.right = right;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * compareAndSet right field</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">casRight</span><span class="hljs-params">(Index&lt;K,V&gt; cmp, Index&lt;K,V&gt; val)</span> &#123;<br>            <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, rightOffset, cmp, val);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Returns true if the node this indexes has been deleted.</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> true if indexed node is known to be deleted</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">indexesDeletedNode</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> node.value == <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Tries to CAS newSucc as successor.  To minimize races with</span><br><span class="hljs-comment">         * unlink that may lose this index node, if the node being</span><br><span class="hljs-comment">         * indexed is known to be deleted, it doesn&#x27;t try to link in.</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> succ the expected current successor</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> newSucc the new successor</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> true if successful</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">link</span><span class="hljs-params">(Index&lt;K,V&gt; succ, Index&lt;K,V&gt; newSucc)</span> &#123;<br>            Node&lt;K,V&gt; n = node;<br>            newSucc.right = succ;<br>            <span class="hljs-keyword">return</span> n.value != <span class="hljs-literal">null</span> &amp;&amp; casRight(succ, newSucc);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Tries to CAS right field to skip over apparent successor</span><br><span class="hljs-comment">         * succ.  Fails (forcing a retraversal by caller) if this node</span><br><span class="hljs-comment">         * is known to be deleted.</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> succ the expected current successor</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> true if successful</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">unlink</span><span class="hljs-params">(Index&lt;K,V&gt; succ)</span> &#123;<br>            <span class="hljs-keyword">return</span> node.value != <span class="hljs-literal">null</span> &amp;&amp; casRight(succ, succ.right);<br>        &#125;<br><br>        <span class="hljs-comment">// Unsafe mechanics</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> sun.misc.Unsafe UNSAFE;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> rightOffset;<br>        <span class="hljs-keyword">static</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                UNSAFE = sun.misc.Unsafe.getUnsafe();<br>                Class&lt;?&gt; k = Index.class;<br>                rightOffset = UNSAFE.objectFieldOffset<br>                    (k.getDeclaredField(<span class="hljs-string">&quot;right&quot;</span>));<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(e);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;<br>        <span class="hljs-keyword">final</span> K key;<br>        <span class="hljs-keyword">volatile</span> Object value;<br>        <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt; next;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Creates a new regular node.</span><br><span class="hljs-comment">         */</span><br>        Node(K key, Object value, Node&lt;K,V&gt; next) &#123;<br>            <span class="hljs-built_in">this</span>.key = key;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Creates a new marker node. A marker is distinguished by</span><br><span class="hljs-comment">         * having its value field point to itself.  Marker nodes also</span><br><span class="hljs-comment">         * have null keys, a fact that is exploited in a few places,</span><br><span class="hljs-comment">         * but this doesn&#x27;t distinguish markers from the base-level</span><br><span class="hljs-comment">         * header node (head.node), which also has a null key.</span><br><span class="hljs-comment">         */</span><br>        Node(Node&lt;K,V&gt; next) &#123;<br>            <span class="hljs-built_in">this</span>.key = <span class="hljs-literal">null</span>;<br>            <span class="hljs-built_in">this</span>.value = <span class="hljs-built_in">this</span>;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * compareAndSet value field</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-title function_">casValue</span><span class="hljs-params">(Object cmp, Object val)</span> &#123;<br>            <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, valueOffset, cmp, val);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * compareAndSet next field</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-title function_">casNext</span><span class="hljs-params">(Node&lt;K,V&gt; cmp, Node&lt;K,V&gt; val)</span> &#123;<br>            <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, nextOffset, cmp, val);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Returns true if this node is a marker. This method isn&#x27;t</span><br><span class="hljs-comment">         * actually called in any current code checking for markers</span><br><span class="hljs-comment">         * because callers will have already read value field and need</span><br><span class="hljs-comment">         * to use that read (not another done here) and so directly</span><br><span class="hljs-comment">         * test if value points to node.</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> true if this node is a marker node</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMarker</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> value == <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Returns true if this node is the header of base-level list.</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> true if this node is header node</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBaseHeader</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> value == BASE_HEADER;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Tries to append a deletion marker to this node.</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> f the assumed current successor of this node</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> true if successful</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-title function_">appendMarker</span><span class="hljs-params">(Node&lt;K,V&gt; f)</span> &#123;<br>            <span class="hljs-keyword">return</span> casNext(f, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(f));<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Helps out a deletion by appending marker or unlinking from</span><br><span class="hljs-comment">         * predecessor. This is called during traversals when value</span><br><span class="hljs-comment">         * field seen to be null.</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> b predecessor</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> f successor</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">helpDelete</span><span class="hljs-params">(Node&lt;K,V&gt; b, Node&lt;K,V&gt; f)</span> &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * Rechecking links and then doing only one of the</span><br><span class="hljs-comment">             * help-out stages per call tends to minimize CAS</span><br><span class="hljs-comment">             * interference among helping threads.</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (f == next &amp;&amp; <span class="hljs-built_in">this</span> == b.next) &#123;<br>                <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span> || f.value != f) <span class="hljs-comment">// not already marked</span><br>                    casNext(f, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(f));<br>                <span class="hljs-keyword">else</span><br>                    b.casNext(<span class="hljs-built_in">this</span>, f.next);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Returns value if this node contains a valid key-value pair,</span><br><span class="hljs-comment">         * else null.</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> this node&#x27;s value if it isn&#x27;t a marker or header or</span><br><span class="hljs-comment">         * is deleted, else null</span><br><span class="hljs-comment">         */</span><br>        V <span class="hljs-title function_">getValidValue</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> value;<br>            <span class="hljs-keyword">if</span> (v == <span class="hljs-built_in">this</span> || v == BASE_HEADER)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="hljs-type">V</span> <span class="hljs-variable">vv</span> <span class="hljs-operator">=</span> (V)v;<br>            <span class="hljs-keyword">return</span> vv;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Creates and returns a new SimpleImmutableEntry holding current</span><br><span class="hljs-comment">         * mapping if this node holds a valid value, else null.</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> new entry or null</span><br><span class="hljs-comment">         */</span><br>        AbstractMap.SimpleImmutableEntry&lt;K,V&gt; <span class="hljs-title function_">createSnapshot</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> value;<br>            <span class="hljs-keyword">if</span> (v == <span class="hljs-literal">null</span> || v == <span class="hljs-built_in">this</span> || v == BASE_HEADER)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="hljs-type">V</span> <span class="hljs-variable">vv</span> <span class="hljs-operator">=</span> (V)v;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbstractMap</span>.SimpleImmutableEntry&lt;K,V&gt;(key, vv);<br>        &#125;<br><br>        <span class="hljs-comment">// UNSAFE mechanics</span><br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> sun.misc.Unsafe UNSAFE;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> valueOffset;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> nextOffset;<br><br>        <span class="hljs-keyword">static</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                UNSAFE = sun.misc.Unsafe.getUnsafe();<br>                Class&lt;?&gt; k = Node.class;<br>                valueOffset = UNSAFE.objectFieldOffset<br>                    (k.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));<br>                nextOffset = UNSAFE.objectFieldOffset<br>                    (k.getDeclaredField(<span class="hljs-string">&quot;next&quot;</span>));<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(e);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="使用案例-6"><a href="#使用案例-6" class="headerlink" title="使用案例"></a>使用案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrentSkipListMapExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ConcurrentSkipListMap&lt;String, String&gt; cslm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentSkipListMap</span>&lt;String, String&gt;();<br>        cslm.put(<span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;Three&quot;</span>);<br>        cslm.put(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;One&quot;</span>);<br>        cslm.put(<span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;Five&quot;</span>);<br>        cslm.put(<span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;Four&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;初始化Map : &quot;</span> + cslm);<br>        <span class="hljs-comment">//获取key的上限（右边最靠近的值）</span><br>        System.out.println(<span class="hljs-string">&quot;2的上限: &quot;</span> + cslm.ceilingEntry(<span class="hljs-string">&quot;2&quot;</span>));<br>        <span class="hljs-comment">//递减方式获取 keySet</span><br>        <span class="hljs-type">NavigableSet</span> <span class="hljs-variable">navigableSet</span> <span class="hljs-operator">=</span> cslm.descendingKeySet();<br>        <span class="hljs-comment">//迭代器遍历</span><br>        System.out.println(<span class="hljs-string">&quot;descendingKeySet: &quot;</span>);<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">itr</span> <span class="hljs-operator">=</span> navigableSet.iterator();<br>        <span class="hljs-keyword">while</span> (itr.hasNext()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (String) itr.next();<br>            System.out.println(s);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;第一个Entry: &quot;</span> + cslm.firstEntry());<br>        System.out.println(<span class="hljs-string">&quot;最后一个Entry: &quot;</span> + cslm.lastEntry());<br>        System.out.println(<span class="hljs-string">&quot;弹出第一个Entry: &quot;</span> + cslm.pollFirstEntry());<br>        System.out.println(<span class="hljs-string">&quot;当前第一个Entry: &quot;</span> + cslm.firstEntry());<br>        System.out.println(<span class="hljs-string">&quot;弹出最后一个Entry: &quot;</span> + cslm.pollLastEntry());<br>        System.out.println(<span class="hljs-string">&quot;当前第一个Entry: &quot;</span> + cslm.lastEntry());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>参考资料：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIwMjU4MzU4MA==&mid=2247484183&idx=1&sn=d002f70643d6ff248a2df55a6f0fa834&chksm=96dd3864a1aab1727eb905dbe7b653b72b82e163a17fbbe44cd62dc563f01657161b28d8f558&scene=21#wechat_redirect">ConcurrentSkipListMap</a></p>
<h2 id="ConcurrentSkipListSet"><a href="#ConcurrentSkipListSet" class="headerlink" title="ConcurrentSkipListSet"></a>ConcurrentSkipListSet</h2><blockquote>
<p>ConcurrentSkipListSet通过ConcurrentSkipListMap的key来进行存储，value存放Object。</p>
</blockquote>
<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><blockquote>
<p>ArrayList的一种线程安全变体，其中所有可变操作（添加、设置等）都是通过创建基础数组的新副本来实现的。顾名思义其容器是在写的时候对数组写入加锁做一次拷贝，而不是对读进行加锁，所以读可以正常进行。</p>
</blockquote>
<p>通常成本太高，但在遍历操作的数量远远超过突变的情况下，可能比其他方法更有效，并且在你无法或不想同步遍历，但需要排除并发线程之间的干扰时非常有用。“快照”样式的迭代器方法使用对创建迭代器时数组状态的引用。该数组在迭代器的生存期内从不更改，因此不可能发生干扰，并且迭代器保证不会抛出ConcurrentModificationException。自创建迭代器以来，迭代器不会反映对列表的添加、删除或更改。不支持迭代器本身的元素更改操作（remove、set和add）。这些方法引发UnsupportedOperationException。</p>
<p>该容器允许所有元素，包括null。</p>
<p>内存一致性影响：与其他并发集合一样，在将对象放入CopyOnWriteArrayList之前，线程中的操作发生在另一个线程的CopyOnWriteArrayList中访问或删除该元素之后的操作之前。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br></code></pre></td></tr></table></figure>
<p>我们来简单分析一下它内部的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>     <span class="hljs-comment">//获取当前容器的锁</span><br>     <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>     <span class="hljs-comment">//进行加锁操作</span><br>     lock.lock();<br>     <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-comment">//获取下标为index的元素</span><br>         Object[] elements = getArray();<br>         <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> get(elements, index);<br>         <span class="hljs-comment">//如果旧的元素不等于当前设置的元素则进行复制，没错就是这么简单粗暴，直接复制得到一个新的数组（其他线程读不影响，我只锁写入）</span><br>         <span class="hljs-keyword">if</span> (oldValue != element) &#123;<br>             <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<span class="hljs-comment">//获取旧数组长度</span><br>             <span class="hljs-comment">//复制旧数组的所有值</span><br>             Object[] newElements = Arrays.copyOf(elements, len);<br>             <span class="hljs-comment">//更新新数组的下标值为我们设置的element</span><br>             newElements[index] = element;<br>             <span class="hljs-comment">//覆盖</span><br>             setArray(newElements);<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>             <span class="hljs-comment">// Not quite a no-op; ensures volatile write semantics</span><br>             setArray(elements);<span class="hljs-comment">//如果oldValue == element</span><br>         &#125;<br>         <span class="hljs-keyword">return</span> oldValue;<span class="hljs-comment">//返回旧的值</span><br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>         lock.unlock();<span class="hljs-comment">//释放锁</span><br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>

<h2 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h2><blockquote>
<p>基于CopyOnWriteArrayList实现</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1653924969999-8c599689-f066-4e8b-b8bb-20fd22e13784.png#averageHue=%23f0f0cc&clientId=u634b6551-9098-4&from=paste&height=313&id=u6acdcb72&originHeight=626&originWidth=1620&originalType=binary&ratio=1&rotation=0&showTitle=false&size=268131&status=done&style=none&taskId=uceecf5cd-5ac0-46bc-8794-78a56ffd8f6&title=&width=810" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h1 id="Synchronizers-（同步器）"><a href="#Synchronizers-（同步器）" class="headerlink" title="Synchronizers （同步器）"></a>Synchronizers （同步器）</h1><p>五个类帮助常见的专用同步习惯用法。</p>
<ul>
<li>Semaphore是经典的并发工具。</li>
<li>CountDownLatch是一个非常简单但非常常见的实用程序，用于阻塞直到给定数量的信号、事件或条件成立。</li>
<li>CyclicBarrier是可重置的多路同步点，在某些并行编程风格中很有用。</li>
<li>Phaser提供了一种更灵活的屏障形式，可用于控制多个线程之间的分阶段计算。</li>
<li>Exchanger允许两个线程在一个集合点交换对象，并且在多个管道设计中很有用。</li>
</ul>
<h2 id="Semaphore-信号量）"><a href="#Semaphore-信号量）" class="headerlink" title="Semaphore(信号量）"></a>Semaphore(信号量）</h2><blockquote>
<p>计数信号量（基于AQS）。Semaphore的内部共存在<strong>Sync</strong>、<strong>NonfairSync</strong>、<strong>FairSync</strong>三个类，NonfairSync与FairSync类继承自Sync类，Sync类继承自AbstractQueuedSynchronizer抽象类，也就Semaphore是依托于NonfairSync、FairSync来实现的。从概念上讲，信号量维护一组许可。如有必要，每个采集模块都会阻塞，直到获得许可证，然后再获取。每次发布都会添加一个许可证，可能会释放一个阻塞收单机构。但是，未使用实际许可对象；信号量只保留可用数字的计数，并相应地进行操作。</p>
</blockquote>
<p>在获取项目之前，每个线程必须从信号量中获取许可，以保证项目可供使用。当线程完成该项目时，它会返回池中，并向信号量返回一个许可，允许另一个线程获取该项目。请注意，在调用acquire时不会持有同步锁，因为这会阻止项目返回到池中。信号量封装了限制对池的访问所需的同步，与维护池本身一致性所需的任何同步分开。<br>初始化为 1 的信号量，并且使用时最多只有一个可用的许可，可以用作互斥锁。这通常被称为二进制信号量，因为它只有两种状态：一个可用许可，或零个可用许可。当以这种方式使用时，二进制信号量具有属性（与许多Lock实现不同），“锁”可以由所有者以外的线程释放（因为信号量没有所有权的概念）。这在一些专门的上下文中很有用，例如死锁恢复。<br>此类的构造函数可选择接受公平参数。当设置为 false 时，此类不保证线程获取许可的顺序。特别是，允许插入，即调用acquire的线程可以在一直等待的线程之前获得许可<a target="_blank" rel="noopener" href="https://people.apache.org/~tellison/classlib_doc/html/classjava_1_1util_1_1concurrent_1_1Semaphore.html#5686bf6e12fed6dcee774b433d023095">。</a>当 fairness 设置为 true 时，信号量保证调用任何获取方法的线程按照处理它们调用这些方法的顺序（先进先出；FIFO）分配许可。请注意，FIFO 排序必然适用于这些方法中的特定内部执行点。因此，一个线程可以调用acquire在另一个之前，但在另一个之后到达排序点，同样在从方法返回时。<br>通常，用于控制资源访问的信号量应该被初始化为公平的，以确保没有线程因访问资源而被饿死。当使用信号量进行其他类型的同步控制时，非公平排序的吞吐量优势通常超过公平性考虑。<br>此类还提供方便的方法来一次<strong>获取</strong>和<strong>释放</strong>多个许可。当这些方法在不公平的情况下使用时，请注意无限期推迟的风险增加。</p>
<h3 id="使用案例-7"><a href="#使用案例-7" class="headerlink" title="使用案例"></a>使用案例</h3><blockquote>
<p>信号量通常用于限制可以访问某些（物理或逻辑）资源的线程数。例如，下面是一个类，它使用信号量控制对项目池的访问</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SemaphoreExample</span> &#123;<br>    <span class="hljs-comment">//设置最大可用许可</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_AVAILABLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(MAX_AVAILABLE, <span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">//获取许可</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getItem</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        available.acquire();<br>        <span class="hljs-keyword">return</span> getNextAvailableItem();<br>    &#125;<br>    <span class="hljs-comment">//返还许可</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putItem</span><span class="hljs-params">(Object x)</span> &#123;<br>        <span class="hljs-keyword">if</span> (markAsUnused(x)) available.release();<br>    &#125;<br>    <span class="hljs-comment">// Not a particularly efficient data structure; just for demo</span><br>    <span class="hljs-keyword">protected</span> Object[] items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[MAX_AVAILABLE];<span class="hljs-comment">//... whatever kinds of items being managed</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[MAX_AVAILABLE];<br>    <span class="hljs-comment">//获取一个可用的下标（由synchronized修饰方法）</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> Object <span class="hljs-title function_">getNextAvailableItem</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (!used[i]) &#123;<br>                used[i] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//设置为正在使用状态</span><br>                <span class="hljs-keyword">return</span> items[i];<span class="hljs-comment">//返回该可用下标的数据对象</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// not reached</span><br>    &#125;<br>    <span class="hljs-comment">//设置该下标为可用状态（由synchronized修饰方法）</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">markAsUnused</span><span class="hljs-params">(Object item)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (item == items[i]) &#123;<br>                <span class="hljs-keyword">if</span> (used[i]) &#123;<br>                    used[i] = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">else</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="CountDownLatch-（计数屏障）"><a href="#CountDownLatch-（计数屏障）" class="headerlink" title="CountDownLatch （计数屏障）"></a>CountDownLatch （计数屏障）</h2><blockquote>
<p>一种同步辅助，允许一个或多个线程等待，直到在其他线程中执行的一组操作完成。</p>
</blockquote>
<p>CountDownLatch用给定的count初始化。由于调用了countDown方法，等待方法一直阻塞，直到当前计数达到零，之后所有等待的线程都被释放，任何后续的await调用立即返回。这是一次性现象——<strong>计数无法重置</strong>。如果您需要重置计数的版本，请考虑使用CyclicBarrier。</p>
<p>CountDownLatch是一种多功能同步工具，可用于多种用途。以 1 为计数的CountDownLatch初始化用作简单的开/关锁存器或门：所有调用await的线程在门处等待，直到它被调用countDown的线程打开。CountDownLatch初始化为N可用于使一个线程等待，直到N个线程完成某个动作，或者某个动作已完成 N 次。<br>的一个有用属性CountDownLatch是它不需要调用countDown的线程在继续之前等待计数达到零，它只是阻止任何线程继续等待，直到所有线程都可以通过。</p>
<h3 id="使用案例-8"><a href="#使用案例-8" class="headerlink" title="使用案例"></a>使用案例</h3><blockquote>
<p>给定CountDownLatch初始值当我们完成一个线程的任务调用一次</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatchExample</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CountDownLatch startSignal;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CountDownLatch doneSignal;<br>        Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123;<br>            <span class="hljs-built_in">this</span>.startSignal = startSignal;<br>            <span class="hljs-built_in">this</span>.doneSignal = doneSignal;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                startSignal.await();<br>                doWork();<br>                doneSignal.countDown();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;&#125; <span class="hljs-comment">// return;</span><br>        &#125;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">//...</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">startSignal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">doneSignal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(N);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<span class="hljs-comment">// create and start threads</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(startSignal, doneSignal)).start();<br>        &#125;<br>        <span class="hljs-comment">//doSomethingElse();            // don&#x27;t let run yet</span><br>        startSignal.countDown();      <span class="hljs-comment">// let all threads proceed</span><br>        <span class="hljs-comment">//doSomethingElse();</span><br>        doneSignal.await();           <span class="hljs-comment">// wait for all to finish</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatchExample</span> &#123;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkerRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CountDownLatch doneSignal;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> i;<br>        WorkerRunnable(CountDownLatch doneSignal, <span class="hljs-type">int</span> i) &#123;<br>            <span class="hljs-built_in">this</span>.doneSignal = doneSignal;<br>            <span class="hljs-built_in">this</span>.i = i;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            doWork();<br>            doneSignal.countDown();<span class="hljs-comment">//任务完成调用countDown方法</span><br>        &#125;<br><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">//...</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">doneSignal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(N);<br>        <span class="hljs-type">Executor</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; ++i) <span class="hljs-comment">// create and start threads</span><br>            e.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WorkerRunnable</span>(doneSignal, i));<br>        doneSignal.await();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="CyclicBarrier-（循环屏障）"><a href="#CyclicBarrier-（循环屏障）" class="headerlink" title="CyclicBarrier （循环屏障）"></a>CyclicBarrier （循环屏障）</h2><blockquote>
<p>一种多线程屏障辅助工具（可重复使用）它允许一组线程相互等待以达到共同的障碍点。</p>
</blockquote>
<p>CyclicBarriers 在涉及固定大小的线程组的程序中很有用，这些线程组必须偶尔相互等待。屏障被称为循环的，因为它可以在等待线程被释放后重新使用。<br>CyclicBarrier支持一个可选的Runnable命令，该命令每个屏障点运行一次，在队伍中的最后一个线程到达之后，但在任何线程被释放之前。此屏障操作对于在任何一方继续之前更新共享状态很有用。</p>
<h3 id="使用案例-9"><a href="#使用案例-9" class="headerlink" title="使用案例"></a>使用案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CyclicBarriersExample</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Work</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>        <span class="hljs-keyword">private</span> CyclicBarrier cyclicBarrier;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Work</span><span class="hljs-params">(CyclicBarrier cyclicBarrier)</span> &#123;<br>            <span class="hljs-built_in">this</span>.cyclicBarrier = cyclicBarrier;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (Math.random() * <span class="hljs-number">10</span>)/<span class="hljs-number">2</span> * <span class="hljs-number">1000</span>;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; &quot;</span> + DateUtils.getDate()+<span class="hljs-string">&quot;sleep: &quot;</span>+time +<span class="hljs-string">&quot; getNumberWaiting: &quot;</span> + cyclicBarrier.getNumberWaiting());<br>                Thread.sleep(time);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@SneakyThrows</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            doWork();<br>            cyclicBarrier.await();<span class="hljs-comment">//到达栅栏</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">cyclicBarrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">10</span>, () -&gt; System.out.println(<span class="hljs-string">&quot;所有任务已经执行完成:&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; &quot;</span> + DateUtils.getDate()));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Work</span>(cyclicBarrier)).start();<br>        &#125;<br>        Thread.sleep(<span class="hljs-number">5000</span>);<br>        <span class="hljs-comment">//重置</span><br>        cyclicBarrier.reset();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Work</span>(cyclicBarrier)).start();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="CyclicBarrier-与-CountDownLatch-区别"><a href="#CyclicBarrier-与-CountDownLatch-区别" class="headerlink" title="CyclicBarrier 与 CountDownLatch 区别"></a>CyclicBarrier 与 CountDownLatch 区别</h3><ul>
<li>CountDownLatch 是一次性的，CyclicBarrier 是可循环利用的</li>
<li>CountDownLatch 参与的线程的职责是不一样的，有的在倒计时，有的在等待倒计时结束。CyclicBarrier 参与的线程职责是一样的。</li>
</ul>
<h2 id="Phaser（阶段）"><a href="#Phaser（阶段）" class="headerlink" title="Phaser（阶段）"></a>Phaser（阶段）</h2><blockquote>
<p>一个可重用的同步屏障，在功能上类似于CyclicBarrier和CountDownLatch，但支持更灵活的使用，无需设置固定的parties，可在使用过程中动态的。</p>
</blockquote>
<p>Phaser与其他屏障的情况不同，在相位器上注册同步的参与方数量可能会随着时间的推移而变化。可以随时注册任务（使用方法register（）、bulkRegister（int）或建立初始参与方数的构造函数的形式），也可以在任何到达时取消注册任务（使用arriveAndDeregister（））。与最基本的同步构造一样，注册和注销只影响内部计数；它们不建立任何进一步的内部簿记，因此任务无法查询它们是否已注册。（可以通过将此类子类化来引入这种簿记）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/2630542/1653978841077-de409a77-8cb2-4c25-b8fd-e714f2620392.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>相关参数解释：</p>
<ul>
<li>phase：当前的周期索引（或者 阶段索引），初始值为0，当所有线程执行完本阶段的任务后，phase就会加一，进入下一阶段；可以结合onAdvance（）方法，在不同的阶段，执行不同的屏障方法。</li>
<li>parties：注册的线程数，即Phaser要监控的线程数量，或者说是 建立的屏障的数量。屏障的数量不是固定的，每个阶段的屏障的数量都可以是不一样。</li>
</ul>
<p>相关方法解释：</p>
<ul>
<li>register(): 调用该方法会使得 parties 加 1</li>
<li>arriveAndAwaitAdvance(): 阻塞等待其他所有线程执行当前阶段完成才能继续往后执行。</li>
<li>arriveAndDeregister()：线程通过栅栏，非阻塞，但是它执行了 deregister 操作，使得 parties 加 1。</li>
<li>arrive():这个方法标记当前线程已经到达栅栏，但是该方法不会阻塞，注意，它不会阻塞。</li>
</ul>
<p> </p>
<h3 id="使用案例-10"><a href="#使用案例-10" class="headerlink" title="使用案例"></a>使用案例</h3><blockquote>
<p>Phaser通过register增加阶段，在调用arriveAndAwaitAdvance方法会阻塞等待其他所有线程执行当前阶段完成才能继续往后执行。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    Phaser phaser;<br>    String title;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThread</span><span class="hljs-params">(Phaser phaser, String title)</span> &#123;<br>        <span class="hljs-built_in">this</span>.phaser = phaser;<br>        <span class="hljs-built_in">this</span>.title = title;<br>        <span class="hljs-comment">//phaser注册一个阶段</span><br>        phaser.register();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-built_in">this</span>).start();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Thread: &quot;</span> + title + <span class="hljs-string">&quot; Phase Zero Started&quot;</span>);<br>        <span class="hljs-comment">//等待所有线程到达再前进</span><br>        phaser.arriveAndAwaitAdvance();<br>        <span class="hljs-comment">// Stop execution to prevent jumbled output</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            System.out.println(e);<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;Thread: &quot;</span> + title + <span class="hljs-string">&quot; Phase One Started&quot;</span>);<br>        phaser.arriveAndAwaitAdvance();<br><br>        <span class="hljs-comment">// Stop execution to prevent jumbled output</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">100</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            System.out.println(e);<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;Thread: &quot;</span> + title + <span class="hljs-string">&quot; Phase Two Started&quot;</span>);<br>        phaser.arriveAndDeregister();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PhaserExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Phaser</span> <span class="hljs-variable">phaser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phaser</span>();<br>        phaser.register();<br>        <span class="hljs-type">int</span> currentPhase;<br><br>        System.out.println(<span class="hljs-string">&quot;Starting&quot;</span>);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(phaser, <span class="hljs-string">&quot;A&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(phaser, <span class="hljs-string">&quot;B&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(phaser, <span class="hljs-string">&quot;C&quot;</span>);<br><br>        <span class="hljs-comment">// Wait for all threads to complete phase Zero.</span><br>        currentPhase = phaser.getPhase();<br>        phaser.arriveAndAwaitAdvance();<br>        System.out.println(<span class="hljs-string">&quot;Phase &quot;</span> + currentPhase + <span class="hljs-string">&quot; Complete&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Phase Zero Ended&quot;</span>);<br>        System.out.println();<br><br>        <span class="hljs-comment">// Wait for all threads to complete phase One.</span><br>        currentPhase = phaser.getPhase();<br>        phaser.arriveAndAwaitAdvance();<br>        System.out.println(<span class="hljs-string">&quot;Phase &quot;</span> + currentPhase + <span class="hljs-string">&quot; Complete&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Phase One Ended&quot;</span>);<br>        System.out.println();<br><br>        currentPhase = phaser.getPhase();<br>        phaser.arriveAndAwaitAdvance();<br>        System.out.println(<span class="hljs-string">&quot;Phase &quot;</span> + currentPhase + <span class="hljs-string">&quot; Complete&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Phase Two Ended&quot;</span>);<br><br>        <span class="hljs-comment">// Deregister the main thread.</span><br>        phaser.arriveAndDeregister();<br>        <span class="hljs-keyword">if</span> (phaser.isTerminated()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Phaser is terminated&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Exchanger（交换者）"><a href="#Exchanger（交换者）" class="headerlink" title="Exchanger（交换者）"></a>Exchanger（交换者）</h2><blockquote>
<p>线程之间交换数据的一种手段。两个线程可以交换对象的同步点。每个线程在进入交换方法时提供一些对象，并在返回时接收另一个线程提供的对象。</p>
</blockquote>
<p>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据， 如果第一个线程先执行exchange方法，它会一直等待第二个线程也执行exchange，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。因此使用Exchanger的重点是成对的线程使用exchange()方法，当有一对线程达到了同步点，就会进行交换数据。因此该工具类的线程对象是成对的。</p>
<h3 id="使用案例-11"><a href="#使用案例-11" class="headerlink" title="使用案例"></a>使用案例</h3><blockquote>
<p>exchange方法会进入阻塞状态</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExchangerExample</span> &#123;<br><br>    <span class="hljs-keyword">static</span> Exchanger&lt;Map&lt;String, String&gt;&gt; exchanger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exchanger</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>        <span class="hljs-keyword">private</span> Map&lt;String,String&gt; map;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Task</span><span class="hljs-params">(Map&lt;String, String&gt; map)</span> &#123;<br>            <span class="hljs-built_in">this</span>.map = map;<br>        &#125;<br><br>        <span class="hljs-meta">@SneakyThrows</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;当前线程：&quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot; 原始数据：&quot;</span>+map);<br>            Map&lt;String, String&gt; exchange = exchanger.exchange(map);<br>            System.out.println();<br>            System.out.println(<span class="hljs-string">&quot;当前线程：&quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot; 交换数据：&quot;</span>+exchange);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        HashMap&lt;String, String&gt; mapA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        mapA.put(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>);<br>        mapA.put(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>);<br>        HashMap&lt;String, String&gt; mapB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        mapB.put(<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>);<br>        mapB.put(<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(mapA)).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(mapB)).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="locks-锁"><a href="#locks-锁" class="headerlink" title="locks (锁)"></a>locks (锁)</h1><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><blockquote>
<p>ReentrantLock重入锁，其内部主要通过Sync（AQS的具体实现）、NonfairSync（Sync子类）非公平锁、FairSync（Sync子类）公平锁来实现，构造方法默认是非公平锁。</p>
</blockquote>
<p>公平锁：会根据先来后到的顺序获取锁<br>非公平锁：不会根据先来后到的顺序获取锁<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1653989358231-d08d37d7-548e-4ad3-8934-3b3427628bf7.png#averageHue=%23f6f7ce&clientId=u634b6551-9098-4&from=paste&height=261&id=u1ea18aa4&originHeight=261&originWidth=834&originalType=binary&ratio=1&rotation=0&showTitle=false&size=63911&status=done&style=none&taskId=ud666a2e8-5cc3-4655-88df-32a2d48bbbd&title=&width=834" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="使用案例-12"><a href="#使用案例-12" class="headerlink" title="使用案例"></a>使用案例</h3><blockquote>
<p>ReentrantLockExample</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLockExample</span> &#123;<br><br><span class="hljs-comment">//    private static ReentrantLock lock = new ReentrantLock();</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(<span class="hljs-literal">true</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建五个线程去获取锁</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>               <span class="hljs-keyword">try</span> &#123;<br>                   <span class="hljs-comment">//获取锁（陷入阻塞）</span><br>                   lock.lock();<br>                   System.out.println(<span class="hljs-string">&quot;线程名: &quot;</span>+Thread.currentThread().getName() + <span class="hljs-string">&quot; 时间: &quot;</span> + DateUtils.getDate() + <span class="hljs-string">&quot; 获取了锁&quot;</span>);<br>                   Thread.sleep(<span class="hljs-number">1000</span>);<br>               &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                    e.printStackTrace();<br>               &#125; <span class="hljs-keyword">finally</span> &#123;<br>                   <span class="hljs-comment">//释放锁</span><br>                   System.out.println(<span class="hljs-string">&quot;线程名: &quot;</span>+Thread.currentThread().getName() + <span class="hljs-string">&quot; 时间: &quot;</span> + DateUtils.getDate() + <span class="hljs-string">&quot; 释放了锁&quot;</span>);<br>                   lock.unlock();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h2><blockquote>
<p>StampedLock是JDK1.8出的一种基于功能的锁，具有三种控制读/写访问的模式分别为写锁 writeLock、悲观读锁 readLock、乐观读 Optimistic reading。StampedLock锁的状态由版本和模式组成。锁获取方法返回表示和控制关于锁状态的访问的戳；这些方法的“try”版本可能会返回特殊值零，以表示无法获取访问权限。锁释放和转换方法需要Stamp作为参数，如果它们与锁的状态不匹配，则会失败。</p>
</blockquote>
<h3 id="使用案例-13"><a href="#使用案例-13" class="headerlink" title="使用案例"></a>使用案例</h3><blockquote>
<p>StampedLock可直接通过构造函数进行创建</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StampedLockExample</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> x, y;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StampedLock</span> <span class="hljs-variable">sl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StampedLock</span>();<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(<span class="hljs-type">double</span> deltaX, <span class="hljs-type">double</span> deltaY)</span> &#123; <span class="hljs-comment">// an exclusively locked method</span><br>        <span class="hljs-comment">//获取一个写锁</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> sl.writeLock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            x += deltaX;<br>            y += deltaY;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//释放锁</span><br>            sl.unlockWrite(stamp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//获取两点之间距离</span><br>    <span class="hljs-type">double</span> <span class="hljs-title function_">distanceFromOrigin</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// A read-only method</span><br>        <span class="hljs-comment">//尝试以乐观读的方式读取数据</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> sl.tryOptimisticRead();<br>        <span class="hljs-type">double</span> <span class="hljs-variable">currentX</span> <span class="hljs-operator">=</span> x, currentY = y;<br>        <span class="hljs-keyword">if</span> (!sl.validate(stamp)) &#123;<span class="hljs-comment">//验证是否有线程在持有写锁，有则转为普通读锁进行读，因为持有写锁的线程可能修改数据</span><br>            stamp = sl.readLock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                currentX = x;<br>                currentY = y;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">//释放锁</span><br>                sl.unlockRead(stamp);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveIfAtOrigin</span><span class="hljs-params">(<span class="hljs-type">double</span> newX, <span class="hljs-type">double</span> newY)</span> &#123; <span class="hljs-comment">// upgrade</span><br>        <span class="hljs-comment">// Could instead start with optimistic, not read mode</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> sl.readLock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (x == <span class="hljs-number">0.0</span> &amp;&amp; y == <span class="hljs-number">0.0</span>) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> sl.tryConvertToWriteLock(stamp);<span class="hljs-comment">//转为写锁</span><br>                <span class="hljs-keyword">if</span> (ws != <span class="hljs-number">0L</span>) &#123;<br>                    stamp = ws;<br>                    x = newX;<br>                    y = newY;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    sl.unlockRead(stamp);<br>                    stamp = sl.writeLock();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            sl.unlock(stamp);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><blockquote>
<p>可从入的读写锁，基于AQS实现，内部持有read、writer两把锁分别控制读写。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantReadWriteLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ReadWriteLock</span>, java.io.Serializable &#123;<br>    <span class="hljs-comment">/** Inner class providing readlock */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;<br>    <span class="hljs-comment">/** Inner class providing writelock */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;<br>    <span class="hljs-comment">/** Performs all synchronization mechanics */</span><br>    <span class="hljs-keyword">final</span> Sync sync;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="使用案例-14"><a href="#使用案例-14" class="headerlink" title="使用案例"></a>使用案例</h3><blockquote>
<p>RWDictionary</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CachedData</span> &#123;<br><br>        Object data;<br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> cacheValid;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">rwl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">processCachedData</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">//尝试获取读锁</span><br>            rwl.readLock().lock();<br>            <span class="hljs-keyword">if</span> (!cacheValid) &#123;<span class="hljs-comment">//保证数据已经可用</span><br>                <span class="hljs-comment">// 在使用写锁时必须先释放读锁</span><br>                rwl.readLock().unlock();<br>                <span class="hljs-comment">// 获取写锁</span><br>                rwl.writeLock().lock();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// Recheck state because another thread might have</span><br>                    <span class="hljs-comment">// acquired write lock and changed state before we did.</span><br>                    <span class="hljs-comment">// 再次验证数据是否可用，可能其他线程已经初始化</span><br>                    <span class="hljs-keyword">if</span> (!cacheValid) &#123;<br>                        data = <span class="hljs-string">&quot;already init&quot;</span>;<br>                        cacheValid = <span class="hljs-literal">true</span>;<span class="hljs-comment">//更新可用标识</span><br>                    &#125;<br>                    <span class="hljs-comment">// Downgrade by acquiring read lock before releasing write lock</span><br>                    <span class="hljs-comment">// 通过在释放写锁之前获取读锁来降级</span><br>                    rwl.readLock().lock();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">//释放锁</span><br>                    rwl.writeLock().unlock(); <span class="hljs-comment">// Unlock write, still hold read</span><br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                use(data);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                rwl.readLock().unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RWDictionary</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Data&gt; m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;String, Data&gt;();<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">rwl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> rwl.readLock();<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> rwl.writeLock();<br><br>        <span class="hljs-keyword">public</span> Data <span class="hljs-title function_">get</span><span class="hljs-params">(String key)</span> &#123;<br>            r.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">return</span> m.get(key);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                r.unlock();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> String[] allKeys() &#123;<br>            r.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">return</span> m.keySet().toArray();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                r.unlock();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Data <span class="hljs-title function_">put</span><span class="hljs-params">(String key, Data value)</span> &#123;<br>            w.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">return</span> m.put(key, value);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                w.unlock();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>            w.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                m.clear();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                w.unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h2 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h2><blockquote>
<p>大名鼎鼎的AQS，抽象队列同步器</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1654053110507-165f1e1e-e6f9-4c32-b534-dadbcfcd187e.png#averageHue=%23000000&clientId=u797eed27-ef13-4&from=paste&height=192&id=u708d002c&originHeight=192&originWidth=2479&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22261&status=done&style=none&taskId=u6498a6c3-48ac-4f33-a272-26cc01fa2fe&title=&width=2479" srcset="/img/loading.gif" lazyload alt="image.png"><br>AQS的原理是依赖于内部的一个volatile修饰的资源变量，CLH队列存储尝试获取锁的线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/2630542/1656602838995-1a560719-7c7c-48a3-8b21-49b7e4c83c3e.jpeg" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-comment">/** Marker to indicate a node is waiting in shared mode */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AbstractQueuedSynchronizer.<span class="hljs-type">Node</span> <span class="hljs-variable">SHARED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span>.Node();<br>    <span class="hljs-comment">/** Marker to indicate a node is waiting in exclusive mode */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AbstractQueuedSynchronizer.<span class="hljs-type">Node</span> <span class="hljs-variable">EXCLUSIVE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">/** waitStatus value to indicate thread has cancelled */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">/** waitStatus value to indicate successor&#x27;s thread needs unparking */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">/** waitStatus value to indicate thread is waiting on condition */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CONDITION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> waitStatus;<br>    <span class="hljs-keyword">volatile</span> AbstractQueuedSynchronizer.Node prev;<br>    <span class="hljs-keyword">volatile</span> AbstractQueuedSynchronizer.Node next;<br>    <br>    <span class="hljs-keyword">volatile</span> Thread thread;<br>    <br>    AbstractQueuedSynchronizer.Node nextWaiter;<br>    <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isShared</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> nextWaiter == SHARED;<br>    &#125;<br>    <br>    <span class="hljs-keyword">final</span> AbstractQueuedSynchronizer.Node <span class="hljs-title function_">predecessor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NullPointerException &#123;<br>        AbstractQueuedSynchronizer.<span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> prev;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    Node() &#123;    <span class="hljs-comment">// Used to establish initial head or SHARED marker</span><br>    &#125;<br>    Node(Thread thread, AbstractQueuedSynchronizer.Node mode) &#123;     <span class="hljs-comment">// Used by addWaiter</span><br>        <span class="hljs-built_in">this</span>.nextWaiter = mode;<br>        <span class="hljs-built_in">this</span>.thread = thread;<br>    &#125;<br>    Node(Thread thread, <span class="hljs-type">int</span> waitStatus) &#123; <span class="hljs-comment">// Used by Condition</span><br>        <span class="hljs-built_in">this</span>.waitStatus = waitStatus;<br>        <span class="hljs-built_in">this</span>.thread = thread;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>AQS 采用了标准的模版方法设计模式，对外提供的是以下的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 独占模式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span>;<br><span class="hljs-comment">// 独占可中断</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><span class="hljs-comment">// 独占带超时时间的</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquireNanos</span><span class="hljs-params">(<span class="hljs-type">int</span> arg, <span class="hljs-type">long</span> nanosTimeout)</span>;<br><span class="hljs-comment">// 共享模式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span>;<br><span class="hljs-comment">// 共享可中断</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><span class="hljs-comment">// 共享带超时时间</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquireSharedNanos</span><span class="hljs-params">(<span class="hljs-type">int</span> arg, <span class="hljs-type">long</span> nanosTimeout)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure>
<p>以上方法都由final修饰，无法进行重写，提供可重写的方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//独占模式,尝试获取资源，成功则返回true，失败则返回false。</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span>;<br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span>;<br><span class="hljs-comment">//共享模式,尝试获取资源，成功则返回0，失败则返回负数。</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span>;<br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span>;<br><span class="hljs-comment">//是否是独占模式</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span>；<br></code></pre></td></tr></table></figure>

<h3 id="获取原理"><a href="#获取原理" class="headerlink" title="获取原理"></a>获取原理</h3><p>在获得同步锁时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；移出队列（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用**   tryRelease(int arg)   **方法释放同步状态，然后唤醒头节点的后继节点。</p>
<p>为什么AQS中采用了双向链表的数据结构来存储线程？<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1656596220890-a6259b5c-7e6f-4c77-a56b-c0301afe3fae.png#averageHue=%23b6b7b4&clientId=u2f1836b4-defe-4&from=paste&height=139&id=u4596d92e&originHeight=278&originWidth=1318&originalType=binary&ratio=1&rotation=0&showTitle=false&size=98854&status=done&style=none&taskId=u4933701f-0440-44c1-8168-4ac011c9ab3&title=&width=659" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ul>
<li><strong>检查</strong>：在AQS的注释中有写到，如果next的指向是null则通过prev检查达到双重检查的效果<blockquote>
<p>Link to the successor node that the current node/thread unparks upon release. Assigned during enqueuing, adjusted when bypassing cancelled predecessors, and nulled out (for sake of GC) when dequeued. The enq operation does not assign next field of a predecessor until after attachment, so seeing a null next field does not necessarily mean that node is at end of queue. However,** if a next field appears to be null, we can scan prev’s from the tail to double-check**. The next field of cancelled nodes is set to point to the node itself instead of null, to make life easier for isOnSyncQueue.</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>中断</strong>：中断操作需要在 AQS 同步队列中删除线程 Node，这也就转化为在链表中删除节点的问题。如果想从CLH 单向链表中间删除一个 Node，因为只维护了前一个节点的指针，想要知道后一个节点的指针的话，不通过从tail开始使用快慢指针遍历是无法办到的。因此直接维护prev、next指针，以降低删除操作的复杂性。</p>
</li>
<li><p><strong>唤醒</strong>：LCH是一个单项链表，维护前一个节点指针，后继线程轮询前一个节点的状态，从而判断是否可以获取锁。而当多线程竞争时，CLH的轮询是非常耗费性能的，无论是对CPU还是总线来说，都是一种巨大的压力。AQS对CLH进行了改进，后继获取锁的线程在经过有限次的轮询后，依旧获取不到锁将陷入阻塞。优点：减少轮询无效操作；缺点：后继线程Node在阻塞后无法感知前一个线程Node的状态，锁被释放时将无法主动醒来。于是AQS使用了双指针，在CLH的prev基础上增加了next。AQS维护了next指针，以便活跃线程释放锁后主动唤醒后续阻塞线程去竞争锁。</p>
</li>
</ul>
<h3 id="使用案例-15"><a href="#使用案例-15" class="headerlink" title="使用案例"></a>使用案例</h3><blockquote>
<p>Mutex</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mutex</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span>, java.io.Serializable &#123;<br><br>    <span class="hljs-comment">// 自定义内部类实现AQS</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>        <span class="hljs-comment">// 报告是否处于锁定状态</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果状态为零，则获取锁</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>            <span class="hljs-keyword">assert</span> acquires == <span class="hljs-number">1</span>; <span class="hljs-comment">// Otherwise unused</span><br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                setExclusiveOwnerThread(Thread.currentThread());<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 通过将状态设置为零来释放锁</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>            <span class="hljs-keyword">assert</span> releases == <span class="hljs-number">1</span>; <span class="hljs-comment">// Otherwise unused</span><br>            <span class="hljs-keyword">if</span> (getState() == <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>            setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>            setState(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 提供条件</span><br>        Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionObject</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// 正确反序列化</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">(ObjectInputStream s)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>            s.defaultReadObject();<br>            setState(<span class="hljs-number">0</span>); <span class="hljs-comment">// 重置为解锁状态</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// The sync object does all the hard work. We just forward to it.</span><br>    <span class="hljs-comment">// 同步对象完成了所有核心的工作。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Sync</span> <span class="hljs-variable">sync</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sync</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        sync.acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        sync.release(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sync.newCondition();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLocked</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sync.isHeldExclusively();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasQueuedThreads</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sync.hasQueuedThreads();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        sync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(timeout));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BooleanLatch</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>        <br>        <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSignalled</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> getState() != <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> ignore)</span> &#123;<br>            <span class="hljs-keyword">return</span> isSignalled() ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> ignore)</span> &#123;<br>            setState(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Sync</span> <span class="hljs-variable">sync</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sync</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSignalled</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sync.isSignalled();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br>        sync.releaseShared(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><blockquote>
<p>这个类与使用它的每个线程相关联，一个许可（在<a target="_blank" rel="noopener" href="https://people.apache.org/~tellison/classlib_doc/html/classjava_1_1util_1_1concurrent_1_1Semaphore.html">Semaphore</a>类的意义上）。park如果许可可用，调用将立即返回，并在此过程中使用它；否则可能会阻塞。unpark如果许可证尚不可用，则调用使许可证可用。（但与信号量不同，许可证不会累积。最多有一个。）</p>
</blockquote>
<p>方法park并unpark提供有效的阻塞和解除阻塞线程的方法，这些线程不会遇到导致不推荐使用的方法Thread.suspend并且Thread.resume无法用于此类目的的问题：一个线程调用park和另一个尝试调用unpark它的线程之间的竞争将由于许可而保持活力。此外，park如果调用者的线程被中断，将返回，并且支持超时版本。该park方法也可能在任何其他时间“无缘无故”地返回，因此通常必须在循环中调用，该循环在返回时重新检查条件。从这个意义上说park，作为“忙等待”的优化，它不会浪费太多时间，但必须与 an 配对unpark才能有效。<br>这些方法旨在用作创建更高级别同步实用程序的工具，它们本身对大多数并发控制应用程序没有用处。</p>
<h3 id="使用案例-16"><a href="#使用案例-16" class="headerlink" title="使用案例"></a>使用案例</h3><blockquote>
<p>LockSupport内部提供的都是静态方法，我们通过类名即可调用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupportExample</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">FIFOMutex</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">locked</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Queue&lt;Thread&gt; waiters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentLinkedQueue</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">wasInterrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>            waiters.add(current);<br><br>            <span class="hljs-comment">// 在队列中不是第一个时阻塞或无法获取锁</span><br>            <span class="hljs-keyword">while</span> (waiters.peek() != current || !locked.compareAndSet(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>)) &#123;<br>                <span class="hljs-comment">/**</span><br><span class="hljs-comment">                 * 除非许可证可用，否则出于线程调度目的禁用当前线程。</span><br><span class="hljs-comment">                 * 如果许可证可用，则会使用该许可证并立即返回调用；否则，出于线程调度目的，当前线程将被禁用，并处于休眠状态，直到发生以下三种情况之一：</span><br><span class="hljs-comment">                 * 1.其他一些线程以当前线程为目标调用unpark；</span><br><span class="hljs-comment">                 * 2.其他线程中断当前线程；</span><br><span class="hljs-comment">                 * 3.该调用错误地（即无原因地）返回。</span><br><span class="hljs-comment">                 * 此方法不报告导致该方法返回的原因。调用者应该首先重新检查导致线程停止的条件。例如，调用者还可以在返回时确定线程的中断状态。</span><br><span class="hljs-comment">                 * 参数：blocker–负责此线程驻车的同步对象</span><br><span class="hljs-comment">                 */</span><br>                LockSupport.park(<span class="hljs-built_in">this</span>);<br>                <span class="hljs-comment">// 等待时忽略中断</span><br>                <span class="hljs-keyword">if</span> (Thread.interrupted()) wasInterrupted = <span class="hljs-literal">true</span>;<br>            &#125;<br>            waiters.remove();<br>            <span class="hljs-comment">// 退出时重新指定中断状态</span><br>            <span class="hljs-keyword">if</span> (wasInterrupted)current.interrupt();<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>            locked.set(<span class="hljs-literal">false</span>);<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 使给定线程的许可证可用（如果尚未可用）。如果线程在park上被阻塞，那么它将解除阻塞。否则，它对park的下一个调用将保证不会阻塞。如果给定的线程尚未启动，则不能保证此操作有任何效果。</span><br><span class="hljs-comment">             * 参数：thread–要取消连接的线程，或null，在这种情况下，此操作无效</span><br><span class="hljs-comment">             */</span><br>            LockSupport.unpark(waiters.peek());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><blockquote>
<p>Condition将Object监视器方法（wait、notify和notifyAll）分解为不同的对象，通过将它们与任意Lock实现的使用结合起来，使每个对象具有多个等待集的效果。<br>Lock替换了synchronized方法和语句Condition的使用，替换了对象监视器方法的使用。</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1654063483216-5c2b16d0-0005-4522-ba09-7e3a82f3d25e.png#averageHue=%23424231&clientId=u797eed27-ef13-4&from=paste&height=80&id=u13e68acb&originHeight=80&originWidth=421&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5978&status=done&style=none&taskId=ub9f58905-4bd4-4e2e-a4ab-7fe0f0b5d91&title=&width=421" srcset="/img/loading.gif" lazyload alt="image.png"><br>Condition（也称为条件队列或条件变量）为一个线程提供了一种暂停执行（“等待”）的方法，直到另一个线程通知某个状态条件现在可能为真。因为对这种共享状态信息的访问发生在不同的线程中，所以它必须受到保护，所以某种形式的锁与条件相关联。等待条件提供的关键属性是它以原子方式释放关联的锁并挂起当前线程，就像Object.wait.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Condition</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使当前线程等待，直到发出信号或中断。</span><br><span class="hljs-comment">     * 与此条件相关联的锁以原子方式释放，当前线程出于线程调度目的被禁用，并处于休眠状态，直到发生以下四种情况之一：</span><br><span class="hljs-comment">     * 其他一些线程为此条件调用signal方法，而当前线程恰好被选择为要唤醒的线程；或</span><br><span class="hljs-comment">     * 其他一些线程为此条件调用signalAll方法；或</span><br><span class="hljs-comment">     * 其他线程中断当前线程，支持中断线程挂起；或</span><br><span class="hljs-comment">     * 出现“虚假唤醒”。</span><br><span class="hljs-comment">     * 在所有情况下，在该方法返回之前，当前线程必须重新获取与此条件关联的锁。当线程返回时，保证持有该锁。</span><br><span class="hljs-comment">     * 如果当前线程：</span><br><span class="hljs-comment">     * 在进入该方法时设置其中断状态；或</span><br><span class="hljs-comment">     * 等待时中断，支持中断线程挂起，</span><br><span class="hljs-comment">     * 然后抛出InterruptedException，并清除当前线程的中断状态。在第一种情况下，未规定是否在释放锁之前进行中断测试。</span><br><span class="hljs-comment">     * 实施注意事项</span><br><span class="hljs-comment">     * 调用此方法时，假设当前线程持有与此条件关联的锁。由实施部门决定是否存在这种情况，如果不是，如何应对。通常，将引发异常（例如IllegalMonitorStateException），实现必须记录该事实。</span><br><span class="hljs-comment">     * 与响应信号的正常方法返回相比，实现更倾向于响应中断。在这种情况下，实现必须确保将信号重定向到另一个等待线程（如果有）。</span><br><span class="hljs-comment">     * 抛出：InterruptedException–如果当前线程被中断（并且支持中断线程挂起）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">awaitUninterruptibly</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">long</span> <span class="hljs-title function_">awaitNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanosTimeout)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">await</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitUntil</span><span class="hljs-params">(Date deadline)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 唤醒一个等待的线程。</span><br><span class="hljs-comment">     * 如果有任何线程在此条件下等待，则会选择一个线程进行唤醒。然后，该线程必须在从等待返回之前重新获取锁。</span><br><span class="hljs-comment">     * 实施注意事项</span><br><span class="hljs-comment">     * 调用此方法时，实现可能（并且通常确实）要求当前线程持有与此条件关联的锁。实现必须记录此先决条件以及未持有锁时所采取的任何操作。通常，会引发异常，例如IllegalMonitorStateException。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 唤醒所有等待的线程。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">signalAll</span><span class="hljs-params">()</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>Condition实例本质上绑定到锁 。要获取Condition特定Lock实例的实例，请使用其newCondition()方法。<br>例如，假设我们有一个支持put和take方法的有界缓冲区。如果take在空缓冲区上尝试 a ，则线程将阻塞，直到项目可用为止；如果put在一个完整的缓冲区上尝试 a，则线程将阻塞，直到有空间可用。我们希望将等待put线程和take线程保持在单独的等待集中，以便我们可以使用在缓冲区中可用的项目或空间时仅通知单个线程的优化。这可以使用两个Condition实例来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionExample</span> &#123;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">BoundedBuffer</span> &#123;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notFull</span> <span class="hljs-operator">=</span> lock.newCondition();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notEmpty</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>        <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">100</span>];<br>        <span class="hljs-type">int</span> putptr, takeptr, count;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Object x)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>            <span class="hljs-comment">//加锁</span><br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//如果 count == items.length 无法再添加线程进入等待状态</span><br>                <span class="hljs-keyword">while</span> (count == items.length) notFull.await();<br>                items[putptr] = x;<span class="hljs-comment">//线程被唤醒更新值</span><br>                <span class="hljs-keyword">if</span> (++putptr == items.length) putptr = <span class="hljs-number">0</span>;<span class="hljs-comment">//如果putptr指针长度和items.length相等重新指向0</span><br>                ++count;<span class="hljs-comment">//数量加一</span><br>                notEmpty.signal();<span class="hljs-comment">//唤醒非空condition</span><br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">//释放锁</span><br>                lock.unlock();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//如果count==0陷入等待</span><br>                <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>) notEmpty.await();<br>                <span class="hljs-comment">//被当元素大于0被唤醒</span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> items[takeptr];<br>                <span class="hljs-keyword">if</span> (++takeptr == items.length) takeptr = <span class="hljs-number">0</span>;<br>                --count;<br>                notFull.signal();<br>                <span class="hljs-keyword">return</span> x;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><p><strong>锁的四种状态：无锁、偏向锁、轻量级锁、重量级锁（级别从高到低）</strong></p>
<ul>
<li><strong>无锁：</strong>不存在竞争关系，或者存在竞争关系，但采用非锁的方式即CAS的方式解决</li>
<li><strong>偏向锁：</strong>对某一个对象第一次上锁时，就是偏向锁，该对象的MarkWord中会存储该线程的ID，可以理解为对象锁认识该线程，可以获取到锁，当多个线程竞争该锁，就会进行锁升级，升为轻量级锁</li>
<li><strong>轻量级锁：</strong>当锁升级为轻量级锁时，线程会在自己的虚拟机栈中开辟一块称为<code>Lock Record</code>的空间，lock record中会存储对象头中Mark Word的副本以及owner指针，线程会通过CAS尝试获得锁，一但获得锁，就会将Mark Word复制到lock record中，并将owner指针指向该对象，另一方面，该对象的Mark word中的指针会指向获得锁的线程的lock record，就完成了获得获取与绑定。其他的线程想要获取锁，会自旋等待。自旋相当于CPU在空转，会浪费CPU的资源，所以产生了自适应自旋，也就是说自旋的时间不再固定，而是由上一次在同一个锁上自旋的时间和锁的状态共同决定。如果上一次自旋获得过锁，JVM就会认为有机会通过自旋获得锁，就会允许更长时间的自旋来获得锁。</li>
<li><strong>重量级锁：</strong>如果线程长时间的自旋或等待的线程特别多，就会进行下一步的锁升级，也就是升级与重量级锁，通过操作系统来操作线程。JDK1.6规定的是，线程自旋10次会升级为重量级锁，或等待线程的数量超过CPU合数的1/2，升级为重量级锁</li>
</ul>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><h4 id="为什么要引入偏向锁？"><a href="#为什么要引入偏向锁？" class="headerlink" title="为什么要引入偏向锁？"></a>为什么要引入偏向锁？</h4><blockquote>
<p>因为经过hotspot的作者的大量研究发现，大多数时候是不存在锁竞争的，常常是一个线程多次获得同一个锁，因此如果每次都要竞争锁会增大很多没有必要付出的代价，为了降低获取锁的代价，才引入了偏向锁。</p>
</blockquote>
<h4 id="偏向锁的升级"><a href="#偏向锁的升级" class="headerlink" title="偏向锁的升级"></a>偏向锁的升级</h4><blockquote>
<p>当线程1访问同步代码块并获取锁对象时。会在Java对象头和栈帧中记录偏向锁的threadID，因为偏向锁不会主动释放锁，因此以后线程1再次获取锁的时候，需要比较当前线程的threadID和Java对象头中的threadID是否一致，如果一致，则还是线程1获取锁对象，则无需调用CAS来加锁、解锁；如果不一致（其他线程如线程2要竞争锁对象，而偏向锁不会主动释放，因此存储的还是线程1的threadID），那么需要查看Java对象头中记录的线程1是否存活，如果没有存活，那么锁对象被重置为无锁状态，其他线程可以竞争设置其为偏向锁；如果存活，那么立刻查找该线程的栈帧信息，如果还是需要继续持有这个锁对象，那么暂停线程1，撤销偏向锁，升级为轻量级锁；如果线程1不再使用该锁对象，那么将锁对象状态设置为无锁状态，重新偏向新的线程。</p>
</blockquote>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p><strong>为什么要引入轻量级锁？</strong></p>
<blockquote>
<p>轻量级锁考虑的是竞争锁对象的线程不多，而且线程持有锁的时间也不长的情景。因为阻塞线程需要CPU从用户态切换到内核态，代价较大，如果刚刚阻塞不久这个锁就被释放了，那这个代价就有点得不偿失了，因此这个时候就干脆不阻塞这个线程，让它自旋等待锁释放。</p>
</blockquote>
<p><strong>轻量级锁什么时候升级为重量级锁？</strong></p>
<blockquote>
<p>线程1获取轻量级锁时会先把锁对象的对象头MarkWord复制一份到线程1的栈帧中创建用于存储锁记录的空间（称为DisplacedMarkWord），然后使用CAS把对象头中的内容替换为线程1存储的锁记录（DisplacedMarkWord）的地址；</p>
</blockquote>
<blockquote>
<p>如果线程1复制对象头的同时（在线程1CAS之前），线程2也准备获取锁，复制的对象头到线程2的锁记录空间中，但是在线程2CAS的时候，发现线程1已经把对象头换了，线程2CAS失败，那么线程2就尝试使用自旋锁来等待线程1释放锁。</p>
</blockquote>
<blockquote>
<p>但是如果自旋的时间太长也不行，因为自旋是需要消耗CPU的，因此自旋的次数是有限制的，如果自旋次数达到了限制线程1还没有释放锁，或者线程1还在执行，线程2还在自旋等待，这时候又有一个线程3来竞争这个锁对象，那么这时候轻量级锁就会膨胀为重量级锁。重量级锁把除了拥有锁的线程都阻塞，防止CPU空转。</p>
</blockquote>
<p>注意：为了避免无用的自旋，轻量级锁一旦膨胀为重量级锁就不会再降级为轻量级锁了；偏向锁升级为轻量级锁也不能再降级为偏向锁。一句话就是，锁升级的过程是不可逆的。但是偏向锁可以重置为无锁的状态。</p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><table>
<thead>
<tr>
<th>锁状态</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁解锁无需额外的消耗，和非同步方法时间相差纳秒级别</td>
<td>如果竞争的线程多，那么会带来额外的锁撤销的消耗</td>
<td>基本没有线程竞争锁的同步场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，使用自旋，提高程序响应速度</td>
<td>如果一直不能获取锁，长时间的自旋会造成CPU的消耗</td>
<td>适用于少量线程竞争锁对象，且线程持有锁的时间不长，追求响应速度的场景</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用CPU自旋，不会导致CPU空转导致消耗CPU资源</td>
<td>线程阻塞，响应时间长</td>
<td>很多线程竞争锁，且锁的持有时间长，追求吞吐量的场景</td>
</tr>
</tbody></table>
<h1 id="Memory-Consistency-Properties-内存一致性关键字）"><a href="#Memory-Consistency-Properties-内存一致性关键字）" class="headerlink" title="Memory Consistency Properties (内存一致性关键字）"></a>Memory Consistency Properties (内存一致性关键字）</h1><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><blockquote>
<p>volatile是JDK提供的关键字，其主要修饰属性（字段）</p>
</blockquote>
<p>被volatile修饰的属性具有以下性质不保证原子性<br>1.不保证原子性<br>2.内存可见性:<br>3.禁止指令重拍:不会因编译器的优化而省重排序</p>
<p>禁止指令重排序：<br>简单地说就是防止编译器对代码进行优化。比如如下程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span> XBYTE[<span class="hljs-number">2</span>]=<span class="hljs-number">0x55</span>;<br><span class="hljs-number">2</span> XBYTE[<span class="hljs-number">2</span>]=<span class="hljs-number">0x56</span>;<br><span class="hljs-number">3</span> XBYTE[<span class="hljs-number">2</span>]=<span class="hljs-number">0x57</span>;<br><span class="hljs-number">4</span> XBYTE[<span class="hljs-number">2</span>]=<span class="hljs-number">0x58</span>;<br></code></pre></td></tr></table></figure>
<p>对外部硬件而言，上述四条语句分别表示不同的操作，会产生四种不同的动作，但是编译器却会对上述四条语句进行优化，认为只有XBYTE[2]=0x58（即忽略前三条语句，只产生一条机器代码）。如果键入volatile，则编译器会逐一地进行编译并产生相应的机器代码（产生四条代码）。<br> <br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/2630542/1652769951521-16fd06b6-03a6-4d05-a6f9-573afbdb98aa.jpeg" srcset="/img/loading.gif" lazyload></p>
<h3 id="使用案例-17"><a href="#使用案例-17" class="headerlink" title="使用案例"></a>使用案例</h3><blockquote>
<p>volatile只能修饰属性字段</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> score;<br></code></pre></td></tr></table></figure>


<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><blockquote>
<p>synchronized是JDK提供的关键字，属于JVM层面的锁，其作业范围可以是锁类、代码库、方法。</p>
</blockquote>
<p>当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这段代码。当两个并发线程访问同一个对象object中的这个加锁同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。然而，当一个线程访问object的一个加锁代码块时，另一个线程仍可以访问该object中的非加锁代码块。</p>
<h3 id="使用案例-18"><a href="#使用案例-18" class="headerlink" title="使用案例"></a>使用案例</h3><blockquote>
<p>可修饰类、代码库、方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Integer num;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 锁方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockMethod</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 锁代码块</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-comment">//do something</span><br>        &#125;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 锁字段</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">synchronized</span> (num)&#123;<br>            <span class="hljs-comment">//do something</span><br>        &#125;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 锁类</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">synchronized</span> (Sync.class)&#123;<br>            <span class="hljs-comment">//do something</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="Synchronized是一个重量级锁"><a href="#Synchronized是一个重量级锁" class="headerlink" title="Synchronized是一个重量级锁"></a>Synchronized是一个重量级锁</h3><p>Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的，监视器锁本质又是依赖于底层的操作系统的 Mutex Lock（互斥锁）来实现的。而操作系统实现线程之间的切换需要从用户态转换到内核态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么 Synchronized 效率低的原因。因此这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为 “重量级锁”。</p>
<h3 id="Synchronized底层实现原理"><a href="#Synchronized底层实现原理" class="headerlink" title="Synchronized底层实现原理"></a>Synchronized底层实现原理</h3><p>同步方法通过ACC_SYNCHRONIZED 关键字隐式的对方法进行加锁。当线程要执行的方法被标注上ACC_SYNCHRONIZED时，需要先获得锁才能执行该方法。<br>同步代码块通过monitorenter和monitorexit执行来进行加锁。当线程执行到monitorenter的时候要先获得锁，才能执行后面的方法。当线程执行到monitorexit的时候则要释放锁。每个对象自身维护着一个被加锁次数的计数器，当计数器不为0时，只有获得锁的线程才能再次获得锁。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs bash">biaoyang@biaodeMacBook-Pro synchronize % javap -verbose Sync.class<br>Classfile /Users/biaoyang/IdeaProjects/demo/src/main/java/com/example/demo/juc/synchronize/Sync.class<br>  Last modified 2022年6月14日; size 620 bytes<br>  SHA-256 checksum ce23c5f2500c4d9bf0c7e6be77d65b9cf9aa37b2460447bba36cec4519abae2f<br>  Compiled from <span class="hljs-string">&quot;Sync.java&quot;</span><br>public class com.example.demo.juc.synchronize.Sync<br>  minor version: 0<br>  major version: 61<br>  flags: (0x0021) ACC_PUBLIC, ACC_SUPER<br>  this_class: <span class="hljs-comment">#14                         // com/example/demo/juc/synchronize/Sync</span><br>  super_class: <span class="hljs-comment">#2                         // java/lang/Object</span><br>  interfaces: 0, fields: 1, methods: 2, attributes: 1<br>Constant pool:<br>   <span class="hljs-comment">#1 = Methodref          #2.#3          // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>   <span class="hljs-comment">#2 = Class              #4             // java/lang/Object</span><br>   <span class="hljs-comment">#3 = NameAndType        #5:#6          // &quot;&lt;init&gt;&quot;:()V</span><br>   <span class="hljs-comment">#4 = Utf8               java/lang/Object</span><br>   <span class="hljs-comment">#5 = Utf8               &lt;init&gt;</span><br>   <span class="hljs-comment">#6 = Utf8               ()V</span><br>   <span class="hljs-comment">#7 = Methodref          #8.#9          // java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br>   <span class="hljs-comment">#8 = Class              #10            // java/lang/Integer</span><br>   <span class="hljs-comment">#9 = NameAndType        #11:#12        // valueOf:(I)Ljava/lang/Integer;</span><br>  <span class="hljs-comment">#10 = Utf8               java/lang/Integer</span><br>  <span class="hljs-comment">#11 = Utf8               valueOf</span><br>  <span class="hljs-comment">#12 = Utf8               (I)Ljava/lang/Integer;</span><br>  <span class="hljs-comment">#13 = Fieldref           #14.#15        // com/example/demo/juc/synchronize/Sync.num:Ljava/lang/Integer;</span><br>  <span class="hljs-comment">#14 = Class              #16            // com/example/demo/juc/synchronize/Sync</span><br>  <span class="hljs-comment">#15 = NameAndType        #17:#18        // num:Ljava/lang/Integer;</span><br>  <span class="hljs-comment">#16 = Utf8               com/example/demo/juc/synchronize/Sync</span><br>  <span class="hljs-comment">#17 = Utf8               num</span><br>  <span class="hljs-comment">#18 = Utf8               Ljava/lang/Integer;</span><br>  <span class="hljs-comment">#19 = Utf8               Code</span><br>  <span class="hljs-comment">#20 = Utf8               LineNumberTable</span><br>  <span class="hljs-comment">#21 = Utf8               lockMethod</span><br>  <span class="hljs-comment">#22 = Utf8               StackMapTable</span><br>  <span class="hljs-comment">#23 = Class              #24            // java/lang/Throwable</span><br>  <span class="hljs-comment">#24 = Utf8               java/lang/Throwable</span><br>  <span class="hljs-comment">#25 = Utf8               SourceFile</span><br>  <span class="hljs-comment">#26 = Utf8               Sync.java</span><br>&#123;<br>  public com.example.demo.juc.synchronize.Sync();<br>    descriptor: ()V<br>    flags: (0x0001) ACC_PUBLIC<br>    Code:<br>      stack=2, locals=1, args_size=1<br>         0: aload_0<br>         1: invokespecial <span class="hljs-comment">#1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>         4: aload_0<br>         5: bipush        100<br>         7: invokestatic  <span class="hljs-comment">#7                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br>        10: putfield      <span class="hljs-comment">#13                 // Field num:Ljava/lang/Integer;</span><br>        13: <span class="hljs-built_in">return</span><br>      LineNumberTable:<br>        line 3: 0<br>        line 5: 4<br><br>  public synchronized void lockMethod();<br>    descriptor: ()V<br>    flags: (0x0021) ACC_PUBLIC, ACC_SYNCHRONIZED<br>    Code:<br>      stack=2, locals=5, args_size=1<br>         0: aload_0<br>         1: dup<br>         2: astore_1<br>         3: monitorenter<br>         4: aload_1<br>         5: monitorexit<br>         6: goto          14<br>         9: astore_2<br>        10: aload_1<br>        11: monitorexit<br>        12: aload_2<br>        13: athrow<br>        14: aload_0<br>        15: getfield      <span class="hljs-comment">#13                 // Field num:Ljava/lang/Integer;</span><br>        18: dup<br>        19: astore_1<br>        20: monitorenter<br>        21: aload_1<br>        22: monitorexit<br>        23: goto          31<br>        26: astore_3<br>        27: aload_1<br>        28: monitorexit<br>        29: aload_3<br>        30: athrow<br>        31: ldc           <span class="hljs-comment">#14                 // class com/example/demo/juc/synchronize/Sync</span><br>        33: dup<br>        34: astore_1<br>        35: monitorenter<br>        36: aload_1<br>        37: monitorexit<br>        38: goto          48<br>        41: astore        4<br>        43: aload_1<br>        44: monitorexit<br>        45: aload         4<br>        47: athrow<br>        48: <span class="hljs-built_in">return</span><br>      Exception table:<br>         from    to  target <span class="hljs-built_in">type</span><br>             4     6     9   any<br>             9    12     9   any<br>            21    23    26   any<br>            26    29    26   any<br>            36    38    41   any<br>            41    45    41   any<br>      LineNumberTable:<br>        line 14: 0<br>        line 16: 4<br>        line 21: 14<br>        line 23: 21<br>        line 28: 31<br>        line 30: 36<br>        line 31: 48<br>      StackMapTable: number_of_entries = 6<br>        frame_type = 255 /* full_frame */<br>          offset_delta = 9<br>          locals = [ class com/example/demo/juc/synchronize/Sync, class java/lang/Object ]<br>          stack = [ class java/lang/Throwable ]<br>        frame_type = 250 /* chop */<br>          offset_delta = 4<br>        frame_type = 255 /* full_frame */<br>          offset_delta = 11<br>          locals = [ class com/example/demo/juc/synchronize/Sync, class java/lang/Object ]<br>          stack = [ class java/lang/Throwable ]<br>        frame_type = 250 /* chop */<br>          offset_delta = 4<br>        frame_type = 255 /* full_frame */<br>          offset_delta = 9<br>          locals = [ class com/example/demo/juc/synchronize/Sync, class java/lang/Object ]<br>          stack = [ class java/lang/Throwable ]<br>        frame_type = 250 /* chop */<br>          offset_delta = 6<br>&#125;<br>SourceFile: <span class="hljs-string">&quot;Sync.java&quot;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">ObjectMonitor</span>() &#123;<br>    _header       = <span class="hljs-literal">NULL</span>;<br>    _count        = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录个数</span><br>    _waiters      = <span class="hljs-number">0</span>,<br>    _recursions   = <span class="hljs-number">0</span>;<br>    _object       = <span class="hljs-literal">NULL</span>;<br>    _owner        = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//指向持有ObjectMonitor的线程；</span><br>    _WaitSet      = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 处于wait状态的线程，会被加入到_WaitSet</span><br>    _WaitSetLock  = <span class="hljs-number">0</span> ;<br>    _Responsible  = <span class="hljs-literal">NULL</span> ;<br>    _succ         = <span class="hljs-literal">NULL</span> ;<br>    _cxq          = <span class="hljs-literal">NULL</span> ;<br>    FreeNext      = <span class="hljs-literal">NULL</span> ;<br>    _EntryList    = <span class="hljs-literal">NULL</span> ; <span class="hljs-comment">// 处于等待锁block状态的线程，会被加入到该列表</span><br>    _SpinFreq     = <span class="hljs-number">0</span> ;<br>    _SpinClock    = <span class="hljs-number">0</span> ;<br>    OwnerIsThread = <span class="hljs-number">0</span> ;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>当monitor对象被线程持有时，Monitor对象中的count就会进行+1，当线程释放monitor对象时，count又会进行-1操作。用count来表示monitor对象是否被持有</p>
<ul>
<li><p>monitorenter: monitorenter指令表示获取锁对象的monitor对象，这是monitor对象中的count并会加+1，如果monitor已经被其他线程所获取，该线程会被阻塞住，直到count=0,再重新尝试获取monitor对象</p>
</li>
<li><p>monitorexit: monitorexit与monitorenter是相对的指令，表示进入和退出。执行monitorexit指令表示该线程释放锁对象的monitor对象,这时monitor对象的count便会-1变成0，其他被阻塞的线程可以重新尝试获取锁对象的monitor对象</p>
</li>
</ul>
<p>从synchronized放置的位置不同可以得出，synchronized用来修饰方法时，是通过ACC_SYNCHRONIZED标识符来保持线程同步的。而用来修饰代码块时，是通过monitorenter和monitorexit指令来完成</p>
<h3 id="Synchronized锁存储位置"><a href="#Synchronized锁存储位置" class="headerlink" title="Synchronized锁存储位置"></a>Synchronized锁存储位置</h3><blockquote>
<p>Synchronized用的锁是存在java的对象头里面的。一个对象在new出来之后再内存中主要分为4个部分：</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/2630542/1655195296910-8f73374b-16dd-4a7a-9b14-8ac5bb953249.jpeg" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>Mark Word：存储了对象的hashCode、GC信息、锁信息三部分。这部分占8字节。</p>
</li>
<li><p>Class Pointer：存储了指向类对象信息的指针。在64位JVM上有一个压缩指针选项-ClassPointer指针：-XX:+UseCompressedClassPointers 为4字节 不开启为8字节。默认是开启的。</p>
</li>
<li><p>实例数据(instance data)：记录了对象里面的变量数据。引用类型：-XX:+UseCompressedOops 为4字节 不开启为8字节 Oops Ordinary Object Pointers</p>
</li>
<li><p>Padding：作为对齐使用，对象在64位服务版本中，规定对象内存必须要能被8字节整除，如果不能整除，那么就靠对齐来补。举个例子：new出了一个对象，内存只占用18字节，但是规定要能被8整除，所以padding=6</p>
</li>
</ul>
<p>Mark Word存储结构如下：<br>32位虚拟机下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1655192186835-d122bc9b-3516-46a9-a067-423c56b1abf0.png#averageHue=%23bac8d9&clientId=u76b0a1f3-8451-4&from=paste&height=162&id=u1233b45e&originHeight=162&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&size=86413&status=done&style=none&taskId=ue3206ea8-8553-4ad9-a687-949d9688864&title=&width=554" srcset="/img/loading.gif" lazyload alt="image.png"><br>64位虚拟机下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1655192195862-e456dbac-29fb-42a7-99c5-d4bc26325303.png#averageHue=%23c2cedc&clientId=u76b0a1f3-8451-4&from=paste&height=184&id=u732b9120&originHeight=184&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&size=90919&status=done&style=none&taskId=u3764c1b8-332e-43db-a7c7-a5e1411ad1b&title=&width=554" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="Synchronized锁的升级过程"><a href="#Synchronized锁的升级过程" class="headerlink" title="Synchronized锁的升级过程"></a>Synchronized锁的升级过程</h3><p>Java SE 1.6 为了减少获得锁和释放锁带来的性能消耗，引入了 “偏向锁” 和 “轻量级锁”：锁一共有 4 种状态，级别从低到高依次是：<strong>无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态</strong>。锁可以升级但不能降级。</p>
<ul>
<li><p>偏向锁：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中记录存储锁偏向的线程ID，以后该线程在进入同步块时先判断对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果存在就直接获取锁。</p>
</li>
<li><p>轻量级锁：当其他线程尝试竞争偏向锁时，锁升级为轻量级锁。线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的MarkWord替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，标识其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p>
</li>
<li><p>重量级锁：锁在原地循环等待的时候，是会消耗CPU资源的。所以自旋必须要有一定的条件控制，否则如果一个线程执行同步代码块的时间很长，那么等待锁的线程会不断的循环反而会消耗CPU资源。默认情况下锁自旋的次数是10 次，可以使用-XX:PreBlockSpin参数来设置自旋锁等待的次数。10次后如果还没获取锁，则升级为重量级锁。</p>
</li>
</ul>
<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><ol>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html#package.description">https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html#package.description</a></li>
<li><a target="_blank" rel="noopener" href="http://mishadoff.com/blog/java-magic-part-4-sun-dot-misc-dot-unsafe/">http://mishadoff.com/blog/java-magic-part-4-sun-dot-misc-dot-unsafe/</a></li>
<li><a target="_blank" rel="noopener" href="https://people.apache.org/~tellison/classlib_doc/html/classjava_1_1util_1_1concurrent_1_1Executors.html">https://people.apache.org/~tellison/classlib_doc/html/classjava_1_1util_1_1concurrent_1_1Executors.html</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/370381079">https://zhuanlan.zhihu.com/p/370381079</a></li>
</ol>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%B9%B6%E5%8F%91%E7%9B%B8%E5%85%B3/" class="category-chain-item">并发相关</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/JUC/">#JUC</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>并发笔记- 并发工具之JUC包</div>
      <div>https://mikeygithub.github.io/2022/04/27/yuque/nmh349/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Mikey</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年4月27日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/05/05/yuque/ydbsrc/" title="学习笔记- Garbage Collector 垃圾收集器">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">学习笔记- Garbage Collector 垃圾收集器</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/04/25/yuque/ygs4dc/" title="算法篇-Reservoir Sampling 蓄水池抽样">
                        <span class="hidden-mobile">算法篇-Reservoir Sampling 蓄水池抽样</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'mikeygithub/commit-utterance');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  





  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.13.10/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});
  });
</script>




  <!-- Custom -->
  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" lazyload class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       Copyright © 麦奇 Powered by <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> and <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> core on github page 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      桂ICP备2020009931号-1
    </a>
  </span>
  
    
      <span>
        <a
          href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=2020009931"
          rel="nofollow noopener"
          class="beian-police"
          target="_blank"
        >
          
            <span style="visibility: hidden; width: 0">|</span>
            <img src="/img/police_beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
          
          <span>桂公网安备2020009931号</span>
        </a>
      </span>
    
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?74301a15e5497361e93588eeee69f4b2";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  
    <!-- Google Analytics -->
    <script defer>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript('https://www.google-analytics.com/analytics.js', function() {
          window.ga = window.ga || function() { (ga.q = ga.q || []).push(arguments) };
          ga.l = +new Date;
          ga('create', 'G-NCN3Z5PSLJ', 'auto');
          ga('send', 'pageview');
        });
      }
    </script>
  

  

  

  

  

  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        MathJax = {
          tex    : {
            inlineMath: { '[+]': [['$', '$']] }
          },
          loader : {
            load: ['ui/lazy']
          },
          options: {
            renderActions: {
              findScript    : [10, doc => {
                document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                  const display = !!node.type.match(/; *mode=display/);
                  const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                  const text = document.createTextNode('');
                  node.parentNode.replaceChild(text, node);
                  math.start = { node: text, delim: '', n: 0 };
                  math.end = { node: text, delim: '', n: 0 };
                  doc.math.push(math);
                });
              }, '', false],
              insertedScript: [200, () => {
                document.querySelectorAll('mjx-container').forEach(node => {
                  let target = node.parentNode;
                  if (target.nodeName.toLowerCase() === 'li') {
                    target.parentNode.classList.add('has-jax');
                  }
                });
              }, '', false]
            }
          }
        };
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.0/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
