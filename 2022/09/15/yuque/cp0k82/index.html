

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <meta name="referrer" content="no-referrer"/>
  <link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/favicon.png">
  <link rel="icon" href="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Mikey">
  <meta name="keywords" content="">
  
    <meta name="description" content="目录 第六章 I&#x2F;O复用I&#x2F;O复用使得程序同时监听多个文件描述符 通常网络程序在以下情况需要使用到I&#x2F;O复用  客户端程序（用户进程）要同时处理多个socket 客户端程序要同时处理用户输入和网络连接 TCP服务要同时处理监听socket和连接socket（这是I&#x2F;O复用最多的场景） 服务器需要同时处理TCP请求和UDP请求 服务器要同时监听多个端口，或者处理多种服务   Linux下实现I&#x2F;O">
<meta property="og:type" content="article">
<meta property="og:title" content="网络编程-Linux高性能服务器编程">
<meta property="og:url" content="https://mikeygithub.github.io/2022/09/15/yuque/cp0k82/index.html">
<meta property="og:site_name" content="麦奇">
<meta property="og:description" content="目录 第六章 I&#x2F;O复用I&#x2F;O复用使得程序同时监听多个文件描述符 通常网络程序在以下情况需要使用到I&#x2F;O复用  客户端程序（用户进程）要同时处理多个socket 客户端程序要同时处理用户输入和网络连接 TCP服务要同时处理监听socket和连接socket（这是I&#x2F;O复用最多的场景） 服务器需要同时处理TCP请求和UDP请求 服务器要同时监听多个端口，或者处理多种服务   Linux下实现I&#x2F;O">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/2630542/1659328094565-f22049e3-df22-474a-9aa2-f3ecb8d2c13e.png">
<meta property="article:published_time" content="2022-09-15T09:24:22.000Z">
<meta property="article:modified_time" content="2023-08-15T13:12:34.698Z">
<meta property="article:author" content="Mikey">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2022/png/2630542/1659328094565-f22049e3-df22-474a-9aa2-f3ecb8d2c13e.png">
  
  
<!--    <meta name="referrer" content="no-referrer-when-downgrade">-->
  
  
  <title>网络编程-Linux高性能服务器编程 - 麦奇</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"mikeygithub.github.io","root":"/","version":"1.9.1","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":200}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"74301a15e5497361e93588eeee69f4b2","google":"G-NCN3Z5PSLJ","gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="麦奇" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>麦奇</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/photo/">
                <i class="iconfont icon-image"></i>
                照片
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/music/">
                <i class="iconfont icon-music"></i>
                音乐
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/atom.xml">
                <i class="iconfont icon-rss"></i>
                RSS
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="网络编程-Linux高性能服务器编程"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Mikey
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-09-15 17:24" pubdate>
          2022年9月15日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          58k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          484 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">网络编程-Linux高性能服务器编程</h1>
            
            <div class="markdown-body">
              
              <p><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1659328094565-f22049e3-df22-474a-9aa2-f3ecb8d2c13e.png#averageHue=%23f1f5f4&clientId=u1936cc43-d136-4&errorMessage=unknown%20error&from=paste&height=406&id=u7c457c94&originHeight=406&originWidth=982&originalType=binary&ratio=1&rotation=0&showTitle=false&size=399165&status=error&style=none&taskId=u19a14553-68a0-4aa4-82d7-3970dc92ec6&title=&width=982" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/2630542/1664337000918-bc6e6f73-2fbb-4b3c-87a2-6339a2e9e266.jpeg" srcset="/img/loading.gif" lazyload></p>
<h1 id="第六章-I-O复用"><a href="#第六章-I-O复用" class="headerlink" title="第六章 I/O复用"></a>第六章 I/O复用</h1><p>I/O复用使得程序同时监听多个文件描述符</p>
<p>通常网络程序在以下情况需要使用到I/O复用</p>
<ul>
<li>客户端程序（用户进程）要同时处理多个socket</li>
<li>客户端程序要同时处理用户输入和网络连接</li>
<li>TCP服务要同时处理监听socket和连接socket（这是I/O复用最多的场景）</li>
<li>服务器需要同时处理TCP请求和UDP请求</li>
<li>服务器要同时监听多个端口，或者处理多种服务</li>
</ul>
<blockquote>
<p>Linux下实现I/O复用的系统调用主要有select、poll和epoll</p>
</blockquote>
<h2 id="select系统调用"><a href="#select系统调用" class="headerlink" title="select系统调用"></a>select系统调用</h2><p>select系统调用的用途是：在一段时间内，监听用户感兴趣的文件描述符上的可读、可写和异常事件。</p>
<h3 id="代码流程"><a href="#代码流程" class="headerlink" title="代码流程"></a>代码流程</h3><h4 id="1-系统调用开始"><a href="#1-系统调用开始" class="headerlink" title="1.系统调用开始"></a>1.系统调用开始</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 代码基于linux5-19-RC8 linux/fs/select.c</span><br><span class="hljs-comment">// 系统调用别名</span><br>SYSCALL_DEFINE5(select, <span class="hljs-type">int</span>, n, fd_set __user *, inp, fd_set __user *, outp,fd_set __user *, <span class="hljs-built_in">exp</span>, <span class="hljs-keyword">struct</span> __kernel_old_timeval __user *, tvp)&#123;<br>	<span class="hljs-keyword">return</span> kern_select(n, inp, outp, <span class="hljs-built_in">exp</span>, tvp);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">undef</span> __FD_SETSIZE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __FD_SETSIZE	1024 <span class="hljs-comment">//fd_set最大支持1024个描述符</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> fds_bits[__FD_SETSIZE / (<span class="hljs-number">8</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>))];<br>&#125; __kernel_fd_set;<br><br><span class="hljs-comment">//linux/types.h</span><br><span class="hljs-keyword">typedef</span> __kernel_fd_set		fd_set;<br><br></code></pre></td></tr></table></figure>

<h4 id="2-调用kern-select函数执行"><a href="#2-调用kern-select函数执行" class="headerlink" title="2.调用kern_select函数执行"></a>2.调用kern_select函数执行</h4><blockquote>
<p>判断是否是带有超时时间如果带有则需要复制到内核空间</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * select调用入口</span><br><span class="hljs-comment"> * @param n 指定被监听文件描述符的总数</span><br><span class="hljs-comment"> * @param __user 用户空间宏定义 表示后面的指针是用户空间的数据</span><br><span class="hljs-comment"> * @param inp 读描述符集指针</span><br><span class="hljs-comment"> * @param outp 写描述符集指针</span><br><span class="hljs-comment"> * @param exp 异常描述符集指针</span><br><span class="hljs-comment"> * @param tvp 超时时间指针</span><br><span class="hljs-comment"> * @return 返回可以操作的文件描述符数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kern_select</span><span class="hljs-params">(<span class="hljs-type">int</span> n, fd_set __user *inp, fd_set __user *outp, fd_set __user *<span class="hljs-built_in">exp</span>, <span class="hljs-keyword">struct</span> __kernel_old_timeval __user *tvp)</span>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec64</span> <span class="hljs-title">end_time</span>, *<span class="hljs-title">to</span> =</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//超时结构体</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">kernel_old_timeval</span> <span class="hljs-title">tv</span>;</span><span class="hljs-comment">//旧版本超时结构体</span><br>	<span class="hljs-type">int</span> ret;<br>	<span class="hljs-comment">//如果是带有超时调用</span><br>	<span class="hljs-keyword">if</span> (tvp) &#123;<br>		<span class="hljs-comment">//将超时参数从用户空间的数据拷贝到内核空间</span><br>		<span class="hljs-keyword">if</span> (copy_from_user(&amp;tv, tvp, <span class="hljs-keyword">sizeof</span>(tv)))<span class="hljs-keyword">return</span> -EFAULT;<br>		<span class="hljs-comment">//将超时时间设置给end_time变量</span><br>		to = &amp;end_time;<br>		<span class="hljs-keyword">if</span> (poll_select_set_timeout(to,tv.tv_sec + (tv.tv_usec / USEC_PER_SEC),(tv.tv_usec % USEC_PER_SEC) * NSEC_PER_USEC))<span class="hljs-keyword">return</span> -EINVAL;<br>	&#125;<br>	<span class="hljs-comment">//（主线）执行select调用</span><br>	ret = core_sys_select(n, inp, outp, <span class="hljs-built_in">exp</span>, to);<br>	<span class="hljs-comment">//将剩余时间写回</span><br>	<span class="hljs-keyword">return</span> poll_select_finish(&amp;end_time, tvp, PT_TIMEVAL, ret);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-调用core-sys-select执行"><a href="#3-调用core-sys-select执行" class="headerlink" title="3.调用core_sys_select执行"></a>3.调用core_sys_select执行</h4><blockquote>
<p>分配位图内存</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 核心系统调用select</span><br><span class="hljs-comment">* @param n 指定被监听文件描述符的总数</span><br><span class="hljs-comment">* @param __user 用户空间宏定义 表示后面的指针是用户空间的数据</span><br><span class="hljs-comment">* @param inp 读描述符集指针</span><br><span class="hljs-comment">* @param outp 写描述符集指针</span><br><span class="hljs-comment">* @param exp 异常描述符集指针</span><br><span class="hljs-comment">* @param 超时时间指针（已复制到内核空间）</span><br><span class="hljs-comment">* @return 返回可以操作的文件描述符数</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">core_sys_select</span><span class="hljs-params">(<span class="hljs-type">int</span> n, fd_set __user *inp, fd_set __user *outp,fd_set __user *<span class="hljs-built_in">exp</span>, <span class="hljs-keyword">struct</span> timespec64 *end_time)</span>&#123;<br>	fd_set_bits fds;<span class="hljs-comment">//文件描述符集位图（结构体看3.1）</span><br>	<span class="hljs-type">void</span> *bits;<br>	<span class="hljs-type">int</span> ret, max_fds;<span class="hljs-comment">//最大文件描述符</span><br>	<span class="hljs-type">size_t</span> size, alloc_size;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fdtable</span> *<span class="hljs-title">fdt</span>;</span><span class="hljs-comment">//文件描述符表</span><br>	<span class="hljs-comment">/* Allocate small arguments on the stack to save memory and be faster */</span><br>	<span class="hljs-comment">//在栈上分配一段内存</span><br>	<span class="hljs-type">long</span> stack_fds[SELECT_STACK_ALLOC/<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>)];<br>	ret = -EINVAL;<br>	<span class="hljs-comment">//参数验证小于0直接返回</span><br>	<span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">goto</span> out_nofds;<br>	<span class="hljs-comment">/* max_fds can increase, so grab it once to avoid race */</span><br>	<span class="hljs-comment">//获得当前进程打开的文件 fd 表，获取最大的 fd</span><br>	rcu_read_lock();<br>    <span class="hljs-comment">//读取文件描述符表</span><br>	fdt = files_fdtable(current-&gt;files);<br>    <span class="hljs-comment">//从files结构中获取最大值（当前进程能够处理的最大文件数目）</span><br>	max_fds = fdt-&gt;max_fds;<br>    <span class="hljs-comment">//释放rcu锁</span><br>	rcu_read_unlock();<br>	<span class="hljs-comment">//防止n超过最大的fds</span><br>	<span class="hljs-keyword">if</span> (n &gt; max_fds)n = max_fds;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * We need 6 bitmaps (in/out/ex for both incoming and outgoing),</span><br><span class="hljs-comment">	 * since we used fdset we need to allocate memory in units of</span><br><span class="hljs-comment">	 * long-words. </span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">//根据传入的需要监控的fd数量获取其需要分配的字节大小</span><br>	size = FDS_BYTES(n);<br>	bits = stack_fds;<br>	<span class="hljs-comment">/* 如果栈上的内存太小，那么就在堆上重新分配内存</span><br><span class="hljs-comment">     * 为什么是除以6呢？</span><br><span class="hljs-comment">     * 因为每个文件描述符要占6个bit（输入：可读，可写，异常；输出结果：可读，可写，异常）*/</span><br>	<span class="hljs-keyword">if</span> (size &gt; <span class="hljs-keyword">sizeof</span>(stack_fds) / <span class="hljs-number">6</span>) &#123;<br>		<span class="hljs-comment">/* Not enough space in on-stack array; must use kmalloc */</span><br>		ret = -ENOMEM;<br>		<span class="hljs-keyword">if</span> (size &gt; (SIZE_MAX / <span class="hljs-number">6</span>))<span class="hljs-keyword">goto</span> out_nofds;<br>		alloc_size = <span class="hljs-number">6</span> * size;<br>		bits = kvmalloc(alloc_size, GFP_KERNEL);<span class="hljs-comment">//分配虚拟内存</span><br>		<span class="hljs-keyword">if</span> (!bits)<span class="hljs-keyword">goto</span> out_nofds;<span class="hljs-comment">//分配失败直接结束</span><br>	&#125;<br>	<span class="hljs-comment">//设置好bitmap对应的内存地址</span><br>	fds.in      = bits;<span class="hljs-comment">//可读</span><br>	fds.out     = bits +   size;<span class="hljs-comment">//可写</span><br>	fds.ex      = bits + <span class="hljs-number">2</span>*size;<span class="hljs-comment">//异常</span><br>	fds.res_in  = bits + <span class="hljs-number">3</span>*size;<span class="hljs-comment">//返回结果，可读</span><br>	fds.res_out = bits + <span class="hljs-number">4</span>*size;<span class="hljs-comment">//返回结果，可写</span><br>	fds.res_ex  = bits + <span class="hljs-number">5</span>*size;<span class="hljs-comment">//返回结果，异常</span><br>	<span class="hljs-comment">//将fd从用户空间（用户进程）拷贝到内核空间</span><br>	<span class="hljs-keyword">if</span> ((ret = get_fd_set(n, inp, fds.in)) ||(ret = get_fd_set(n, outp, fds.out)) ||(ret = get_fd_set(n, <span class="hljs-built_in">exp</span>, fds.ex)))<span class="hljs-keyword">goto</span> out;<br>	<span class="hljs-comment">//清空返回结果的文件描述符集</span><br>	zero_fd_set(n, fds.res_in);<br>	zero_fd_set(n, fds.res_out);<br>	zero_fd_set(n, fds.res_ex);<br>	<span class="hljs-comment">//执行select（主线）</span><br>	ret = do_select(n, &amp;fds, end_time);<br>    <span class="hljs-comment">//错误结束</span><br>	<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">goto</span> out;<br>    <span class="hljs-comment">//超时结束</span><br>	<span class="hljs-keyword">if</span> (!ret) &#123;<br>		ret = -ERESTARTNOHAND;<br>        <span class="hljs-comment">// 检测到有信号则系统调用退出，返回用户空间执行信号处理函数</span><br>		<span class="hljs-keyword">if</span> (signal_pending(current))<span class="hljs-keyword">goto</span> out;<br>		ret = <span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//将fd拷贝到用户空间（用户进程）</span><br>	<span class="hljs-keyword">if</span> (set_fd_set(n, inp, fds.res_in) ||set_fd_set(n, outp, fds.res_out) ||set_fd_set(n, <span class="hljs-built_in">exp</span>, fds.res_ex))ret = -EFAULT;<br><br>out:<br>    <span class="hljs-comment">//如果是堆内存需要主动释放</span><br>	<span class="hljs-keyword">if</span> (bits != stack_fds)kvfree(bits);<span class="hljs-comment">//释放堆内存</span><br>out_nofds:<br>	<span class="hljs-keyword">return</span> ret;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="3-1结构体-fd-set-bits"><a href="#3-1结构体-fd-set-bits" class="headerlink" title="3.1结构体 fd_set_bits"></a>3.1结构体 fd_set_bits</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-comment">//指针都是用来指向描述符集合</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *in, *out, *ex;<span class="hljs-comment">//输入的文件描述符集事件</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *res_in, *res_out, *res_ex;<span class="hljs-comment">//响应的文件描述符集事件</span><br>&#125; fd_set_bits;<br></code></pre></td></tr></table></figure>

<h4 id="3-2结构体-fdtable文件描述符表"><a href="#3-2结构体-fdtable文件描述符表" class="headerlink" title="3.2结构体 fdtable文件描述符表"></a>3.2结构体 fdtable文件描述符表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fdtable</span> &#123;</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_fds;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> __<span class="hljs-title">rcu</span> **<span class="hljs-title">fd</span>;</span>      <span class="hljs-comment">/* current fd array */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *close_on_exec;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *open_fds;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *full_fds_bits;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="4-调用-do-select-方法"><a href="#4-调用-do-select-方法" class="headerlink" title="4.调用 do_select 方法"></a>4.调用 do_select 方法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * select 的具体实现</span><br><span class="hljs-comment"> * @param n 指定被监听文件描述符的总数</span><br><span class="hljs-comment"> * @param fds 文件描述符位图</span><br><span class="hljs-comment"> * @param end_time 超时时间</span><br><span class="hljs-comment"> * @return</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">do_select</span><span class="hljs-params">(<span class="hljs-type">int</span> n, fd_set_bits *fds, <span class="hljs-keyword">struct</span> timespec64 *end_time)</span>&#123;<br>	<span class="hljs-type">ktime_t</span> expire, *to = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_wqueues</span> <span class="hljs-title">table</span>;</span><span class="hljs-comment">//定义一个poll_wqueues变量</span><br>	poll_table *wait;<br>	<span class="hljs-type">int</span> retval, i, timed_out = <span class="hljs-number">0</span>;<span class="hljs-comment">//超时标识</span><br>	u64 slack = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">__poll_t</span> busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : <span class="hljs-number">0</span>;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> busy_start = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-comment">//Read Copy Update 锁机制</span><br>	rcu_read_lock();<br>	<span class="hljs-comment">//根据设置的fd位图fds，检查确认所有位置对应的fd确实被打开了，并返回最大的fd</span><br>	retval = max_select_fd(n, fds);<br>	<span class="hljs-comment">//释放锁</span><br>	rcu_read_unlock();<br>	<span class="hljs-comment">//如果为负值直接返回</span><br>	<span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> retval;<br>	n = retval;<br>	<span class="hljs-comment">//初始化 poll_wqueues （重点）</span><br>	<span class="hljs-comment">//poll_wqueues.poll_table.qproc函数指针初始化，该函数是驱动程序中poll函数（fop-&gt;poll）实现中必须要调用的poll_wait()中使用的函数。</span><br>	poll_initwait(&amp;table);<br>	wait = &amp;table.pt;<span class="hljs-comment">//poll_table封装在poll_wqueues中</span><br>	<span class="hljs-comment">//判断是否超时</span><br>	<span class="hljs-keyword">if</span> (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) &#123;<br>		wait-&gt;_qproc = <span class="hljs-literal">NULL</span>;<br>		timed_out = <span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-comment">//重新估算时间</span><br>	<span class="hljs-keyword">if</span> (end_time &amp;&amp; !timed_out)slack = select_estimate_accuracy(end_time);<br><br>	retval = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (;;) &#123;<span class="hljs-comment">//死循环</span><br>		<span class="hljs-comment">//六种类型指针</span><br>		<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *rinp, *routp, *rexp, *inp, *outp, *<span class="hljs-built_in">exp</span>;<br>		<span class="hljs-type">bool</span> can_busy_loop = <span class="hljs-literal">false</span>;<br>		<span class="hljs-comment">//给上面指针赋值，指向fds对应的类型</span><br>		inp = fds-&gt;in; outp = fds-&gt;out; <span class="hljs-built_in">exp</span> = fds-&gt;ex;<br>		rinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex;<br>		<span class="hljs-comment">//遍历所有的fd（n个文件描述符）</span><br>		<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; ++rinp, ++routp, ++rexp) &#123;<br>			<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> in, out, ex, all_bits, bit = <span class="hljs-number">1</span>, j;<br>			<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> res_in = <span class="hljs-number">0</span>, res_out = <span class="hljs-number">0</span>, res_ex = <span class="hljs-number">0</span>;<br>			<span class="hljs-type">__poll_t</span> mask;<br>			<span class="hljs-comment">// 先取出当前循环周期中的32（设long占32位）个文件描述符对应的bitmaps</span><br>			in = *inp++; out = *outp++; ex = *<span class="hljs-built_in">exp</span>++;<br>			all_bits = in | out | ex;<span class="hljs-comment">//按位或，组合所有类型</span><br>			<span class="hljs-keyword">if</span> (all_bits == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//当前位图块没有需要处理的文件描述符(关心的fd)，则结束本块fd，调到下一个fd位图块</span><br>				i += BITS_PER_LONG;<span class="hljs-comment">//BITS_PER_LONG 位图宏定义</span><br>				<span class="hljs-keyword">continue</span>;<br>			&#125;<br>			<span class="hljs-comment">//遍历当前所有位</span><br>			<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; BITS_PER_LONG; ++j, ++i, bit &lt;&lt;= <span class="hljs-number">1</span>) &#123;<br>				<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fd</span> <span class="hljs-title">f</span>;</span><br>				<span class="hljs-comment">//struct fd &#123;</span><br>				<span class="hljs-comment">//	struct file *file;//文件指针</span><br>				<span class="hljs-comment">//	unsigned int flags;</span><br>				<span class="hljs-comment">//&#125;;</span><br>				<span class="hljs-comment">//i超出n范围直接跳出</span><br>				<span class="hljs-keyword">if</span> (i &gt;= n)<span class="hljs-keyword">break</span>;<br>				<span class="hljs-comment">//跳过不关心的bit</span><br>				<span class="hljs-keyword">if</span> (!(bit &amp; all_bits))<span class="hljs-keyword">continue</span>;<br>				mask = EPOLLNVAL;<br>				<span class="hljs-comment">//获取当前文件描述符的file结构指针</span><br>				f = fdget(i);<br>				<span class="hljs-comment">//因为没有rdlock加锁，因此当前进程中描述符i对应的文件可能已经 被异步关闭。这就是为什么需要判断file是否为空的原因</span><br>				<span class="hljs-comment">//（重点主线）如果文件存在</span><br>				<span class="hljs-keyword">if</span> (f.file) &#123;<br>					<span class="hljs-comment">// 设置poll_table智能柜想要监听的事件</span><br>					wait_key_set(wait, in, out, bit,busy_flag);<br>					<span class="hljs-comment">//（重点）调用文件的poll操作，返回准备好的事件</span><br>					mask = vfs_poll(f.file, wait);<br>					<span class="hljs-comment">// 关闭文件监听</span><br>					fdput(f);<br>				&#125;<br>				<span class="hljs-comment">/* events验证，其中retval表示就绪的资源数 */</span><br>				<span class="hljs-comment">//可读</span><br>				<span class="hljs-keyword">if</span> ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) &#123;<br>					res_in |= bit;<span class="hljs-comment">//设置响应</span><br>					retval++;<br>					wait-&gt;_qproc = <span class="hljs-literal">NULL</span>;<br>				&#125;<br>				<span class="hljs-comment">//可写</span><br>				<span class="hljs-keyword">if</span> ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; bit)) &#123;<br>					res_out |= bit;<br>					retval++;<br>					wait-&gt;_qproc = <span class="hljs-literal">NULL</span>;<br>				&#125;<br>				<span class="hljs-comment">//异常</span><br>				<span class="hljs-keyword">if</span> ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; bit)) &#123;<br>					res_ex |= bit;<br>					retval++;<br>					wait-&gt;_qproc = <span class="hljs-literal">NULL</span>;<br>				&#125;<br>				<span class="hljs-comment">/* got something, stop busy polling */</span><br>				<span class="hljs-keyword">if</span> (retval) &#123;<br>					can_busy_loop = <span class="hljs-literal">false</span>;<br>					busy_flag = <span class="hljs-number">0</span>;<br>				<span class="hljs-comment">/*</span><br><span class="hljs-comment">				 * only remember a returned</span><br><span class="hljs-comment">				 * POLL_BUSY_LOOP if we asked for it</span><br><span class="hljs-comment">				 */</span><br>				&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (busy_flag &amp; mask)can_busy_loop = <span class="hljs-literal">true</span>;<br><br>			&#125;<br>			<span class="hljs-comment">/* 写出结果，注意写出的目的地是传进来的fd_set_bits */</span><br>			<span class="hljs-keyword">if</span> (res_in)*rinp = res_in;<br>			<span class="hljs-keyword">if</span> (res_out)*routp = res_out;<br>			<span class="hljs-keyword">if</span> (res_ex)*rexp = res_ex;<br>			<span class="hljs-comment">//主动让出cpu等待下次循环</span><br>			cond_resched();<br>		&#125;<span class="hljs-comment">//遍历完n个fd</span><br>		wait-&gt;_qproc = <span class="hljs-literal">NULL</span>;<br>		<span class="hljs-comment">//如果当前这轮循环有准备好的事件|超时|（中断）检测到有信号则系统调用退出，返回用户空间执行信号处理函数 跳出死循环</span><br>		<span class="hljs-keyword">if</span> (retval || timed_out || signal_pending(current))<span class="hljs-keyword">break</span>;<br>		<span class="hljs-comment">//存在错误</span><br>		<span class="hljs-keyword">if</span> (table.error) &#123;<br>			retval = table.error;<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br><br>		<span class="hljs-comment">/* only if found POLL_BUSY_LOOP sockets &amp;&amp; not out of time */</span><br>		<span class="hljs-keyword">if</span> (can_busy_loop &amp;&amp; !need_resched()) &#123;<br>			<span class="hljs-keyword">if</span> (!busy_start) &#123;<br>				busy_start = busy_loop_current_time();<br>				<span class="hljs-keyword">continue</span>;<br>			&#125;<br>			<span class="hljs-keyword">if</span> (!busy_loop_timeout(busy_start))<span class="hljs-keyword">continue</span>;<br>		&#125;<br>		busy_flag = <span class="hljs-number">0</span>;<br><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * If this is the first loop and we have a timeout</span><br><span class="hljs-comment">		 * given, then we convert to ktime_t and set the to</span><br><span class="hljs-comment">		 * pointer to the expiry value.</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (end_time &amp;&amp; !to) &#123;<br>			expire = timespec64_to_ktime(*end_time);<br>			to = &amp;expire;<br>		&#125;<br>		<span class="hljs-comment">/* 能够到达这一步就说明没有发生就绪、中断以及超时 */</span><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * 判断poll_wqueues是否已触发，如果还没有触发，那就设置当前运行状态为可中断阻塞并进行睡眠，等待被唤醒...</span><br><span class="hljs-comment">		 * 被唤醒之后重新进行迭代，获取资源就绪情况...</span><br><span class="hljs-comment">		 * 在向资源注册监听与判断poll_wqueues是否已触发这段时间内，可能资源异步就绪了，如果没有触发标志，那么可能就</span><br><span class="hljs-comment">		 * 会丢失资源就绪这个事件，可能导致select()永久沉睡...</span><br><span class="hljs-comment">		 * 这就是为什么需要poll_wqueues.triggered字段的原因...</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (!poll_schedule_timeout(&amp;table, TASK_INTERRUPTIBLE,to, slack))timed_out = <span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">     	 * 1. 卸载安装到资源监听队列上的poll_table_entry</span><br><span class="hljs-comment">     	 * 2. 释放poll_wqueues占用的资源</span><br><span class="hljs-comment">     	 */</span><br>	poll_freewait(&amp;table);<br>	<span class="hljs-comment">//返回就绪的资源数</span><br>	<span class="hljs-keyword">return</span> retval;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-1-结构体"><a href="#4-1-结构体" class="headerlink" title="4.1 结构体"></a>4.1 结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_wqueues</span> &#123;</span><br>	poll_table pt;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_table_page</span> *<span class="hljs-title">table</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">polling_task</span>;</span><span class="hljs-comment">//保存当前调用select的用户进程struct task_struct结构体</span><br>	<span class="hljs-type">int</span> triggered;<span class="hljs-comment">//当前用户进程被唤醒后置成1，以免该进程接着进睡眠</span><br>	<span class="hljs-type">int</span> error;<span class="hljs-comment">//错误码</span><br>	<span class="hljs-type">int</span> inline_index;<span class="hljs-comment">//数组inline_entries的引用下标</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_table_entry</span> <span class="hljs-title">inline_entries</span>[<span class="hljs-title">N_INLINE_POLL_ENTRIES</span>];</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_table_page</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_table_page</span> * <span class="hljs-title">next</span>;</span><span class="hljs-comment">//指向下一个申请的物理页</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_table_entry</span> * <span class="hljs-title">entry</span>;</span><span class="hljs-comment">//指向entries[]中首个待分配(空的) poll_table_entry地址</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_table_entry</span> <span class="hljs-title">entries</span>[];</span><span class="hljs-comment">//该page页后面剩余的空间都是待分配的poll_table_entry结构体</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_table_struct</span> &#123;</span><br>	poll_queue_proc _qproc;<br>	<span class="hljs-type">__poll_t</span> _key;<br>&#125; poll_table;<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_table_entry</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">filp</span>;</span><span class="hljs-comment">//指向特定fd对应的file结构体;</span><br>	<span class="hljs-type">__poll_t</span> key;<span class="hljs-comment">//等待特定fd对应硬件设备的事件掩码，如POLLIN、 POLLOUT、POLLERR</span><br>	<span class="hljs-type">wait_queue_entry_t</span> wait;<span class="hljs-comment">//代表调用select()的应用进程，等待在fd对应设备的特定事件 (读或者写)的等待队列头上，的等待队列项</span><br>	<span class="hljs-type">wait_queue_head_t</span> *wait_address;<span class="hljs-comment">//设备驱动程序中特定事件的等待队列头(该fd执行fop-&gt;poll，需要等待时在哪等，所以叫等待地址)</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="4-2-调用-poll-initwait-进行初始化"><a href="#4-2-调用-poll-initwait-进行初始化" class="headerlink" title="4.2 调用 poll_initwait 进行初始化"></a>4.2 调用 poll_initwait 进行初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">poll_initwait</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> poll_wqueues *pwq)</span>&#123;<br>	init_poll_funcptr(&amp;pwq-&gt;pt, __pollwait);<br>	pwq-&gt;polling_task = current;<br>	pwq-&gt;triggered = <span class="hljs-number">0</span>;<br>	pwq-&gt;error = <span class="hljs-number">0</span>;<br>	pwq-&gt;table = <span class="hljs-literal">NULL</span>;<br>	pwq-&gt;inline_index = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-4-调用-init-poll-funcptr-初始化开启监听事件"><a href="#4-4-调用-init-poll-funcptr-初始化开启监听事件" class="headerlink" title="4.4 调用 init_poll_funcptr 初始化开启监听事件"></a>4.4 调用 init_poll_funcptr 初始化开启监听事件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">init_poll_funcptr</span><span class="hljs-params">(poll_table *pt, poll_queue_proc qproc)</span>&#123;<br>	pt-&gt;_qproc = qproc;<br>	pt-&gt;_key   = ~(<span class="hljs-type">__poll_t</span>)<span class="hljs-number">0</span>;<span class="hljs-comment">//缺省开启全部事件监听</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-5-调用wait-key-set设置要监听的事件"><a href="#4-5-调用wait-key-set设置要监听的事件" class="headerlink" title="4.5 调用wait_key_set设置要监听的事件"></a>4.5 调用wait_key_set设置要监听的事件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLLIN_SET (EPOLLRDNORM | EPOLLRDBAND | EPOLLIN | EPOLLHUP | EPOLLERR | EPOLLNVAL)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLLOUT_SET (EPOLLWRBAND | EPOLLWRNORM | EPOLLOUT | EPOLLERR | EPOLLNVAL)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLLEX_SET (EPOLLPRI | EPOLLNVAL)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置 poll_table 要监听的事件</span><br><span class="hljs-comment"> * @param wait</span><br><span class="hljs-comment"> * @param in</span><br><span class="hljs-comment"> * @param out</span><br><span class="hljs-comment"> * @param bit</span><br><span class="hljs-comment"> * @param ll_flag</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">wait_key_set</span><span class="hljs-params">(poll_table *wait, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> in,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> out, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> bit,<span class="hljs-type">__poll_t</span> ll_flag)</span> &#123;<br>	wait-&gt;_key = POLLEX_SET | ll_flag;<br>	<span class="hljs-keyword">if</span> (in &amp; bit)wait-&gt;_key |= POLLIN_SET;<span class="hljs-comment">//in事件</span><br>	<span class="hljs-keyword">if</span> (out &amp; bit)wait-&gt;_key |= POLLOUT_SET;<span class="hljs-comment">//out事件</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="4-6-调用-vfs-poll-返回准备好的事件"><a href="#4-6-调用-vfs-poll-返回准备好的事件" class="headerlink" title="4.6 调用 vfs_poll 返回准备好的事件"></a>4.6 调用 vfs_poll 返回准备好的事件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用文件操作的poll方法</span><br><span class="hljs-comment"> * @param file 文件</span><br><span class="hljs-comment"> * @param pt poll_table_struct 结构体指针</span><br><span class="hljs-comment"> * @return 返回准备好的事件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">__poll_t</span> <span class="hljs-title function_">vfs_poll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-keyword">struct</span> poll_table_struct *pt)</span>&#123;<br>	<span class="hljs-comment">//如果 fd 所在的文件系统的 file_operations 实现了 poll ，那么就会直接调用，如果没有，那么就会报告响应的错误码</span><br>	<span class="hljs-keyword">if</span> (unlikely(!file-&gt;f_op-&gt;poll))<span class="hljs-keyword">return</span> DEFAULT_POLLMASK;<br>	<span class="hljs-keyword">return</span> file-&gt;f_op-&gt;poll(file, pt);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-7-结构体file"><a href="#4-7-结构体file" class="headerlink" title="4.7 结构体file"></a>4.7 结构体file</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//linux-5.19-rc8/include/linux/fs.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">llist_node</span>	<span class="hljs-title">fu_llist</span>;</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> 	<span class="hljs-title">fu_rcuhead</span>;</span><br>	&#125; f_u;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">path</span>		<span class="hljs-title">f_path</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span>		*<span class="hljs-title">f_inode</span>;</span>	<span class="hljs-comment">/* cached value */</span><br>	<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span>	*<span class="hljs-title">f_op</span>;</span><span class="hljs-comment">//（主线）文件支持的操作</span><br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Protects f_ep, f_flags.</span><br><span class="hljs-comment">	 * Must not be taken from IRQ context.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">spinlock_t</span>		f_lock;<br>	<span class="hljs-type">atomic_long_t</span>		f_count;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> 		f_flags;<br>	<span class="hljs-type">fmode_t</span>			f_mode;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span>		<span class="hljs-title">f_pos_lock</span>;</span><br>	<span class="hljs-type">loff_t</span>			f_pos;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fown_struct</span>	<span class="hljs-title">f_owner</span>;</span><br>	<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span>	*<span class="hljs-title">f_cred</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_ra_state</span>	<span class="hljs-title">f_ra</span>;</span><br><br>	u64			f_version;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SECURITY</span><br>	<span class="hljs-type">void</span>			*f_security;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-comment">/* needed for tty driver, and maybe others */</span><br>	<span class="hljs-type">void</span>			*private_data;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_EPOLL</span><br>	<span class="hljs-comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_head</span>	*<span class="hljs-title">f_ep</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* #ifdef CONFIG_EPOLL */</span></span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space</span>	*<span class="hljs-title">f_mapping</span>;</span><br>	<span class="hljs-type">errseq_t</span>		f_wb_err;<br>	<span class="hljs-type">errseq_t</span>		f_sb_err; <span class="hljs-comment">/* for syncfs */</span><br>&#125; __randomize_layout<br>  __attribute__((aligned(<span class="hljs-number">4</span>)));	<span class="hljs-comment">/* lest something weird decides that 2 is OK */</span><br></code></pre></td></tr></table></figure>

<h4 id="4-8-结构体-file-operations-（4-6中调用的poll）"><a href="#4-8-结构体-file-operations-（4-6中调用的poll）" class="headerlink" title="4.8 结构体 file_operations （4.6中调用的poll）"></a>4.8 结构体 file_operations （4.6中调用的poll）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br>	<span class="hljs-type">loff_t</span> (*llseek) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">int</span>);<br>	<span class="hljs-type">ssize_t</span> (*read) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);<br>	<span class="hljs-type">ssize_t</span> (*write) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);<br>	<span class="hljs-type">ssize_t</span> (*read_iter) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-keyword">struct</span> iov_iter *);<br>	<span class="hljs-type">ssize_t</span> (*write_iter) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-keyword">struct</span> iov_iter *);<br>	<span class="hljs-type">int</span> (*iopoll)(<span class="hljs-keyword">struct</span> kiocb *kiocb, <span class="hljs-keyword">struct</span> io_comp_batch *,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags);<br>	<span class="hljs-type">int</span> (*iterate) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> dir_context *);<br>	<span class="hljs-type">int</span> (*iterate_shared) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> dir_context *);<br>	<span class="hljs-type">__poll_t</span> (*poll) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> poll_table_struct *);<span class="hljs-comment">//（主线）调用文件的poll方法操作</span><br>	<span class="hljs-type">long</span> (*unlocked_ioctl) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<br>	<span class="hljs-type">long</span> (*compat_ioctl) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<br>	<span class="hljs-type">int</span> (*mmap) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> vm_area_struct *);<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mmap_supported_flags;<br>	<span class="hljs-type">int</span> (*open) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);<br>	<span class="hljs-type">int</span> (*flush) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">fl_owner_t</span> id);<br>	<span class="hljs-type">int</span> (*release) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);<br>	<span class="hljs-type">int</span> (*fsync) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">loff_t</span>, <span class="hljs-type">int</span> datasync);<br>	<span class="hljs-type">int</span> (*fasync) (<span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>);<br>	<span class="hljs-type">int</span> (*lock) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file_lock *);<br>	<span class="hljs-type">ssize_t</span> (*sendpage) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> page *, <span class="hljs-type">int</span>, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *, <span class="hljs-type">int</span>);<br>	<span class="hljs-type">unsigned</span> <span class="hljs-title function_">long</span> <span class="hljs-params">(*get_unmapped_area)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)</span>;<br>	<span class="hljs-type">int</span> (*check_flags)(<span class="hljs-type">int</span>);<br>	<span class="hljs-type">int</span> (*flock) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file_lock *);<br>	<span class="hljs-type">ssize_t</span> (*splice_write)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span> *, <span class="hljs-type">size_t</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<br>	<span class="hljs-type">ssize_t</span> (*splice_read)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span> *, <span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-type">size_t</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<br>	<span class="hljs-type">int</span> (*setlease)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">long</span>, <span class="hljs-keyword">struct</span> file_lock **, <span class="hljs-type">void</span> **);<br>	<span class="hljs-type">long</span> (*fallocate)(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">int</span> mode, <span class="hljs-type">loff_t</span> offset,<span class="hljs-type">loff_t</span> len);<br>	<span class="hljs-type">void</span> (*show_fdinfo)(<span class="hljs-keyword">struct</span> seq_file *m, <span class="hljs-keyword">struct</span> file *f);<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_MMU</span><br>	<span class="hljs-type">unsigned</span> (*mmap_capabilities)(<span class="hljs-keyword">struct</span> file *);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-type">ssize_t</span> (*copy_file_range)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span>, <span class="hljs-keyword">struct</span> file *,<span class="hljs-type">loff_t</span>, <span class="hljs-type">size_t</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<br>	<span class="hljs-type">loff_t</span> (*remap_file_range)(<span class="hljs-keyword">struct</span> file *file_in, <span class="hljs-type">loff_t</span> pos_in,<span class="hljs-keyword">struct</span> file *file_out, <span class="hljs-type">loff_t</span> pos_out,<span class="hljs-type">loff_t</span> len, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> remap_flags);<br>	<span class="hljs-type">int</span> (*fadvise)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">loff_t</span>, <span class="hljs-type">int</span>);<br>	<span class="hljs-type">int</span> (*uring_cmd)(<span class="hljs-keyword">struct</span> io_uring_cmd *ioucmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> issue_flags);<br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure>

<h4 id="4-9-释放-poll-wqueues-的资源占用"><a href="#4-9-释放-poll-wqueues-的资源占用" class="headerlink" title="4.9 释放 poll_wqueues 的资源占用"></a>4.9 释放 poll_wqueues 的资源占用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放 poll_wqueues 的资源占用</span><br><span class="hljs-comment"> * @param pwq </span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">poll_freewait</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> poll_wqueues *pwq)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_table_page</span> * <span class="hljs-title">p</span> =</span> pwq-&gt;table;<br>	<span class="hljs-type">int</span> i;<br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; pwq-&gt;inline_index; i++)free_poll_entry(pwq-&gt;inline_entries + i);<br>	<span class="hljs-keyword">while</span> (p) &#123;<br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_table_entry</span> * <span class="hljs-title">entry</span>;</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_table_page</span> *<span class="hljs-title">old</span>;</span><br><br>		entry = p-&gt;entry;<br>		<span class="hljs-keyword">do</span> &#123;<br>			entry--;<br>			free_poll_entry(entry);<br>		&#125; <span class="hljs-keyword">while</span> (entry &gt; p-&gt;entries);<br>		old = p;<br>		p = p-&gt;next;<br>		free_page((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) old);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="流程图示"><a href="#流程图示" class="headerlink" title="流程图示"></a>流程图示</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/2630542/1661245514701-83285cdc-90e4-4dff-a79c-56e5e3af52cb.jpeg" srcset="/img/loading.gif" lazyload></p>
<h3 id="相关总结"><a href="#相关总结" class="headerlink" title="相关总结"></a>相关总结</h3><p>优点：</p>
<ul>
<li>用户可以在一个线程内同时处理多个socket的IO请求。同时没有多线程多进程那样耗费系统资源  </li>
<li>目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点</li>
</ul>
<p>缺点：</p>
<ul>
<li>可处理的fd集有限，默认1024个</li>
<li>采用轮询遍历每个fd位图其效率较为低下，调用处于阻塞状态</li>
<li>客户进程获取返回的数据后还需遍历fd集才知道哪些fd准备好</li>
<li>每次调用需要复制大量的句柄数据结构到内核空间，产生巨大的开销</li>
</ul>
<h2 id="poll系统调用"><a href="#poll系统调用" class="headerlink" title="poll系统调用"></a>poll系统调用</h2><blockquote>
<p>poll的代码和select在同一个文件中</p>
</blockquote>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><h4 id="1-系统调用函数"><a href="#1-系统调用函数" class="headerlink" title="1.系统调用函数"></a>1.系统调用函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 代码基于linux5-19-RC8 linux/fs/select.c</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* poll系统调用</span><br><span class="hljs-comment">* @param ufds 用户空间poll文件描述符</span><br><span class="hljs-comment">* @param nfds ufds的长度</span><br><span class="hljs-comment">* @param timeout_msecs 超时参数</span><br><span class="hljs-comment">*/</span><br>SYSCALL_DEFINE3(poll, <span class="hljs-keyword">struct</span> pollfd __user *, ufds, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, nfds,<span class="hljs-type">int</span>, timeout_msecs)&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec64</span> <span class="hljs-title">end_time</span>, *<span class="hljs-title">to</span> =</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//超时时间</span><br>    <span class="hljs-type">int</span> ret;<span class="hljs-comment">//响应结果</span><br>    <span class="hljs-keyword">if</span> (timeout_msecs &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//计算超时时间</span><br>        to = &amp;end_time;<br>        poll_select_set_timeout(to, timeout_msecs / MSEC_PER_SEC,<br>                                NSEC_PER_MSEC * (timeout_msecs % MSEC_PER_SEC));<br>    &#125;<br>    <span class="hljs-comment">//(主线)核心调用</span><br>    ret = do_sys_poll(ufds, nfds, to);<br>    <span class="hljs-comment">//错误码（系统错误）-ERESTARTNOHAND表明,被中断的系统调用</span><br>    <span class="hljs-keyword">if</span> (ret == -ERESTARTNOHAND) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">restart_block</span> *<span class="hljs-title">restart_block</span>;</span><br><br>        restart_block = &amp;current-&gt;restart_block;<br>        restart_block-&gt;poll.ufds = ufds;<br>        restart_block-&gt;poll.nfds = nfds;<br>        <span class="hljs-comment">//是否超时</span><br>        <span class="hljs-keyword">if</span> (timeout_msecs &gt;= <span class="hljs-number">0</span>) &#123;<br>            restart_block-&gt;poll.tv_sec = end_time.tv_sec;<br>            restart_block-&gt;poll.tv_nsec = end_time.tv_nsec;<br>            restart_block-&gt;poll.has_timeout = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span><br>            restart_block-&gt;poll.has_timeout = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//重启服务</span><br>        ret = set_restart_fn(restart_block, do_restart_poll);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="1-1-pollfd结构体"><a href="#1-1-pollfd结构体" class="headerlink" title="1.1 pollfd结构体"></a>1.1 pollfd结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * poll文件描述符结构体</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> &#123;</span><br>	<span class="hljs-type">int</span> fd;<span class="hljs-comment">//文件描述符</span><br>	<span class="hljs-type">short</span> <span class="hljs-type">int</span> events;<span class="hljs-comment">//关心的events</span><br>	<span class="hljs-type">short</span> <span class="hljs-type">int</span> revents;<span class="hljs-comment">//返回就绪的events</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="2-调用do-sys-poll方法"><a href="#2-调用do-sys-poll方法" class="headerlink" title="2.调用do_sys_poll方法"></a>2.调用do_sys_poll方法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * poll系统调用核心：</span><br><span class="hljs-comment"> * - 分配链表空间</span><br><span class="hljs-comment"> * - 初始化 poll_wqueues 控制块</span><br><span class="hljs-comment"> * - 调用 do_poll 方法</span><br><span class="hljs-comment"> * @param __user</span><br><span class="hljs-comment"> * @return 返回</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">do_sys_poll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pollfd __user *ufds, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nfds, <span class="hljs-keyword">struct</span> timespec64 *end_time)</span> &#123;<br>	<span class="hljs-comment">//定义一个poll调用控制块（表）</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_wqueues</span> <span class="hljs-title">table</span>;</span><br>	<span class="hljs-type">int</span> err = -EFAULT, fdcount, len;<br>	<span class="hljs-comment">/* Allocate small arguments on the stack to save memory and be</span><br><span class="hljs-comment">	   faster - use long to make sure the buffer is aligned properly</span><br><span class="hljs-comment">	   on 64 bit archs to avoid unaligned access */</span><br>	<span class="hljs-comment">//优先在栈上分配空间</span><br>	<span class="hljs-type">long</span> stack_pps[POLL_STACK_ALLOC/<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>)];<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_list</span> *<span class="hljs-title">const</span> <span class="hljs-title">head</span> =</span> (<span class="hljs-keyword">struct</span> poll_list *)stack_pps;<br> 	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_list</span> *<span class="hljs-title">walk</span> =</span> head;<br> 	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> todo = nfds;<br>	<span class="hljs-comment">//检查是否超出长度限制</span><br>	<span class="hljs-keyword">if</span> (nfds &gt; rlimit(RLIMIT_NOFILE))<span class="hljs-keyword">return</span> -EINVAL;<br>	<span class="hljs-comment">//获取分配的空间长度</span><br>	len = <span class="hljs-type">min_t</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, nfds, N_STACK_PPS);<br>	<span class="hljs-comment">//为每一个节点（pollfd）进行分配空间</span><br>	<span class="hljs-keyword">for</span> (;;) &#123;<br>		walk-&gt;next = <span class="hljs-literal">NULL</span>;<br>		walk-&gt;len = len;<br>		<span class="hljs-comment">//所需长度为0则可跳出循环</span><br>		<span class="hljs-keyword">if</span> (!len)<span class="hljs-keyword">break</span>;<br>		<span class="hljs-comment">//复制文件描述符到内核空间</span><br>		<span class="hljs-keyword">if</span> (copy_from_user(walk-&gt;entries, ufds + nfds-todo,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pollfd) * walk-&gt;len))<span class="hljs-keyword">goto</span> out_fds;<br><br>		todo -= walk-&gt;len;<br>		<span class="hljs-keyword">if</span> (!todo)<span class="hljs-keyword">break</span>;<br><br>		len = min(todo, POLLFD_PER_PAGE);<br>		<span class="hljs-comment">//在堆区分配空间</span><br>		walk = walk-&gt;next = kmalloc(struct_size(walk, entries, len),GFP_KERNEL);<br>		<span class="hljs-keyword">if</span> (!walk) &#123;<br>			err = -ENOMEM;<br>			<span class="hljs-keyword">goto</span> out_fds;<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">//初始化poll控制块</span><br>	poll_initwait(&amp;table);<br>	<span class="hljs-comment">//(主线）执行poll调用</span><br>	fdcount = do_poll(head, &amp;table, end_time);<br>	<span class="hljs-comment">//释放poll控制块</span><br>	poll_freewait(&amp;table);<br>	<span class="hljs-comment">//如果用户没有写入权限</span><br>	<span class="hljs-keyword">if</span> (!user_write_access_begin(ufds, nfds * <span class="hljs-keyword">sizeof</span>(*ufds)))<span class="hljs-keyword">goto</span> out_fds;<br><br>	<span class="hljs-keyword">for</span> (walk = head; walk; walk = walk-&gt;next) &#123;<br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> *<span class="hljs-title">fds</span> =</span> walk-&gt;entries;<br>		<span class="hljs-type">int</span> j;<br><br>		<span class="hljs-keyword">for</span> (j = walk-&gt;len; j; fds++, ufds++, j--)<br>			unsafe_put_user(fds-&gt;revents, &amp;ufds-&gt;revents, Efault);<br>  	&#125;<br>	user_write_access_end();<br><br>	err = fdcount;<br>out_fds:<br>	walk = head-&gt;next;<br>	<span class="hljs-keyword">while</span> (walk) &#123;<br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_list</span> *<span class="hljs-title">pos</span> =</span> walk;<br>		walk = walk-&gt;next;<br>		kfree(pos);<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> err;<br><br>Efault:<br>	user_write_access_end();<br>	err = -EFAULT;<br>	<span class="hljs-keyword">goto</span> out_fds;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-1调用poll-initwait-amp-table-初始化poll控制块"><a href="#2-1调用poll-initwait-amp-table-初始化poll控制块" class="headerlink" title="2.1调用poll_initwait(&amp;table)初始化poll控制块"></a>2.1调用poll_initwait(&amp;table)初始化poll控制块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 初始化poll队列</span><br><span class="hljs-comment"> * @param pwq</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">poll_initwait</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> poll_wqueues *pwq)</span> &#123;<br>	<span class="hljs-comment">//调用__pollwait初始化监听队列</span><br>	init_poll_funcptr(&amp;pwq-&gt;pt, __pollwait);<br>	pwq-&gt;polling_task = current;<span class="hljs-comment">//当前调用的进程</span><br>	pwq-&gt;triggered = <span class="hljs-number">0</span>;<span class="hljs-comment">//是否已经触发</span><br>	pwq-&gt;error = <span class="hljs-number">0</span>;<span class="hljs-comment">//是否错误</span><br>	pwq-&gt;table = <span class="hljs-literal">NULL</span>;<br>	pwq-&gt;inline_index = <span class="hljs-number">0</span>;<br>&#125;<br>EXPORT_SYMBOL(poll_initwait);<br></code></pre></td></tr></table></figure>

<h4 id="2-1-1调用-pollwait添加监听文件"><a href="#2-1-1调用-pollwait添加监听文件" class="headerlink" title=" 2.1.1调用__pollwait添加监听文件"></a> 2.1.1调用__pollwait添加监听文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Add a new entry */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将poll_table_entry挂载到资源文件的监听队列</span><br><span class="hljs-comment"> * @param filp 被监听的资源文件</span><br><span class="hljs-comment"> * @param wait_address 被监听的资源文件的等待队列头</span><br><span class="hljs-comment"> * @param p 在poll_initwait()中设置的poll_tbale</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __pollwait(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">wait_queue_head_t</span> *wait_address,poll_table *p)&#123;<br>	<span class="hljs-comment">//获取 poll_wqueues</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_wqueues</span> *<span class="hljs-title">pwq</span> =</span> container_of(p, <span class="hljs-keyword">struct</span> poll_wqueues, pt);<br>	<span class="hljs-comment">//获取 poll_table_entry</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_table_entry</span> *<span class="hljs-title">entry</span> =</span> poll_get_entry(pwq);<br>	<span class="hljs-comment">//如果获取不到直接返回</span><br>	<span class="hljs-keyword">if</span> (!entry)<span class="hljs-keyword">return</span>;<br>	<span class="hljs-comment">//增加资源文件引用计数并关联到entry的filp属性</span><br>	entry-&gt;filp = get_file(filp);<br>	<span class="hljs-comment">//保存资源文件到队列头</span><br>	entry-&gt;wait_address = wait_address;<br>	<span class="hljs-comment">//赋值监听事件给entry的key</span><br>	entry-&gt;key = p-&gt;_key;<br>	<span class="hljs-comment">//初始化一个等待队列节点，其中唤醒函数设置为pollwake(重点)</span><br>	init_waitqueue_func_entry(&amp;entry-&gt;wait, pollwake);<br>	<span class="hljs-comment">//</span><br>	entry-&gt;wait.private = pwq;<br>	<span class="hljs-comment">//添加到监听队列</span><br>	add_wait_queue(wait_address, &amp;entry-&gt;wait);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-调用-do-poll-方法"><a href="#3-调用-do-poll-方法" class="headerlink" title="3.调用 do_poll 方法"></a>3.调用 do_poll 方法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 核心调用poll</span><br><span class="hljs-comment"> * @param list fd列表的链表</span><br><span class="hljs-comment"> * @param wait 调度控制块</span><br><span class="hljs-comment"> * @param end_time 超时时间</span><br><span class="hljs-comment"> * @return 返回准备好的fd个数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">do_poll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> poll_list *<span class="hljs-built_in">list</span>, <span class="hljs-keyword">struct</span> poll_wqueues *wait,<span class="hljs-keyword">struct</span> timespec64 *end_time)</span>&#123;<br>	<span class="hljs-comment">//获取poll_table</span><br>	poll_table* pt = &amp;wait-&gt;pt;<br>	<span class="hljs-comment">//时间</span><br>	<span class="hljs-type">ktime_t</span> expire, *to = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-type">int</span> timed_out = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;<br>	u64 slack = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">__poll_t</span> busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : <span class="hljs-number">0</span>;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> busy_start = <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">/* Optimise the no-wait case */</span><br>	<span class="hljs-comment">//判断是否超时</span><br>	<span class="hljs-keyword">if</span> (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) &#123;<br>		pt-&gt;_qproc = <span class="hljs-literal">NULL</span>;<br>		timed_out = <span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-comment">//预估时间</span><br>	<span class="hljs-keyword">if</span> (end_time &amp;&amp; !timed_out)slack = select_estimate_accuracy(end_time);<br>	<span class="hljs-comment">//死循环遍历</span><br>	<span class="hljs-keyword">for</span> (;;) &#123;<br>		<span class="hljs-comment">//当前遍历的链表节点（节点中包含pollfd数组）</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_list</span> *<span class="hljs-title">walk</span>;</span><br>		<span class="hljs-type">bool</span> can_busy_loop = <span class="hljs-literal">false</span>;<br>		<span class="hljs-comment">//遍历链表</span><br>		<span class="hljs-keyword">for</span> (walk = <span class="hljs-built_in">list</span>; walk != <span class="hljs-literal">NULL</span>; walk = walk-&gt;next) &#123;<span class="hljs-comment">//walk = walk-&gt;next链表移动</span><br>			<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> * <span class="hljs-title">pfd</span>, * <span class="hljs-title">pfd_end</span>;</span><br>			pfd = walk-&gt;entries;<br>			pfd_end = pfd + walk-&gt;len;<br>			<span class="hljs-comment">//遍历当前节点的所有fd</span><br>			<span class="hljs-keyword">for</span> (; pfd != pfd_end; pfd++) &#123;<br>				<span class="hljs-comment">/*</span><br><span class="hljs-comment">				 * Fish for events. If we found one, record it</span><br><span class="hljs-comment">				 * and kill poll_table-&gt;_qproc, so we don&#x27;t</span><br><span class="hljs-comment">				 * needlessly register any other waiters after</span><br><span class="hljs-comment">				 * this. They&#x27;ll get immediately deregistered</span><br><span class="hljs-comment">				 * when we break out and return.</span><br><span class="hljs-comment">				 */</span><br>				<span class="hljs-comment">//(主线) 调用do_pollfd 返回触发的事件</span><br>				<span class="hljs-keyword">if</span> (do_pollfd(pfd, pt, &amp;can_busy_loop,busy_flag)) &#123;<br>					count++;<br>					pt-&gt;_qproc = <span class="hljs-literal">NULL</span>;<br>					<span class="hljs-comment">/* found something, stop busy polling */</span><br>					busy_flag = <span class="hljs-number">0</span>;<br>					can_busy_loop = <span class="hljs-literal">false</span>;<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * All waiters have already been registered, so don&#x27;t provide</span><br><span class="hljs-comment">		 * a poll_table-&gt;_qproc to them on the next loop iteration.</span><br><span class="hljs-comment">		 */</span><br>		pt-&gt;_qproc = <span class="hljs-literal">NULL</span>;<br>		<span class="hljs-keyword">if</span> (!count) &#123;<br>			count = wait-&gt;error;<br>			<span class="hljs-keyword">if</span> (signal_pending(current))count = -ERESTARTNOHAND;<br>		&#125;<br>		<span class="hljs-comment">//有准备好的fd或者超时则跳出死循环</span><br>		<span class="hljs-keyword">if</span> (count || timed_out)<span class="hljs-keyword">break</span>;<br><br>		<span class="hljs-comment">/* only if found POLL_BUSY_LOOP sockets &amp;&amp; not out of time */</span><br>		<span class="hljs-keyword">if</span> (can_busy_loop &amp;&amp; !need_resched()) &#123;<br>			<span class="hljs-keyword">if</span> (!busy_start) &#123;<br>				busy_start = busy_loop_current_time();<br>				<span class="hljs-keyword">continue</span>;<br>			&#125;<br>			<span class="hljs-keyword">if</span> (!busy_loop_timeout(busy_start))<br>				<span class="hljs-keyword">continue</span>;<br>		&#125;<br>		busy_flag = <span class="hljs-number">0</span>;<br><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * If this is the first loop and we have a timeout</span><br><span class="hljs-comment">		 * given, then we convert to ktime_t and set the to</span><br><span class="hljs-comment">		 * pointer to the expiry value.</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (end_time &amp;&amp; !to) &#123;<br>			expire = timespec64_to_ktime(*end_time);<br>			to = &amp;expire;<br>		&#125;<br>		<span class="hljs-comment">//判断是否超时</span><br>		<span class="hljs-keyword">if</span> (!poll_schedule_timeout(wait, TASK_INTERRUPTIBLE, to, slack))timed_out = <span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-1-调用-do-pollfd"><a href="#3-1-调用-do-pollfd" class="headerlink" title="3.1 调用 do_pollfd"></a>3.1 调用 do_pollfd</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用fd驱动函数</span><br><span class="hljs-comment"> * @param pollfd pollfd结构体</span><br><span class="hljs-comment"> * @param pwait</span><br><span class="hljs-comment"> * @param can_busy_poll</span><br><span class="hljs-comment"> * @param busy_flag</span><br><span class="hljs-comment"> * @return 返回准备好的事件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">__poll_t</span> <span class="hljs-title function_">do_pollfd</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pollfd *pollfd, poll_table *pwait,<span class="hljs-type">bool</span> *can_busy_poll,<span class="hljs-type">__poll_t</span> busy_flag)</span> &#123;<br>	<span class="hljs-comment">//文件描述符</span><br>	<span class="hljs-type">int</span> fd = pollfd-&gt;fd;<br>	<span class="hljs-type">__poll_t</span> mask = <span class="hljs-number">0</span>, filter;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fd</span> <span class="hljs-title">f</span>;</span><br>	<span class="hljs-comment">//fd无效直接返回</span><br>	<span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">goto</span> out;<br>	mask = EPOLLNVAL;<br>	<span class="hljs-comment">//获取真正的文件</span><br>	f = fdget(fd);<br>	<span class="hljs-comment">//验证文件有效性</span><br>	<span class="hljs-keyword">if</span> (!f.file)<span class="hljs-keyword">goto</span> out;<br>	<span class="hljs-comment">/* userland u16 -&gt;events contains POLL... bitmap */</span><br>	filter = demangle_poll(pollfd-&gt;events) | EPOLLERR | EPOLLHUP;<br>	pwait-&gt;_key = filter | busy_flag;<br>	<span class="hljs-comment">//(核心)调用file的驱动 vfs_poll 返回该文件已经准备好的事件</span><br>	mask = vfs_poll(f.file, pwait);<br>	<span class="hljs-keyword">if</span> (mask &amp; busy_flag)*can_busy_poll = <span class="hljs-literal">true</span>;<br>	mask &amp;= filter;		<span class="hljs-comment">/* Mask out unneeded events. */</span><br>	fdput(f);<br><br>out:<br>	<span class="hljs-comment">/* ... and so does -&gt;revents */</span><br>	pollfd-&gt;revents = mangle_poll(mask);<br>	<span class="hljs-keyword">return</span> mask;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-2-poll-freewait-amp-table"><a href="#2-2-poll-freewait-amp-table" class="headerlink" title="2.2 poll_freewait(&amp;table);"></a>2.2 poll_freewait(&amp;table);</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放 poll_wqueues 的资源占用</span><br><span class="hljs-comment"> * @param pwq</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">poll_freewait</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> poll_wqueues *pwq)</span>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_table_page</span> * <span class="hljs-title">p</span> =</span> pwq-&gt;table;<br>	<span class="hljs-type">int</span> i;<br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; pwq-&gt;inline_index; i++)free_poll_entry(pwq-&gt;inline_entries + i);<br>	<span class="hljs-keyword">while</span> (p) &#123;<br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_table_entry</span> * <span class="hljs-title">entry</span>;</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_table_page</span> *<span class="hljs-title">old</span>;</span><br><br>		entry = p-&gt;entry;<br>		<span class="hljs-keyword">do</span> &#123;<br>			entry--;<br>			free_poll_entry(entry);<br>		&#125; <span class="hljs-keyword">while</span> (entry &gt; p-&gt;entries);<br>		old = p;<br>		p = p-&gt;next;<br>		free_page((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) old);<br>	&#125;<br>&#125;<br>EXPORT_SYMBOL(poll_freewait);<br></code></pre></td></tr></table></figure>

<h3 id="流程图示-1"><a href="#流程图示-1" class="headerlink" title="流程图示"></a>流程图示</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/2630542/1661305098017-a0311ed3-7ad9-4425-a04b-cdb48b0048c5.jpeg" srcset="/img/loading.gif" lazyload></p>
<h3 id="相关总结-1"><a href="#相关总结-1" class="headerlink" title="相关总结"></a>相关总结</h3><p>优点：</p>
<ul>
<li>和select相比能监听的fd个数更多（采用链表的方式存储）</li>
<li>poll 事件相比 select 的in/out/err ，明显支持的情况更多</li>
</ul>
<p>缺点：</p>
<ul>
<li>和select一样每次监听都需要不断的遍历每个fd，效率不是很高</li>
<li>每次调用都需要将用户态的fd复制到内核态中</li>
<li>每次用户进程都需要遍历fd才能知道那个准备好</li>
</ul>
<h2 id="epoll系统调用"><a href="#epoll系统调用" class="headerlink" title="epoll系统调用"></a>epoll系统调用</h2><p>epoll没有最大并发连接的限制，上限是最大可以打开文件的数目，这个数字一般远大于2048, 一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</p>
<p>epoll函数</p>
<ul>
<li>do_epoll_create : 创建epoll控制块</li>
<li>do_epoll_ctl : 增删改操作</li>
<li>do_epoll_wait : 陷入内核等待</li>
</ul>
<h3 id="创建流程"><a href="#创建流程" class="headerlink" title="创建流程"></a>创建流程</h3><h4 id="1-创建epoll系统调用"><a href="#1-创建epoll系统调用" class="headerlink" title="1. 创建epoll系统调用"></a>1. 创建epoll系统调用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * epoll系统调用</span><br><span class="hljs-comment"> */</span><br>SYSCALL_DEFINE1(epoll_create1, <span class="hljs-type">int</span>, flags)<br>&#123;<br>	<span class="hljs-keyword">return</span> do_epoll_create(flags);<br>&#125;<br><br>SYSCALL_DEFINE1(epoll_create, <span class="hljs-type">int</span>, size)<br>&#123;<br>	<span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">0</span>)<br>		<span class="hljs-keyword">return</span> -EINVAL;<br><br>	<span class="hljs-keyword">return</span> do_epoll_create(<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="2-调用do-epoll-create创建epoll"><a href="#2-调用do-epoll-create创建epoll" class="headerlink" title="2.调用do_epoll_create创建epoll"></a>2.调用do_epoll_create创建epoll</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建epoll的fd</span><br><span class="hljs-comment"> * @param flags</span><br><span class="hljs-comment"> * @return</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">do_epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> flags)</span> &#123;<br>	<span class="hljs-type">int</span> error, fd;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> *<span class="hljs-title">ep</span> =</span> <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span><br><br>	<span class="hljs-comment">/* Check the EPOLL_* constant for consistency.  */</span><br>	BUILD_BUG_ON(EPOLL_CLOEXEC != O_CLOEXEC);<br><br>	<span class="hljs-keyword">if</span> (flags &amp; ~EPOLL_CLOEXEC)<span class="hljs-keyword">return</span> -EINVAL;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Create the internal data structure (&quot;struct eventpoll&quot;).</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">//传入应用创建eventpoll的结构体</span><br>	error = ep_alloc(&amp;ep);<br>	<span class="hljs-comment">//出现错误返回错误</span><br>	<span class="hljs-keyword">if</span> (error &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> error;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Creates all the items needed to setup an eventpoll file. That is,</span><br><span class="hljs-comment">	 * a file structure and a free file descriptor.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">//创建设置eventpoll文件所需的所有项。即文件结构和自由文件描述符。</span><br>	fd = get_unused_fd_flags(O_RDWR | (flags &amp; O_CLOEXEC));<br>	<span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//创建失败</span><br>		error = fd;<br>		<span class="hljs-keyword">goto</span> out_free_ep;<br>	&#125;<br>	<span class="hljs-comment">//创建一个名字为“[eventpoll]”的eventpollfs文件描述符</span><br>	file = anon_inode_getfile(<span class="hljs-string">&quot;[eventpoll]&quot;</span>, &amp;eventpoll_fops, ep,O_RDWR | (flags &amp; O_CLOEXEC));<br>	<span class="hljs-keyword">if</span> (IS_ERR(file)) &#123;<br>		error = PTR_ERR(file);<br>		<span class="hljs-keyword">goto</span> out_free_fd;<br>	&#125;<br>	<span class="hljs-comment">//赋值个ep</span><br>	ep-&gt;file = file;<br>	<span class="hljs-comment">//将文件加入fd数组表（绑定file和fd）</span><br>	fd_install(fd, file);<br>	<span class="hljs-comment">//返回fd</span><br>	<span class="hljs-keyword">return</span> fd;<br><br>out_free_fd:<br>	put_unused_fd(fd);<br>out_free_ep:<br>	ep_free(ep);<br>	<span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-1-创建分配一个eventpoll结构体"><a href="#2-1-创建分配一个eventpoll结构体" class="headerlink" title="2.1.创建分配一个eventpoll结构体"></a>2.1.创建分配一个eventpoll结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建分配一个eventpoll</span><br><span class="hljs-comment"> * @param pep</span><br><span class="hljs-comment"> * @return</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ep_alloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> eventpoll **pep)</span>&#123;<br>	<span class="hljs-type">int</span> error;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_struct</span> *<span class="hljs-title">user</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> *<span class="hljs-title">ep</span>;</span><br><br>	user = get_current_user();<span class="hljs-comment">//当前用户</span><br>	error = -ENOMEM;<br>	ep = kzalloc(<span class="hljs-keyword">sizeof</span>(*ep), GFP_KERNEL);<span class="hljs-comment">//申请内存</span><br>	<span class="hljs-keyword">if</span> (unlikely(!ep))<span class="hljs-keyword">goto</span> free_uid;<span class="hljs-comment">//分配失败</span><br>	<span class="hljs-comment">//初始化互斥锁</span><br>	mutex_init(&amp;ep-&gt;mtx);<br>	rwlock_init(&amp;ep-&gt;lock);<span class="hljs-comment">//初始化读写锁</span><br>	init_waitqueue_head(&amp;ep-&gt;wq);<span class="hljs-comment">//初始化等待队列头</span><br>	init_waitqueue_head(&amp;ep-&gt;poll_wait);<br>	INIT_LIST_HEAD(&amp;ep-&gt;rdllist);<span class="hljs-comment">//初始化就绪队列</span><br>	ep-&gt;rbr = RB_ROOT_CACHED;<span class="hljs-comment">//初始化红黑树</span><br>	ep-&gt;ovflist = EP_UNACTIVE_PTR;<br>	ep-&gt;user = user;<span class="hljs-comment">//当前用户</span><br><br>	*pep = ep;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//正常返回0</span><br><span class="hljs-comment">//出现错误</span><br>free_uid:<br>	free_uid(user);<br>	<span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="修改流程"><a href="#修改流程" class="headerlink" title="修改流程"></a>修改流程</h3><h4 id="1-修改epoll系统调用"><a href="#1-修改epoll系统调用" class="headerlink" title="1.修改epoll系统调用"></a>1.修改epoll系统调用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 代码基于linux5-19-RC8 linux/fs/eventpoll.c</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * epoll系统调用函数 实现插入/删除/修改fd的功能</span><br><span class="hljs-comment"> */</span><br>SYSCALL_DEFINE4(epoll_ctl, <span class="hljs-type">int</span>, epfd, <span class="hljs-type">int</span>, op, <span class="hljs-type">int</span>, fd,<span class="hljs-keyword">struct</span> epoll_event __user *, event)<br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">epds</span>;</span><br>	<span class="hljs-comment">//判断是否需要来自用户空间的事件副本 &amp;&amp; 拷贝事件到内核空间</span><br>	<span class="hljs-keyword">if</span> (ep_op_has_event(op) &amp;&amp; copy_from_user(&amp;epds, event, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> epoll_event)))<span class="hljs-keyword">return</span> -EFAULT;<br>	<span class="hljs-comment">//执行操作</span><br>	<span class="hljs-keyword">return</span> do_epoll_ctl(epfd, op, fd, &amp;epds, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="1-1-epoll事件结构体"><a href="#1-1-epoll事件结构体" class="headerlink" title="1.1 epoll事件结构体"></a>1.1 epoll事件结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * epoll事件结构体</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> &#123;</span><br>	<span class="hljs-type">__poll_t</span> events;<span class="hljs-comment">//事件</span><br>	__u64 data;<span class="hljs-comment">//数据</span><br>&#125; EPOLL_PACKED;<br></code></pre></td></tr></table></figure>

<h4 id="2-调用-do-epoll-ctl"><a href="#2-调用-do-epoll-ctl" class="headerlink" title="2. 调用 do_epoll_ctl"></a>2. 调用 do_epoll_ctl</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * epoll操作方法</span><br><span class="hljs-comment"> * @param epfd</span><br><span class="hljs-comment"> * @param op 操作类型 [EPOLL_CTL_ADD,EPOLL_CTL_DEL,EPOLL_CTL_MOD]</span><br><span class="hljs-comment"> * @param fd 文件描述符</span><br><span class="hljs-comment"> * @param epds epoll_event结构体</span><br><span class="hljs-comment"> * @param nonblock 是否是非阻塞</span><br><span class="hljs-comment"> * @return</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">do_epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *epds,<span class="hljs-type">bool</span> nonblock)</span> &#123;<br>	<span class="hljs-type">int</span> error;<br>	<span class="hljs-type">int</span> full_check = <span class="hljs-number">0</span>;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fd</span> <span class="hljs-title">f</span>, <span class="hljs-title">tf</span>;</span><br>	<span class="hljs-comment">//eventpoll结构体</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> *<span class="hljs-title">ep</span>;</span><br>	<span class="hljs-comment">//epitem结构体</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">epi</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> *<span class="hljs-title">tep</span> =</span> <span class="hljs-literal">NULL</span>;<br><br>	error = -EBADF;<br>	f = fdget(epfd);<span class="hljs-comment">//获取文件描述符</span><br>	<span class="hljs-keyword">if</span> (!f.file) <span class="hljs-keyword">goto</span> error_return;<br><br>	<span class="hljs-comment">/* Get the &quot;struct file *&quot; for the target file */</span><br>	<span class="hljs-comment">//目标文件</span><br>	tf = fdget(fd);<br>	<span class="hljs-keyword">if</span> (!tf.file)<span class="hljs-keyword">goto</span> error_fput;<br><br>	<span class="hljs-comment">/* The target file descriptor must support poll */</span><br>	error = -EPERM;<br>	<span class="hljs-comment">//如果文件不支持则直接退出</span><br>	<span class="hljs-keyword">if</span> (!file_can_poll(tf.file))<span class="hljs-keyword">goto</span> error_tgt_fput;<br><br>	<span class="hljs-comment">/* Check if EPOLLWAKEUP is allowed */</span><br>	<span class="hljs-comment">// 检查是否支持epoll唤醒</span><br>	<span class="hljs-keyword">if</span> (ep_op_has_event(op))ep_take_care_of_epollwakeup(epds);<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * We have to check that the file structure underneath the file descriptor</span><br><span class="hljs-comment">	 * the user passed to us _is_ an eventpoll file. And also we do not permit</span><br><span class="hljs-comment">	 * adding an epoll file descriptor inside itself.</span><br><span class="hljs-comment">	 */</span><br>	error = -EINVAL;<br>	<span class="hljs-comment">//检查文件</span><br>	<span class="hljs-keyword">if</span> (f.file == tf.file || !is_file_epoll(f.file))<br>		<span class="hljs-keyword">goto</span> error_tgt_fput;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * epoll adds to the wakeup queue at EPOLL_CTL_ADD time only,</span><br><span class="hljs-comment">	 * so EPOLLEXCLUSIVE is not allowed for a EPOLL_CTL_MOD operation.</span><br><span class="hljs-comment">	 * Also, we do not currently supported nested exclusive wakeups.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (ep_op_has_event(op) &amp;&amp; (epds-&gt;events &amp; EPOLLEXCLUSIVE)) &#123;<br>		<span class="hljs-keyword">if</span> (op == EPOLL_CTL_MOD)<br>			<span class="hljs-keyword">goto</span> error_tgt_fput;<br>		<span class="hljs-keyword">if</span> (op == EPOLL_CTL_ADD &amp;&amp; (is_file_epoll(tf.file) ||<br>				(epds-&gt;events &amp; ~EPOLLEXCLUSIVE_OK_BITS)))<br>			<span class="hljs-keyword">goto</span> error_tgt_fput;<br>	&#125;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * At this point it is safe to assume that the &quot;private_data&quot; contains</span><br><span class="hljs-comment">	 * our own data structure.</span><br><span class="hljs-comment">	 */</span><br>	ep = f.file-&gt;private_data;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * When we insert an epoll file descriptor inside another epoll file</span><br><span class="hljs-comment">	 * descriptor, there is the chance of creating closed loops, which are</span><br><span class="hljs-comment">	 * better be handled here, than in more critical paths. While we are</span><br><span class="hljs-comment">	 * checking for loops we also determine the list of files reachable</span><br><span class="hljs-comment">	 * and hang them on the tfile_check_list, so we can check that we</span><br><span class="hljs-comment">	 * haven&#x27;t created too many possible wakeup paths.</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * We do not need to take the global &#x27;epumutex&#x27; on EPOLL_CTL_ADD when</span><br><span class="hljs-comment">	 * the epoll file descriptor is attaching directly to a wakeup source,</span><br><span class="hljs-comment">	 * unless the epoll file descriptor is nested. The purpose of taking the</span><br><span class="hljs-comment">	 * &#x27;epmutex&#x27; on add is to prevent complex toplogies such as loops and</span><br><span class="hljs-comment">	 * deep wakeup paths from forming in parallel through multiple</span><br><span class="hljs-comment">	 * EPOLL_CTL_ADD operations.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">//需要获取mutex对红黑树进行操作</span><br>	error = epoll_mutex_lock(&amp;ep-&gt;mtx, <span class="hljs-number">0</span>, nonblock);<br>	<span class="hljs-keyword">if</span> (error)<br>		<span class="hljs-keyword">goto</span> error_tgt_fput;<br>	<span class="hljs-keyword">if</span> (op == EPOLL_CTL_ADD) &#123;<br>		<span class="hljs-keyword">if</span> (READ_ONCE(f.file-&gt;f_ep) || ep-&gt;gen == loop_check_gen ||<br>		    is_file_epoll(tf.file)) &#123;<br>			mutex_unlock(&amp;ep-&gt;mtx);<br>			error = epoll_mutex_lock(&amp;epmutex, <span class="hljs-number">0</span>, nonblock);<br>			<span class="hljs-keyword">if</span> (error)<br>				<span class="hljs-keyword">goto</span> error_tgt_fput;<br>			loop_check_gen++;<br>			full_check = <span class="hljs-number">1</span>;<br>			<span class="hljs-keyword">if</span> (is_file_epoll(tf.file)) &#123;<br>				tep = tf.file-&gt;private_data;<br>				error = -ELOOP;<br>				<span class="hljs-keyword">if</span> (ep_loop_check(ep, tep) != <span class="hljs-number">0</span>)<br>					<span class="hljs-keyword">goto</span> error_tgt_fput;<br>			&#125;<br>			error = epoll_mutex_lock(&amp;ep-&gt;mtx, <span class="hljs-number">0</span>, nonblock);<br>			<span class="hljs-keyword">if</span> (error)<br>				<span class="hljs-keyword">goto</span> error_tgt_fput;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Try to lookup the file inside our RB tree. Since we grabbed &quot;mtx&quot;</span><br><span class="hljs-comment">	 * above, we can be sure to be able to use the item looked up by</span><br><span class="hljs-comment">	 * ep_find() till we release the mutex.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">//从红黑树中寻找添加的fd是否存在，存在则返回到ep中，否则返回NULL</span><br>	epi = ep_find(ep, tf.file, fd);<br><br>	error = -EINVAL;<br>	<span class="hljs-keyword">switch</span> (op) &#123;<span class="hljs-comment">//区分op类型增删改</span><br>	<span class="hljs-keyword">case</span> EPOLL_CTL_ADD:<span class="hljs-comment">//新增</span><br>		<span class="hljs-comment">//查找不到则添加</span><br>		<span class="hljs-keyword">if</span> (!epi) &#123;<br>			epds-&gt;events |= EPOLLERR | EPOLLHUP;<br>			error = ep_insert(ep, epds, tf.file, fd, full_check);<span class="hljs-comment">//插入</span><br>		&#125; <span class="hljs-keyword">else</span><span class="hljs-comment">//否则不重复添加</span><br>			error = -EEXIST;<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">case</span> EPOLL_CTL_DEL:<span class="hljs-comment">//删除</span><br>		<span class="hljs-keyword">if</span> (epi)<br>			error = ep_remove(ep, epi);<span class="hljs-comment">//删除</span><br>		<span class="hljs-keyword">else</span><br>			error = -ENOENT;<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">case</span> EPOLL_CTL_MOD:<span class="hljs-comment">//修改</span><br>		<span class="hljs-keyword">if</span> (epi) &#123;<br>			<span class="hljs-keyword">if</span> (!(epi-&gt;event.events &amp; EPOLLEXCLUSIVE)) &#123;<br>				epds-&gt;events |= EPOLLERR | EPOLLHUP;<br>				error = ep_modify(ep, epi, epds);<br>			&#125;<br>		&#125; <span class="hljs-keyword">else</span><br>			error = -ENOENT;<br>		<span class="hljs-keyword">break</span>;<br>	&#125;<br>	mutex_unlock(&amp;ep-&gt;mtx);<br><br>error_tgt_fput:<br>	<span class="hljs-keyword">if</span> (full_check) &#123;<br>		clear_tfile_check_list();<br>		loop_check_gen++;<br>		mutex_unlock(&amp;epmutex);<br>	&#125;<br><br>	fdput(tf);<br>error_fput:<br>	fdput(f);<br>error_return:<br><br>	<span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-1-结构体eventpoll控制块"><a href="#2-1-结构体eventpoll控制块" class="headerlink" title="2.1 结构体eventpoll控制块"></a>2.1 结构体eventpoll控制块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> &#123;</span><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * This mutex is used to ensure that files are not removed</span><br><span class="hljs-comment">	 * while epoll is using them. This is held during the event</span><br><span class="hljs-comment">	 * collection loop, the file cleanup path, the epoll file exit</span><br><span class="hljs-comment">	 * code and the ctl operations.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">mtx</span>;</span><br><br>	<span class="hljs-comment">/* Wait queue used by sys_epoll_wait() */</span><br>	<span class="hljs-type">wait_queue_head_t</span> wq;<span class="hljs-comment">//调用进程等待队列</span><br><br>	<span class="hljs-comment">/* Wait queue used by file-&gt;poll() */</span><br>	<span class="hljs-type">wait_queue_head_t</span> poll_wait;<span class="hljs-comment">//等待队列队头（如果被监听的文件是一个epoll类型）</span><br><br>	<span class="hljs-comment">/* List of ready file descriptors */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">rdllist</span>;</span><span class="hljs-comment">//已经准备好的文件描述符队列队头（双向链表）</span><br><br>	<span class="hljs-comment">/* Lock which protects rdllist and ovflist */</span><br>	<span class="hljs-type">rwlock_t</span> lock;<span class="hljs-comment">//读写锁</span><br><br>	<span class="hljs-comment">/* RB tree root used to store monitored fd structs */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_root_cached</span> <span class="hljs-title">rbr</span>;</span><span class="hljs-comment">//红黑树root节点（存储epitem）</span><br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * This is a single linked list that chains all the &quot;struct epitem&quot; that</span><br><span class="hljs-comment">	 * happened while transferring ready events to userspace w/out</span><br><span class="hljs-comment">	 * holding -&gt;lock.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">ovflist</span>;</span><span class="hljs-comment">//</span><br><br>	<span class="hljs-comment">/* wakeup_source used when ep_scan_ready_list is running */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">wakeup_source</span> *<span class="hljs-title">ws</span>;</span><br><br>	<span class="hljs-comment">/* The user that created the eventpoll descriptor */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_struct</span> *<span class="hljs-title">user</span>;</span><span class="hljs-comment">//当前进程用户</span><br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span><span class="hljs-comment">//真正的文件</span><br><br>	<span class="hljs-comment">/* used to optimize loop detection check */</span><br>	u64 gen;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_head</span> <span class="hljs-title">refs</span>;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NET_RX_BUSY_POLL</span><br>	<span class="hljs-comment">/* used to track busy poll napi_id */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> napi_id;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span><br>	<span class="hljs-comment">/* tracks wakeup nests for lockdep validation */</span><br>	u8 nests;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h4 id="2-2-结构体epitem红黑树节点"><a href="#2-2-结构体epitem红黑树节点" class="headerlink" title="2.2 结构体epitem红黑树节点"></a>2.2 结构体epitem红黑树节点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> &#123;</span><br>    <br>	<span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>		<span class="hljs-comment">/* RB tree node links this structure to the eventpoll RB tree */</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> <span class="hljs-title">rbn</span>;</span><span class="hljs-comment">//指向红黑树的节点</span><br>		<span class="hljs-comment">/* Used to free the struct epitem */</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span><br>	&#125;;<br><br>	<span class="hljs-comment">/* List header used to link this structure to the eventpoll ready list */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">rdllink</span>;</span><br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Works together &quot;struct eventpoll&quot;-&gt;ovflist in keeping the</span><br><span class="hljs-comment">	 * single linked chain of items.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//</span><br><br>	<span class="hljs-comment">/* The file descriptor information this item refers to */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_filefd</span> <span class="hljs-title">ffd</span>;</span><span class="hljs-comment">//文件fd</span><br><br>	<span class="hljs-comment">/* List containing poll wait queues */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eppoll_entry</span> *<span class="hljs-title">pwqlist</span>;</span><span class="hljs-comment">//等待队列</span><br><br>	<span class="hljs-comment">/* The &quot;container&quot; of this item */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> *<span class="hljs-title">ep</span>;</span><span class="hljs-comment">//指向eventpoll控制块</span><br><br>	<span class="hljs-comment">/* List header used to link this item to the &quot;struct file&quot; items list */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_node</span> <span class="hljs-title">fllink</span>;</span><br><br>	<span class="hljs-comment">/* wakeup_source used when EPOLLWAKEUP is set */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">wakeup_source</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">ws</span>;</span><br><br>	<span class="hljs-comment">/* The structure that describe the interested events and the source fd */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">event</span>;</span><span class="hljs-comment">//事件</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="2-3-红黑树查找对应的fd的epitem"><a href="#2-3-红黑树查找对应的fd的epitem" class="headerlink" title=" 2.3 红黑树查找对应的fd的epitem"></a> 2.3 红黑树查找对应的fd的epitem</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 红黑树查找对应的fd的epitem</span><br><span class="hljs-comment"> * @param ep</span><br><span class="hljs-comment"> * @param file</span><br><span class="hljs-comment"> * @param fd</span><br><span class="hljs-comment"> * @return</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> epitem *<span class="hljs-title function_">ep_find</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> eventpoll *ep, <span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">int</span> fd)</span>&#123;<br>	<span class="hljs-type">int</span> kcmp;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> *<span class="hljs-title">rbp</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">epi</span>, *<span class="hljs-title">epir</span> =</span> <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_filefd</span> <span class="hljs-title">ffd</span>;</span><br><br>	ep_set_ffd(&amp;ffd, file, fd);<span class="hljs-comment">//初始化指针</span><br>	<span class="hljs-comment">//二分搜索</span><br>	<span class="hljs-keyword">for</span> (rbp = ep-&gt;rbr.rb_root.rb_node; rbp; ) &#123;<br>		epi = rb_entry(rbp, <span class="hljs-keyword">struct</span> epitem, rbn);<br>		kcmp = ep_cmp_ffd(&amp;ffd, &amp;epi-&gt;ffd);<br>		<span class="hljs-keyword">if</span> (kcmp &gt; <span class="hljs-number">0</span>)<br>			rbp = rbp-&gt;rb_right;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (kcmp &lt; <span class="hljs-number">0</span>)<br>			rbp = rbp-&gt;rb_left;<br>		<span class="hljs-keyword">else</span> &#123;<br>			epir = epi;<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> epir;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><h4 id="1-调用ep-insert插入"><a href="#1-调用ep-insert插入" class="headerlink" title="1.调用ep_insert插入"></a>1.调用ep_insert插入</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 插入操作（必须在持有“mtx”的情况下调用）</span><br><span class="hljs-comment"> * @param ep 控制块</span><br><span class="hljs-comment"> * @param event</span><br><span class="hljs-comment"> * @param tfile</span><br><span class="hljs-comment"> * @param fd</span><br><span class="hljs-comment"> * @param full_check</span><br><span class="hljs-comment"> * @return</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ep_insert</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> eventpoll *ep, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> epoll_event *event,<span class="hljs-keyword">struct</span> file *tfile, <span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> full_check)</span><br>&#123;<br>	<span class="hljs-type">int</span> error, pwake = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">__poll_t</span> revents;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">epi</span>;</span><span class="hljs-comment">//红黑树节点结构体</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ep_pqueue</span> <span class="hljs-title">epq</span>;</span><span class="hljs-comment">//epoll队列</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> *<span class="hljs-title">tep</span> =</span> <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-comment">//判断是否是epoll文件</span><br>	<span class="hljs-keyword">if</span> (is_file_epoll(tfile))tep = tfile-&gt;private_data;<br><br>	lockdep_assert_irqs_enabled();<br>	<span class="hljs-comment">//epoll可监控的最大值</span><br>	<span class="hljs-comment">//unsigned int sysctl_nr_open __read_mostly = 1024*1024;</span><br>	<span class="hljs-keyword">if</span> (unlikely(percpu_counter_compare(&amp;ep-&gt;user-&gt;epoll_watches,max_user_watches) &gt;= <span class="hljs-number">0</span>))<span class="hljs-keyword">return</span> -ENOSPC;<br>	<span class="hljs-comment">//增加cpu计数</span><br>	percpu_counter_inc(&amp;ep-&gt;user-&gt;epoll_watches);<br>	<span class="hljs-comment">//从缓存中申请内存,申请失败减掉计数</span><br>	<span class="hljs-comment">//epi_cache内存池在epoll模块初始化时已经分配,这里根据slab直接取一个epitem</span><br>	<span class="hljs-keyword">if</span> (!(epi = kmem_cache_zalloc(epi_cache, GFP_KERNEL))) &#123;<br>		percpu_counter_dec(&amp;ep-&gt;user-&gt;epoll_watches);<br>		<span class="hljs-keyword">return</span> -ENOMEM;<br>	&#125;<br>	<span class="hljs-comment">//初始化工作 epitem</span><br>	<span class="hljs-comment">/* Item initialization follow here ... */</span><br>	INIT_LIST_HEAD(&amp;epi-&gt;rdllink);<br>	epi-&gt;ep = ep;<span class="hljs-comment">//设置指向ep的指针</span><br>	ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);<span class="hljs-comment">//设置ffd</span><br>	epi-&gt;event = *event;<span class="hljs-comment">//设置监听的事件</span><br>	epi-&gt;next = EP_UNACTIVE_PTR;<br>	<span class="hljs-comment">//加锁</span><br>	<span class="hljs-keyword">if</span> (tep)mutex_lock_nested(&amp;tep-&gt;mtx, <span class="hljs-number">1</span>);<br>	<span class="hljs-comment">/* Add the current item to the list of active epoll hook for this file */</span><br>	<span class="hljs-comment">//将当前项添加到此文件的活动epoll钩子列表</span><br>	<span class="hljs-keyword">if</span> (unlikely(attach_epitem(tfile, epi) &lt; <span class="hljs-number">0</span>)) &#123;<br>		<span class="hljs-keyword">if</span> (tep)mutex_unlock(&amp;tep-&gt;mtx);<br>		kmem_cache_free(epi_cache, epi);<br>		percpu_counter_dec(&amp;ep-&gt;user-&gt;epoll_watches);<br>		<span class="hljs-keyword">return</span> -ENOMEM;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (full_check &amp;&amp; !tep)list_file(tfile);<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Add the current item to the RB tree. All RB tree operations are</span><br><span class="hljs-comment">	 * protected by &quot;mtx&quot;, and ep_insert() is called with &quot;mtx&quot; held.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">//插入到红黑树中</span><br>	ep_rbtree_insert(ep, epi);<br>	<span class="hljs-keyword">if</span> (tep)mutex_unlock(&amp;tep-&gt;mtx);<br><br>	<span class="hljs-comment">/* now check if we&#x27;ve created too many backpaths */</span><br>	<span class="hljs-keyword">if</span> (unlikely(full_check &amp;&amp; reverse_path_check())) &#123;<br>		ep_remove(ep, epi);<br>		<span class="hljs-keyword">return</span> -EINVAL;<br>	&#125;<br>	<span class="hljs-comment">//如果events里设置了EPOLLWAKEUP, 还需要为autosleep创建一个唤醒源 ep_create_wakeup_source</span><br>	<span class="hljs-keyword">if</span> (epi-&gt;event.events &amp; EPOLLWAKEUP) &#123;<br>		error = ep_create_wakeup_source(epi);<br>		<span class="hljs-keyword">if</span> (error) &#123;<br>			ep_remove(ep, epi);<br>			<span class="hljs-keyword">return</span> error;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">/* Initialize the poll table using the queue callback */</span><br>	<span class="hljs-comment">//初始化</span><br>	epq.epi = epi;<br><br>	<span class="hljs-comment">/* 设置epq的回调函数为ep_ptable_queue_proc,当调用poll_wait时会调用该回调函数，</span><br><span class="hljs-comment">     	 * 而函数体ep_ptable_queue_proc内部所做的主要工作,</span><br><span class="hljs-comment">     	 * 就是把epitem对应fd的事件到来时的回调函数设置为ep_poll_callback。</span><br><span class="hljs-comment">     	 * ep_poll_callback所做的主要工作就是把就绪的fd放到就绪链表rdllist上,</span><br><span class="hljs-comment">     	 * 然后唤醒epoll_wait的调用者, 被唤醒的进程再把rdllist上就绪的fd的events拷贝给用户进程,</span><br><span class="hljs-comment">     	 * 完成一个闭环。</span><br><span class="hljs-comment">     	*/</span><br>	init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Attach the item to the poll hooks and get current event bits.</span><br><span class="hljs-comment">	 * We can safely use the file* here because its usage count has</span><br><span class="hljs-comment">	 * been increased by the caller of this function. Note that after</span><br><span class="hljs-comment">	 * this operation completes, the poll callback can start hitting</span><br><span class="hljs-comment">	 * the new item.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">//如果当前监听的事件刚好发生，则直接返回</span><br>	revents = ep_item_poll(epi, &amp;epq.pt, <span class="hljs-number">1</span>);<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * We have to check if something went wrong during the poll wait queue</span><br><span class="hljs-comment">	 * install process. Namely an allocation for a wait queue failed due</span><br><span class="hljs-comment">	 * high memory pressure.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (unlikely(!epq.epi)) &#123;<br>		ep_remove(ep, epi);<br>		<span class="hljs-keyword">return</span> -ENOMEM;<br>	&#125;<br><br>	<span class="hljs-comment">/* We have to drop the new item inside our item list to keep track of it */</span><br>	write_lock_irq(&amp;ep-&gt;lock);<br><br>	<span class="hljs-comment">/* record NAPI ID of new item if present */</span><br>	ep_set_busy_poll_napi_id(epi);<br><br>	<span class="hljs-comment">/* If the file is already &quot;ready&quot; we drop it inside the ready list */</span><br>	<span class="hljs-comment">//如果当前的epi已经就绪了，上面的revents返回就绪的事件，则把其加入就绪列表rdllink</span><br>	<span class="hljs-keyword">if</span> (revents &amp;&amp; !ep_is_linked(epi)) &#123;<br>		<span class="hljs-comment">//加入就序列表尾部</span><br>		list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);<br>		ep_pm_stay_awake(epi);<br>		<span class="hljs-comment">/* Notify waiting tasks that events are available */</span><br>		<span class="hljs-comment">//主动唤醒通知等待任务事件可用</span><br>		<span class="hljs-keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))wake_up(&amp;ep-&gt;wq);<br>		<span class="hljs-keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))pwake++;<br>	&#125;<br>	<span class="hljs-comment">//释放ep的锁</span><br>	write_unlock_irq(&amp;ep-&gt;lock);<br><br>	<span class="hljs-comment">/* We have to call this outside the lock */</span><br>	<span class="hljs-keyword">if</span> (pwake)ep_poll_safewake(ep, <span class="hljs-literal">NULL</span>);<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="2-插入节点到红黑树"><a href="#2-插入节点到红黑树" class="headerlink" title="2.插入节点到红黑树"></a>2.插入节点到红黑树</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 插入epi到红黑树中</span><br><span class="hljs-comment"> * @param ep eventpoll控制块</span><br><span class="hljs-comment"> * @param epi 插入的节点</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ep_rbtree_insert</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> eventpoll *ep, <span class="hljs-keyword">struct</span> epitem *epi)</span><br>&#123;<br>	<span class="hljs-type">int</span> kcmp;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> **<span class="hljs-title">p</span> =</span> &amp;ep-&gt;rbr.rb_root.rb_node, *parent = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">epic</span>;</span><br>	<span class="hljs-type">bool</span> leftmost = <span class="hljs-literal">true</span>;<br><br>	<span class="hljs-keyword">while</span> (*p) &#123;<br>		parent = *p;<br>		epic = rb_entry(parent, <span class="hljs-keyword">struct</span> epitem, rbn);<br>		kcmp = ep_cmp_ffd(&amp;epi-&gt;ffd, &amp;epic-&gt;ffd);<br>		<span class="hljs-keyword">if</span> (kcmp &gt; <span class="hljs-number">0</span>) &#123;<br>			p = &amp;parent-&gt;rb_right;<br>			leftmost = <span class="hljs-literal">false</span>;<br>		&#125; <span class="hljs-keyword">else</span><br>			p = &amp;parent-&gt;rb_left;<br>	&#125;<br>	<span class="hljs-comment">//通过rbn关联（注意实际上插入红黑树的是rbn,通过其进行关联epitem）</span><br>	rb_link_node(&amp;epi-&gt;rbn, parent, p);<br>	rb_insert_color_cached(&amp;epi-&gt;rbn, &amp;ep-&gt;rbr, leftmost);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 红黑树的插入操作</span><br><span class="hljs-comment"> * @param node </span><br><span class="hljs-comment"> * @param parent </span><br><span class="hljs-comment"> * @param rb_link </span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">rb_link_node</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> rb_node *node, <span class="hljs-keyword">struct</span> rb_node *parent,<span class="hljs-keyword">struct</span> rb_node **rb_link)</span><br>&#123;<br>	node-&gt;__rb_parent_color = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)parent;<span class="hljs-comment">//父节点颜色</span><br>	node-&gt;rb_left = node-&gt;rb_right = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//设置其左右节点为NULL</span><br>	*rb_link = node;<span class="hljs-comment">//将rb_link指针指向node</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-1查找到对应插入的位置"><a href="#2-1查找到对应插入的位置" class="headerlink" title="2.1查找到对应插入的位置"></a>2.1查找到对应插入的位置</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 插入epi到红黑树中</span><br><span class="hljs-comment"> * @param ep eventpoll控制块</span><br><span class="hljs-comment"> * @param epi 插入的节点</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ep_rbtree_insert</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> eventpoll *ep, <span class="hljs-keyword">struct</span> epitem *epi)</span><br>&#123;<br>	<span class="hljs-type">int</span> kcmp;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> **<span class="hljs-title">p</span> =</span> &amp;ep-&gt;rbr.rb_root.rb_node, *parent = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">epic</span>;</span><br>	<span class="hljs-type">bool</span> leftmost = <span class="hljs-literal">true</span>;<br><br>	<span class="hljs-keyword">while</span> (*p) &#123;<br>		parent = *p;<br>		epic = rb_entry(parent, <span class="hljs-keyword">struct</span> epitem, rbn);<br>		kcmp = ep_cmp_ffd(&amp;epi-&gt;ffd, &amp;epic-&gt;ffd);<br>		<span class="hljs-keyword">if</span> (kcmp &gt; <span class="hljs-number">0</span>) &#123;<br>			p = &amp;parent-&gt;rb_right;<br>			leftmost = <span class="hljs-literal">false</span>;<br>		&#125; <span class="hljs-keyword">else</span><br>			p = &amp;parent-&gt;rb_left;<br>	&#125;<br>	<span class="hljs-comment">//通过rbn关联</span><br>	rb_link_node(&amp;epi-&gt;rbn, parent, p);<br>	rb_insert_color_cached(&amp;epi-&gt;rbn, &amp;ep-&gt;rbr, leftmost);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-2-插入节点"><a href="#2-2-插入节点" class="headerlink" title="2.2 插入节点"></a>2.2 插入节点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">rb_link_node</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> rb_node *node, <span class="hljs-keyword">struct</span> rb_node *parent,<span class="hljs-keyword">struct</span> rb_node **rb_link)</span><br>&#123;<br>	node-&gt;__rb_parent_color = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)parent;<br>	node-&gt;rb_left = node-&gt;rb_right = <span class="hljs-literal">NULL</span>;<br>	*rb_link = node;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-初始化poll回调函数指针"><a href="#3-初始化poll回调函数指针" class="headerlink" title="3.初始化poll回调函数指针"></a>3.初始化poll回调函数指针</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 初始化</span><br><span class="hljs-comment"> * @param pt</span><br><span class="hljs-comment"> * @param qproc</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">init_poll_funcptr</span><span class="hljs-params">(poll_table *pt, poll_queue_proc qproc)</span><br>&#123;<br>	<span class="hljs-comment">//pt是poll_table_struct结构体类型，设置其回调函数</span><br>	pt-&gt;_qproc = qproc;<br>	<span class="hljs-comment">//默认监听所有事件</span><br>	pt-&gt;_key   = ~(<span class="hljs-type">__poll_t</span>)<span class="hljs-number">0</span>; <span class="hljs-comment">/* all events enabled */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-1-结构体poll-table-struct"><a href="#3-1-结构体poll-table-struct" class="headerlink" title="3.1 结构体poll_table_struct"></a>3.1 结构体poll_table_struct</h4><blockquote>
<p>存储回调函数和监听的事件类型</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_table_struct</span> &#123;</span><br>	poll_queue_proc _qproc;<br>	<span class="hljs-type">__poll_t</span> _key;<br>&#125; poll_table;<br></code></pre></td></tr></table></figure>

<h4 id="3-2-唤醒时回调的函数"><a href="#3-2-唤醒时回调的函数" class="headerlink" title="3.2 唤醒时回调的函数"></a>3.2 唤醒时回调的函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ep_ptable_queue_proc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">wait_queue_head_t</span> *whead,poll_table *pt)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ep_pqueue</span> *<span class="hljs-title">epq</span> =</span> container_of(pt, <span class="hljs-keyword">struct</span> ep_pqueue, pt);<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">epi</span> =</span> epq-&gt;epi;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eppoll_entry</span> *<span class="hljs-title">pwq</span>;</span><span class="hljs-comment">//结构体见3.3</span><br><br>	<span class="hljs-keyword">if</span> (unlikely(!epi))	<span class="hljs-comment">// an earlier allocation has failed</span><br>		<span class="hljs-keyword">return</span>;<br><br>	pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL);<br>	<span class="hljs-keyword">if</span> (unlikely(!pwq)) &#123;<br>		epq-&gt;epi = <span class="hljs-literal">NULL</span>;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-comment">//初始化等待队列，当唤醒时调用ep_poll_callback</span><br>	init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);<br>	pwq-&gt;whead = whead;<br>	pwq-&gt;base = epi;<br>	<span class="hljs-keyword">if</span> (epi-&gt;event.events &amp; EPOLLEXCLUSIVE)add_wait_queue_exclusive(whead, &amp;pwq-&gt;wait);<br>	<span class="hljs-keyword">else</span> add_wait_queue(whead, &amp;pwq-&gt;wait);<br>	pwq-&gt;next = epi-&gt;pwqlist;<br>	epi-&gt;pwqlist = pwq;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-3-结构体-eppoll-entry"><a href="#3-3-结构体-eppoll-entry" class="headerlink" title="3.3 结构体 eppoll_entry"></a>3.3 结构体 eppoll_entry</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Wait structure used by the poll hooks */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eppoll_entry</span> &#123;</span><br>	<span class="hljs-comment">/* List header used to link this structure to the &quot;struct epitem&quot; */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eppoll_entry</span> *<span class="hljs-title">next</span>;</span><br>	<span class="hljs-comment">/* The &quot;base&quot; pointer is set to the container &quot;struct epitem&quot; */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">base</span>;</span><br>	<span class="hljs-comment">/* Wait queue item that will be linked to the target file wait queue head.*/</span><br>	<span class="hljs-type">wait_queue_entry_t</span> wait;<br>	<span class="hljs-comment">/* The wait queue head that linked the &quot;wait&quot; wait queue item */</span><br>	<span class="hljs-type">wait_queue_head_t</span> *whead;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="3-4-回调函数ep-poll-callback"><a href="#3-4-回调函数ep-poll-callback" class="headerlink" title="3.4 回调函数ep_poll_callback"></a>3.4 回调函数ep_poll_callback</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * epoll回调函数主要的功能是将被监视文件的等待事件就绪时，</span><br><span class="hljs-comment"> * 将文件对应的epitem实例添加到就绪队列中，当用户调用epoll_wait()时，</span><br><span class="hljs-comment"> * 内核会将就绪队列中的事件报告给用户</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param wait</span><br><span class="hljs-comment"> * @param mode</span><br><span class="hljs-comment"> * @param sync</span><br><span class="hljs-comment"> * @param key</span><br><span class="hljs-comment"> * @return</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ep_poll_callback</span><span class="hljs-params">(<span class="hljs-type">wait_queue_entry_t</span> *wait, <span class="hljs-type">unsigned</span> mode, <span class="hljs-type">int</span> sync, <span class="hljs-type">void</span> *key)</span><br>&#123;<br>	<span class="hljs-type">int</span> pwake = <span class="hljs-number">0</span>;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">epi</span> =</span> ep_item_from_wait(wait);<span class="hljs-comment">//从等待队列指针获取“struct epitem”</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> *<span class="hljs-title">ep</span> =</span> epi-&gt;ep;<span class="hljs-comment">//ep控制块</span><br>	<span class="hljs-type">__poll_t</span> pollflags = key_to_poll(key);<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br>	<span class="hljs-type">int</span> ewake = <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">//获取读锁</span><br>	read_lock_irqsave(&amp;ep-&gt;lock, flags);<br><br>	ep_set_busy_poll_napi_id(epi);<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * If the event mask does not contain any poll(2) event, we consider the</span><br><span class="hljs-comment">	 * descriptor to be disabled. This condition is likely the effect of the</span><br><span class="hljs-comment">	 * EPOLLONESHOT bit that disables the descriptor when an event is received,</span><br><span class="hljs-comment">	 * until the next EPOLL_CTL_MOD will be issued.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">//如果当前epitem不感兴趣任何事件则直接跳出</span><br>	<span class="hljs-keyword">if</span> (!(epi-&gt;event.events &amp; ~EP_PRIVATE_BITS))<br>		<span class="hljs-keyword">goto</span> out_unlock;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Check the events coming with the callback. At this stage, not</span><br><span class="hljs-comment">	 * every device reports the events in the &quot;key&quot; parameter of the</span><br><span class="hljs-comment">	 * callback. We need to be able to handle both cases here, hence the</span><br><span class="hljs-comment">	 * test for &quot;key&quot; != NULL before the event match test.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (pollflags &amp;&amp; !(pollflags &amp; epi-&gt;event.events))<br>		<span class="hljs-keyword">goto</span> out_unlock;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * If we are transferring events to userspace, we can hold no locks</span><br><span class="hljs-comment">	 * (because we&#x27;re accessing user memory, and because of linux f_op-&gt;poll()</span><br><span class="hljs-comment">	 * semantics). All the events that happen during that period of time are</span><br><span class="hljs-comment">	 * chained in ep-&gt;ovflist and requeued later on.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">// ovflist默认值是EP_UNACTIVE_PTR，epoll_wait()遍历rdllist之前会把ovflist设置为NULL，</span><br>	<span class="hljs-comment">// 遍历完再恢复为EP_UNACTIVE_PTR，因此通过判断ovflist的值是不是EP_UNACTIVE_PTR可知此时rdllist是不是正在被访问。</span><br>	<span class="hljs-keyword">if</span> (READ_ONCE(ep-&gt;ovflist) != EP_UNACTIVE_PTR) &#123;<br>		<span class="hljs-keyword">if</span> (chain_epi_lockless(epi))ep_pm_stay_awake_rcu(epi);<br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!ep_is_linked(epi)) &#123;<br>		<span class="hljs-comment">/* In the usual case, add event to ready list. */</span><br>		<span class="hljs-comment">//将事件添加到就绪列表</span><br>		<span class="hljs-keyword">if</span> (list_add_tail_lockless(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist))ep_pm_stay_awake_rcu(epi);<br>	&#125;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Wake up ( if active ) both the eventpoll wait list and the -&gt;poll()</span><br><span class="hljs-comment">	 * wait list.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">//如果等待队列不为空，则将他们进行唤醒</span><br>	<span class="hljs-keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq)) &#123;<br>		<span class="hljs-keyword">if</span> ((epi-&gt;event.events &amp; EPOLLEXCLUSIVE) &amp;&amp;<br>					!(pollflags &amp; POLLFREE)) &#123;<br>			<span class="hljs-keyword">switch</span> (pollflags &amp; EPOLLINOUT_BITS) &#123;<br>			<span class="hljs-keyword">case</span> EPOLLIN:<br>				<span class="hljs-keyword">if</span> (epi-&gt;event.events &amp; EPOLLIN)<br>					ewake = <span class="hljs-number">1</span>;<br>				<span class="hljs-keyword">break</span>;<br>			<span class="hljs-keyword">case</span> EPOLLOUT:<br>				<span class="hljs-keyword">if</span> (epi-&gt;event.events &amp; EPOLLOUT)<br>					ewake = <span class="hljs-number">1</span>;<br>				<span class="hljs-keyword">break</span>;<br>			<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>				ewake = <span class="hljs-number">1</span>;<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>		&#125;<br>		<span class="hljs-comment">//唤醒等待的进程</span><br>		wake_up(&amp;ep-&gt;wq);<br>	&#125;<br>	<span class="hljs-keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))<br>		pwake++;<br><br>out_unlock:<br>	read_unlock_irqrestore(&amp;ep-&gt;lock, flags);<br><br>	<span class="hljs-comment">/* We have to call this outside the lock */</span><br>	<span class="hljs-keyword">if</span> (pwake)<br>		ep_poll_safewake(ep, epi);<br><br>	<span class="hljs-keyword">if</span> (!(epi-&gt;event.events &amp; EPOLLEXCLUSIVE))<br>		ewake = <span class="hljs-number">1</span>;<br><br>	<span class="hljs-keyword">if</span> (pollflags &amp; POLLFREE) &#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * If we race with ep_remove_wait_queue() it can miss</span><br><span class="hljs-comment">		 * -&gt;whead = NULL and do another remove_wait_queue() after</span><br><span class="hljs-comment">		 * us, so we can&#x27;t use __remove_wait_queue().</span><br><span class="hljs-comment">		 */</span><br>		list_del_init(&amp;wait-&gt;entry);<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * -&gt;whead != NULL protects us from the race with ep_free()</span><br><span class="hljs-comment">		 * or ep_remove(), ep_remove_wait_queue() takes whead-&gt;lock</span><br><span class="hljs-comment">		 * held by the caller. Once we nullify it, nothing protects</span><br><span class="hljs-comment">		 * ep/epi or even wait.</span><br><span class="hljs-comment">		 */</span><br>		smp_store_release(&amp;ep_pwq_from_wait(wait)-&gt;whead, <span class="hljs-literal">NULL</span>);<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> ewake;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-调用ep-item-poll函数"><a href="#4-调用ep-item-poll函数" class="headerlink" title="4.调用ep_item_poll函数"></a>4.调用ep_item_poll函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 核心调用</span><br><span class="hljs-comment"> * @param epi epitem 节点</span><br><span class="hljs-comment"> * @param pt poll_table </span><br><span class="hljs-comment"> * @param depth</span><br><span class="hljs-comment"> * @return</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">__poll_t</span> <span class="hljs-title function_">ep_item_poll</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> epitem *epi, poll_table *pt, <span class="hljs-type">int</span> depth)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span> =</span> epi-&gt;ffd.file;<br>	<span class="hljs-type">__poll_t</span> res;<br><br>	pt-&gt;_key = epi-&gt;event.events;<br>	<span class="hljs-keyword">if</span> (!is_file_epoll(file))<span class="hljs-comment">//不支持epoll则调用poll</span><br>		res = vfs_poll(file, pt);<br>	<span class="hljs-keyword">else</span><span class="hljs-comment">//（主线）否则调用epoll</span><br>		res = __ep_eventpoll_poll(file, pt, depth);<br>	<span class="hljs-keyword">return</span> res &amp; epi-&gt;event.events;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-1-调用-ep-eventpoll-poll"><a href="#4-1-调用-ep-eventpoll-poll" class="headerlink" title="4.1 调用 __ep_eventpoll_poll"></a>4.1 调用 __ep_eventpoll_poll</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 主线</span><br><span class="hljs-comment"> * @param file 文件</span><br><span class="hljs-comment"> * @param wait poll_table</span><br><span class="hljs-comment"> * @param depth</span><br><span class="hljs-comment"> * @return</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">__poll_t</span> __ep_eventpoll_poll(<span class="hljs-keyword">struct</span> file *file, poll_table *wait, <span class="hljs-type">int</span> depth)<br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> *<span class="hljs-title">ep</span> =</span> file-&gt;private_data;<span class="hljs-comment">//获取ep控制块</span><br>	LIST_HEAD(txlist);<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">epi</span>, *<span class="hljs-title">tmp</span>;</span><br>	poll_table pt;<br>	<span class="hljs-type">__poll_t</span> res = <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">//重置回调函数为NULL</span><br>	init_poll_funcptr(&amp;pt, <span class="hljs-literal">NULL</span>);<br>	<span class="hljs-comment">/* Insert inside our poll wait queue */</span><br>	<span class="hljs-comment">//主线</span><br>	poll_wait(file, &amp;ep-&gt;poll_wait, wait);<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Proceed to find out if wanted events are really available inside</span><br><span class="hljs-comment">	 * the ready list.</span><br><span class="hljs-comment">	 */</span><br>	mutex_lock_nested(&amp;ep-&gt;mtx, depth);<br>	<span class="hljs-comment">//</span><br>	ep_start_scan(ep, &amp;txlist);<br>	list_for_each_entry_safe(epi, tmp, &amp;txlist, rdllink) &#123;<br>		<span class="hljs-keyword">if</span> (ep_item_poll(epi, &amp;pt, depth + <span class="hljs-number">1</span>)) &#123;<br>			res = EPOLLIN | EPOLLRDNORM;<br>			<span class="hljs-keyword">break</span>;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">			 * Item has been dropped into the ready list by the poll</span><br><span class="hljs-comment">			 * callback, but it&#x27;s not actually ready, as far as</span><br><span class="hljs-comment">			 * caller requested events goes. We can remove it here.</span><br><span class="hljs-comment">			 */</span><br>			__pm_relax(ep_wakeup_source(epi));<br>			list_del_init(&amp;epi-&gt;rdllink);<br>		&#125;<br>	&#125;<br>	ep_done_scan(ep, &amp;txlist);<br>	mutex_unlock(&amp;ep-&gt;mtx);<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-2-调用poll-wait函数触发回调"><a href="#4-2-调用poll-wait函数触发回调" class="headerlink" title="4.2 调用poll_wait函数触发回调"></a>4.2 调用poll_wait函数触发回调</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用回调函数</span><br><span class="hljs-comment"> * @param filp</span><br><span class="hljs-comment"> * @param wait_address</span><br><span class="hljs-comment"> * @param p</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">poll_wait</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file * filp, <span class="hljs-type">wait_queue_head_t</span> * wait_address, poll_table *p)</span><br>&#123;<br>	<span class="hljs-keyword">if</span> (p &amp;&amp; p-&gt;_qproc &amp;&amp; wait_address)<br>        <span class="hljs-comment">//调用init_poll_funcptr设置的回调函数</span><br>		p-&gt;_qproc(filp, wait_address, p);<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><h4 id="1-调用ep-remove删除"><a href="#1-调用ep-remove删除" class="headerlink" title="1. 调用ep_remove删除"></a>1. 调用ep_remove删除</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 移除 epitem 操作</span><br><span class="hljs-comment"> * @param ep ep控制块</span><br><span class="hljs-comment"> * @param epi 需要移除的epitem</span><br><span class="hljs-comment"> * @return</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ep_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> eventpoll *ep, <span class="hljs-keyword">struct</span> epitem *epi)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span> =</span> epi-&gt;ffd.file;<span class="hljs-comment">//获取文件</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitems_head</span> *<span class="hljs-title">to_free</span>;</span><span class="hljs-comment">//epitem头指针</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_head</span> *<span class="hljs-title">head</span>;</span><br><br>	lockdep_assert_irqs_enabled();<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Removes poll wait queue hooks.</span><br><span class="hljs-comment">	 */</span><br>	ep_unregister_pollwait(ep, epi);<br><br>	<span class="hljs-comment">/* Remove the current item from the list of epoll hooks */</span><br>	spin_lock(&amp;file-&gt;f_lock);<span class="hljs-comment">//获取锁</span><br>	to_free = <span class="hljs-literal">NULL</span>;<br>	head = file-&gt;f_ep;<br>	<span class="hljs-comment">//遍历fllink获取要移除的节点</span><br>	<span class="hljs-keyword">if</span> (head-&gt;first == &amp;epi-&gt;fllink &amp;&amp; !epi-&gt;fllink.next) &#123;<br>		file-&gt;f_ep = <span class="hljs-literal">NULL</span>;<br>		<span class="hljs-keyword">if</span> (!is_file_epoll(file)) &#123;<br>			<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitems_head</span> *<span class="hljs-title">v</span>;</span><br>			v = container_of(head, <span class="hljs-keyword">struct</span> epitems_head, epitems);<br>			<span class="hljs-keyword">if</span> (!smp_load_acquire(&amp;v-&gt;next))<br>				to_free = v;<br>		&#125;<br>	&#125;<br>	hlist_del_rcu(&amp;epi-&gt;fllink);<br>	spin_unlock(&amp;file-&gt;f_lock);<br>	free_ephead(to_free);<span class="hljs-comment">//释放</span><br><br>	rb_erase_cached(&amp;epi-&gt;rbn, &amp;ep-&gt;rbr);<br><br>	write_lock_irq(&amp;ep-&gt;lock);<br>	<span class="hljs-keyword">if</span> (ep_is_linked(epi))<br>		list_del_init(&amp;epi-&gt;rdllink);<br>	write_unlock_irq(&amp;ep-&gt;lock);<br><br>	wakeup_source_unregister(ep_wakeup_source(epi));<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * At this point it is safe to free the eventpoll item. Use the union</span><br><span class="hljs-comment">	 * field epi-&gt;rcu, since we are trying to minimize the size of</span><br><span class="hljs-comment">	 * &#x27;struct epitem&#x27;. The &#x27;rbn&#x27; field is no longer in use. Protected by</span><br><span class="hljs-comment">	 * ep-&gt;mtx. The rcu read side, reverse_path_check_proc(), does not make</span><br><span class="hljs-comment">	 * use of the rbn field.</span><br><span class="hljs-comment">	 */</span><br>	call_rcu(&amp;epi-&gt;rcu, epi_rcu_free);<span class="hljs-comment">//释放</span><br><br>	percpu_counter_dec(&amp;ep-&gt;user-&gt;epoll_watches);<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-移除进程等待队列wq"><a href="#2-移除进程等待队列wq" class="headerlink" title="2.移除进程等待队列wq"></a>2.移除进程等待队列wq</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 取消注册的进程</span><br><span class="hljs-comment"> * @param ep </span><br><span class="hljs-comment"> * @param epi </span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ep_unregister_pollwait</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> eventpoll *ep, <span class="hljs-keyword">struct</span> epitem *epi)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eppoll_entry</span> **<span class="hljs-title">p</span> =</span> &amp;epi-&gt;pwqlist;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eppoll_entry</span> *<span class="hljs-title">pwq</span>;</span><br><br>	<span class="hljs-keyword">while</span> ((pwq = *p) != <span class="hljs-literal">NULL</span>) &#123;<br>		*p = pwq-&gt;next;<br>		ep_remove_wait_queue(pwq);<span class="hljs-comment">//移除</span><br>		kmem_cache_free(pwq_cache, pwq);<span class="hljs-comment">//释放内存</span><br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>


<h3 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h3><h4 id="1-调用ep-modify修改"><a href="#1-调用ep-modify修改" class="headerlink" title="1.调用ep_modify修改"></a>1.调用ep_modify修改</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 修改操作：将epi设置为感兴趣的event</span><br><span class="hljs-comment"> * @param ep控制块</span><br><span class="hljs-comment"> * @param epi epitem</span><br><span class="hljs-comment"> * @param event 更改后的事件</span><br><span class="hljs-comment"> * @return</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ep_modify</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> eventpoll *ep, <span class="hljs-keyword">struct</span> epitem *epi,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> epoll_event *event)</span><br>&#123;<br>	<span class="hljs-type">int</span> pwake = <span class="hljs-number">0</span>;<br>	poll_table pt;<br><br>	lockdep_assert_irqs_enabled();<br>	<span class="hljs-comment">//将pt的回调函数置空</span><br>	init_poll_funcptr(&amp;pt, <span class="hljs-literal">NULL</span>);<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Set the new event interest mask before calling f_op-&gt;poll();</span><br><span class="hljs-comment">	 * otherwise we might miss an event that happens between the</span><br><span class="hljs-comment">	 * f_op-&gt;poll() call and the new event set registering.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">//设置新的感兴趣的事件</span><br>	epi-&gt;event.events = event-&gt;events; <span class="hljs-comment">/* need barrier below */</span><br>	epi-&gt;event.data = event-&gt;data; <span class="hljs-comment">/* protected by mtx */</span><br>	<span class="hljs-comment">//加入唤醒源</span><br>	<span class="hljs-keyword">if</span> (epi-&gt;event.events &amp; EPOLLWAKEUP) &#123;<br>		<span class="hljs-keyword">if</span> (!ep_has_wakeup_source(epi))<br>			ep_create_wakeup_source(epi);<br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ep_has_wakeup_source(epi)) &#123;<br>		ep_destroy_wakeup_source(epi);<br>	&#125;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * The following barrier has two effects:</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * 1) Flush epi changes above to other CPUs.  This ensures</span><br><span class="hljs-comment">	 *    we do not miss events from ep_poll_callback if an</span><br><span class="hljs-comment">	 *    event occurs immediately after we call f_op-&gt;poll().</span><br><span class="hljs-comment">	 *    We need this because we did not take ep-&gt;lock while</span><br><span class="hljs-comment">	 *    changing epi above (but ep_poll_callback does take</span><br><span class="hljs-comment">	 *    ep-&gt;lock).</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * 2) We also need to ensure we do not miss _past_ events</span><br><span class="hljs-comment">	 *    when calling f_op-&gt;poll().  This barrier also</span><br><span class="hljs-comment">	 *    pairs with the barrier in wq_has_sleeper (see</span><br><span class="hljs-comment">	 *    comments for wq_has_sleeper).</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * This barrier will now guarantee ep_poll_callback or f_op-&gt;poll</span><br><span class="hljs-comment">	 * (or both) will notice the readiness of an item.</span><br><span class="hljs-comment">	 */</span><br>	smp_mb();<span class="hljs-comment">//内存屏障</span><br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Get current event bits. We can safely use the file* here because</span><br><span class="hljs-comment">	 * its usage count has been increased by the caller of this function.</span><br><span class="hljs-comment">	 * If the item is &quot;hot&quot; and it is not registered inside the ready</span><br><span class="hljs-comment">	 * list, push it inside.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">//如果在当前有准备好的事件了则将其加入到就绪队列中去</span><br>	<span class="hljs-keyword">if</span> (ep_item_poll(epi, &amp;pt, <span class="hljs-number">1</span>)) &#123;<br>		write_lock_irq(&amp;ep-&gt;lock);<br>		<span class="hljs-keyword">if</span> (!ep_is_linked(epi)) &#123;<br>			list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);<br>			ep_pm_stay_awake(epi);<br><br>			<span class="hljs-comment">/* Notify waiting tasks that events are available */</span><br>			<span class="hljs-keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))<br>				wake_up(&amp;ep-&gt;wq);<br>			<span class="hljs-keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))<br>				pwake++;<br>		&#125;<br>		write_unlock_irq(&amp;ep-&gt;lock);<br>	&#125;<br><br>	<span class="hljs-comment">/* We have to call this outside the lock */</span><br>	<span class="hljs-keyword">if</span> (pwake)<br>		ep_poll_safewake(ep, <span class="hljs-literal">NULL</span>);<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="陷入内核"><a href="#陷入内核" class="headerlink" title="陷入内核"></a>陷入内核</h3><h4 id="1-系统调用"><a href="#1-系统调用" class="headerlink" title="1.系统调用"></a>1.系统调用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">SYSCALL_DEFINE4(epoll_wait, <span class="hljs-type">int</span>, epfd, <span class="hljs-keyword">struct</span> epoll_event __user *, events,<span class="hljs-type">int</span>, maxevents, <span class="hljs-type">int</span>, timeout)<br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec64</span> <span class="hljs-title">to</span>;</span><br>	<span class="hljs-keyword">return</span> do_epoll_wait(epfd, events, maxevents,ep_timeout_to_timespec(&amp;to, timeout));<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-调用do-epoll-wait"><a href="#2-调用do-epoll-wait" class="headerlink" title="2.调用do_epoll_wait"></a>2.调用do_epoll_wait</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等待事件</span><br><span class="hljs-comment"> * @param epfd</span><br><span class="hljs-comment"> * @param events 用户空间事件</span><br><span class="hljs-comment"> * @param maxevents 最大事件数</span><br><span class="hljs-comment"> * @param to 超时时间</span><br><span class="hljs-comment"> * @return 返回准备好的事件个数/调用错误响应码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">do_epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event __user *events,<span class="hljs-type">int</span> maxevents, <span class="hljs-keyword">struct</span> timespec64 *to)</span><br>&#123;<br>	<span class="hljs-type">int</span> error;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fd</span> <span class="hljs-title">f</span>;</span><span class="hljs-comment">//文件描述符</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> *<span class="hljs-title">ep</span>;</span><span class="hljs-comment">//ep控制块</span><br><br>	<span class="hljs-comment">/* The maximum number of event must be greater than zero */</span><br>	<span class="hljs-keyword">if</span> (maxevents &lt;= <span class="hljs-number">0</span> || maxevents &gt; EP_MAX_EVENTS)<span class="hljs-keyword">return</span> -EINVAL;<br><br>	<span class="hljs-comment">/* Verify that the area passed by the user is writeable */</span><br>	<span class="hljs-comment">//检查是否能正常访问</span><br>	<span class="hljs-keyword">if</span> (!access_ok(events, maxevents * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> epoll_event)))<span class="hljs-keyword">return</span> -EFAULT;<br><br>	<span class="hljs-comment">/* Get the &quot;struct file *&quot; for the eventpoll file */</span><br>	<span class="hljs-comment">//根据epfd获取对应的fd</span><br>	f = fdget(epfd);<br>	<span class="hljs-keyword">if</span> (!f.file)<span class="hljs-keyword">return</span> -EBADF;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * We have to check that the file structure underneath the fd</span><br><span class="hljs-comment">	 * the user passed to us _is_ an eventpoll file.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">//判断当前文件是否支持epoll</span><br>	error = -EINVAL;<br>	<span class="hljs-keyword">if</span> (!is_file_epoll(f.file))<span class="hljs-keyword">goto</span> error_fput;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * At this point it is safe to assume that the &quot;private_data&quot; contains</span><br><span class="hljs-comment">	 * our own data structure.</span><br><span class="hljs-comment">	 */</span><br>	ep = f.file-&gt;private_data;<br><br>	<span class="hljs-comment">/* Time to fish for events ... */</span><br>	<span class="hljs-comment">//(主线)调用ep_poll函数</span><br>	error = ep_poll(ep, events, maxevents, to);<br><br>error_fput:<br>	fdput(f);<br>	<span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-调用ep-poll"><a href="#3-调用ep-poll" class="headerlink" title="3.调用ep_poll"></a>3.调用ep_poll</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ep_poll - Retrieves ready events, and delivers them to the caller-supplied event buffer.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @ep: Pointer to the eventpoll context.</span><br><span class="hljs-comment"> * @events: Pointer to the userspace buffer where the ready events should be stored.</span><br><span class="hljs-comment"> * @maxevents: Size (in terms of number of events) of the caller event buffer.</span><br><span class="hljs-comment"> * @timeout: Maximum timeout for the ready events fetch operation, in</span><br><span class="hljs-comment"> *           timespec. If the timeout is zero, the function will not block,</span><br><span class="hljs-comment"> *           while if the @timeout ptr is NULL, the function will block</span><br><span class="hljs-comment"> *           until at least one event has been retrieved (or an error occurred).</span><br><span class="hljs-comment"> * Return: the number of ready events which have been fetched, or an error code, in case of error.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ep_poll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> eventpoll *ep, <span class="hljs-keyword">struct</span> epoll_event __user *events,<span class="hljs-type">int</span> maxevents, <span class="hljs-keyword">struct</span> timespec64 *timeout)</span><br>&#123;<br>	<span class="hljs-type">int</span> res, eavail, timed_out = <span class="hljs-number">0</span>;<br>	u64 slack = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">wait_queue_entry_t</span> wait;<br>	<span class="hljs-type">ktime_t</span> expires, *to = <span class="hljs-literal">NULL</span>;<br><br>	lockdep_assert_irqs_enabled();<br>	<span class="hljs-comment">//是否带有超时时间</span><br>	<span class="hljs-keyword">if</span> (timeout &amp;&amp; (timeout-&gt;tv_sec | timeout-&gt;tv_nsec)) &#123;<br>		slack = select_estimate_accuracy(timeout);<br>		to = &amp;expires;<br>		*to = timespec64_to_ktime(*timeout);<br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timeout) &#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * Avoid the unnecessary trip to the wait queue loop, if the</span><br><span class="hljs-comment">		 * caller specified a non blocking operation.</span><br><span class="hljs-comment">		 */</span><br>		timed_out = <span class="hljs-number">1</span>;<br>	&#125;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * This call is racy: We may or may not see events that are being added</span><br><span class="hljs-comment">	 * to the ready list under the lock (e.g., in IRQ callbacks). For cases</span><br><span class="hljs-comment">	 * with a non-zero timeout, this thread will check the ready list under</span><br><span class="hljs-comment">	 * lock and will add to the wait queue.  For cases with a zero</span><br><span class="hljs-comment">	 * timeout, the user by definition should not care and will have to</span><br><span class="hljs-comment">	 * recheck again.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">//检查是否有可用的事件（查看rdlist）</span><br>	eavail = ep_events_available(ep);<br>	<span class="hljs-comment">//死循环</span><br>	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>		<span class="hljs-keyword">if</span> (eavail) &#123;<span class="hljs-comment">//如果已经有了可用的事件</span><br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">			 * Try to transfer events to user space. In case we get</span><br><span class="hljs-comment">			 * 0 events and there&#x27;s still timeout left over, we go</span><br><span class="hljs-comment">			 * trying again in search of more luck.</span><br><span class="hljs-comment">			 */</span><br>			<span class="hljs-comment">//(主线)尝试将事件传输到用户空间</span><br>			res = ep_send_events(ep, events, maxevents);<br>			<span class="hljs-keyword">if</span> (res)<span class="hljs-keyword">return</span> res;<br>		&#125;<br>		<span class="hljs-comment">//超时返回</span><br>		<span class="hljs-keyword">if</span> (timed_out)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>		eavail = ep_busy_loop(ep, timed_out);<br>		<span class="hljs-keyword">if</span> (eavail)<span class="hljs-keyword">continue</span>;<br>		<span class="hljs-comment">//中断</span><br>		<span class="hljs-keyword">if</span> (signal_pending(current))<span class="hljs-keyword">return</span> -EINTR;<br><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * Internally init_wait() uses autoremove_wake_function(),</span><br><span class="hljs-comment">		 * thus wait entry is removed from the wait queue on each</span><br><span class="hljs-comment">		 * wakeup. Why it is important? In case of several waiters</span><br><span class="hljs-comment">		 * each new wakeup will hit the next waiter, giving it the</span><br><span class="hljs-comment">		 * chance to harvest new event. Otherwise wakeup can be</span><br><span class="hljs-comment">		 * lost. This is also good performance-wise, because on</span><br><span class="hljs-comment">		 * normal wakeup path no need to call __remove_wait_queue()</span><br><span class="hljs-comment">		 * explicitly, thus ep-&gt;lock is not taken, which halts the</span><br><span class="hljs-comment">		 * event delivery.</span><br><span class="hljs-comment">		 */</span><br>		init_wait(&amp;wait);<br><br>		write_lock_irq(&amp;ep-&gt;lock);<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * Barrierless variant, waitqueue_active() is called under</span><br><span class="hljs-comment">		 * the same lock on wakeup ep_poll_callback() side, so it</span><br><span class="hljs-comment">		 * is safe to avoid an explicit barrier.</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-comment">//设置当前状态位任务中断</span><br>		__set_current_state(TASK_INTERRUPTIBLE);<br><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * Do the final check under the lock. ep_scan_ready_list()</span><br><span class="hljs-comment">		 * plays with two lists (-&gt;rdllist and -&gt;ovflist) and there</span><br><span class="hljs-comment">		 * is always a race when both lists are empty for short</span><br><span class="hljs-comment">		 * period of time although events are pending, so lock is</span><br><span class="hljs-comment">		 * important.</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-comment">//再次判断就绪队列</span><br>		eavail = ep_events_available(ep);<br>		<span class="hljs-keyword">if</span> (!eavail)__add_wait_queue_exclusive(&amp;ep-&gt;wq, &amp;wait);<br>		<br>		write_unlock_irq(&amp;ep-&gt;lock);<br><br>		<span class="hljs-keyword">if</span> (!eavail)timed_out = !schedule_hrtimeout_range(to, slack,HRTIMER_MODE_ABS);<br>		__set_current_state(TASK_RUNNING);<br><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * We were woken up, thus go and try to harvest some events.</span><br><span class="hljs-comment">		 * If timed out and still on the wait queue, recheck eavail</span><br><span class="hljs-comment">		 * carefully under lock, below.</span><br><span class="hljs-comment">		 */</span><br>		eavail = <span class="hljs-number">1</span>;<br><br>		<span class="hljs-keyword">if</span> (!list_empty_careful(&amp;wait.entry)) &#123;<br>			write_lock_irq(&amp;ep-&gt;lock);<br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">			 * If the thread timed out and is not on the wait queue,</span><br><span class="hljs-comment">			 * it means that the thread was woken up after its</span><br><span class="hljs-comment">			 * timeout expired before it could reacquire the lock.</span><br><span class="hljs-comment">			 * Thus, when wait.entry is empty, it needs to harvest</span><br><span class="hljs-comment">			 * events.</span><br><span class="hljs-comment">			 */</span><br>			<span class="hljs-keyword">if</span> (timed_out)eavail = list_empty(&amp;wait.entry);<br>			__remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);<br>			write_unlock_irq(&amp;ep-&gt;lock);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-拷贝事件到用户空间"><a href="#4-拷贝事件到用户空间" class="headerlink" title="4.拷贝事件到用户空间"></a>4.拷贝事件到用户空间</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 发送事件到用户空间</span><br><span class="hljs-comment"> * @param ep eventpoll控制块</span><br><span class="hljs-comment"> * @param events</span><br><span class="hljs-comment"> * @param maxevents</span><br><span class="hljs-comment"> * @return event cnt</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ep_send_events</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> eventpoll *ep,<span class="hljs-keyword">struct</span> epoll_event __user *events, <span class="hljs-type">int</span> maxevents)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">epi</span>, *<span class="hljs-title">tmp</span>;</span><br>	LIST_HEAD(txlist);<br>	poll_table pt;<br>	<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Always short-circuit for fatal signals to allow threads to make a</span><br><span class="hljs-comment">	 * timely exit without the chance of finding more events available and</span><br><span class="hljs-comment">	 * fetching repeatedly.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (fatal_signal_pending(current))<span class="hljs-keyword">return</span> -EINTR;<br>	<span class="hljs-comment">//重置poll_table回调函数</span><br>	init_poll_funcptr(&amp;pt, <span class="hljs-literal">NULL</span>);<br><br>	mutex_lock(&amp;ep-&gt;mtx);<br>	<span class="hljs-comment">//开始扫描就绪的fd</span><br>	ep_start_scan(ep, &amp;txlist);<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * We can loop without lock because we are passed a task private list.</span><br><span class="hljs-comment">	 * Items cannot vanish during the loop we are holding ep-&gt;mtx.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">//传入链表进行遍历</span><br>	list_for_each_entry_safe(epi, tmp, &amp;txlist, rdllink) &#123;<br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">wakeup_source</span> *<span class="hljs-title">ws</span>;</span><br>		<span class="hljs-type">__poll_t</span> revents;<br><br>		<span class="hljs-keyword">if</span> (res &gt;= maxevents)<span class="hljs-keyword">break</span>;<span class="hljs-comment">//超出最大长度结束循环</span><br><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * Activate ep-&gt;ws before deactivating epi-&gt;ws to prevent</span><br><span class="hljs-comment">		 * triggering auto-suspend here (in case we reactive epi-&gt;ws</span><br><span class="hljs-comment">		 * below).</span><br><span class="hljs-comment">		 *</span><br><span class="hljs-comment">		 * This could be rearranged to delay the deactivation of epi-&gt;ws</span><br><span class="hljs-comment">		 * instead, but then epi-&gt;ws would temporarily be out of sync</span><br><span class="hljs-comment">		 * with ep_is_linked().</span><br><span class="hljs-comment">		 */</span><br>		ws = ep_wakeup_source(epi);<br>		<span class="hljs-keyword">if</span> (ws) &#123;<br>			<span class="hljs-keyword">if</span> (ws-&gt;active)<br>				__pm_stay_awake(ep-&gt;ws);<br>			__pm_relax(ws);<br>		&#125;<br><br>		list_del_init(&amp;epi-&gt;rdllink);<br><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * If the event mask intersect the caller-requested one,</span><br><span class="hljs-comment">		 * deliver the event to userspace. Again, we are holding ep-&gt;mtx,</span><br><span class="hljs-comment">		 * so no operations coming from userspace can change the item.</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-comment">//(主线）调用 ep_item_poll</span><br>		revents = ep_item_poll(epi, &amp;pt, <span class="hljs-number">1</span>);<br>		<span class="hljs-keyword">if</span> (!revents)<span class="hljs-keyword">continue</span>;<span class="hljs-comment">//如果没有准备好的事件直接结束当前循环</span><br>		<span class="hljs-comment">//(主线) 拷贝事件到用户空间</span><br>		events = epoll_put_uevent(revents, epi-&gt;event.data, events);<br>		<span class="hljs-keyword">if</span> (!events) &#123;<br>			list_add(&amp;epi-&gt;rdllink, &amp;txlist);<span class="hljs-comment">//添加进链表</span><br>			ep_pm_stay_awake(epi);<br>			<span class="hljs-keyword">if</span> (!res)res = -EFAULT;<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>		res++;<br>		<span class="hljs-keyword">if</span> (epi-&gt;event.events &amp; EPOLLONESHOT)epi-&gt;event.events &amp;= EP_PRIVATE_BITS;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(epi-&gt;event.events &amp; EPOLLET)) &#123;<span class="hljs-comment">//边缘触发方式</span><br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">			 * If this file has been added with Level</span><br><span class="hljs-comment">			 * Trigger mode, we need to insert back inside</span><br><span class="hljs-comment">			 * the ready list, so that the next call to</span><br><span class="hljs-comment">			 * epoll_wait() will check again the events</span><br><span class="hljs-comment">			 * availability. At this point, no one can insert</span><br><span class="hljs-comment">			 * into ep-&gt;rdllist besides us. The epoll_ctl()</span><br><span class="hljs-comment">			 * callers are locked out by</span><br><span class="hljs-comment">			 * ep_scan_ready_list() holding &quot;mtx&quot; and the</span><br><span class="hljs-comment">			 * poll callback will queue them in ep-&gt;ovflist.</span><br><span class="hljs-comment">			 */</span><br>			list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);<span class="hljs-comment">//添加进链表</span><br>			ep_pm_stay_awake(epi);<br>		&#125;<br>	&#125;<br>	ep_done_scan(ep, &amp;txlist);<span class="hljs-comment">//完成扫描</span><br>	mutex_unlock(&amp;ep-&gt;mtx);<br><br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-1调用ep-start-scan"><a href="#4-1调用ep-start-scan" class="headerlink" title="4.1调用ep_start_scan"></a>4.1调用ep_start_scan</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * ep-&gt;mutex needs to be held because we could be hit by</span><br><span class="hljs-comment"> * eventpoll_release_file() and epoll_ctl().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ep_start_scan</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> eventpoll *ep, <span class="hljs-keyword">struct</span> list_head *txlist)</span><br>&#123;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Steal the ready list, and re-init the original one to the</span><br><span class="hljs-comment">	 * empty list. Also, set ep-&gt;ovflist to NULL so that events</span><br><span class="hljs-comment">	 * happening while looping w/out locks, are not lost. We cannot</span><br><span class="hljs-comment">	 * have the poll callback to queue directly on ep-&gt;rdllist,</span><br><span class="hljs-comment">	 * because we want the &quot;sproc&quot; callback to be able to do it</span><br><span class="hljs-comment">	 * in a lockless way.</span><br><span class="hljs-comment">	 */</span><br>	lockdep_assert_irqs_enabled();<br>	write_lock_irq(&amp;ep-&gt;lock);<br>	list_splice_init(&amp;ep-&gt;rdllist, txlist);<span class="hljs-comment">//拼接两个链表</span><br>	WRITE_ONCE(ep-&gt;ovflist, <span class="hljs-literal">NULL</span>);<span class="hljs-comment">//写入ovflist链表</span><br>	write_unlock_irq(&amp;ep-&gt;lock);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-2调用ep-done-scan"><a href="#4-2调用ep-done-scan" class="headerlink" title="4.2调用ep_done_scan"></a>4.2调用ep_done_scan</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ep_done_scan</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> eventpoll *ep,<span class="hljs-keyword">struct</span> list_head *txlist)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">epi</span>, *<span class="hljs-title">nepi</span>;</span><br><br>	write_lock_irq(&amp;ep-&gt;lock);<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * During the time we spent inside the &quot;sproc&quot; callback, some</span><br><span class="hljs-comment">	 * other events might have been queued by the poll callback.</span><br><span class="hljs-comment">	 * We re-insert them inside the main ready-list here.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">for</span> (nepi = READ_ONCE(ep-&gt;ovflist); (epi = nepi) != <span class="hljs-literal">NULL</span>;<br>	     nepi = epi-&gt;next, epi-&gt;next = EP_UNACTIVE_PTR) &#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * We need to check if the item is already in the list.</span><br><span class="hljs-comment">		 * During the &quot;sproc&quot; callback execution time, items are</span><br><span class="hljs-comment">		 * queued into -&gt;ovflist but the &quot;txlist&quot; might already</span><br><span class="hljs-comment">		 * contain them, and the list_splice() below takes care of them.</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (!ep_is_linked(epi)) &#123;<br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">			 * -&gt;ovflist is LIFO, so we have to reverse it in order</span><br><span class="hljs-comment">			 * to keep in FIFO.</span><br><span class="hljs-comment">			 */</span><br>			list_add(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);<span class="hljs-comment">//添加到链表</span><br>			ep_pm_stay_awake(epi);<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * We need to set back ep-&gt;ovflist to EP_UNACTIVE_PTR, so that after</span><br><span class="hljs-comment">	 * releasing the lock, events will be queued in the normal way inside</span><br><span class="hljs-comment">	 * ep-&gt;rdllist.</span><br><span class="hljs-comment">	 */</span><br>	WRITE_ONCE(ep-&gt;ovflist, EP_UNACTIVE_PTR);<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Quickly re-inject items left on &quot;txlist&quot;.</span><br><span class="hljs-comment">	 */</span><br>	list_splice(txlist, &amp;ep-&gt;rdllist);<span class="hljs-comment">//拼接</span><br>	__pm_relax(ep-&gt;ws);<br><br>	<span class="hljs-keyword">if</span> (!list_empty(&amp;ep-&gt;rdllist)) &#123;<br>		<span class="hljs-keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))<br>			wake_up(&amp;ep-&gt;wq);<br>	&#125;<br>	<span class="hljs-comment">//释放锁</span><br>	write_unlock_irq(&amp;ep-&gt;lock);<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="流程图示-2"><a href="#流程图示-2" class="headerlink" title="流程图示"></a>流程图示</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/2630542/1661789691774-9cc87ec9-bf2a-46b7-af53-e4d2d8ae3326.jpeg" srcset="/img/loading.gif" lazyload></p>
<h3 id="相关总结-2"><a href="#相关总结-2" class="headerlink" title="相关总结"></a>相关总结</h3><p>和select/poll相比，epoll进行了功能分离，将添加进阻塞队列和等待数据进行分离，先用 epoll_ctl 维护等待队列，再调用 epoll_wait 阻塞进程。具体流程是先用epoll_create 创建一个 epoll 对象 epfd，再通过 epoll_ctl 将需要监视的 socket 添加到 epfd 中，最后调用 epoll_wait 等待数据。</p>
<p>优点：</p>
<ul>
<li>相比 select/poll，epoll 拆分了功能，将操作和监听分离，操作粒度更小，效率更高</li>
<li>epoll采用回调方式将其准备好的fd加入就绪链表，用户进程无需遍历整个fd集</li>
</ul>
<p>缺点：</p>
<ul>
<li>epoll适合的是大量连接但操作不平凡的socket，如果是少了连接且触发频繁select和poll效率可能会更高</li>
</ul>
<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/find/master">https://github.com/torvalds/linux/find/master</a><br><a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2022/pdf/2630542/1659327995071-4a68745c-73bd-43f6-9349-cf75533a9b2f.pdf?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2022/pdf/2630542/1659327995071-4a68745c-73bd-43f6-9349-cf75533a9b2f.pdf%22,%22name%22:%22Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.pdf%22,%22size%22:34037912,%22type%22:%22application/pdf%22,%22ext%22:%22pdf%22,%22source%22:%22%22,%22status%22:%22done%22,%22mode%22:%22title%22,%22download%22:true,%22taskId%22:%22u61d08399-4835-4f65-a603-d24327a232d%22,%22taskType%22:%22upload%22,%22__spacing%22:%22both%22,%22id%22:%22u390d6afb%22,%22margin%22:%7B%22top%22:true,%22bottom%22:true%7D,%22card%22:%22file%22%7D">Linux高性能服务器编程.pdf</a><br><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/find/master">
</a></p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="category-chain-item">网络编程</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>网络编程-Linux高性能服务器编程</div>
      <div>https://mikeygithub.github.io/2022/09/15/yuque/cp0k82/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Mikey</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年9月15日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/10/01/yuque/bbzd4a/" title="Rust-学习笔记">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Rust-学习笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/09/01/yuque/qmcirn/" title="性能调优-内存泄露的排查方法">
                        <span class="hidden-mobile">性能调优-内存泄露的排查方法</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'mikeygithub/commit-utterance');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  





  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.13.10/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});
  });
</script>




  <!-- Custom -->
  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" lazyload class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       Copyright © 麦奇 Powered by <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> and <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> core on github page 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      桂ICP备2020009931号-1
    </a>
  </span>
  
    
      <span>
        <a
          href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=2020009931"
          rel="nofollow noopener"
          class="beian-police"
          target="_blank"
        >
          
            <span style="visibility: hidden; width: 0">|</span>
            <img src="/img/police_beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
          
          <span>桂公网安备2020009931号</span>
        </a>
      </span>
    
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?74301a15e5497361e93588eeee69f4b2";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  
    <!-- Google Analytics -->
    <script defer>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript('https://www.google-analytics.com/analytics.js', function() {
          window.ga = window.ga || function() { (ga.q = ga.q || []).push(arguments) };
          ga.l = +new Date;
          ga('create', 'G-NCN3Z5PSLJ', 'auto');
          ga('send', 'pageview');
        });
      }
    </script>
  

  

  

  

  

  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        MathJax = {
          tex    : {
            inlineMath: { '[+]': [['$', '$']] }
          },
          loader : {
            load: ['ui/lazy']
          },
          options: {
            renderActions: {
              findScript    : [10, doc => {
                document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                  const display = !!node.type.match(/; *mode=display/);
                  const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                  const text = document.createTextNode('');
                  node.parentNode.replaceChild(text, node);
                  math.start = { node: text, delim: '', n: 0 };
                  math.end = { node: text, delim: '', n: 0 };
                  doc.math.push(math);
                });
              }, '', false],
              insertedScript: [200, () => {
                document.querySelectorAll('mjx-container').forEach(node => {
                  let target = node.parentNode;
                  if (target.nodeName.toLowerCase() === 'li') {
                    target.parentNode.classList.add('has-jax');
                  }
                });
              }, '', false]
            }
          }
        };
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.0/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
