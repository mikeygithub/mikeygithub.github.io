

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <meta name="referrer" content="no-referrer"/>
  <link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/favicon.png">
  <link rel="icon" href="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Mikey">
  <meta name="keywords" content="">
  
    <meta name="description" content="前言Rust 和 WebAssembly 是当前非常热门的技术，它们都具有非常强大的性能和安全性。Rust 是一种系统级编程语言，具有内存安全、并发性和高效性等特点。WebAssembly 是一种新型的低级字节码，可以在浏览器中运行高性能的应用程序。Rust 与 WebAssembly 的结合可以让我们在 Web 上构建出更高效、更安全的应用程序。 本篇文章将介绍 Rust 和 WebAssem">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust wasm 的探索与实践">
<meta property="og:url" content="https://mikeygithub.github.io/2023/04/20/yuque/Rust%20wasm%20%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E8%B7%B5/index.html">
<meta property="og:site_name" content="麦奇">
<meta property="og:description" content="前言Rust 和 WebAssembly 是当前非常热门的技术，它们都具有非常强大的性能和安全性。Rust 是一种系统级编程语言，具有内存安全、并发性和高效性等特点。WebAssembly 是一种新型的低级字节码，可以在浏览器中运行高性能的应用程序。Rust 与 WebAssembly 的结合可以让我们在 Web 上构建出更高效、更安全的应用程序。 本篇文章将介绍 Rust 和 WebAssem">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/2630542/1681973325424-053404d4-53ae-4914-b46e-185859a15ced.png">
<meta property="article:published_time" content="2023-04-20T15:24:22.000Z">
<meta property="article:modified_time" content="2024-04-03T16:09:55.000Z">
<meta property="article:author" content="Mikey">
<meta property="article:tag" content="wasm">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2023/png/2630542/1681973325424-053404d4-53ae-4914-b46e-185859a15ced.png">
  
  
<!--    <meta name="referrer" content="no-referrer-when-downgrade">-->
  
  
  <title>Rust wasm 的探索与实践 - 麦奇</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"mikeygithub.github.io","root":"/","version":"1.9.1","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":200}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"74301a15e5497361e93588eeee69f4b2","google":"G-NCN3Z5PSLJ","gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="麦奇" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>麦奇</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/photo/">
                <i class="iconfont icon-image"></i>
                照片
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/music/">
                <i class="iconfont icon-music"></i>
                音乐
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/atom.xml">
                <i class="iconfont icon-rss"></i>
                RSS
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://cdn.nlark.com/yuque/0/2022/png/2630542/1651338804824-c3567992-2841-42e6-85b2-90ff83da2674.png?x-oss-process=image%2Fformat%2Cwebp%2Fresize%2Cw_2276%2Climit_0') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Rust wasm 的探索与实践"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Mikey
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-04-20 23:24" pubdate>
          2023年4月20日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          20k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          166 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Rust wasm 的探索与实践</h1>
            
            <div class="markdown-body">
              
              <p><img src="https://cdn.nlark.com/yuque/0/2023/png/2630542/1681973325424-053404d4-53ae-4914-b46e-185859a15ced.png#averageHue=%23bcb6e0&clientId=u253087b4-9a5c-4&from=paste&height=225&id=u986887aa&originHeight=450&originWidth=650&originalType=binary%E2%88%B6=2&rotation=0&showTitle=false&size=39372&status=done&style=none&taskId=u7d7be08d-8ad1-4bfc-8995-7b5588faa78&title=&width=325" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Rust 和 WebAssembly 是当前非常热门的技术，它们都具有非常强大的性能和安全性。Rust 是一种系统级编程语言，具有内存安全、并发性和高效性等特点。WebAssembly 是一种新型的低级字节码，可以在浏览器中运行高性能的应用程序。Rust 与 WebAssembly 的结合可以让我们在 Web 上构建出更高效、更安全的应用程序。</p>
<p>本篇文章将介绍 Rust 和 WebAssembly 的基础知识，包括如何使用 Rust 编写 WebAssembly 模块，如何在 Rust 和 JavaScript 之间进行互操作，以及如何将 Rust wasm 发布到 npm 上。此外，我们还将介绍一些实际的 Rust wasm 项目案例，并对 Rust wasm 的优势和未来展望进行讨论。</p>
<h2 id="Rust-语言简介"><a href="#Rust-语言简介" class="headerlink" title="Rust 语言简介"></a>Rust 语言简介</h2><p>Rust 是一种由 Mozilla 开发的系统级编程语言，它结合了 C++ 和其他现代编程语言的优点。Rust 具有内存安全、并发性和高效性等特点，可以用于构建高性能的系统级应用程序。Rust 的设计目标是为了提供一个安全、并发和高效的编程语言。Rust 的语法类似于 C 和 C++，但是 Rust 有一些独特的特性，使其比传统的系统编程语言更加安全和可靠。</p>
<p>以下是 Rust 的一些主要特性：</p>
<ol>
<li><p>内存安全：Rust 的内存安全特性可以防止一些常见的内存错误，例如空指针、野指针和数据竞争等问题。Rust 的所有权系统确保内存管理的正确性。</p>
</li>
<li><p>零成本抽象：Rust 支持高级抽象，例如泛型和 trait，但是这些抽象在编译时会被完全展开，从而避免了运行时开销。</p>
</li>
<li><p>并发安全：Rust 支持线程安全和并发编程。Rust 的所有权系统可以保证多线程程序的正确性。</p>
</li>
<li><p>高性能：Rust 的编译器可以生成高效的本机代码，使其在性能方面与 C 和 C++ 相当。</p>
</li>
<li><p>开放源代码：Rust 是一个开放源代码项目，任何人都可以参与开发和改进。</p>
</li>
</ol>
<p>Rust 的应用领域包括操作系统、网络服务器、游戏引擎、嵌入式设备等。Rust 的生态系统非常丰富，拥有许多优秀的库和框架，可以用于各种应用场景。</p>
<p>Rust 的一大特点是它的<strong>所有权系统</strong>。所有权系统是 Rust 的一项内存管理功能，它确保内存分配和回收的正确性。在 Rust 中，每个值都有一个所有者，当所有者离开作用域时，值就会被释放。这种内存管理方式可以防止空指针和内存泄漏等问题。</p>
<h2 id="WebAssembly-简介"><a href="#WebAssembly-简介" class="headerlink" title="WebAssembly 简介"></a>WebAssembly 简介</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/2630542/1682261587670-66a6ada0-94cb-463b-9326-f49ef9582572.png#averageHue=%23f8f4ef&clientId=ud123310a-0087-4&from=paste&height=288&id=u5afd3697&originHeight=576&originWidth=1209&originalType=binary%E2%88%B6=2&rotation=0&showTitle=false&size=120917&status=done&style=none&taskId=u590b2e3a-39ad-4c93-8a3b-fb332f942ed&title=&width=604.5" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p><strong>WebAssembly</strong>或称<strong>wasm</strong>是一个<strong>低级编程语言</strong>。WebAssembly是便携式的<strong>抽象语法树</strong>，被设计来提供比JavaScript更快速的编译及执行。WebAssembly将让开发者能运用自己熟悉的编程语言（最初以C/C++作为实现目标）编译，再藉虚拟机引擎在浏览器内执行。WebAssembly的开发团队分别来自Mozilla、Google、Microsoft、Apple，代表着四大网络浏览器Firefox、Chrome、Microsoft Edge、Safari。2017年11月，以上四个浏览器都开始实验性的支持WebAssembly。在 2019 年 12 月 5 日，W3C制定《WebAssembly 核心规范 》，WebAssembly 正式被认证为 <strong>Web 的标准之一</strong>。</p>
<p>以下是 <strong>WebAssembly</strong> 的一些主要特点：</p>
<ul>
<li><p><strong>高效且快速</strong>：Wasm 堆栈机器被设计为使用高效的二进制格式进行编码，以实现快速的加载和执行。WebAssembly 旨在利用广泛平台上可用的通用硬件功能，在本机速度下执行。</p>
</li>
<li><p><strong>安全：</strong>WebAssembly 提供了内存安全的沙盒执行环境，可以在现有的 JavaScript 虚拟机中实现。当嵌入到 Web 中时，WebAssembly 将遵循浏览器的同源和权限安全策略，确保安全性。</p>
</li>
<li><p><strong>开放且可调试：</strong>WebAssembly 旨在以文本格式进行更好的打印，以便用于调试、测试、实验、优化、学习、教学和手动编写程序。在网络上查看 Wasm 模块的源代码时将使用文本格式，使得开发人员可以更轻松地调试和优化代码。</p>
</li>
<li><p><strong>开放式 web 平台的一部分：</strong>WebAssembly 旨在保持 web 的无版本、经过功能测试和向后兼容的特性。WebAssembly 模块可以调用和被 JavaScript 上下文调用，并且可以通过可从 JavaScript 访问的相同 Web API 访问浏览器功能。此外，WebAssembly 还支持非网络嵌入，为更广泛的应用场景提供了支持。</p>
</li>
</ul>
<p>WebAssembly 与 JavaScript 不同，它是一种真正的<strong>二进制格式</strong>，可以直接在浏览器中运行，而不需要像 JavaScript 那样先被解释成字节码。这意味着 WebAssembly 的性能比 JavaScript 更好，并且可以被用于更高效的计算密集型任务。</p>
<h1 id="Rust-与-WebAssembly"><a href="#Rust-与-WebAssembly" class="headerlink" title="Rust 与 WebAssembly"></a>Rust 与 WebAssembly</h1><p>Rust 与 WebAssembly 的结合可以让我们在 Web 上构建出更高效、更安全的应用程序。Rust 可以编译成 WebAssembly 模块，这些模块可以在浏览器中运行，提供更快、更安全的性能。</p>
<h2 id="安装-Rust-和-WebAssembly-工具"><a href="#安装-Rust-和-WebAssembly-工具" class="headerlink" title="安装 Rust 和 WebAssembly 工具"></a>安装 Rust 和 WebAssembly 工具</h2><p>wasm-pack : <a target="_blank" rel="noopener" href="https://rustwasm.github.io/wasm-pack/installer/">https://rustwasm.github.io/wasm-pack/installer/</a><br>wasm-pack 是一个用于构建、测试和发布 Rust 和 WebAssembly 应用程序的工具，可以让我们快速、简单地将 Rust 代码编译为 WebAssembly 模块。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">curl https:<span class="hljs-comment">//rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh</span><br></code></pre></td></tr></table></figure>

<h2 id="Rust-编写-WebAssembly-代码"><a href="#Rust-编写-WebAssembly-代码" class="headerlink" title="Rust 编写 WebAssembly 代码"></a>Rust 编写 WebAssembly 代码</h2><ol>
<li><p>创建一个 Rust 应用程序，并将其编写为库（library）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">cargo new rust-wasm<br></code></pre></td></tr></table></figure>
</li>
<li><p>在应用程序的根目录下创建一个名为 Cargo.toml 的文件，并添加以下内容：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">#这个配置告诉 Rust 的包管理器 Cargo 将应用程序编译为动态链接库（dylib），这是 WebAssembly 模块所需的格式。</span><br><span class="hljs-section">[lib]</span><br><span class="hljs-attr">crate-type</span> = [<span class="hljs-string">&quot;cdylib&quot;</span>]<br><br><span class="hljs-section">[dependencies]</span><br><span class="hljs-comment">#用于将 Rust 代码编译为 WebAssembly 模块的库。</span><br><span class="hljs-attr">wasm-bindgen</span> = <span class="hljs-string">&quot;0.2&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>在应用程序的根目录下创建一个名为 src/lib.rs 的文件，并在其中编写 Rust 代码。你可以使用 #[wasm_bindgen] 注解将 Rust 函数导出为 JavaScript 函数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> wasm_bindgen::prelude::*;<br><br><span class="hljs-meta">#[wasm_bindgen]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(a: <span class="hljs-type">i32</span>, b: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    a + b<br>&#125;<br></code></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Rust-编译成-WebAssembly"><a href="#Rust-编译成-WebAssembly" class="headerlink" title="Rust 编译成 WebAssembly"></a>Rust 编译成 WebAssembly</h2><p>rust编译成wasm的方式有两种，一种是通过 wasm-pack，另一种通过 cargo build –target wasm32-unknown-unknown</p>
<ol>
<li><p>通过 wasm-pack 进行构造wasm</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">wasm-pack build --target web<br></code></pre></td></tr></table></figure>
<p>生成目标文件</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust">pkg<br>├── README.md<br>├── package.json<br>├── rust_wasm.d.ts<br>├── rust_wasm.js<br>├── rust_wasm_bg.wasm<br>└── rust_wasm_bg.wasm.d.ts<br></code></pre></td></tr></table></figure>
<p>wasm-pack 生成构建后的包相比 cargo 直接构建生成文件的会更丰富，能够方便我们快速的调用wasm</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script type=<span class="hljs-string">&quot;module&quot;</span>&gt;<br>  <span class="hljs-keyword">import</span> init, &#123;calc_fib&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./pkg/rust_wasm.js&quot;</span>;<br><span class="hljs-title function_">init</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// greet(&quot;WebAssembly&quot;);</span><br>  <span class="hljs-comment">// 开始计时</span><br>  <span class="hljs-keyword">const</span> st = performance.<span class="hljs-title function_">now</span>();<br>  <span class="hljs-keyword">const</span> ret = <span class="hljs-title function_">calc_fib</span>(<span class="hljs-number">40</span>)<br>  <span class="hljs-comment">// 结束计时</span><br>  <span class="hljs-keyword">const</span> et = performance.<span class="hljs-title function_">now</span>();<br>  <span class="hljs-comment">// 计算执行时间</span><br>  <span class="hljs-keyword">const</span> edt = et - st;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`rust-wasm 代码执行时间为 <span class="hljs-subst">$&#123;edt&#125;</span> 毫秒 <span class="hljs-subst">$&#123;ret&#125;</span>`</span>);<br><br>&#125;);<br><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p>通过 cargo 指定构建目标为wasm32-unknown-unknown 进行构建，它会将 Rust 代码编译成 WebAssembly 模块。我们可以使用 cargo 工具来编译 Rust 代码，命令如下：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">cargo <span class="hljs-keyword">build</span> --target wasm32-<span class="hljs-keyword">unknown</span>-<span class="hljs-keyword">unknown</span><br></code></pre></td></tr></table></figure>

</li>
</ol>
<p>这个命令会将 Rust 代码编译成 WebAssembly 模块，并生成一个 .wasm 文件。我们可以在js中进行导入使用</p>
<h1 id="Rust-wasm-运行原理"><a href="#Rust-wasm-运行原理" class="headerlink" title="Rust wasm 运行原理"></a>Rust wasm 运行原理</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/2630542/1682262262837-19c3b49b-8405-4d96-8c71-b1af07e1cb63.jpeg#averageHue=%23f6e9e3&clientId=ud123310a-0087-4&from=ui&height=284&id=uea464ebd&originHeight=1145&originWidth=2048&originalType=binary%E2%88%B6=2&rotation=0&showTitle=false&size=99492&status=done&style=none&taskId=u7de623f3-151d-4157-83bf-550e027d605&title=&width=508" srcset="/img/loading.gif" lazyload alt="a.jpeg"><br>rust编译成wasm主要是通过rust wasm的工具链来实现</p>
<h2 id="JavaScript运行原理"><a href="#JavaScript运行原理" class="headerlink" title="JavaScript运行原理"></a>JavaScript运行原理</h2><p>JavaScript引擎是一种实现JavaScript语言的解释器或编译器，它负责解释和执行JavaScript代码，实现网页的动态交互和功能。JavaScript引擎的核心概念和技术：</p>
<ol>
<li>解释器和编译器：JavaScript引擎通常包含解释器和编译器两个部分。解释器可以快速解释和执行JavaScript代码，但是性能较低；编译器可以将JavaScript代码编译为机器码，实现更高的性能，但是需要额外的编译时间和空间。</li>
<li>JIT编译：JavaScript引擎通常采用JIT（Just-In-Time）编译技术，将JavaScript代码编译为本地机器码，并缓存编译结果，以提高代码执行的性能。</li>
<li>内存管理：JavaScript引擎需要负责管理内存的分配和释放，避免内存泄漏和内存溢出等问题。</li>
<li>优化技术：JavaScript引擎通常采用多种优化技术，例如内联缓存、代码消除、循环展开等，以提高代码的执行效率和响应速度。</li>
<li>跨平台支持：JavaScript引擎需要支持多种平台和操作系统，例如浏览器、移动设备等。</li>
</ol>
<p>常见的JavaScript引擎包括V8、SpiderMonkey、JavaScriptCore等。其中，V8是Google开发的JavaScript引擎，在Chrome浏览器中得到广泛应用，具有高性能和低内存占用的特点。JavaScript引擎是实现JavaScript语言的核心技术之一，它的性能和功能对于网页的交互和用户体验至关重要。</p>
<p>V8引擎的结构可以分为两个主要部分：解析器和执行引擎。</p>
<p><strong>解析器</strong></p>
<p>解析器的主要任务是将JavaScript代码转换成抽象语法树（AST）。解析器包括以下组件：</p>
<ul>
<li>词法分析器（tokenizer）：将代码分解成单个的标记（tokens），例如变量名、操作符和关键字。</li>
<li>语法分析器（parser）：将标记序列转换成抽象语法树（AST）。</li>
<li>解释器（interpreter）：执行AST并生成字节码，字节码是一种介于AST和机器码之间的中间码。</li>
</ul>
<p><strong>执行引擎</strong></p>
<p>执行引擎的主要任务是执行AST并将其转换成机器码。执行引擎包括以下组件：</p>
<ul>
<li>编译器（compiler）：将字节码转换成机器码。</li>
<li>垃圾回收器（garbage collector）：自动管理内存，回收不再使用的内存。</li>
<li>最优化编译器（optimizer）：对代码进行优化，以提高执行性能。</li>
</ul>
<p><strong>V8引擎</strong>使用了即时编译（JIT）的技术，它可以动态地将解释器生成的字节码转换成机器码，并且在代码执行时进行优化，以提高代码的执行速度</p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/2630542/1682225816802-6c2c25df-07f4-401f-b0d0-7e22bae94fa9.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>代码输入：JavaScript引擎接收JavaScript代码作为输入。</p>
<p>词法分析：JavaScript引擎将代码分解为一系列的token，每个token表示一个词法单元，例如关键字、运算符、变量名等。</p>
<p>语法分析：JavaScript引擎将token流转换为抽象语法树（AST），表示代码的语法结构和逻辑。</p>
<p>生成字节码：JavaScript引擎将AST转换为字节码，这是一种中间形式的代码表示，用于优化和执行。</p>
<p>JIT编译器：JavaScript引擎使用JIT编译器将字节码编译为本地机器码，以提高代码的执行效率和响应速度。</p>
<p>生成机器码：JavaScript引擎将编译后的机器码存储在内存中，用于后续的代码执行。</p>
<p>代码执行：JavaScript引擎执行机器码，实现代码的动态交互和功能。</p>
<h2 id="WebAssmbly运行原理"><a href="#WebAssmbly运行原理" class="headerlink" title="WebAssmbly运行原理"></a>WebAssmbly运行原理</h2><p>WebAssembly 之所以比 JavaScript 更高效，是因为它的设计和实现可以更好地利用计算机硬件的特性。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/2630542/1682225818815-1761a2d8-25b7-4b6a-af1f-dfba673eccf7.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>WebAssembly 是一种低级字节码格式，它的指令集是基于栈的，可以直接映射到底层硬件的指令集，从而实现更好的性能。与之相比，JavaScript 是一种高级语言，其代码需要经过解释器的解释和执行，还需要进行垃圾回收、动态类型检查等操作，这些都会带来一定的性能开销。</p>
<p>WebAssembly 还提供了一些优化的特性，如本地变量、线性内存等，可以使得代码的性能更加高效。WebAssembly 的线性内存模型允许程序直接访问内存，而不需要通过 JavaScript 中的 ArrayBuffer 对象等中间层，从而避免了不必要的拷贝操作，提高了内存访问的效率。</p>
<p>WebAssembly 还支持多线程，并提供了原子操作和共享内存等机制，可以更好地利用现代计算机的多核心处理能力，实现并行计算，进一步提高程序的性能。相比之下，JavaScript 的架构主要是基于<strong>事件驱动</strong>的，通过事件驱动机制实现异步编程，避免了阻塞主线程，提高了程序的响应性。但是，由于 JavaScript 是一种高级语言，其代码需要经过解释器的解释和执行，因此在性能上不如 WebAssembly。同时，JavaScript 的内存管理由垃圾回收器负责，会带来一定的运行时开销。此外，JavaScript 并不直接支持多线程，虽然可以通过 Web Workers 等机制实现并发，但是相对来说还是比较复杂和低效的。</p>
<p>综上所述，WebAssembly 通过优化其设计和实现，可以更好地利用计算机硬件的特性，从而实现更高效的性能。而 JavaScript 则主要是通过事件循环机制实现异步编程，提高程序的响应性，但在性能上不如 WebAssembly。</p>
<p><strong>对比</strong></p>
<p>webassembly和js的运行原理有以下几点不同：</p>
<ul>
<li>webassembly的字节码和底层机器码很相似，可以快速地被浏览器解码和验证，并且不需要进行额外的优化。js则需要经过多个步骤才能转换成机器码，例如词法分析，语法分析，抽象语法树生成，字节码生成，即时编译和优化等。</li>
<li>webassembly是一种静态类型的语言，它的数据类型和内存布局都是在编译时确定的，并且可以直接操作内存。js则是一种动态类型的语言，它的数据类型和内存管理都是在运行时确定的，并且需要通过<strong>垃圾回收机制</strong>来释放内存。</li>
<li>webassembly可以利用多种语言的特性和优势，例如C/C++的底层性能和Rust的内存安全等。js则只能使用JavaScript提供的功能和API。</li>
<li>webassembly支持多线程，js只能单线程运行</li>
</ul>
<p>综上所述，wasm比js高效的原因主要有以下几点：</p>
<ul>
<li>wasm可以更快地被浏览器加载和执行，减少了网络传输和解析编译的时间。</li>
<li>wasm可以更直接地访问和操作内存，提高了运行时的性能。</li>
<li>wasm可以使用多种语言编写，充分利用各种语言的优势</li>
</ul>
<h2 id="Low-Level-Virtual-Machine"><a href="#Low-Level-Virtual-Machine" class="headerlink" title="Low Level Virtual Machine"></a>Low Level Virtual Machine</h2><p>LLVM（low level virtual machine） 是一个开源的编译器框架，提供了一组模块化的工具和库，可用于构建编译器、调试器、静态分析工具等软件。</p>
<p>LLVM 的核心组件是一个面向对象的中间语言 (Intermediate Representation, IR)，称为 LLVM IR。LLVM IR 是一种低级别的汇编语言，可以被转换成多种目标平台的机器码。</p>
<p>LLVM 可以将 LLVM IR 编译成多种目标平台的机器码，包括 x86、ARM、MIPS 等常见的处理器架构，以及 WebAssembly 等新兴的目标平台。这使得 LLVM 成为一个通用的编译器框架，可以用于构建多种语言和多种目标平台的编译器。</p>
<p>LLVM 还提供了一组优化工具，可以对 LLVM IR 进行各种优化，从而提高生成的代码的性能和质量。这些优化包括删除无用代码、提取常量、内联函数、循环优化等。<br>Rust 编译器使用 LLVM 作为其后端，将 Rust 代码编译成 LLVM IR，然后将其转换成目标平台的机器码。这使得 Rust 可以跨平台编译，同时也为 Rust 提供了强大的优化能力。</p>
<p>LLVM有两个特点：</p>
<p>（1）LLVM有一个<strong>特定指令格式</strong>的IR语言，我们可以通过书写Pass来对其IR进行优化。<br>（2）可以作为多种语言的后端，提供与编程语言无关的优化和针对多种CPU的代码生成功能。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/2630542/1682225147288-664b3bb7-bb68-4baf-9769-24ed86075d67.png#averageHue=%23f8f8f8&clientId=u8a28cd20-937d-4&from=paste&height=242&id=u63904ec0&originHeight=224&originWidth=640&originalType=binary%E2%88%B6=2&rotation=0&showTitle=false&size=66950&status=done&style=none&taskId=u98b2c670-2bd8-4ffd-a480-d0a95106d06&title=&width=692" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>Rust 代码被编译成 WebAssembly 代码是通过以下步骤完成的：</p>
<ol>
<li><p>Rust 代码被编译成中间语言 LLVM IR<br>Rust 代码首先被编译成中间语言 LLVM IR (Intermediate Representation)，这是一种低级别的汇编语言，可以被转换成多种目标平台的机器码。LLVM 是一个开源的编译器框架，它支持多种语言和多种目标平台。</p>
</li>
<li><p>LLVM IR 被编译成 WebAssembly 二进制格式<br>LLVM IR 被编译成 WebAssembly 二进制格式的过程由 LLVM 工具链中的 wasm-llvm 工具完成。这个工具将 LLVM IR 转换成 WebAssembly 二进制格式，同时生成 WebAssembly 模块的导入和导出声明。</p>
</li>
<li><p>WebAssembly 模块被优化<br>生成的 WebAssembly 模块可以进行进一步的优化，以提高性能。这可以通过使用工具如 wasm-opt 来进行优化。wasm-opt 可以应用一系列优化，例如删除无用代码、提取常量、缩减代码大小等。</p>
</li>
<li><p>WebAssembly 模块与 JavaScript 代码集成<br>WebAssembly 模块本身不能直接在浏览器中运行，需要将其与 JavaScript 代码集成。可以使用 wasm-bindgen 库来自动生成与 WebAssembly 模块进行交互的 JavaScript 代码，从而实现 JavaScript 和 WebAssembly 之间的互操作性。</p>
</li>
</ol>
<h2 id="Rust-wasm的运行原理"><a href="#Rust-wasm的运行原理" class="headerlink" title="Rust wasm的运行原理"></a>Rust wasm的运行原理</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/2630542/1682259639216-2af812c0-4747-4bcc-8ed5-38cce41e6f75.jpeg" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>Rust代码编译为Wasm模块：使用Rust编写代码后，可以使用Rust的 <code>wasm32-unknown-unknown</code> 目标来编译Wasm模块。这将生成一个二进制Wasm文件，其中包含了Rust代码的编译结果。</li>
<li>将Wasm模块嵌入到Web页面中：Wasm模块可以通过Web页面的 <code>&lt;script&gt;</code> 标签嵌入到HTML中，也可以通过JavaScript动态加载。</li>
<li>JavaScript与Wasm模块通信：在Web页面中，JavaScript代码可以通过WebAssembly对象与Wasm模块进行通信。WebAssembly对象提供了多个API，允许JavaScript代码调用Wasm模块的函数和访问其内存。</li>
<li>Wasm模块执行：当JavaScript代码调用Wasm模块的函数时，Wasm模块将在WebAssembly虚拟机中执行。WebAssembly虚拟机是一个独立的沙箱环境，它提供了一组严格的指令和内存模型，这使得Wasm模块可以在不同的平台和浏览器中运行。</li>
</ol>
<p>Rust WebAssembly的运行原理是将Rust代码编译为Wasm模块，然后在Web页面中通过JavaScript与Wasm模块通信，最终在WebAssembly虚拟机中执行Wasm模块。这种方式可以使得Rust代码在Web环境中获得更高的性能和更广泛的应用场景。</p>
<h1 id="Rust-wasm-工具链"><a href="#Rust-wasm-工具链" class="headerlink" title="Rust wasm 工具链"></a>Rust wasm 工具链</h1><h2 id="Rust-的-wasm-bindgen-crate"><a href="#Rust-的-wasm-bindgen-crate" class="headerlink" title="Rust 的 wasm-bindgen crate"></a>Rust 的 wasm-bindgen crate</h2><p>wasm-bindgen是一个Rust库，它提供了一种在Web浏览器中实现WebAssembly模块和JavaScript互操作的方式。它生成Rust代码的JavaScript绑定，可以从JavaScript中调用，也可以从 Rust 中调用 JavaScript 函数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> wasm_bindgen::prelude::*;<br><br><span class="hljs-meta">#[wasm_bindgen]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">hello_world</span>() &#123;<br>    console::<span class="hljs-title function_ invoke__">log_1</span>(&amp;<span class="hljs-string">&quot;Hello, World!&quot;</span>.<span class="hljs-title function_ invoke__">into</span>());<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用wasm-bindgen，可以编写可以编译为WebAssembly的Rust代码，并用作Web应用程序中的库。该库负责生成必要的粘合代码，以将Rust函数和类型公开给JavaScript，反之亦然，易于从JavaScript中调用Rust代码，反之亦然。<br>wasm-bindgen还提供了用于在Rust中处理JavaScript对象的工具，包括自动将JavaScript对象转换为Rust类型，反之亦然。这使得Rust代码可以使用在JavaScript中创建的对象，从而使得可以在JavaScript应用程序中使用Rust代码而无需编写大量的样板代码。<br>总的来说，wasm-bindgen是构建结合Rust和JavaScript的优势的高性能Web应用程序的强大工具。</p>
<h2 id="wasm-pack"><a href="#wasm-pack" class="headerlink" title="wasm-pack"></a>wasm-pack</h2><p>wasm-pack: 打包、测试和发布 Rust generated WebAssembly</p>
<p>wasm-pack 是一个命令行工具，用于打包、测试和发布 Rust 生成的 WebAssembly。它可以将 Rust 代码编译成 WebAssembly 模块，并生成一个可以发布到 npm 的包。</p>
<h2 id="wasm-bindgen-test"><a href="#wasm-bindgen-test" class="headerlink" title="wasm-bindgen-test"></a>wasm-bindgen-test</h2><p>wasm-bindgen-test: 测试 Rust wasm 代码</p>
<p>wasm-bindgen-test 是一个测试框架，用于测试 Rust wasm 代码。它可以将 Rust 函数导出为 JavaScript 函数，并提供了一些辅助函数，使测试变得更加容易。</p>
<h2 id="wasm-pack-plugin"><a href="#wasm-pack-plugin" class="headerlink" title="wasm-pack-plugin"></a>wasm-pack-plugin</h2><p>wasm-pack-plugin: 与现有的 JS 构建工具集成</p>
<p>wasm-pack-plugin 是一个可以与现有的 JavaScript 构建工具集成的插件。它可以让我们在构建 JavaScript 应用程序时自动构建 Rust wasm 模块，从而简化构建过程。</p>
<h1 id="Rust-wasm-与-JavaScript-交互"><a href="#Rust-wasm-与-JavaScript-交互" class="headerlink" title="Rust wasm 与 JavaScript 交互"></a>Rust wasm 与 JavaScript 交互</h1><h2 id="从-JS-调用-Rust-函数"><a href="#从-JS-调用-Rust-函数" class="headerlink" title="从 JS 调用 Rust 函数"></a>从 JS 调用 Rust 函数</h2><p>要从 JavaScript 中调用 Rust 函数，我们需要使用 wasm-bindgen。首先，在 Rust 函数上添加 #[wasm_bindgen] 属性，这将导出 Rust 函数作为 JavaScript 函数。然后，在 JavaScript 中导入 Rust 函数，并通过 JavaScript 调用它。</p>
<h2 id="从-Rust-调用-JS-函数"><a href="#从-Rust-调用-JS-函数" class="headerlink" title="从 Rust 调用 JS 函数"></a>从 Rust 调用 JS 函数</h2><p>要从 Rust 中调用 JavaScript 函数，我们需要使用 wasm-bindgen。首先，在 Rust 中使用 #[wasm_bindgen] 属性导入 JavaScript 函数。然后，在 Rust 中调用 JavaScript 函数，并将结果转换为 Rust 类型。</p>
<h2 id="Rust-wasm的管理内存"><a href="#Rust-wasm的管理内存" class="headerlink" title="Rust wasm的管理内存"></a>Rust wasm的管理内存</h2><p>在 Rust wasm 中，我们需要手动管理内存。Rust 提供了一些功能，如 Box 和 Rc，用于管理内存。我们还可以使用 wasm-bindgen 的内存分配器功能来管理内存。在 JavaScript 中，我们可以使用 TypedArray 和 ArrayBuffer 等功能来管理内存。</p>
<h2 id="Rust-wasm-和-JS-类型转换"><a href="#Rust-wasm-和-JS-类型转换" class="headerlink" title="Rust wasm 和 JS 类型转换"></a>Rust wasm 和 JS 类型转换</h2><p>在 Rust wasm 和 JavaScript 之间传递数据时，我们需要进行类型转换。Rust wasm 和 JavaScript 支持的数据类型不完全相同，因此我们需要将数据转换为适当的类型。我们可以使用 wasm-bindgen 的类型转换功能来轻松地进行类型转换。</p>
<h1 id="Rust-wasm-性能测试"><a href="#Rust-wasm-性能测试" class="headerlink" title="Rust wasm 性能测试"></a>Rust wasm 性能测试</h1><p>选择编程语言和技术栈的决策往往是基于项目需求和特点的，因此对于不同的项目，最适合的选择也会有所不同。下面是对不同的WebAssembly语言进行简单的比较，并提供一些测试用例和结果。</p>
<h2 id="Rust-WebAssembly-vs-Go-WebAssembly"><a href="#Rust-WebAssembly-vs-Go-WebAssembly" class="headerlink" title="Rust WebAssembly vs. Go WebAssembly"></a>Rust WebAssembly vs. Go WebAssembly</h2><p>对于WebAssembly，Rust和Go都是非常流行的语言。Rust在内存安全性和性能方面表现出色，而Go则在并发性和开发速度方面优秀。下面是一个测试用例，比较两种语言在WebAssembly上的性能：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 将计算斐波那契数列的递归函数暴露给 JavaScript</span><br><span class="hljs-meta">#[wasm_bindgen]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">calc_fib</span>(n: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-comment">// let start_time = Instant::now();</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">fib</span>(n);<br>    <span class="hljs-comment">// log_duration(start_time, &amp;format!(&quot;Calculated fib(&#123;&#125;)&quot;, n));</span><br>    result<br>&#125;<br><span class="hljs-comment">// 计算斐波那契数列的递归函数</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fib</span>(n: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>    <span class="hljs-title function_ invoke__">fib</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-title function_ invoke__">fib</span>(n - <span class="hljs-number">2</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Go</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;syscall/js&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    js.Global().Set(<span class="hljs-string">&quot;fib&quot;</span>, js.FuncOf(fib))<br>    <span class="hljs-keyword">select</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fib</span><span class="hljs-params">(this js.Value, args []js.Value)</span></span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    n := args[<span class="hljs-number">0</span>].Int()<br>    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> n<br>    &#125;<br>    <span class="hljs-keyword">return</span> fib(<span class="hljs-literal">nil</span>, []js.Value&#123;js.ValueOf(n - <span class="hljs-number">1</span>)&#125;) + fib(<span class="hljs-literal">nil</span>, []js.Value&#123;js.ValueOf(n - <span class="hljs-number">2</span>)&#125;)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在计算斐波那契数列的情况下，Rust WebAssembly的性能明显优于Go WebAssembly。具体来说，在计算n=40的情况下，Rust WebAssembly需要大约500毫秒钟的时间，而Go WebAssembly需要大约3.5秒钟的时间。</p>
<h2 id="Rust-WebAssembly-vs-C-C-WebAssembly"><a href="#Rust-WebAssembly-vs-C-C-WebAssembly" class="headerlink" title="Rust WebAssembly vs. C/C++ WebAssembly"></a>Rust WebAssembly vs. C/C++ WebAssembly</h2><p>C/C++是一种非常流行的系统级编程语言，也是WebAssembly的主要目标之一。与Rust类似，C/C++可以提供高性能和内存安全性，但是它的开发速度可能比Rust要慢一些。下面是一个测试用例，比较Rust和C/C++在WebAssembly上的性能：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// Rust</span><br><span class="hljs-meta">#[no_mangle]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fib</span>(n: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span> &#123;<br>        n<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_ invoke__">fib</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-title function_ invoke__">fib</span>(n - <span class="hljs-number">2</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C++</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">fib</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">fib</span>(n - <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在计算斐波那契数列的情况下，我们可以看到Rust WebAssembly的性能略优于C++ WebAssembly。具体来说，在计算n=40的情况下，Rust WebAssembly需要大约1秒钟的时间，而C++ WebAssembly需要大约1.2秒钟的时间。</p>
<h2 id="Rust-WebAssembly-vs-WebAssembly-Text-Format"><a href="#Rust-WebAssembly-vs-WebAssembly-Text-Format" class="headerlink" title="Rust WebAssembly vs. WebAssembly Text Format"></a>Rust WebAssembly vs. WebAssembly Text Format</h2><p>WebAssembly Text Format是一种可读的文本格式，可以将其转换为WebAssembly二进制格式。它可以用作WebAssembly的中间表示，但是它的性能可能不如WebAssembly二进制格式。下面是一个测试用例，比较Rust WebAssembly和WebAssembly Text Format的性能：</p>
<p>在计算斐波那契数列的情况下，我们可以看到Rust WebAssembly的性能远远优于WebAssembly Text Format。具体来说，在计算n=40的情况下，Rust WebAssembly需要大约1秒钟的时间，而WebAssembly Text Format需要大约10秒钟的时间。</p>
<p>综上所述，选择哪种WebAssembly语言和技术栈取决于项目的具体需求和特点。如果需要高性能和内存安全性，那么Rust可能是更好的选择。如果需要高并发性和开发速度，那么Go可能更适合。如果需要可读性和可调试性，那么WebAssembly Text Format可能是不错的选择。在选择之前，可以通过编写测试用例来比较不同的语言和技术栈的性能和特点。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// Rust</span><br><span class="hljs-meta">#[no_mangle]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fib</span>(n: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span> &#123;<br>        n<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_ invoke__">fib</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-title function_ invoke__">fib</span>(n - <span class="hljs-number">2</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>除了fib对比还有没有其他的对比<br>除了斐波那契数列计算之外，我们可以通过比较不同WebAssembly语言在处理不同类型的计算任务时的性能来更全面地了解它们的优劣。</p>
<p><strong>图像处理</strong></p>
<p>图像处理是一种非常常见的计算密集型任务，可以用于图像过滤、图像增强、图像压缩等。下面是使用Rust和C++分别对一个640x480的图像进行高斯模糊处理的WebAssembly代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// Rust</span><br><span class="hljs-meta">#[no_mangle]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">blur</span>(src: &amp;[<span class="hljs-type">u8</span>], dst: &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">u8</span>], width: <span class="hljs-type">usize</span>, height: <span class="hljs-type">usize</span>, radius: <span class="hljs-type">usize</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">kernel</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0.0</span>; radius * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">sigma</span> = radius <span class="hljs-keyword">as</span> <span class="hljs-type">f32</span> / <span class="hljs-number">3.0</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">scale</span> = <span class="hljs-number">1.0</span> / (sigma * <span class="hljs-number">2.0</span> * std::<span class="hljs-type">f32</span>::consts::PI).<span class="hljs-title function_ invoke__">sqrt</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">sum</span> = <span class="hljs-number">0.0</span>;<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..kernel.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = i <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span> - radius <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span>;<br>        kernel[i] = (scale * (-<span class="hljs-number">0.5</span> * (x <span class="hljs-keyword">as</span> <span class="hljs-type">f32</span> / sigma).<span class="hljs-title function_ invoke__">powi</span>(<span class="hljs-number">2</span>)).<span class="hljs-title function_ invoke__">exp</span>()) <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span>;<br>        sum += kernel[i];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..kernel.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        kernel[i] /= sum;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">y</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..height &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">x</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..width &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">r</span> = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">g</span> = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">b</span> = <span class="hljs-number">0</span>;<br><br>            <span class="hljs-keyword">for</span> <span class="hljs-variable">dy</span> <span class="hljs-keyword">in</span> -radius <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span>..=radius <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span> &#123;<br>                <span class="hljs-keyword">for</span> <span class="hljs-variable">dx</span> <span class="hljs-keyword">in</span> -radius <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span>..=radius <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span> &#123;<br>                    <span class="hljs-keyword">let</span> <span class="hljs-variable">yy</span> = (y <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span> + dy).<span class="hljs-title function_ invoke__">clamp</span>(<span class="hljs-number">0</span>, height <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span> - <span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>                    <span class="hljs-keyword">let</span> <span class="hljs-variable">xx</span> = (x <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span> + dx).<span class="hljs-title function_ invoke__">clamp</span>(<span class="hljs-number">0</span>, width <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span> - <span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>                    <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = (yy * width + xx) * <span class="hljs-number">4</span>;<br><br>                    r += (src[p] <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span> * kernel[(dy + radius <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>] * kernel[(dx + radius <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>]) <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span>;<br>                    g += (src[p + <span class="hljs-number">1</span>] <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span> * kernel[(dy + radius <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>] * kernel[(dx + radius <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>]) <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span>;<br>                    b += (src[p + <span class="hljs-number">2</span>] <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span> * kernel[(dy + radius <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>] * kernel[(dx + radius <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>]) <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = (y * width + x) * <span class="hljs-number">4</span>;<br>            dst[p] = r;<br>            dst[p + <span class="hljs-number">1</span>] = g;<br>            dst[p + <span class="hljs-number">2</span>] = b;<br>            dst[p + <span class="hljs-number">3</span>] = src[p + <span class="hljs-number">3</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// C++</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">emscripten_memcpy8</span><span class="hljs-params">(<span class="hljs-type">void</span>*, <span class="hljs-type">const</span> <span class="hljs-type">void</span>*, <span class="hljs-type">size_t</span>)</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">clamp</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> x &lt; a ? a : (x &gt; b ? b : x);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">blur</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* src, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* dst, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">int</span> radius)</span> &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title function_">kernel</span><span class="hljs-params">(radius * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>)</span>;<br>    <span class="hljs-type">double</span> sigma = radius / <span class="hljs-number">3.0</span>;<br>    <span class="hljs-type">double</span> scale = <span class="hljs-number">1.0</span> / (sigma * <span class="hljs-number">2.0</span> * M_PI);<br>    <span class="hljs-type">double</span> sum = <span class="hljs-number">0.0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; kernel.size(); i++) &#123;<br>        <span class="hljs-type">int</span> x = i - radius;<br>        kernel[i] = <span class="hljs-built_in">exp</span>(<span class="hljs-number">-0.5</span> * <span class="hljs-built_in">pow</span>(x / sigma, <span class="hljs-number">2</span>)) * scale;<br>        sum += kernel[i];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; kernel.size(); i++) &#123;<br>        kernel[i] /= sum;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; height; y++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; width; x++) &#123;<br>            <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> g = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> b = <span class="hljs-number">0</span>;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> dy = -radius; dy &lt;= radius; dy++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> dx = -radius; dx &lt;= radius; dx++) &#123;<br>                    <span class="hljs-type">int</span> yy = clamp(y + dy, <span class="hljs-number">0</span>, height - <span class="hljs-number">1</span>);<br>                    <span class="hljs-type">int</span> xx = clamp(x + dx, <span class="hljs-number">0</span>, width - <span class="hljs-number">1</span>);<br>                    <span class="hljs-type">int</span> p = (yy * width + xx) * <span class="hljs-number">4</span>;<br><br>                    r += (<span class="hljs-type">double</span>)src[p] * kernel[dy + radius] * kernel[dx + radius];<br>                    g += (<span class="hljs-type">double</span>)src[p + <span class="hljs-number">1</span>] * kernel[dy + radius] * kernel[dx + radius];<br>                    b += (<span class="hljs-type">double</span>)src[p + <span class="hljs-number">2</span>] * kernel[dy + radius] * kernel[dx + radius];<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-type">int</span> p = (y * width + x) * <span class="hljs-number">4</span>;<br>            dst[p] = r;<br>            dst[p + <span class="hljs-number">1</span>] = g;<br>            dst[p + <span class="hljs-number">2</span>] = b;<br>            dst[p + <span class="hljs-number">3</span>] = src[p + <span class="hljs-number">3</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在计算这个图像的高斯模糊处理时，我们可以看到Rust WebAssembly的性能略优于C++ WebAssembly。具体来说，在计算半径为8的高斯模糊时，Rust WebAssembly需要约为84毫秒，而C++ WebAssembly需要约为93毫秒。</p>
<p><strong>数组操作</strong></p>
<p>数组操作是另一种常见的计算密集型任务，可以用于排序、查找、搜索等。下面是使用JavaScript和C++分别对一个包含10000个整数的数组进行排序的WebAssembly代码：</p>
<p>在这个例子中，我们可以看到C++ WebAssembly的性能略优于JavaScript WebAssembly。具体来说，在对包含10000个整数的数组进行排序时，C++ WebAssembly需要约为3.5毫秒，而JavaScript WebAssembly需要约为4.2毫秒。<br>综上所述，我们可以通过比较不同WebAssembly语言在不同类型的计算任务中的性能来更全面地了解它们的优劣。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// JavaScript</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sortArray</span>(<span class="hljs-params">array</span>) &#123;<br>  <span class="hljs-keyword">const</span> memory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title class_">Memory</span>(&#123; <span class="hljs-attr">initial</span>: <span class="hljs-number">256</span> &#125;);<br>  <span class="hljs-keyword">const</span> wasmModule = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title class_">Module</span>(wasmCode);<br>  <span class="hljs-keyword">const</span> wasmInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title class_">Instance</span>(wasmModule, &#123; <span class="hljs-attr">env</span>: &#123; memory &#125; &#125;);<br>  <span class="hljs-keyword">const</span> &#123; sortArray &#125; = wasmInstance.<span class="hljs-property">exports</span>;<br><br>  <span class="hljs-keyword">const</span> arrayPointer = wasmInstance.<span class="hljs-property">exports</span>.<span class="hljs-property">__indirect_function_table</span>.<span class="hljs-title function_">get</span>(array);<br>  <span class="hljs-keyword">const</span> arrayLength = array.<span class="hljs-property">length</span>;<br><br>  <span class="hljs-title function_">sortArray</span>(arrayPointer, arrayLength);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C++</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">emscripten_memcpy8</span><span class="hljs-params">(<span class="hljs-type">void</span>*, <span class="hljs-type">const</span> <span class="hljs-type">void</span>*, <span class="hljs-type">size_t</span>)</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sort_array</span><span class="hljs-params">(<span class="hljs-type">int</span>* <span class="hljs-built_in">array</span>, <span class="hljs-type">int</span> length)</span> &#123;<br>    <span class="hljs-built_in">std</span>::sort(<span class="hljs-built_in">array</span>, <span class="hljs-built_in">array</span> + length);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试对比表</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="Rust-wasm-实际应用"><a href="#Rust-wasm-实际应用" class="headerlink" title="Rust wasm 实际应用"></a>Rust wasm 实际应用</h1><p>Rust wasm 可以用于构建高效、安全的 Web 应用程序，也可以用于构建跨平台的桌面应用程序。</p>
<p>通过 wasm-pack 发布你的包到 npm </p>
<p>要将 Rust wasm 包发布到 npm，我们可以使用 wasm-pack。wasm-pack 可以将 Rust 代码编译成 WebAssembly 模块，并生成一个可以发布到 npm 的包。我们可以使用以下命令来发布 Rust wasm 包到 npm：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">wasm-pack publish</span><br></code></pre></td></tr></table></figure>

<p>与 Web 框架集成(如 Vue.js、React)</p>
<p>Rust wasm 可以与现有的 Web 框架集成，如 Vue.js、React 和 Angular 等。我们可以使用 wasm-bindgen 和 wasm-pack-plugin 将 Rust wasm 模块与现有的 JavaScript 应用程序集成在一起。</p>
<ul>
<li>计算机视觉</li>
<li>3D地图 - Altus平台，Google地球</li>
<li>用户界面设计</li>
<li>语言检测</li>
<li>音频混合</li>
<li>视频编解码器支持</li>
<li>数字信号处理</li>
<li>医学影像</li>
<li>物理模拟</li>
<li>加密</li>
<li>压缩 - zlib-asm，Brotli，lzma</li>
<li>计算机代数</li>
</ul>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>一些现实的 Rust wasm 项目案例分析</p>
<h3 id="Yew"><a href="#Yew" class="headerlink" title="Yew"></a>Yew</h3><p>Yew 是一个 Rust 编写的现代 Web 框架，它基于 WebAssembly 和 Virtual DOM。它提供了一种高效和安全的方式来编写 Web 应用程序，并且可以通过编译成 WebAssembly 模块在浏览器中运行。<br>Yew 旨在提供与 React 和 Vue 等现代 Web 框架相似的功能，包括组件化、事件处理、状态管理等。它使用 Rust 的所有权系统来确保内存安全，并且可以与 JavaScript 代码无缝交互。</p>
<h3 id="Parity-Substrate"><a href="#Parity-Substrate" class="headerlink" title="Parity Substrate"></a>Parity Substrate</h3><p>Parity Substrate 是一个用于构建区块链应用程序的 Rust 框架，它使用 WebAssembly 技术来提高性能和安全性。 Substrate 通过可插拔的模块化架构使得构建自定义区块链变得更加容易。<br>Substrate 提供了一组自定义的 Rust 库，可以轻松地创建和部署智能合约，并且可以在不同的区块链网络之间进行互操作性。使用 WebAssembly 技术，Substrate 可以实现高性能的智能合约执行，同时保证了内存安全性。</p>
<h3 id="xi-editor"><a href="#xi-editor" class="headerlink" title="xi-editor"></a>xi-editor</h3><p>xi-editor 是一个 Rust 编写的文本编辑器，它使用 WebAssembly 技术来提高性能。xi-editor 的目标是提供一个快速、可扩展和易于定制的文本编辑器，可以在不同的平台上运行。<br>使用 WebAssembly 技术，xi-editor 可以在浏览器中运行，并且可以与 JavaScript 代码无缝交互。此外，Rust 的所有权系统可以确保内存安全，避免了常见的内存安全问题。</p>
<p>这些 Rust wasm 项目展示了 WebAssembly 的潜力，它可以为 Web 应用程序提供高性能、安全性和可维护性，并且可以在不同的平台上运行。</p>
<h2 id="Rust-wasm在shopify里的应用"><a href="#Rust-wasm在shopify里的应用" class="headerlink" title="Rust wasm在shopify里的应用"></a>Rust wasm在shopify里的应用</h2><h3 id="shopify-function"><a href="#shopify-function" class="headerlink" title="shopify function"></a>shopify function</h3><blockquote>
<p>shopify function 支持商家自定义后端逻辑</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> shopify_function::prelude::*;<br><span class="hljs-keyword">use</span> shopify_function::<span class="hljs-type">Result</span>;<br><br><span class="hljs-keyword">use</span> serde::&#123;Deserialize, Serialize&#125;;<br><br>generate_types!(<br>    query_path = <span class="hljs-string">&quot;./input.graphql&quot;</span>,<br>    schema_path = <span class="hljs-string">&quot;./schema.graphql&quot;</span><br>);<br><br><span class="hljs-meta">#[derive(Serialize, Deserialize, Default, PartialEq)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Config</span> &#123;<br>    <span class="hljs-keyword">pub</span> quantity: <span class="hljs-type">i64</span>,<br>    <span class="hljs-keyword">pub</span> percentage: <span class="hljs-type">f64</span>,<br>&#125;<br><br><span class="hljs-meta">#[shopify_function]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">function</span>(input: input::ResponseData) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;output::FunctionResult&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">config</span>: Config = input<br>        .discount_node<br>        .metafield<br>        .<span class="hljs-title function_ invoke__">as_ref</span>()<br>        .<span class="hljs-title function_ invoke__">map</span>(|m| serde_json::from_str::&lt;Config&gt;(m.value.<span class="hljs-title function_ invoke__">as_str</span>()))<br>        .<span class="hljs-title function_ invoke__">transpose</span>()?<br>        .<span class="hljs-title function_ invoke__">unwrap_or_default</span>();<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cart_lines</span> = input.cart.lines;<br><br>    <span class="hljs-keyword">if</span> cart_lines.<span class="hljs-title function_ invoke__">is_empty</span>() || config.percentage == <span class="hljs-number">0.0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Ok</span>(output::FunctionResult &#123;<br>            discount_application_strategy: output::DiscountApplicationStrategy::FIRST,<br>            discounts: <span class="hljs-built_in">vec!</span>[],<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">targets</span> = <span class="hljs-built_in">vec!</span>[];<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">line</span> <span class="hljs-keyword">in</span> cart_lines &#123;<br>        <span class="hljs-keyword">if</span> line.quantity &gt;= config.quantity &#123;<br>            targets.<span class="hljs-title function_ invoke__">push</span>(output::Target &#123;<br>                product_variant: <span class="hljs-title function_ invoke__">Some</span>(output::ProductVariantTarget &#123;<br>                    id: <span class="hljs-keyword">match</span> line.merchandise &#123;<br>                        input::InputCartLinesMerchandise::<span class="hljs-title function_ invoke__">ProductVariant</span>(variant) =&gt; variant.id,<br>                        _ =&gt; <span class="hljs-keyword">continue</span>,<br>                    &#125;,<br>                    quantity: <span class="hljs-literal">None</span>,<br>                &#125;),<br>            &#125;);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> targets.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Ok</span>(output::FunctionResult &#123;<br>            discount_application_strategy: output::DiscountApplicationStrategy::FIRST,<br>            discounts: <span class="hljs-built_in">vec!</span>[],<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-title function_ invoke__">Ok</span>(output::FunctionResult &#123;<br>        discounts: <span class="hljs-built_in">vec!</span>[output::Discount &#123;<br>            message: <span class="hljs-literal">None</span>,<br>            targets,<br>            value: output::Value &#123;<br>                percentage: <span class="hljs-title function_ invoke__">Some</span>(output::Percentage &#123;<br>                    value: config.percentage.<span class="hljs-title function_ invoke__">to_string</span>(),<br>                &#125;),<br>                fixed_amount: <span class="hljs-literal">None</span>,<br>            &#125;,<br>        &#125;],<br>        discount_application_strategy: output::DiscountApplicationStrategy::FIRST,<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="总结和展望"><a href="#总结和展望" class="headerlink" title="总结和展望"></a>总结和展望</h1><h2 id="Rust-wasm-的优势"><a href="#Rust-wasm-的优势" class="headerlink" title="Rust wasm 的优势"></a>Rust wasm 的优势</h2><p>Rust wasm 具有以下优势：</p>
<ol>
<li>内存安全：Rust 的所有权系统可以保证内存安全，避免了常见的内存安全问题，如空指针和内存泄漏。</li>
<li>高效性：Rust 是一种高效的语言，可以生成高性能的 WebAssembly 模块，提供了比 JavaScript 更好的性能。</li>
<li>并发性：Rust 支持并发编程，可以轻松地编写并发应用程序，而不需要担心数据竞争和其他问题。</li>
<li>可维护性：Rust 是一种可维护的语言，它具有良好的模块化和抽象机制，可以使代码更易于理解和维护。</li>
<li>跨平台：Rust wasm 可以在任何支持 WebAssembly 的平台上运行，如浏览器、Node.js 和桌面应用程序等。</li>
</ol>
<p>Rust wasm 可以用于多种应用场景，如：</p>
<ol>
<li>Web 应用程序：Rust wasm 可以用于编写 Web 应用程序的一部分，以提高性能和安全性。</li>
<li>游戏：Rust wasm 可以用于编写游戏的一部分，以提高性能和安全性，并使游戏更易于移植到不同的平台上。</li>
<li>数据科学：Rust wasm 可以用于在浏览器中运行数据科学代码，从而使数据科学更易于使用和共享。</li>
<li>区块链：Rust wasm 可以用于编写智能合约，以提高安全性和性能。</li>
</ol>
<h2 id="当前存在的问题"><a href="#当前存在的问题" class="headerlink" title="当前存在的问题"></a>当前存在的问题</h2><p>虽然 Rust wasm 技术有很多优势，但也存在一些问题：</p>
<ol>
<li>工具链不完善：Rust wasm 技术目前的工具链还不够完善，使用起来还有一些困难，需要更多的工作来改进工具链的可用性和易用性。</li>
<li>生态系统不完整：Rust wasm 技术的生态系统还不够完整，需要更多的开发者和社区的参与，来完善 Rust wasm 技术的生态系统。</li>
<li>学习曲线较陡峭：Rust 是一种相对较新的编程语言，学习曲线相对较陡峭，需要一定的时间和精力来学习和掌握。</li>
</ol>
<h2 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h2><p>尽管 Rust wasm 技术目前还存在一些问题，但未来它有很大的发展潜力：<br>2.1. 更广泛的应用：随着 Rust wasm 技术的发展，它将在更多的应用场景中得到应用，包括 Web 应用程序、游戏、数据科学和区块链等领域。<br>2.2. 更完整的生态系统：随着 Rust wasm 技术的发展，它的生态系统将变得更加完整，将有更多的开发者和社区参与其中，从而促进技术的发展。<br>2.3. 更好的工具链支持：随着 Rust wasm 技术的发展，工具链的支持将变得更加完善，使得开发者可以更轻松地使用 Rust wasm 技术来构建应用程序。<br>2.4. 更好的性能和安全性：随着 Rust wasm 技术的发展，它将提供更好的性能和安全性，使得 Rust wasm 技术在 Web 应用程序和其他领域中得到更广泛的应用。</p>
<h2 id="WebGL-WebGPU"><a href="#WebGL-WebGPU" class="headerlink" title="WebGL/WebGPU"></a>WebGL/WebGPU</h2><p>WebGPU是一种新的标准化的图形硬件接口，它可以让WebAssembly访问GPU的功能和资源。WebAssembly和WebGPU可以结合使用，实现高效的图形渲染和计算</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>什么是Rust和WebAssembly，它们为什么能提高Web应用的性能和安全性？</li>
<li>如何使用Rust和WebAssembly开发Web应用，需要哪些工具和库？</li>
<li>Rust和WebAssembly如何与JavaScript，HTML和CSS协同工作，如何实现无缝的互操作？</li>
<li>Rust和WebAssembly在实际项目中的应用案例，如Serverless函数，源码映射，压缩编码等。</li>
<li>Rust和WebAssembly的优化手段和技巧，如wasm-opt，运行时选择等。</li>
<li>Rust和WebAssembly的未来发展趋势和挑战。</li>
</ul>
<ol>
<li>Rust和WebAssembly的学习资源和社区，如官方文档，教程，博客，问答网站等。</li>
<li>Rust和WebAssembly的最佳实践和常见问题，如内存管理，错误处理，调试工具等。</li>
<li>Rust和WebAssembly的高级主题和新特性，如异步编程，多线程，SIMD等。</li>
<li>Rust和WebAssembly的创新应用和前沿探索，如Serverless函数，源码映射，压缩编码等。</li>
</ol>
<h2 id="相关框架"><a href="#相关框架" class="headerlink" title="相关框架"></a>相关框架</h2><ol>
<li>相关资料：<a target="_blank" rel="noopener" href="https://rustwasm.github.io/book/">https://rustwasm.github.io/book/</a></li>
<li>wavm：<a target="_blank" rel="noopener" href="https://wavm.github.io/">https://wavm.github.io/</a></li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.chromium.org/2023/04/how-webassembly-is-accelerating-new-web.html">https://blog.chromium.org/2023/04/how-webassembly-is-accelerating-new-web.html</a></p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" class="category-chain-item">编程语言</a>
  
  
    <span>></span>
    
  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/" class="category-chain-item">Rust</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/wasm/">#wasm</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Rust wasm 的探索与实践</div>
      <div>https://mikeygithub.github.io/2023/04/20/yuque/Rust wasm 的探索与实践/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Mikey</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年4月20日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/05/14/yuque/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E5%BA%93%20-%20Apache%20Doris/" title="分析数据库 - Apache Doris">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">分析数据库 - Apache Doris</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/04/08/yuque/WebAssembly-%E7%8E%B0%E4%BB%A3%E7%BD%91%E7%BB%9C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E6%96%B0%E5%9E%8B%E4%BB%A3%E7%A0%81/" title="WebAssembly-现代网络浏览器中的新型代码">
                        <span class="hidden-mobile">WebAssembly-现代网络浏览器中的新型代码</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'mikeygithub/commit-utterance');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  





  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.13.10/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});
  });
</script>




  <!-- Custom -->
  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" lazyload class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       Copyright © 麦奇 Powered by <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> and <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> core on github page 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      桂ICP备2020009931号-1
    </a>
  </span>
  
    
      <span>
        <a
          href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=2020009931"
          rel="nofollow noopener"
          class="beian-police"
          target="_blank"
        >
          
            <span style="visibility: hidden; width: 0">|</span>
            <img src="/img/police_beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
          
          <span>桂公网安备2020009931号</span>
        </a>
      </span>
    
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?74301a15e5497361e93588eeee69f4b2";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  
    <!-- Google Analytics -->
    <script defer>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript('https://www.google-analytics.com/analytics.js', function() {
          window.ga = window.ga || function() { (ga.q = ga.q || []).push(arguments) };
          ga.l = +new Date;
          ga('create', 'G-NCN3Z5PSLJ', 'auto');
          ga('send', 'pageview');
        });
      }
    </script>
  

  

  

  

  

  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        MathJax = {
          tex    : {
            inlineMath: { '[+]': [['$', '$']] }
          },
          loader : {
            load: ['ui/lazy']
          },
          options: {
            renderActions: {
              findScript    : [10, doc => {
                document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                  const display = !!node.type.match(/; *mode=display/);
                  const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                  const text = document.createTextNode('');
                  node.parentNode.replaceChild(text, node);
                  math.start = { node: text, delim: '', n: 0 };
                  math.end = { node: text, delim: '', n: 0 };
                  doc.math.push(math);
                });
              }, '', false],
              insertedScript: [200, () => {
                document.querySelectorAll('mjx-container').forEach(node => {
                  let target = node.parentNode;
                  if (target.nodeName.toLowerCase() === 'li') {
                    target.parentNode.classList.add('has-jax');
                  }
                });
              }, '', false]
            }
          }
        };
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.0/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
