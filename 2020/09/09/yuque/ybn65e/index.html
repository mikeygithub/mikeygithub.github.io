

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <meta name="referrer" content="no-referrer"/>
  <link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/favicon.png">
  <link rel="icon" href="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Mikey">
  <meta name="keywords" content="">
  
    <meta name="description" content="动态规划算法描述 动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。   动态规划问题的一般形式就是求最值。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求最长递增子序列呀，最小编辑距离呀等等。既然是要求最值，核心问题是什么呢？求解动态规划的核心问题是穷举。因为要求最值，肯定要把">
<meta property="og:type" content="article">
<meta property="og:title" content="算法学习-动态规划">
<meta property="og:url" content="https://mikeygithub.github.io/2020/09/09/yuque/ybn65e/index.html">
<meta property="og:site_name" content="麦奇">
<meta property="og:description" content="动态规划算法描述 动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。   动态规划问题的一般形式就是求最值。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求最长递增子序列呀，最小编辑距离呀等等。既然是要求最值，核心问题是什么呢？求解动态规划的核心问题是穷举。因为要求最值，肯定要把">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/2630542/1641045384892-59ee9e1e-d740-43db-9be5-6c7312944bbe.png">
<meta property="article:published_time" content="2020-09-09T09:24:22.000Z">
<meta property="article:modified_time" content="2023-03-19T04:09:04.962Z">
<meta property="article:author" content="Mikey">
<meta property="article:tag" content="动态规划">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2022/png/2630542/1641045384892-59ee9e1e-d740-43db-9be5-6c7312944bbe.png">
  
  
<!--    <meta name="referrer" content="no-referrer-when-downgrade">-->
  
  
  <title>算法学习-动态规划 - 麦奇</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"mikeygithub.github.io","root":"/","version":"1.9.1","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":200}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"74301a15e5497361e93588eeee69f4b2","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="麦奇" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>麦奇</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/photo/">
                <i class="iconfont icon-image"></i>
                照片
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/music/">
                <i class="iconfont icon-music"></i>
                音乐
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/atom.xml">
                <i class="iconfont icon-rss"></i>
                RSS
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="算法学习-动态规划"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Mikey
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2020-09-09 17:24" pubdate>
          2020年9月9日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          51k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          426 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">算法学习-动态规划</h1>
            
            <div class="markdown-body">
              
              <p><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1641045384892-59ee9e1e-d740-43db-9be5-6c7312944bbe.png#averageHue=%233f48cc&clientId=u58b196f8-dee9-4&errorMessage=unknown%20error&from=paste&height=124&id=ua875c8a7&name=image.png&originHeight=248&originWidth=359&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8421&status=error&style=none&taskId=u078fb1c1-0d0e-4afd-8b33-52324a988b3&title=&width=179.5" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><blockquote>
<p>动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。</p>
</blockquote>
<blockquote>
<p>动态规划问题的一般形式就是<code>求最值</code>。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求最长递增子序列呀，最小编辑距离呀等等。既然是要求最值，核心问题是什么呢？求解动态规划的核心问题是<code>穷举</code>。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。首先，动态规划的穷举有点特别，因为这类问题存在「重叠子问题」，如果暴力穷举的话效率会极其低下，所以需要<code>「备忘录」</code>或者<code>「DP table」</code>来优化穷举过程，避免不必要计算。 而且，动态规划问题一定会具备「最优子结构」，才能通过子问题的最值得到原问题的最值。<br>另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出正确的<code>「状态转移方程」</code>才能正确地穷举。</p>
</blockquote>
<blockquote>
<p>以上提到的<code>重叠子问题</code>、<code>最优子结构</code>、<code>状态转移方程</code>就是动态规划三要素。</p>
</blockquote>
<h2 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">这个问题的base case(最简单情况)是什么？  <br>这个问题有什么&quot;状态&quot;？<br>对于每个状态可以做什么选择使得状态发生改变？<br>如何定义dp数组/函数的含义来表现状态和选择？<br></code></pre></td></tr></table></figure>

<h2 id="算法关键"><a href="#算法关键" class="headerlink" title="算法关键"></a>算法关键</h2><ul>
<li>最优子结构 opt[n]=best_of(opt[n-1],opt[n-2])</li>
<li>存储中间状态: opt[i]</li>
<li>递推公式(状态转移方程或DP方程) FIB: opt[i]=opt[n-1]+opt[n-2]   二位路径: opt[i,j]=opt[i-1][j]+opt[i][j+1]</li>
</ul>
<h2 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">初始化base <span class="hljs-keyword">case</span></span><br>dp[0][0][...]=base case<br><span class="hljs-meta prompt_"># </span><span class="language-bash">进行状态转移</span><br>for 状态1 in 状态1所有值:<br>    for 状态2 in 状态2所有值:<br>        for ...<br>            dp[状态1][状态2][...] = 求最值(选择1,选择2,...)<br></code></pre></td></tr></table></figure>

<blockquote>
<p>列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。</p>
</blockquote>
<h2 id="二分动规"><a href="#二分动规" class="headerlink" title="二分动规"></a>二分动规</h2><blockquote>
<p>动态规划结合二分查找，通过二分查找确定其上一个（如会议的结束时间）可选的值</p>
</blockquote>
<p>相关题目<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-number-of-events-that-can-be-attended-ii/">1751. 最多可以参加的会议数目 II</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-profit-in-job-scheduling/">1235. 规划兼职工作</a></p>
<h2 id="数位动规"><a href="#数位动规" class="headerlink" title="数位动规"></a>数位动规</h2><p><a target="_blank" rel="noopener" href="https://oi-wiki.org/dp/number/">https://oi-wiki.org/dp/number/</a></p>
<p>数位是指把一个数字按照个、十、百、千等等一位一位地拆开，关注它每一位上的数字。如果拆的是十进制数，那么每一位数字都是 0~9，其他进制可类比十进制。<br>数位 DP：用来解决一类特定问题，这种问题比较好辨认，一般具有这几个特征：</p>
<ol>
<li>要求统计满足一定条件的数的数量（即，最终目的为计数）；</li>
<li>这些条件经过转化后可以使用「数位」的思想去理解和判断；</li>
<li>输入会提供一个数字区间（有时也只提供上界）来作为统计的限制；</li>
<li>上界很大（比如 ），暴力枚举验证会超时。</li>
</ol>
<p>数位 DP 的基本原理：<br>考虑人类计数的方式，最朴素的计数就是从小到大开始依次加一。但我们发现对于位数比较多的数，这样的过程中有许多重复的部分。例如，从 7000 数到 7999、从 8000 数到 8999、和从 9000 数到 9999 的过程非常相似，它们都是后三位从 000 变到 999，不一样的地方只有千位这一位，所以我们可以把这些过程归并起来，将这些过程中产生的计数答案也都存在一个通用的数组里。此数组根据题目具体要求设置状态，用递推或 DP 的方式进行状态转移。</p>
<p>数位 DP 中通常会利用常规计数问题技巧，比如把一个区间内的答案拆成两部分相减（即那么有了通用答案数组，接下来就是统计答案。统计答案可以选择记忆化搜索，也可以选择循环迭代递推。为了不重不漏地统计所有不超过上限的答案，要从高到低枚举每一位，再考虑每一位都可以填哪些数字，最后利用通用答案数组统计答案。</p>
<p>接下来我们具体看几道题目。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/">https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/</a></p>
<h2 id="例子参考"><a href="#例子参考" class="headerlink" title="例子参考"></a>例子参考</h2><p><a href="http://mikeygithub.github.io/2020/11/19/interview/LeetCode-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">参考例子</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/39948290/answer/612439961">如何理解动态规划？ - 牛岱的回答 - 知乎</a></p>
<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><blockquote>
<p>动态规划</p>
</blockquote>
<h4 id="零钱兑换-medium"><a href="#零钱兑换-medium" class="headerlink" title="零钱兑换(medium)"></a>零钱兑换(medium)</h4><blockquote>
<p>动态规划、状态转移方程　F(S)=F(S-C)+1</p>
</blockquote>
<p>例子2：假设<br>coins = [1, 2, 3], amount = 6<br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/coin-change-1.jpeg#height=375&id=arSsy&originHeight=778&originWidth=1000&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=482" srcset="/img/loading.gif" lazyload><br>在上图中，可以看到：</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex">F(3)=min(F(3−c1),F(3−c2),F(3−c3))+1<br>    =min(F(3−1),F(3−2),F(3−3))+1  <br>    =min(F(2),F(1),F(0))+1  <br>    =min(1,1,0)+1  <br>    =1<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//dp[i]表示凑成i金额的最少金币个数</span><br>    <span class="hljs-comment">//那么每轮在遍历金币如果出现更大面额的金币就将其兑换</span><br>    <span class="hljs-comment">//dp[i] = Math.min(dp[i-c]+1,dp[i]); for in coins</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> amount + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[amount + <span class="hljs-number">1</span>];<br>        Arrays.fill(dp, max);<span class="hljs-comment">//填充</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//basecase</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= amount; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; coins.length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (coins[j] &lt;= i) &#123;<br>                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount] &gt; amount ? -<span class="hljs-number">1</span> : dp[amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="零钱兑换-II（medium）"><a href="#零钱兑换-II（medium）" class="headerlink" title="零钱兑换 II（medium）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change-2/">零钱兑换 II</a>（medium）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql">class Solution &#123;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>思路:动态规划<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i]表示amount<span class="hljs-operator">=</span>i的coins可凑成总金额的方式;通过遍历不同的coin累计dp[i]的组成方式个数<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[j]<span class="hljs-operator">=</span>dp[i]<span class="hljs-operator">+</span>dp[j<span class="hljs-operator">-</span>coins[i]];<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[<span class="hljs-number">0</span>]<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br>    <br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">1.</span>为什么内层从coin开始 ? 因为i表示的是金额，如果 i<span class="hljs-operator">&lt;</span>coin 此时是无法凑的<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">2.</span>为什么dp[i] <span class="hljs-operator">=</span> dp[i] <span class="hljs-operator">+</span> dp[i<span class="hljs-operator">-</span>c] ? dp[i]表示的是amount<span class="hljs-operator">=</span>i可以凑成的总数,那当前i大于等于新的coin,此时可以用c来凑出一直方式，那就是dp[i<span class="hljs-operator">-</span>c]<br>    public <span class="hljs-type">int</span> change(<span class="hljs-type">int</span> amount, <span class="hljs-type">int</span>[] coins) &#123;<br>        <span class="hljs-type">int</span>[] dp <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[amount<span class="hljs-operator">+</span><span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>]<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> coin:coins)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i<span class="hljs-operator">=</span>coin;i<span class="hljs-operator">&lt;=</span>amount;i<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)&#123;<br>                dp[i] <span class="hljs-operator">=</span> dp[i] <span class="hljs-operator">+</span> dp[i<span class="hljs-operator">-</span>coin];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="斐波那契数列-easy"><a href="#斐波那契数列-easy" class="headerlink" title="斐波那契数列(easy)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">斐波那契数列(easy)</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>            dp[i] %= <span class="hljs-number">1000000007</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>    <span class="hljs-comment">//空间优化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">one</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">two</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> two;<br>            two = (one+two)%<span class="hljs-number">1000000007</span>;<br>            one = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> two;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="礼物的最大价值-medium"><a href="#礼物的最大价值-medium" class="headerlink" title="礼物的最大价值(medium)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof">礼物的最大价值(medium)</a></h4><p>[</p>
<p>](<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof">https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof</a>)<br>礼物的最大价值<br>题目描述</p>
<blockquote>
<p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
</blockquote>
<p>示例<br>输入:</p>
<blockquote>
<p>[    <br>      [1,3,1],<br>   [1,5,1],<br>   [4,2,1]<br>]</p>
</blockquote>
<p>输出: 12 解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物<br>解题思路<br>动态规划+dp数组，自底向上，状态转移方程 <code>f(i, j) = max&#123;f(i - 1, j), f(i, j - 1)&#125; + grid[i][j]</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<span class="hljs-comment">//获取数组长度</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<span class="hljs-comment">//dp数组 最长长度为n+1 用于存放</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<span class="hljs-comment">//两层循环</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                dp[j] = Math.max(dp[j], dp[j - <span class="hljs-number">1</span>]) + grid[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<span class="hljs-comment">//结合状态转移方程</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="丑数-中等"><a href="#丑数-中等" class="headerlink" title="丑数(中等)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/chou-shu-lcof">丑数(中等)</a></h4><p>丑数</p>
<blockquote>
<p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>
</blockquote>
<p>示例</p>
<blockquote>
<p>输入: n = 10 输出: 12 解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</p>
</blockquote>
<p>说明</p>
<blockquote>
<p>1是丑数。 n 不超过1690。</p>
</blockquote>
<p>解题思路</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs latex">状态定义： 设动态规划列表 dp ，dp[i] 代表第 i + 1 个丑数。<br>转移方程：<br>当索引 a, b, c 满足以下条件时， dp[i] 为三种情况的最小值；<br>每轮计算 dp[i] 后，需要更新索引 a, b, c 的值，使其始终满足方程条件。<br>实现方法：分别独立判断 dp[i] 和 dp[a]×2 , dp[b]×3 , dp[c]×5 的大小关系，若相等则将对应索引 a , b , c 加 1 。<br><br>dp[a]×2&gt;dp[i−1]≥dp[a−1]×2  <br>dp[b]×3&gt;dp[i−1]≥dp[b−1]×3  <br>dp[c]×5&gt;dp[i−1]≥dp[c−1]×5  <br><br>得出公式=dp[i] = min(dp[a]×2,dp[b]×3,dp[c]×5)<br><br>初始状态： dp[0] = 1 ，即第一个丑数为 1.  <br>返回值： dp[n-1] ，即返回第 n 个丑数.<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//dp[i]表示第i个丑数</span><br>    <span class="hljs-comment">//[1, 2, 3, 4, 5, 6, 8, 9, 10, 12]</span><br>    <span class="hljs-comment">// 2, 3, 5分别定义三个指针 n2,n3,n5</span><br>    <span class="hljs-comment">//dp[i] = Math.min(dp[n2]*2,dp[n3]*3,dp[n5]*5);</span><br>    <span class="hljs-comment">//min值为当前指针时更新指针+1</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,n3 = <span class="hljs-number">0</span>,n5 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            dp[i] = Math.min(dp[n2]*<span class="hljs-number">2</span>,Math.min(dp[n3]*<span class="hljs-number">3</span>,dp[n5]*<span class="hljs-number">5</span>));<br>            <span class="hljs-keyword">if</span>(dp[i]==<span class="hljs-number">2</span>*dp[n2])n2++;<br>            <span class="hljs-keyword">if</span>(dp[i]==<span class="hljs-number">3</span>*dp[n3])n3++;<br>            <span class="hljs-keyword">if</span>(dp[i]==<span class="hljs-number">5</span>*dp[n5])n5++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="最长回文子串（中等）"><a href="#最长回文子串（中等）" class="headerlink" title="最长回文子串（中等）"></a>最长回文子串（中等）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java">思路：<br><span class="hljs-number">1.</span>首先对称有两种情况，分别是以一个字母为中心、两个字母为中心的回文子串。<br><br>暴力解法：枚举所有的情况（超时）<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,length = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length()-<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;s.length();j++)&#123;<br>                <span class="hljs-keyword">if</span>(isPalindrome(s,i,j))&#123;<br>                    <span class="hljs-keyword">if</span>(j-i+<span class="hljs-number">1</span>&gt;length)&#123;<br>                        length=j-i+<span class="hljs-number">1</span>;<br>                        left=i;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//返回最大的</span><br>        <span class="hljs-keyword">return</span> s.substring(left,left+length);<br>    &#125;<br>    <span class="hljs-comment">//是否是回文串</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(String s,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span>&#123;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(left)!=s.charAt(right))<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            left++;<br>            right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br>中心扩散法:如果一个字符串是回文串，那么去掉头尾的两个依然是回文串。从中心向两边扩散（分为两种情况，一个字符为中心和两个字符为中心）<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span>(s.length()&lt;<span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> s;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-type">int</span> <span class="hljs-variable">beginIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> centerSpread(s,i,i);<span class="hljs-comment">//一个字母为中心</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">len2</span> <span class="hljs-operator">=</span> centerSpread(s,i,i+<span class="hljs-number">1</span>);<span class="hljs-comment">//两个字母为中心</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">currMax</span> <span class="hljs-operator">=</span> Math.max(len1,len2);<br>            <span class="hljs-keyword">if</span>(currMax&gt;maxLength)&#123;<br>                <span class="hljs-comment">// 根据i和currMax算begin下标</span><br>                <span class="hljs-comment">// 奇数：i-currMax/2</span><br>                <span class="hljs-comment">// 偶数：i-currMax/2+1</span><br>                <span class="hljs-comment">// 统一：i-(currMax-1)/2</span><br>                beginIndex = i - (currMax - <span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>                maxLength=currMax;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(beginIndex,beginIndex+maxLength);<br>    &#125;<br>    <span class="hljs-comment">//aba abba</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">centerSpread</span><span class="hljs-params">(String s,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span>&#123;<br>        <span class="hljs-keyword">while</span>(left&gt;=<span class="hljs-number">0</span>&amp;&amp;right&lt;s.length()&amp;&amp;s.charAt(left)==s.charAt(right))&#123;<br>            left--;<br>            right++;<br>        &#125;<br>        <span class="hljs-comment">//right-left+1-2=right-left-1;</span><br>        <span class="hljs-keyword">return</span> right-left-<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br>动态规划：<br><br>dp[i][j] 表示：子串 s[i..j] 是否为回文子串，这里子串 s[i..j] 定义为左闭右闭区间，即可以取到 s[i] 和 s[j]。<br>dp[i][j] = (s[i] == s[j]) and dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> s;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>        <span class="hljs-comment">// dp[i][j]:表示s[i][j]是否是回文串</span><br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[len][len];<br>        <span class="hljs-comment">// 初始化：单独一个字符肯定是回文子串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) dp[i][i] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 经验：dp区域是正方形的话，通常左下角区域无效不需要再填，因为走过的区域不用再走</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; len; j++) &#123; <span class="hljs-comment">// 上三角区域，按列从上到下填</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; j; i++) &#123;<br>                <span class="hljs-comment">// 首尾不相等时，必不是回文串</span><br>                <span class="hljs-keyword">if</span> (cs[i] != cs[j]) &#123;<br>                    dp[i][j] = <span class="hljs-literal">false</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 首尾相等时，有2种情况</span><br>                    <span class="hljs-comment">// 情况1：s[i...j]长度不超过3，不用检查必为回文串</span><br>                    <span class="hljs-comment">// 情况2：s[i...j]长度大于3，由s[i+1...j-1]来判断</span><br>                    dp[i][j] = j - i + <span class="hljs-number">1</span> &lt;= <span class="hljs-number">3</span> || dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-comment">// 更新max和begin</span><br>                <span class="hljs-keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="hljs-number">1</span> &gt; maxLen) &#123;<br>                    maxLen = j - i + <span class="hljs-number">1</span>;<br>                    begin = i;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(begin, begin + maxLen);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="最长公共子序列-中等"><a href="#最长公共子序列-中等" class="headerlink" title="最长公共子序列(中等)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-subsequence/">最长公共子序列(中等)</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//dp[i][j]表示text1以i结尾,text2以j结尾的最长公共子序列长度</span><br><br>    <span class="hljs-comment">//二维表</span><br>    <span class="hljs-comment">//  abcde</span><br>    <span class="hljs-comment">// 000000</span><br>    <span class="hljs-comment">//a011111</span><br>    <span class="hljs-comment">//c011222</span><br>    <span class="hljs-comment">//e011223</span><br><br>    <span class="hljs-comment">//dp[i][j] = dp[i-1][j-1]+1  (text1[i]==text2[j])</span><br>    <span class="hljs-comment">//dp[i][j] = dp[i][j-1] (text1[i]!=text2[j])</span><br>    <span class="hljs-comment">//dp[i][j] = dp[i-1][j] (text1[i]!=text2[j])</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> text1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> text2.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> text1.charAt(i-<span class="hljs-number">1</span>);<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> text2.charAt(j-<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(c1==c2)dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>                dp[i][j] = Math.max(dp[i-<span class="hljs-number">1</span>][j],dp[i][j]);<br>                dp[i][j] = Math.max(dp[i][j-<span class="hljs-number">1</span>],dp[i][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//dp[i]表示以i结尾的最长递增子序列</span><br>    <span class="hljs-comment">//每轮以nums[i]结尾作为增长序列进行计算，计算n轮即可得出</span><br>    <span class="hljs-comment">//dp[i] = max(dp[i], dp[j] + 1) for j in [0, i)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">//base case</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            dp[i] = <span class="hljs-number">1</span>;<span class="hljs-comment">//最后一个为必取</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-comment">//必须是nums[i]大于nums[j]（前面的数）才能累计</span><br>                <span class="hljs-keyword">if</span> (nums[i]&gt;nums[j])dp[i] = Math.max(dp[i],dp[j]+<span class="hljs-number">1</span>);<br>            &#125;<br>            max = Math.max(max,dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="不同路径-中等"><a href="#不同路径-中等" class="headerlink" title="不同路径(中等)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths/">不同路径(中等)</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//dp方程 dp[i][j]=dp[i+1][j]+dp[i][j+1]</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][n-<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) dp[m-<span class="hljs-number">1</span>][i]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m-<span class="hljs-number">2</span>; i &gt;=  <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">2</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                dp[i][j]=dp[i+<span class="hljs-number">1</span>][j]+dp[i][j+<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-comment">//自顶向下 dp[i][j]=dp[i-1][j]+dp[i][j-1]</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j]+dp[i][j-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="不同路径-II-中等"><a href="#不同路径-II-中等" class="headerlink" title="不同路径 II(中等)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths-ii/">不同路径 II(中等)</a></h4><blockquote>
<p>一维数组压缩状态</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> obstacleGrid.length, m = obstacleGrid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>        f[<span class="hljs-number">0</span>] = obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    f[j] = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; obstacleGrid[i][j - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//且没有障碍的时候在推导</span><br>                    f[j] += f[j - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[m - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>复杂度分析</p>
<ul>
<li>时间复杂度：O(nm)O(nm)，其中 nn 为网格的行数，mm 为网格的列数。我们只需要遍历所有网格一次即可。</li>
<li>空间复杂度：O(m)O(m)。利用滚动数组优化，我们可以只用 O(m)O(m) 大小的空间来记录当前行的 ff 值。</li>
</ul>
<h4 id="最长公共子序列-中等-1"><a href="#最长公共子序列-中等-1" class="headerlink" title="最长公共子序列(中等)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-subsequence/">最长公共子序列(中等)</a></h4><p><img src="https://g.yuque.com/gr/latex?%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B=%5Cbegin%7Bcases%7D%20dp%5Bi%5D%5Bj%5D=dp%5Bi-1%5D%5Bj-1%5D+1%20&%20(str1%5Bi%5D==str2%5Bj%5D)%5C%5C%5C%5C%20dp%5Bi%5D%5Bj%5D=max(dp%5Bi-1%5D%5Bj%5D,dp%5Bi%5D%5Bj-1%5D)%20&%20(str1%5Bi%5D!=str2%5Bj%5D)%5C%5C%5C%5C%20%5Cend%7Bcases%7D%0A#card=math&code=%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B%3D%5Cbegin%7Bcases%7D%20dp%5Bi%5D%5Bj%5D%3Ddp%5Bi-1%5D%5Bj-1%5D%2B1%20%26%20%28str1%5Bi%5D%3D%3Dstr2%5Bj%5D%29%5C%5C%5C%5C%20dp%5Bi%5D%5Bj%5D%3Dmax%28dp%5Bi-1%5D%5Bj%5D%2Cdp%5Bi%5D%5Bj-1%5D%29%20%26%20%28str1%5Bi%5D%21%3Dstr2%5Bj%5D%29%5C%5C%5C%5C%20%5Cend%7Bcases%7D%0A&id=LJFl9" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>  <span class="hljs-title function_">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> &#123;<br>        <span class="hljs-type">char</span>[] t1 = text1.toCharArray();<br>        <span class="hljs-type">char</span>[] t2 = text2.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length1</span> <span class="hljs-operator">=</span> t1.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length2</span> <span class="hljs-operator">=</span> t2.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length1+<span class="hljs-number">1</span>][length2+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//求dp</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; length1 +<span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; length2 +<span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (t1[i-<span class="hljs-number">1</span>] == t2[j-<span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-comment">// 这边找到一个 lcs 的元素，继续往前找</span><br>                    dp[i][j] = <span class="hljs-number">1</span>+ dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//谁能让 lcs 最长，就听谁的</span><br>                    dp[i][j] = Math.max(dp[i-<span class="hljs-number">1</span>][j],dp[i][j-<span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[length1][length2];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="最大子序和-简单"><a href="#最大子序和-简单" class="headerlink" title="最大子序和(简单)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/">最大子序和(简单)</a></h4><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<blockquote>
<p>状态转移方程 f(i)=max{f(i−1)+nums[i],nums[i]}</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, maxAns = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>            pre = Math.max(pre + x, x);<br>            maxAns = Math.max(maxAns, pre);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxAns;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="乘积最大子数组-中等"><a href="#乘积最大子数组-中等" class="headerlink" title="乘积最大子数组(中等)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-subarray/description/">乘积最大子数组(中等)</a></h4><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/maximum-product-subarray.png#id=CQWS1&originHeight=126&originWidth=452&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//dp[i][0]表示以i结尾的乘积最大值</span><br>    <span class="hljs-comment">//dp[i][1]表示以i结尾的乘积最小值</span><br>    <span class="hljs-comment">//dp[i][0]=Math.max(nums[i],dp[i-1][1]*nums[i],dp[i-1][0]*nums[i])</span><br>    <span class="hljs-comment">//dp[i][1]=Math.min(nums[i],dp[i-1][1]*nums[i],dp[i-1][0]*nums[i])</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProduct</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] maxF = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length];<br>        <span class="hljs-type">int</span>[] minF = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length];<br>        System.arraycopy(nums, <span class="hljs-number">0</span>, maxF, <span class="hljs-number">0</span>, length);<br>        System.arraycopy(nums, <span class="hljs-number">0</span>, minF, <span class="hljs-number">0</span>, length);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; length; ++i) &#123;<br>            maxF[i] = Math.max(maxF[i - <span class="hljs-number">1</span>] * nums[i], Math.max(nums[i], minF[i - <span class="hljs-number">1</span>] * nums[i]));<br>            minF[i] = Math.min(minF[i - <span class="hljs-number">1</span>] * nums[i], Math.min(nums[i], maxF[i - <span class="hljs-number">1</span>] * nums[i]));<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> maxF[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; length; ++i) &#123;<br>            ans = Math.max(ans, maxF[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">//优化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProduct</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxF</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>], minF = nums[<span class="hljs-number">0</span>], ans = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; length; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mx</span> <span class="hljs-operator">=</span> maxF, mn = minF;<br>            maxF = Math.max(mx * nums[i], Math.max(nums[i], mn * nums[i]));<br>            minF = Math.min(mn * nums[i], Math.min(nums[i], mx * nums[i]));<br>            ans = Math.max(maxF, ans);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="删除并获得点数-中等"><a href="#删除并获得点数-中等" class="headerlink" title="删除并获得点数(中等)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-and-earn/">删除并获得点数(中等)</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteAndEarn</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxVal</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//找出最大值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : nums) &#123;<br>            maxVal = Math.max(maxVal, val);<br>        &#125;<br>        <span class="hljs-comment">//构建数组(每个数有的个数)</span><br>        <span class="hljs-type">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[maxVal + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : nums) &#123;<br>            sum[val] += val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> rob(sum);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>], second = Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> second;<br>            second = Math.max(first + nums[i], second);<br>            first = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> second;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="回文串-中等"><a href="#回文串-中等" class="headerlink" title="回文串(中等)"></a>回文串(中等)</h4><blockquote>
<p>思路1:中间向两边扩散，遍历字符数组，时间复杂度O(n^2)</p>
</blockquote>
<blockquote>
<p>思路2:对于一个子串而言，如果它是回文串，并且长度大于 2，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串 “ababa”，如果我们已经知道 “bab” 是回文串，那么 “ababa” 一定是回文串，这是因为它的首尾两个字母都是 “a”。<br>得出状态转移方程 <code>P(i,j)=P(i+1,j−1)∧(Si==Sj)</code>也就是说，只有 s[i+1:j-1]s[i+1:j−1] 是回文串，并且 ss 的第 i 和 j 个字母相同时，s[i:j]s[i:j] 才会是回文串。时间复杂度O(n^2)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">//dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-comment">//特殊情况</span><br>        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// dp[i][j] 表示 s[i..j] 是否是回文串</span><br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[len][len];<br>        <span class="hljs-comment">// 初始化：所有长度为 1 的子串都是回文串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            dp[i][i] = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-type">char</span>[] charArray = s.toCharArray();<br>        <span class="hljs-comment">// 递推开始</span><br>        <span class="hljs-comment">// 先枚举子串长度（先一列一列的填，在一行一行填）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">L</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; L &lt;= len; L++) &#123;<br>            <span class="hljs-comment">// 枚举左边界，左边界的上限设置可以宽松一些</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>                <span class="hljs-comment">// 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> L + i - <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 如果右边界越界，就可以退出当前循环</span><br>                <span class="hljs-keyword">if</span> (j &gt;= len) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">//如果字符不相等</span><br>                <span class="hljs-keyword">if</span> (charArray[i] != charArray[j]) &#123;<br>                    dp[i][j] = <span class="hljs-literal">false</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-keyword">if</span> (j - i &lt; <span class="hljs-number">3</span>) &#123;<br>                        dp[i][j] = <span class="hljs-literal">true</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-comment">// 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置</span><br>                <span class="hljs-keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="hljs-number">1</span> &gt; maxLen) &#123;<br>                    maxLen = j - i + <span class="hljs-number">1</span>;<br>                    begin = i;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(begin, begin + maxLen);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>马拉车算法</p>
</blockquote>
<h4 id="最长定差子序列-中等"><a href="#最长定差子序列-中等" class="headerlink" title="最长定差子序列(中等)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/">最长定差子序列(中等)</a></h4><blockquote>
<p>我们从头遍历数组，遇到一个数 x，判断 x-d 在不在数组里面即可知道，能不能形成以 x 为结尾的等差数组，同时，我们记录下来以 x 结尾的等差数组的长度，这样，在后续的遍历过程中，我们就可以使用得上这个长度了。</p>
</blockquote>
<p>我们来举个例子，假设给定数组为 [1,5,3,6,5,7]，等差 d=2，辅助数组为 dp，求解的过程如下：<br>遍历到 1，发现 1-2=-1 不在 dp 数组，记录 dp[1] = 1，表示以 1 结尾的等差数列只有 1 个数；<br>遍历到 5，发现 5-2=3 不在 dp 数组，记录 dp[5]=1；<br>遍历到 3，发现 3-2=1 在 dp 数组且以 1 结尾的等差数列长度为 1，所以，记录 dp[3]=dp[3-2]+1=2，表示以 3 结尾的等差数列长度为 2；<br>遍历到 6，发现 6-2=4 不在 dp 数组，记录 dp[6]=1；<br>遍历到 5，发现 5-2=3 在 dp 数组，记录 dp[5]=dp[5-2]+1=3；<br>遍历到 7，发现 7-2=5 在 dp 数组，记录 dp[7]=dp[7-2]+1=4；<br>取 dp 数组中的最大值，即 4，所以，最长等差子序列的长度为 4。<br>这其实就是动态规划的递推过程，所以，我们可以定义动态规划如下：<br>状态定义：dp[x] 表示以 x 结尾的最长等差子序列的长度；<br>状态转移：dp[x]=dp[x-d]+1；<br>初始值：无；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestSubsequence</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> difference)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Map&lt;Integer, Integer&gt; dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : arr) &#123;<br>            dp.put(v, dp.getOrDefault(v - difference, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            ans = Math.max(ans, dp.get(v));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="分割等和子集-中等"><a href="#分割等和子集-中等" class="headerlink" title="分割等和子集(中等)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">分割等和子集(中等)</a></h4><p>思路:</p>
<blockquote>
<p>转化为求当前数组元素和==所有元素和/2，进一步转化为背包问题，将数组元素装入total_sum/2的背包中，通过动态规划求解</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, maxNum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            sum += num;<br>            maxNum = Math.max(maxNum, num);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (maxNum &gt; target) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[target + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> target; j &gt;= num; --j) &#123;<br>                dp[j] |= dp[j - num];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="戳气球-hard"><a href="#戳气球-hard" class="headerlink" title="戳气球 (hard)"></a>戳气球 (hard)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">思路:<br>dp[i][j] 表示开区间 (i,j) 能拿到的的金币，k是这个区间 最后一个 被戳爆的气球，枚举i和j，<br>遍历所有区间。<br><br>i-j能获得的最大数量的金币=戳破当前的气球获得的金钱+之前i-k、k-j区间中已经获得的金币<br><br>dp[i][j]=max(dp[i][j],dp[i][k]+val[i] * val[k] * val[j]+dp[k][j])<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxCoins</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>][n + <span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span>[] val = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>];<br>        val[<span class="hljs-number">0</span>] = val[n + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">//边界</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-comment">//初始化</span><br>            val[i] = nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">2</span>; j &lt;= n + <span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; k &lt; j; k++) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> val[i] * val[k] * val[j];<br>                    sum += dp[i][k] + dp[k][j];<br>                    dp[i][j] = Math.max(dp[i][j], sum);<br>                &#125;<br>            &#125;<br>        &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n + <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h4 id="198-打家劫舍（mid）"><a href="#198-打家劫舍（mid）" class="headerlink" title="198. 打家劫舍（mid）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a>（mid）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//dp方程：dp[i]=max(dp[i-1],dp[i-2]+num[i])</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//dp[i] = max(dp[i-1],dp[i-2]+nums[i])</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        <span class="hljs-comment">//边界</span><br>        dp[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>]=Math.max(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;nums.length;i++)&#123;<br>            dp[i] = Math.max(dp[i-<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">2</span>]+nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[nums.length-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="打家劫舍II"><a href="#打家劫舍II" class="headerlink" title="打家劫舍II"></a>打家劫舍II</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//因为围成了圈，分为两种情况，抢了第一个，最后一个就不能抢了</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> Math.max(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">return</span> Math.max(<br>            robRange(<span class="hljs-number">0</span>,nums.length-<span class="hljs-number">2</span>,nums),<span class="hljs-comment">//可取第一个进行计算,不取最后一个</span><br>            robRange(<span class="hljs-number">1</span>,nums.length-<span class="hljs-number">1</span>,nums)<span class="hljs-comment">//可取最后一个进行计算,不取第一个</span><br>        );<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">robRange</span><span class="hljs-params">(<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end,<span class="hljs-type">int</span>[] nums)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">one</span> <span class="hljs-operator">=</span> nums[start];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span>Math.max(nums[start],nums[start+<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start+<span class="hljs-number">2</span>;i&lt;=end;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> second;<br>            second = Math.max(one+nums[i],second);<br>            one = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> second;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="打家劫舍III-medium"><a href="#打家劫舍III-medium" class="headerlink" title="打家劫舍III  (medium)"></a>打家劫舍III  (medium)</h4><p>其核心思想还是不能取相临的节点，针对某个节点有两种选择 打劫或者不打劫，当前打劫下一个节点就不能打劫。通过dfs遍历树，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-type">int</span>[] rootStatus = dfs(root);<br>    <span class="hljs-keyword">return</span> Math.max(rootStatus[<span class="hljs-number">0</span>], rootStatus[<span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dfs(TreeNode node) &#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//arr[0]抢，arr[1]不抢</span><br>    <span class="hljs-type">int</span>[] l = dfs(node.left);<br>    <span class="hljs-type">int</span>[] r = dfs(node.right);<br>    <span class="hljs-comment">//选择当前节点=当前节点+左边子节点不抢+右边子节点不抢</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">selected</span> <span class="hljs-operator">=</span> node.val + l[<span class="hljs-number">1</span>] + r[<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//不选择当前节点，就可以抢或者不抢左右子节点</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">notSelected</span> <span class="hljs-operator">=</span> Math.max(l[<span class="hljs-number">0</span>], l[<span class="hljs-number">1</span>]) + Math.max(r[<span class="hljs-number">0</span>], r[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;selected, notSelected&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="买卖股票-（easy）"><a href="#买卖股票-（easy）" class="headerlink" title="买卖股票 （easy）"></a>买卖股票 （easy）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//贪心</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minPrices</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxProfit</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;prices.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(prices[i]&lt;minPrices)minPrices=prices[i];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(prices[i]-minPrices&gt;maxProfit)&#123;<br>                maxProfit=prices[i]-minPrices;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxProfit;<br>    &#125;<br>    <span class="hljs-comment">// dp[i][2] 表示第i天获得的最大利润</span><br><br>    <span class="hljs-comment">// dp[i][0] 下标为 i 这天结束的时候，不持股，手上拥有的现金数</span><br>    <span class="hljs-comment">// dp[i][1] 下标为 i 这天结束的时候，持股，手上拥有的现金数</span><br><br>    <span class="hljs-comment">//今天卖出或者昨天卖出</span><br>    <span class="hljs-comment">// dp[i][0] = Math.max(dp[i-1][1]+prices[i],dp[i-1][0])  </span><br>    <span class="hljs-comment">//                      dp[i-1][1]+prices[i]表示前一天持股今天卖出+prices[i]</span><br>    <span class="hljs-comment">//                      dp[i-1][0]表示前一天就已经卖出不持股</span><br>    <br>    <span class="hljs-comment">//今天买入或者昨天买入</span><br>    <span class="hljs-comment">// dp[i][1] = Math.max(dp[i-1][1],-prices[i])</span><br>    <span class="hljs-comment">//                      dp[i-1][1] 表示前一天买入后手上拥有的现金数</span><br>    <span class="hljs-comment">//                      -prices[i] 表示今天买入后手上拥有的现金数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+prices[i],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);<br>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],-prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="买卖股票II（medium）"><a href="#买卖股票II（medium）" class="headerlink" title="买卖股票II（medium）"></a>买卖股票II（medium）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//dp</span><br>    <span class="hljs-comment">//要么买入股票，要么卖出得到现金。买入股票需要前一天已经卖出，所以如果买入比较 （前一天卖出得到的钱-今天买入话的钱）再和昨天如果买入dp[i-1][1]取拥有max现金的</span><br>    <span class="hljs-comment">//定义状态</span><br>    <span class="hljs-comment">//dp[i][j] 表示到下标为i的这一天，持股状态为j时，我们手上拥有的最大现金数。j=0持有现金，j=1表示持有股票</span><br>    <span class="hljs-comment">//dp[i][0] = max(dp[i-1][0],dp[i-1][1]+prices[i]) max(昨天卖出股票后拥有的现金,昨天买入股票后拥有的现金+今天卖出得的现金)</span><br>    <span class="hljs-comment">//dp[i][1] = max(dp[i-1][1],dp[i-1][0]-prices[i]) max(昨天买入股票拥有的现金,昨天持有现金拥有的现金-今天买入股票花费的现金)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>    	<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);<br>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<span class="hljs-comment">//持有现金</span><br>    &#125;<br>    <span class="hljs-comment">//贪心：有利可图就卖出</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;prices.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(prices[i]-prices[i-<span class="hljs-number">1</span>]&gt;<span class="hljs-number">0</span>)&#123;<br>                ans+=prices[i]-prices[i-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="买卖股票的最佳时机-III-hard"><a href="#买卖股票的最佳时机-III-hard" class="headerlink" title="买卖股票的最佳时机 III (hard)"></a>买卖股票的最佳时机 III (hard)</h4><p>思路：动态规划</p>
<p>每一天结束之后，有可能处于以下五种状态之一：</p>
<ul>
<li>没有买股也没有卖股。</li>
<li>买了第一支股，但是还没有卖出第一支股。</li>
<li>买了第一支股，并且卖出第一支股。</li>
<li>买了第一支股，并且卖出第一支股，买了第二支股，但是还没有卖出第二支股。</li>
<li>买了第一支股，并且卖出第一支股，买了第二支股，并且卖出第二支股。</li>
<li>我们可以遍历 prices 数组，模拟第 i 天的情况。计算出第 i 天五种情况利润的最大值。</li>
</ul>
<p>1.对于第一种情况，利润始终为 0。</p>
<p>2.对于第二种情况，由于还没有盈利，只买进了某支股，为亏损状态。此时，亏损的最小值是 prices[0] 至 prices[i] 的最小值，假设为 buy1。可以看做，第二种情况利润的最大值为：-buy1。</p>
<blockquote>
<p>状态转移方程为：buy1 = max(buy1, -prices[i]);</p>
</blockquote>
<p>3.对于第三种情况，利润的计算需要在第二种情况的基础上再卖出一支股。所以需要先计算第二种情况，再在遍历到 prices[i] 的时候，判断要不要卖出。如果在以最小的亏损买入第一支股的情况下，卖出当前这支股所得利润最大，则卖出当前这支股。</p>
<blockquote>
<p>状态转移方程为：sell1 = max(sell1, prices[i] + buy1);</p>
</blockquote>
<p>注意这里是 prices[i] + buy1，不是 prices[i] - buy1，因为 buy1 是负值，代表利润。</p>
<p>4.对于第四种情况，不能直接买入，因为有可能第一支股还没卖出。利润的计算需要在第三种情况的基础上再买入一支股。所以需要先计算第三种情况，再在遍历到 prices[i] 的时候，判断要不要买入。如果在卖出第一支股所得利润最大的情况下，买入当前这支股最终所得利润最大，则买入当前这支股。</p>
<blockquote>
<p>状态转移方程为：buy2 = max(buy2, sell1 - prices[i]);</p>
</blockquote>
<p>5.对于第五种情况，利润的计算需要在第四种情况的基础上再卖出一支股。所以需要先计算第四种情况，再在遍历到 prices[i] 的时候，判断要不要卖出。如果在卖出第一支股然后买入第二支股所得利润最大的情况下，卖出当前这支股所得利润最大，则卖出当前这支股。</p>
<p>状态转移方程为：</p>
<blockquote>
<p>状态转移方程为：sell2 = max(sell2, prices[i] + buy2);</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">buy1</span> <span class="hljs-operator">=</span> -prices[<span class="hljs-number">0</span>], sell1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">buy2</span> <span class="hljs-operator">=</span> -prices[<span class="hljs-number">0</span>], sell2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            buy1 = Math.max(buy1, -prices[i]);<br>            sell1 = Math.max(sell1, buy1 + prices[i]);<br>            buy2 = Math.max(buy2, sell1 - prices[i]);<br>            sell2 = Math.max(sell2, buy2 + prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sell2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs sql">class Solution &#123;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>一天结束时，可能有持股、可能未持股、可能卖出过<span class="hljs-number">1</span>次、可能卖出过<span class="hljs-number">2</span>次、也可能未卖出过<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>所以定义状态转移数组dp[天数][当前是否持股][卖出的次数]<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>具体一天结束时的<span class="hljs-number">6</span>种状态：<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>未持股，未卖出过股票：说明从未进行过买卖，利润为<span class="hljs-number">0</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<span class="hljs-operator">=</span><span class="hljs-number">0</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>未持股，卖出过<span class="hljs-number">1</span>次股票：可能是今天卖出，也可能是之前卖的（昨天也未持股且卖出过）<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<span class="hljs-operator">=</span><span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<span class="hljs-operator">+</span>prices[i],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>])<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>未持股，卖出过<span class="hljs-number">2</span>次股票:可能是今天卖出，也可能是之前卖的（昨天也未持股且卖出过）<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]<span class="hljs-operator">=</span><span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]<span class="hljs-operator">+</span>prices[i],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">2</span>])<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>持股，未卖出过股票：可能是今天买的，也可能是之前买的（昨天也持股）<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<span class="hljs-operator">=</span><span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<span class="hljs-operator">-</span>prices[i],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>持股，卖出过<span class="hljs-number">1</span>次股票：可能是今天买的，也可能是之前买的（昨天也持股）<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]<span class="hljs-operator">=</span><span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<span class="hljs-operator">-</span>prices[i],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>持股，卖出过<span class="hljs-number">2</span>次股票：最多交易<span class="hljs-number">2</span>次，这种情况不存在<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]<span class="hljs-operator">=</span>MIN_VALUE<br>    public <span class="hljs-type">int</span> maxProfit(<span class="hljs-type">int</span>[] prices) &#123;<br>        <span class="hljs-type">int</span> n <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span>[][][] dp <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n][<span class="hljs-number">2</span>][<span class="hljs-number">3</span>];<br>        <span class="hljs-type">int</span> MIN_VALUE <span class="hljs-operator">=</span> Integer.MIN_VALUE <span class="hljs-operator">/</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>第一天休息<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>第一天买入<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<span class="hljs-operator">=</span><span class="hljs-operator">-</span>prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>第一天不可能已经有卖出<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] <span class="hljs-operator">=</span> MIN_VALUE;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] <span class="hljs-operator">=</span> MIN_VALUE;<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>第一天不可能已经卖出<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] <span class="hljs-operator">=</span> MIN_VALUE;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] <span class="hljs-operator">=</span> MIN_VALUE;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i<span class="hljs-operator">=</span><span class="hljs-number">1</span>;i<span class="hljs-operator">&lt;</span>n;i<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)&#123;<br>            dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>            dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<span class="hljs-operator">=</span>Math.<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<span class="hljs-operator">+</span>prices[i],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]);<br>            dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]<span class="hljs-operator">=</span>Math.<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]<span class="hljs-operator">+</span>prices[i],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]);<br>            dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<span class="hljs-operator">=</span>Math.<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<span class="hljs-operator">-</span>prices[i],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);<br>            dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]<span class="hljs-operator">=</span>Math.<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<span class="hljs-operator">-</span>prices[i],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>            dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]<span class="hljs-operator">=</span>Math.<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<span class="hljs-operator">-</span>prices[i],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>            dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]<span class="hljs-operator">=</span>MIN_VALUE;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,Math.<span class="hljs-built_in">max</span>(dp[n <span class="hljs-operator">-</span> <span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], dp[n <span class="hljs-operator">-</span> <span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="买卖股票的最佳时机-IV-hard"><a href="#买卖股票的最佳时机-IV-hard" class="headerlink" title="买卖股票的最佳时机 IV (hard)"></a>买卖股票的最佳时机 IV (hard)</h4><h4 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">买卖股票的最佳时机含手续费</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//买入 dp[i][0] =  max(dp[i-1][0],dp[i-1][1]+prices[i])</span><br>    <span class="hljs-comment">//卖出 dp[i][1] =  max(dp[i-1][1],dp[i-1][0]-prices[i]-fee)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices, <span class="hljs-type">int</span> fee)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[prices.length][<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=-prices[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;prices.length;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] =  Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]-prices[i]));<br>            dp[i][<span class="hljs-number">1</span>] =  Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+prices[i])-fee);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[prices.length-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="最佳买卖股票时机含冷冻期"><a href="#最佳买卖股票时机含冷冻期" class="headerlink" title="最佳买卖股票时机含冷冻期"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">最佳买卖股票时机含冷冻期</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-keyword">if</span> (prices.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-comment">// f[i][0]: 手上持有股票的最大收益</span><br>        <span class="hljs-comment">// f[i][1]: 手上不持有股票，并且处于冷冻期中的累计最大收益</span><br>        <span class="hljs-comment">// f[i][2]: 手上不持有股票，并且不在冷冻期中的累计最大收益</span><br>        <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">3</span>];<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-comment">//</span><br>            f[i][<span class="hljs-number">0</span>] = Math.max(f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - prices[i]);<br>            f[i][<span class="hljs-number">1</span>] = f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i];<br>            f[i][<span class="hljs-number">2</span>] = Math.max(f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(f[n - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], f[n - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>参考大佬的题解：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/mai-mai-gu-piao-wen-ti-by-chen-wei-f-xvs1/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/mai-mai-gu-piao-wen-ti-by-chen-wei-f-xvs1/</a><br><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1641307193131-59c0f6a3-0be7-4777-b98e-caf89127a8ab.png#averageHue=%23f4f4f4&clientId=uc9b68089-6912-4&errorMessage=unknown%20error&from=paste&height=373&id=u38ab70ae&name=image.png&originHeight=745&originWidth=956&originalType=binary&ratio=1&rotation=0&showTitle=false&size=101900&status=error&style=none&taskId=ucb98539b-81e3-4538-8338-5a189535e1f&title=&width=478" srcset="/img/loading.gif" lazyload alt="image.png"><br>状态转移方程<br>dp[i][k][0] = Math.max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i])<br>//冷却时间1天，所以要从 i - 2 天转移状态<br>//买入，卖出 —- 冷冻期 —-  买入，卖出<br>dp[i][k][1] = Math.max(dp[i - 1][k][1], dp[i - 2][k - 1][0] - prices[i])<br>题目不限制k的大小，可以舍去<br>dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i])<br>dp[i][1] = Math.max(dp[i - 1][1], dp[i - 2][0] - prices[i])<br>//降维i<br>dp[0] = Math.max(dp[0], dp[1] + prices[i])<br>dp[1] = Math.max(dp[1], profit_freeze - prices[i])</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">const</span> <span class="hljs-variable">maxProfit</span> <span class="hljs-operator">=</span> function (prices) &#123;<br>    <span class="hljs-type">let</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>    <span class="hljs-type">let</span> <span class="hljs-variable">buy</span> <span class="hljs-operator">=</span> -prices[<span class="hljs-number">0</span>];<span class="hljs-comment">//手中有股票</span><br>    <span class="hljs-type">let</span> <span class="hljs-variable">sell</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//没有股票</span><br>    <span class="hljs-type">let</span> <span class="hljs-variable">profit_freeze</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">let</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">let</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> sell;<br>        sell = Math.max(sell, buy + prices[i]);<br>        buy = Math.max(buy, profit_freeze - prices[i]);<br>        profit_freeze = temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sell;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="最大子数组和（easy）"><a href="#最大子数组和（easy）" class="headerlink" title="最大子数组和（easy）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/">最大子数组和</a>（easy）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//dp[i]表示以第nums[i]结尾的最大取值</span><br>    <span class="hljs-comment">//dp[i] = Math.max(nums[i],dp[i-1]+nums[i]);</span><br>    <span class="hljs-comment">//在遍历过程中共两种选择：</span><br>    <span class="hljs-comment">// 1.在当前数组中选择当前的数 dp[i-1]+nums[i]</span><br>    <span class="hljs-comment">// 2.在当前数组中不选择当前的数，那当前的数作为新一轮的数组第一个元素 nums[i]</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> dp[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dp[i-<span class="hljs-number">1</span>]+nums[i];<br>            dp[i] = nums[i] &gt; cur ? nums[i] : cur;<br>            ret = ret &gt; dp[i] ? ret :dp[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/edit-distance/">编辑距离</a></h4><p>举个例子，word1 = “abcde”, word2 = “fgh”,我们现在算这俩字符串的编辑距离，就是找从word1，最少多少步，能变成word2？那就有三种方式：</p>
<ol>
<li>知道”abcd”变成”fgh”多少步（假设X步），那么从”abcde”到”fgh”就是”abcde”-&gt;”abcd”-&gt;”fgh”。（一次删除，加X步，总共X+1步）</li>
<li>知道”abcde”变成“fg”多少步（假设Y步），那么从”abcde”到”fgh”就是”abcde”-&gt;”fg”-&gt;”fgh”。（先Y步，再一次添加，加X步，总共Y+1步）</li>
<li>知道”abcd”变成“fg”多少步（假设Z步），那么从”abcde”到”fgh”就是”abcde”-&gt;”fge”-&gt;”fgh”。（先不管最后一个字符，把前面的先变好，用了Z步，然后把最后一个字符给替换了。这里如果最后一个字符碰巧就一样，那就不用替换，省了一步）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//word1变成word2最少操作步骤</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//dp[i][j] 表示 A 的前 i 个字母和 B 的前 j 个字母之间的编辑距离</span><br><span class="hljs-comment">//dp[i][j]=min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+int(word1[i]!=word2[j]))</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> word1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> word2.length();<br>        <span class="hljs-keyword">if</span>(m*n==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> m+n;<br>        <span class="hljs-comment">//dp[i][j]表示 word1[0..i] 转为为 word2[0...j] 所使用的最少操作数</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//初始化(&quot;&quot;转为其他字符串(abc)的操作数为len(abc))</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)dp[<span class="hljs-number">0</span>][i]=i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;i++)dp[i][<span class="hljs-number">0</span>]=i;<br>        <span class="hljs-comment">//递推dp</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">delete</span> <span class="hljs-operator">=</span> dp[i-<span class="hljs-number">1</span>][j]+<span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> dp[i][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">replace</span> <span class="hljs-operator">=</span> dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(word1.charAt(i-<span class="hljs-number">1</span>)!=word2.charAt(j-<span class="hljs-number">1</span>))replace++;<br>                dp[i][j]=Math.min(replace,Math.min(add,delete));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br><span class="hljs-comment">// dp[i][j] 代表 word1 到 i 位置转换成 word2 到 j 位置需要最少步数</span><br><span class="hljs-comment">// 所以，</span><br><span class="hljs-comment">// 当 word1[i] == word2[j]，dp[i][j] = dp[i-1][j-1]；</span><br><span class="hljs-comment">// 当 word1[i] != word2[j]，dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1</span><br><span class="hljs-comment">// 其中，dp[i-1][j-1] 表示替换操作，dp[i-1][j] 表示删除操作，dp[i][j-1] 表示插入操作。</span><br><span class="hljs-comment">// 注意，针对第一行，第一列要单独考虑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> word1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> word2.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= m; i++) dp[i][<span class="hljs-number">0</span>] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) dp[<span class="hljs-number">0</span>][i] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (word1.charAt(i-<span class="hljs-number">1</span>)==word2.charAt(j-<span class="hljs-number">1</span>)) dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">else</span> dp[i][j] = Math.min(Math.min(dp[i][j-<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][j]),dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>])+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="统计元音字母序列的数目"><a href="#统计元音字母序列的数目" class="headerlink" title="统计元音字母序列的数目"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-vowels-permutation/">统计元音字母序列的数目</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//已知:</span><br>    <span class="hljs-comment">//每个元音 &#x27;a&#x27; 后面都只能跟着 &#x27;e&#x27;</span><br>    <span class="hljs-comment">//每个元音 &#x27;e&#x27; 后面只能跟着 &#x27;a&#x27; 或者是 &#x27;i&#x27;</span><br>    <span class="hljs-comment">//每个元音 &#x27;i&#x27; 后面 不能 再跟着另一个 &#x27;i&#x27;</span><br>    <span class="hljs-comment">//每个元音 &#x27;o&#x27; 后面只能跟着 &#x27;i&#x27; 或者是 &#x27;u&#x27;</span><br>    <span class="hljs-comment">//每个元音 &#x27;u&#x27; 后面只能跟着 &#x27;a&#x27;</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">//可知:</span><br>    <span class="hljs-comment">//每个元音 &#x27;a&#x27; 前面 &#x27;u&#x27;,&#x27;e&#x27;,&#x27;i&#x27;</span><br>    <span class="hljs-comment">//每个元音 &#x27;e&#x27; 前面 &#x27;a&#x27;,&#x27;i&#x27;</span><br>    <span class="hljs-comment">//每个元音 &#x27;i&#x27; 前面 &#x27;o&#x27;,&#x27;e&#x27;</span><br>    <span class="hljs-comment">//每个元音 &#x27;o&#x27; 前面 &#x27;i&#x27;,</span><br>    <span class="hljs-comment">//每个元音 &#x27;u&#x27; 前面 &#x27;o&#x27;,&#x27;i&#x27;</span><br>    <span class="hljs-comment">//dp[i][j]标识长度为i，元音j结尾的个数</span><br>    <span class="hljs-comment">//dp[i][0] = dp[i-1][4] + dp[i-1][1] + dp[i-1][2]</span><br>    <span class="hljs-comment">//dp[i][1] = dp[i-1][0] + dp[i-1][2]</span><br>    <span class="hljs-comment">//dp[i][2] = dp[i-1][3] + dp[i-1][1]</span><br>    <span class="hljs-comment">//dp[i][3] = dp[i-1][2]</span><br>    <span class="hljs-comment">//dp[i][4] = dp[i-1][2] + dp[i-1][3]</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countVowelPermutation0</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br>        <span class="hljs-type">long</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n+<span class="hljs-number">1</span>][<span class="hljs-number">5</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)dp[<span class="hljs-number">1</span>][i]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;n+<span class="hljs-number">1</span>;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = (dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">4</span>] + dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>])%mod;<br>            dp[i][<span class="hljs-number">1</span>] = (dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>])%mod;<br>            dp[i][<span class="hljs-number">2</span>] = (dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] + dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])%mod;<br>            dp[i][<span class="hljs-number">3</span>] = (dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>])%mod;<br>            dp[i][<span class="hljs-number">4</span>] = (dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] + dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">3</span>])%mod;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)((dp[n][<span class="hljs-number">0</span>]+dp[n][<span class="hljs-number">1</span>]+dp[n][<span class="hljs-number">2</span>]+dp[n][<span class="hljs-number">3</span>]+dp[n][<span class="hljs-number">4</span>])%mod);<br>    &#125;<br>    <span class="hljs-comment">//dp优化空间</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countVowelPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, e = <span class="hljs-number">1</span>, i = <span class="hljs-number">1</span>, o = <span class="hljs-number">1</span>, u = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; k &lt; n + <span class="hljs-number">1</span>; k++) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">ap</span> <span class="hljs-operator">=</span> a,ep = e,ip = i,op = o,up = u;<br>            a = (up + ep + ip) % mod;<br>            e = (ap + ip) % mod;<br>            i = (op + ep) % mod;<br>            o = ip % mod;<br>            u = (ip + op) % mod;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) ((a + e + i + o + u) % mod);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">最长重复子数组</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//dp[i][j]表示以nums1[i]结尾nums2[j]结尾的最长重复子数组</span><br>    <span class="hljs-comment">//dp[i][j] = Math.max(0,dp[i-1][j-1]+1 &amp;&amp; nums1[i]==nums2[j])</span><br>    <br>    <span class="hljs-comment">//dp[i][j]表示以nums1[i]结尾和nums2[j]结尾的最长重复数组</span><br>    <span class="hljs-comment">//  1,2,3,2,1]</span><br>    <span class="hljs-comment">//3,0,0,1,0,0</span><br>    <span class="hljs-comment">//2,0,1,1,2,0</span><br>    <span class="hljs-comment">//1,1,0,0,2,3</span><br>    <span class="hljs-comment">//4,0,0,0,0,0</span><br>    <span class="hljs-comment">//7,0,0,0,0,0</span><br>    <span class="hljs-comment">//如果碰到了不等于的，那从这个不等于的位置就要从0开始计了，这一点和求公共子序列不同</span><br>    <span class="hljs-comment">//dp[i][j] = max(dp[i-1][j-1]+(A[i-1] == B[j-1]?1:0),dp[i-1][j],dp[i][j-1])</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span>[] B)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> A.length, m = B.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                dp[i][j] = A[i] == B[j] ? dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>                ans = Math.max(ans, dp[i][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="最长有效括号（hard）"><a href="#最长有效括号（hard）" class="headerlink" title="最长有效括号（hard）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-valid-parentheses/">最长有效括号</a>（hard）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">1.</span>我们只有遇到<span class="hljs-string">&#x27;)&#x27;</span>的时候才有必要去计算<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">2.</span>每两个字符检查一次：<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">2.1</span> “()”的情况,当前<span class="hljs-string">&#x27;)&#x27;</span>与s[i<span class="hljs-number">-1</span>]构成有效括号,dp[i]<span class="hljs-operator">=</span>dp[i<span class="hljs-number">-2</span>]<span class="hljs-operator">+</span><span class="hljs-number">2</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">2.2</span> “))”的情况,s[i<span class="hljs-number">-1</span>]<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;)&#x27;</span>,需要判断，s[i<span class="hljs-number">-1</span>]是否与前面的构成有效括号，否则s[i]无法构成有效括号。<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>		这时，我们只需要找到和s[i]配对对位置，并判断其是否是 <span class="hljs-string">&#x27;(&#x27;</span> 即可。和其配对的位置为：i<span class="hljs-operator">-</span>dp[i−<span class="hljs-number">1</span>]<span class="hljs-number">-1</span>。<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>	（因为dp[i<span class="hljs-number">-1</span>]表示的是[<span class="hljs-number">0</span>,i<span class="hljs-number">-1</span>]的有效括号个数,使用i<span class="hljs-operator">-</span>dp[i<span class="hljs-number">-1</span>]得出第一位有效括号的下标，<span class="hljs-number">-1</span>则获取前面一位，如&quot;))(())&quot;,dp[<span class="hljs-number">4</span>]<span class="hljs-operator">=</span><span class="hljs-number">2</span>, <span class="hljs-number">5</span><span class="hljs-operator">-</span>dp[<span class="hljs-number">4</span>]<span class="hljs-number">-1</span><span class="hljs-operator">=</span><span class="hljs-number">2</span>,dp[<span class="hljs-number">5</span>]<span class="hljs-operator">=</span>dp[<span class="hljs-number">4</span>]<span class="hljs-operator">+</span>dp[<span class="hljs-number">2</span>]<span class="hljs-operator">+</span><span class="hljs-number">2</span>)<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>	  如果s[i<span class="hljs-operator">-</span>dp[i<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>]<span class="hljs-operator">=</span><span class="hljs-string">&#x27;(&#x27;</span>则 dp[i]<span class="hljs-operator">=</span>dp[i<span class="hljs-number">-1</span>]<span class="hljs-operator">+</span>dp[i<span class="hljs-operator">-</span>dp[i<span class="hljs-number">-1</span>]<span class="hljs-number">-2</span>]<span class="hljs-operator">+</span><span class="hljs-number">2</span><br>class Solution &#123;<br>    public <span class="hljs-type">int</span> longestValidParentheses(String s) &#123;<br>        <span class="hljs-type">int</span> maxans <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] dp <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[s.length()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i <span class="hljs-operator">&lt;</span> s.length(); i<span class="hljs-operator">+</span><span class="hljs-operator">+</span>) &#123;<br>            if (s.charAt(i) <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                if (s.charAt(i <span class="hljs-operator">-</span> <span class="hljs-number">1</span>) <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] <span class="hljs-operator">=</span> (i <span class="hljs-operator">&gt;=</span> <span class="hljs-number">2</span> ? dp[i <span class="hljs-operator">-</span> <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) <span class="hljs-operator">+</span> <span class="hljs-number">2</span>;<br>                &#125; <span class="hljs-keyword">else</span> if (i <span class="hljs-operator">-</span> dp[i <span class="hljs-operator">-</span> <span class="hljs-number">1</span>] <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-operator">&amp;&amp;</span> s.charAt(i <span class="hljs-operator">-</span> dp[i <span class="hljs-operator">-</span> <span class="hljs-number">1</span>] <span class="hljs-operator">-</span> <span class="hljs-number">1</span>) <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] <span class="hljs-operator">=</span> dp[i <span class="hljs-operator">-</span> <span class="hljs-number">1</span>] <span class="hljs-operator">+</span> ((i <span class="hljs-operator">-</span> dp[i <span class="hljs-operator">-</span> <span class="hljs-number">1</span>]) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">2</span> ? dp[i <span class="hljs-operator">-</span> dp[i <span class="hljs-operator">-</span> <span class="hljs-number">1</span>] <span class="hljs-operator">-</span> <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) <span class="hljs-operator">+</span> <span class="hljs-number">2</span>;<br>                &#125;<br>                maxans <span class="hljs-operator">=</span> Math.<span class="hljs-built_in">max</span>(maxans, dp[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="221-最大正方形（mid）"><a href="#221-最大正方形（mid）" class="headerlink" title="221. 最大正方形（mid）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximal-square/">221. 最大正方形</a>（mid）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql">class Solution &#123;<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i][j]表示以[i][j]下标正方形的边长<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i][j]<span class="hljs-operator">=</span><span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] , dp[i<span class="hljs-number">-1</span>][j] , dp[i][j<span class="hljs-number">-1</span>])<br>    public <span class="hljs-type">int</span> maximalSquare(<span class="hljs-type">char</span>[][] matrix) &#123;<br>        if (matrix <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-keyword">null</span> <span class="hljs-operator">||</span> matrix.length <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-operator">||</span> matrix[<span class="hljs-number">0</span>].length <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ret <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> m <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> n <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] dp <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[m][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i<span class="hljs-operator">=</span><span class="hljs-number">0</span>;i<span class="hljs-operator">&lt;</span>m;i<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j<span class="hljs-operator">=</span><span class="hljs-number">0</span>;j<span class="hljs-operator">&lt;</span>n;j<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)&#123;<br>                if(matrix[i][j]<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    if(i<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-number">0</span><span class="hljs-operator">||</span>j<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-number">0</span>) dp[i][j] <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">else</span> dp[i][j] <span class="hljs-operator">=</span> Math.<span class="hljs-built_in">min</span>(Math.<span class="hljs-built_in">min</span>(dp[i <span class="hljs-operator">-</span> <span class="hljs-number">1</span>][j], dp[i][j <span class="hljs-operator">-</span> <span class="hljs-number">1</span>]), dp[i <span class="hljs-operator">-</span> <span class="hljs-number">1</span>][j <span class="hljs-operator">-</span> <span class="hljs-number">1</span>]) <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;<br>                    ret <span class="hljs-operator">=</span> Math.<span class="hljs-built_in">max</span>(ret,dp[i][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret<span class="hljs-operator">*</span>ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-break/">单词拆分</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql">class Solution &#123;<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i] 表示以i结尾的字符串是否能被wordDict拆分<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i] <span class="hljs-operator">=</span> dp[j]<span class="hljs-operator">+</span>wordDict.contains(s(j,i));<br>    public <span class="hljs-type">boolean</span> wordBreak(String s, List<span class="hljs-operator">&lt;</span>String<span class="hljs-operator">&gt;</span> wordDict) &#123;<br>        <span class="hljs-type">int</span> n <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">boolean</span>[] dp <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-type">boolean</span>[n<span class="hljs-operator">+</span><span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i<span class="hljs-operator">=</span><span class="hljs-number">1</span>;i<span class="hljs-operator">&lt;=</span>n;i<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j<span class="hljs-operator">=</span><span class="hljs-number">0</span>;j<span class="hljs-operator">&lt;</span>i;j<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)&#123;<br>                if(dp[j]<span class="hljs-operator">&amp;&amp;</span>wordDict.contains(s.<span class="hljs-built_in">substring</span>(j,i)))&#123;<br>                    dp[i] <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>                    break;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="解码方法"><a href="#解码方法" class="headerlink" title="解码方法"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/decode-ways/">解码方法</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs sql">class Solution &#123;<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i]表示以i下标结尾的s的编码总数<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>如果s[i]能解码 dp[i]<span class="hljs-operator">=</span>dp[i<span class="hljs-number">-1</span>]<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>如果s[i]和s[i<span class="hljs-number">-1</span>]能组成 dp[i]<span class="hljs-operator">+</span><span class="hljs-operator">=</span>dp[i<span class="hljs-number">-2</span>]<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i] <span class="hljs-operator">=</span> dp[i<span class="hljs-number">-1</span>] <span class="hljs-operator">+</span> dp[i<span class="hljs-number">-2</span>] ((<span class="hljs-number">1</span><span class="hljs-operator">&lt;=</span>s[i<span class="hljs-number">-2</span>,i]<span class="hljs-operator">&lt;=</span><span class="hljs-number">26</span>))<br>    public <span class="hljs-type">int</span> numDecodings(String s) &#123;<br>        <span class="hljs-type">int</span> n <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[] dp <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n<span class="hljs-operator">+</span><span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i<span class="hljs-operator">=</span><span class="hljs-number">1</span>;i<span class="hljs-operator">&lt;=</span>n;i<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)&#123;<br>            if(s.charAt(i<span class="hljs-number">-1</span>)<span class="hljs-operator">!=</span><span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                dp[i]<span class="hljs-operator">+</span><span class="hljs-operator">=</span>dp[i<span class="hljs-number">-1</span>];<br>            &#125;<br>            if(i<span class="hljs-operator">&gt;</span><span class="hljs-number">1</span><span class="hljs-operator">&amp;&amp;</span>(s.charAt(i<span class="hljs-number">-2</span>)<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;1&#x27;</span><span class="hljs-operator">||</span>(s.charAt(i<span class="hljs-number">-2</span>)<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;2&#x27;</span><span class="hljs-operator">&amp;&amp;</span>s.charAt(i<span class="hljs-number">-1</span>)<span class="hljs-operator">&lt;=</span><span class="hljs-string">&#x27;6&#x27;</span>)))&#123;<br>                dp[i]<span class="hljs-operator">+</span><span class="hljs-operator">=</span>dp[i<span class="hljs-number">-2</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>思路：回溯（超时）<br>    private <span class="hljs-type">int</span> count;<br>    public <span class="hljs-type">int</span> numDecodingsByBacktrack(String s) &#123;<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>backtrack(s,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    public void backtrack(String s,<span class="hljs-type">int</span> index)&#123;<br>        if(index<span class="hljs-operator">=</span><span class="hljs-operator">=</span>s.length())&#123;<br>            count<span class="hljs-operator">+</span><span class="hljs-operator">+</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        if(index<span class="hljs-operator">&lt;</span>s.length()<span class="hljs-operator">&amp;&amp;</span>s.charAt(index)<span class="hljs-operator">!=</span><span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>            backtrack(s,index<span class="hljs-operator">+</span><span class="hljs-number">1</span>);<br>        &#125;<br>        if(index<span class="hljs-operator">&lt;</span>s.length()<span class="hljs-number">-1</span><span class="hljs-operator">&amp;&amp;</span>s.charAt(index)<span class="hljs-operator">!=</span><span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>            <span class="hljs-type">int</span> x <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i<span class="hljs-operator">=</span>index;i<span class="hljs-operator">&lt;</span>index<span class="hljs-operator">+</span><span class="hljs-number">2</span>;i<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)x <span class="hljs-operator">=</span> x <span class="hljs-operator">*</span> <span class="hljs-number">10</span> <span class="hljs-operator">+</span> s.charAt(i)<span class="hljs-operator">-</span><span class="hljs-string">&#x27;0&#x27;</span>;<br>            if(x<span class="hljs-operator">&gt;=</span><span class="hljs-number">1</span><span class="hljs-operator">&amp;&amp;</span>x<span class="hljs-operator">&lt;=</span><span class="hljs-number">26</span>)backtrack(s,index<span class="hljs-operator">+</span><span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/regular-expression-matching/">正则表达式匹配</a></h4><p>dp[i][j]表示s[0…i] p[0..j] 是否匹配</p>
<ul>
<li>遇到 p[j] == ‘<em>‘ 时判断dp[i][j-2]是否匹配（注意’</em>‘表示*前面的字符有0个或多个），</li>
</ul>
<p>1.当dp[i][j-2] = true 时，则 dp[i][j] = true<br>2.当dp[i][j-2] = false 时，如果 s[i-1]==true &amp;&amp;(s[i]==p[i-1] || p[i-1]==’.’) 则 dp[i][j] = true</p>
<ul>
<li>遇到 p[j] == ‘.’ 取 dp[i][j] = dp[i-1][j-1]</li>
<li>遇到 s[i]==p[j] 取 dp[i][j] = dp[i-1][j-1]</li>
<li>遇到 s[i]!=p[j] 即 dp[i][j] = false</li>
</ul>
<p>dp表</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>A</th>
<th>.</th>
<th>*</th>
<th>B</th>
<th>B</th>
<th>A</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>T</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>
<tr>
<td>A</td>
<td>F</td>
<td>T</td>
<td>F</td>
<td>T</td>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>
<tr>
<td>B</td>
<td>F</td>
<td>F</td>
<td>T</td>
<td>T</td>
<td>T</td>
<td>F</td>
<td>F</td>
</tr>
<tr>
<td>B</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>T</td>
<td>T</td>
<td>T</td>
<td>F</td>
</tr>
<tr>
<td>A</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>T</td>
<td>F</td>
<td>F</td>
<td>T</td>
</tr>
<tr>
<td>A</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>T</td>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>
<tr>
<td>A</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>T</td>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs sql">class Solution &#123;<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i][j]表示s[<span class="hljs-number">0.</span>..i] p[<span class="hljs-number">0.</span>.j] 是否匹配<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 遇到 p[j] <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&#x27;*&#x27;</span> 时判断dp[i][j<span class="hljs-number">-2</span>]是否匹配（注意<span class="hljs-string">&#x27;*&#x27;</span>表示<span class="hljs-operator">*</span>前面的字符有<span class="hljs-number">0</span>个或多个），<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>  <span class="hljs-number">1.</span>当dp[i][j<span class="hljs-number">-2</span>] <span class="hljs-operator">=</span> <span class="hljs-literal">true</span> 时，则 dp[i][j] <span class="hljs-operator">=</span> <span class="hljs-literal">true</span><br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>  <span class="hljs-number">2.</span>当dp[i][j<span class="hljs-number">-2</span>] <span class="hljs-operator">=</span> <span class="hljs-literal">false</span> 时，如果 s[i<span class="hljs-number">-1</span>]<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-literal">true</span> <span class="hljs-operator">&amp;&amp;</span>(s[i]<span class="hljs-operator">=</span><span class="hljs-operator">=</span>p[i<span class="hljs-number">-1</span>] <span class="hljs-operator">||</span> p[i<span class="hljs-number">-1</span>]<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;.&#x27;</span>) 则 dp[i][j] <span class="hljs-operator">=</span> <span class="hljs-literal">true</span> (即f[i<span class="hljs-number">-1</span>][j])<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>遇到 p[j] <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&#x27;.&#x27;</span> 取 dp[i][j] <span class="hljs-operator">=</span> dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>遇到 s[i]<span class="hljs-operator">=</span><span class="hljs-operator">=</span>p[j] 取 dp[i][j] <span class="hljs-operator">=</span> dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>遇到 s[i]<span class="hljs-operator">!=</span>p[j] 即 dp[i][j] <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br>    public <span class="hljs-type">boolean</span> isMatch(String s, String p) &#123;<br>        <span class="hljs-type">int</span> m <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> n <span class="hljs-operator">=</span> p.length();<br>        <span class="hljs-type">boolean</span>[][] dp <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-type">boolean</span>[m<span class="hljs-operator">+</span><span class="hljs-number">1</span>][n<span class="hljs-operator">+</span><span class="hljs-number">1</span>];<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>init<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i<span class="hljs-operator">=</span><span class="hljs-number">0</span>;i<span class="hljs-operator">&lt;=</span>m;i<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j<span class="hljs-operator">=</span><span class="hljs-number">1</span>;j<span class="hljs-operator">&lt;=</span>n;j<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)&#123;<br>                if(p.charAt(j<span class="hljs-number">-1</span>) <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>                    dp[i][j] <span class="hljs-operator">=</span> dp[i][j<span class="hljs-number">-2</span>];<br>                    if(<span class="hljs-keyword">matches</span>(s,p,i,j<span class="hljs-number">-1</span>))dp[i][j] <span class="hljs-operator">=</span> dp[i][j]<span class="hljs-operator">||</span>dp[i<span class="hljs-number">-1</span>][j];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    if(<span class="hljs-keyword">matches</span>(s,p,i,j))dp[i][j] <span class="hljs-operator">=</span> dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>    public <span class="hljs-type">boolean</span> <span class="hljs-keyword">matches</span>(String s,String p,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)&#123;<br>        if(i<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        if(p.charAt(j<span class="hljs-number">-1</span>)<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;.&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> s.charAt(i<span class="hljs-number">-1</span>) <span class="hljs-operator">=</span><span class="hljs-operator">=</span> p.charAt(j<span class="hljs-number">-1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="44-通配符匹配（hard"><a href="#44-通配符匹配（hard" class="headerlink" title="44. 通配符匹配（hard)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/wildcard-matching/">44. 通配符匹配</a>（hard)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMatch</span><span class="hljs-params">(String s, String p)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> p.length();<br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (p.charAt(i - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;*&#x27;</span>) dp[<span class="hljs-number">0</span>][i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (p.charAt(j - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                    dp[i][j] = dp[i][j - <span class="hljs-number">1</span>] || dp[i - <span class="hljs-number">1</span>][j];<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.charAt(j - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;?&#x27;</span> || s.charAt(i - <span class="hljs-number">1</span>) == p.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="骑士在棋盘上的概率"><a href="#骑士在棋盘上的概率" class="headerlink" title="骑士在棋盘上的概率"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/knight-probability-in-chessboard/">骑士在棋盘上的概率</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs sql">class Solution &#123;<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>思路:dp[step][i][j]表示骑士从棋盘上的点 (i,j) 出发，走了 step 步时仍然留在棋盘上的概率<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[step][i][j] <span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">/</span><span class="hljs-number">8</span>)(∑dp[step−<span class="hljs-number">1</span>][i<span class="hljs-operator">+</span>di][j<span class="hljs-operator">+</span>dj])  其中(di,dj) 表示走法对坐标的偏移量如下的dirs<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[<span class="hljs-number">0</span>][i][j]<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br>    private <span class="hljs-type">int</span>[][] dirs <span class="hljs-operator">=</span> &#123;&#123;<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-2</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>&#125;,&#123;<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>&#125;&#125;;<br>    public <span class="hljs-keyword">double</span> knightProbability(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> <span class="hljs-type">row</span>, <span class="hljs-type">int</span> <span class="hljs-keyword">column</span>) &#123;<br>        <span class="hljs-keyword">double</span>[][][] dp <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[k <span class="hljs-operator">+</span> <span class="hljs-number">1</span>][n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> step <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; step <span class="hljs-operator">&lt;=</span> k; step<span class="hljs-operator">+</span><span class="hljs-operator">+</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i <span class="hljs-operator">&lt;</span> n; i<span class="hljs-operator">+</span><span class="hljs-operator">+</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j <span class="hljs-operator">&lt;</span> n; j<span class="hljs-operator">+</span><span class="hljs-operator">+</span>) &#123;<br>                    if (step <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">0</span>) &#123;<br>                        dp[step][i][j] <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                            <span class="hljs-type">int</span> ni <span class="hljs-operator">=</span> i <span class="hljs-operator">+</span> dir[<span class="hljs-number">0</span>], nj <span class="hljs-operator">=</span> j <span class="hljs-operator">+</span> dir[<span class="hljs-number">1</span>];<br>                            if (ni <span class="hljs-operator">&gt;=</span> <span class="hljs-number">0</span> <span class="hljs-operator">&amp;&amp;</span> ni <span class="hljs-operator">&lt;</span> n <span class="hljs-operator">&amp;&amp;</span> nj <span class="hljs-operator">&gt;=</span> <span class="hljs-number">0</span> <span class="hljs-operator">&amp;&amp;</span> nj <span class="hljs-operator">&lt;</span> n) &#123;<br>                                dp[step][i][j] <span class="hljs-operator">+</span><span class="hljs-operator">=</span> dp[step <span class="hljs-operator">-</span> <span class="hljs-number">1</span>][ni][nj] <span class="hljs-operator">/</span> <span class="hljs-number">8</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[k][<span class="hljs-type">row</span>][<span class="hljs-keyword">column</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/triangle/">三角形最小路径和</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs sql">class Solution &#123;<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>自顶向下<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i][j] 表示从三角形顶部走到位置(i,j) 的最小路径和。这里的位置(i,j) 指的是三角形中第 i 行第 j 列（均从 <span class="hljs-number">0</span> 开始编号）的位置。<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>上一步就只能在位置 (i−<span class="hljs-number">1</span>,j−<span class="hljs-number">1</span>) 或者位置 (i−<span class="hljs-number">1</span>,j)<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i][j] <span class="hljs-operator">=</span> Math.<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-1</span>][j])<span class="hljs-operator">+</span>triangle.get(i).<span class="hljs-keyword">get</span>(j);<br>    public <span class="hljs-type">int</span> minimumTotal0(List<span class="hljs-operator">&lt;</span>List<span class="hljs-operator">&lt;</span><span class="hljs-type">Integer</span><span class="hljs-operator">&gt;&gt;</span> triangle) &#123;<br>        <span class="hljs-type">int</span> n <span class="hljs-operator">=</span> triangle.size();<br>        <span class="hljs-type">int</span>[][] dp <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n][n];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] <span class="hljs-operator">=</span> triangle.get(<span class="hljs-number">0</span>).<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i <span class="hljs-operator">&lt;</span> n; <span class="hljs-operator">+</span><span class="hljs-operator">+</span>i) &#123;<br>            dp[i][<span class="hljs-number">0</span>] <span class="hljs-operator">=</span> dp[i <span class="hljs-operator">-</span> <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] <span class="hljs-operator">+</span> triangle.get(i).<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>);<span class="hljs-operator">/</span><span class="hljs-operator">/</span>直接从i<span class="hljs-number">-1</span>开始免去前面不必要的计算<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j <span class="hljs-operator">&lt;</span> i; <span class="hljs-operator">+</span><span class="hljs-operator">+</span>j) &#123;<br>                dp[i][j] <span class="hljs-operator">=</span> Math.<span class="hljs-built_in">min</span>(dp[i <span class="hljs-operator">-</span> <span class="hljs-number">1</span>][j <span class="hljs-operator">-</span> <span class="hljs-number">1</span>], dp[i <span class="hljs-operator">-</span> <span class="hljs-number">1</span>][j]) <span class="hljs-operator">+</span> triangle.get(i).<span class="hljs-keyword">get</span>(j);<br>            &#125;<br>            dp[i][i] <span class="hljs-operator">=</span> dp[i <span class="hljs-operator">-</span> <span class="hljs-number">1</span>][i <span class="hljs-operator">-</span> <span class="hljs-number">1</span>] <span class="hljs-operator">+</span> triangle.get(i).<span class="hljs-keyword">get</span>(i);<span class="hljs-operator">/</span><span class="hljs-operator">/</span>最后一个只能取上一行的最后一个<br>        &#125;  <br>        <span class="hljs-type">int</span> totalMin <span class="hljs-operator">=</span> dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i<span class="hljs-operator">=</span><span class="hljs-number">0</span>;i<span class="hljs-operator">&lt;</span>n;i<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)totalMin<span class="hljs-operator">=</span>Math.<span class="hljs-built_in">min</span>(totalMin,dp[n<span class="hljs-number">-1</span>][i]);<br>        <span class="hljs-keyword">return</span> totalMin;<br>    &#125;<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>自底向上<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i][j] <span class="hljs-operator">=</span> Math.<span class="hljs-built_in">min</span>(dp[i <span class="hljs-operator">+</span> <span class="hljs-number">1</span>][j], dp[i <span class="hljs-operator">+</span> <span class="hljs-number">1</span>][j <span class="hljs-operator">+</span> <span class="hljs-number">1</span>]) <span class="hljs-operator">+</span> triangle.get(i).<span class="hljs-keyword">get</span>(j);<br>    public <span class="hljs-type">int</span> minimumTotal(List<span class="hljs-operator">&lt;</span>List<span class="hljs-operator">&lt;</span><span class="hljs-type">Integer</span><span class="hljs-operator">&gt;&gt;</span> triangle) &#123;<br>        <span class="hljs-type">int</span> n <span class="hljs-operator">=</span> triangle.size();<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span> dp[i][j] 表示从点 (i, j) 到底边的最小路径和。<br>        <span class="hljs-type">int</span>[][] dp <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n <span class="hljs-operator">+</span> <span class="hljs-number">1</span>][n <span class="hljs-operator">+</span> <span class="hljs-number">1</span>];<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 从三角形的最后一行开始递推。<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i <span class="hljs-operator">=</span> n <span class="hljs-operator">-</span> <span class="hljs-number">1</span>; i <span class="hljs-operator">&gt;=</span> <span class="hljs-number">0</span>; i<span class="hljs-comment">--) &#123;</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j <span class="hljs-operator">&lt;=</span> i; j<span class="hljs-operator">+</span><span class="hljs-operator">+</span>) &#123;<br>                dp[i][j] <span class="hljs-operator">=</span> Math.<span class="hljs-built_in">min</span>(dp[i <span class="hljs-operator">+</span> <span class="hljs-number">1</span>][j], dp[i <span class="hljs-operator">+</span> <span class="hljs-number">1</span>][j <span class="hljs-operator">+</span> <span class="hljs-number">1</span>]) <span class="hljs-operator">+</span> triangle.get(i).<span class="hljs-keyword">get</span>(j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="鸡蛋掉落"><a href="#鸡蛋掉落" class="headerlink" title="鸡蛋掉落"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/super-egg-drop/">鸡蛋掉落</a></h4><p>转移的状态有: k鸡蛋个数，n为楼层，所以dp为二维数组，dp[k][n] = m 当前状态为 k 个鸡蛋，面对 n 层楼# 这个状态下最少的扔鸡蛋次数为 m</p>
<ul>
<li>如果鸡蛋碎了，那么鸡蛋的个数 K 应该减一，搜索的楼层区间应该从 [1..N] 变为 [1..i-1] 共 i-1 层楼；</li>
<li>如果鸡蛋没碎，那么鸡蛋的个数 K 不变，搜索的楼层区间应该从 [1..N] 变为 [i+1..N] 共 N-i 层楼。</li>
</ul>
<p>dp[k][n] = dp[k][n - 1] + dp[k - 1][n - 1] + 1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<br>  <span class="hljs-type">int</span> <span class="hljs-title function_">superEggDrop</span><span class="hljs-params">(<span class="hljs-type">int</span> K, <span class="hljs-type">int</span> N)</span> &#123;<br>    <span class="hljs-comment">// m 最多不会超过 N 次（线性扫描）</span><br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[K + <span class="hljs-number">1</span>][N + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// base case:</span><br>    <span class="hljs-comment">// dp[0][..] = 0</span><br>    <span class="hljs-comment">// dp[..][0] = 0</span><br>    <span class="hljs-comment">// Java 默认初始化数组都为 0</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (dp[K][m] &lt; N) &#123;<br>        m++;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; k &lt;= K; k++)<br>            dp[k][m] = dp[k][m - <span class="hljs-number">1</span>] + dp[k - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> m;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="不同的二叉搜索树（mid）"><a href="#不同的二叉搜索树（mid）" class="headerlink" title="不同的二叉搜索树（mid）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees/">不同的二叉搜索树</a>（mid）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//以每个节点作为根节点，[1,i)作为左子树，(i,n]作为右子树，进行构建不同的二叉搜索树</span><br>    <span class="hljs-comment">//其左右子树又可以采用此方式进行构建不同的二叉搜索树,可转化为子问题，由此可采用动态规划</span><br>    <span class="hljs-comment">//则根为 i 的所有二叉搜索树的集合是左子树集合和右子树集合的笛卡尔积</span><br>    <span class="hljs-comment">//dp[i]+=dp[j-1]*dp[i-j] j=[1,i] i=[2,n+1]</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//basecase</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//dp[i]+=dp[j-1]*dp[i-j] j=[1,i] i=[2,n+1]</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>                dp[i] += dp[j-<span class="hljs-number">1</span>]*dp[i-j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>    <span class="hljs-comment">//数学：卡塔兰数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 提示：我们在这里需要用 long 类型防止计算过程中的溢出</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">C</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            C = C * <span class="hljs-number">2</span> * (<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>) / (i + <span class="hljs-number">2</span>);<span class="hljs-comment">//卡塔兰数公式</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) C;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="交错字符串（mid）"><a href="#交错字符串（mid）" class="headerlink" title="交错字符串（mid）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/interleaving-string/">交错字符串</a>（mid）</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/2630542/1645543673605-5fcb55fe-28bc-4ba1-b54e-b94e7b7f45a7.png#averageHue=%23c2e42c&clientId=u77e453a4-9c31-4&errorMessage=unknown%20error&from=paste&height=174&id=u36d20912&name=image.png&originHeight=348&originWidth=1109&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19017&status=error&style=none&taskId=u581ffa6c-232d-4073-b457-1d7a7a30f51&title=&width=554.5" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//dp[i][j] 表示 s1 的前 i 个字符和 s2 的前 j 个字符是否能构成 s3 的前 i+j 个字符</span><br><span class="hljs-comment">//画出如上dp二维表</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInterleave</span><span class="hljs-params">(String s1, String s2, String s3)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> s1.length(), l2 = s2.length(), l3 = s3.length();<br>    <span class="hljs-comment">//不满足直接返回</span><br>    <span class="hljs-keyword">if</span> (l1 + l2 != l3)  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//dp数组</span><br>    <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[l1 + <span class="hljs-number">1</span>][l2 + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//basecase</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//dp[i][j] = true (s3.charAt(i-1)==s1.charAt(i-1) &amp;&amp; dp[i-1][0] and 0&lt;i&lt;s1.length)</span><br>    <span class="hljs-comment">//dp[i][j] = true (s3.charAt(i-1)==s2.charAt(i-1) &amp;&amp; dp[0][i-1] and 0&lt;i&lt;s2.length)</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; l1 + <span class="hljs-number">1</span>; i++) &#123;<br>        dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &amp;&amp; s1.charAt(i - <span class="hljs-number">1</span>) == s3.charAt(i - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; l2 + <span class="hljs-number">1</span>; i++) &#123;<br>        dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] &amp;&amp; s2.charAt(i - <span class="hljs-number">1</span>) == s3.charAt(i - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//dp[i][j] = (dp[i][j - 1] &amp;&amp; s2.charAt(j - 1) == s3.charAt(i + j - 1)) || (dp[i - 1][j] &amp;&amp; s1.charAt(i - 1) == s3.charAt(i + j - 1));</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; l1 + <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; l2 + <span class="hljs-number">1</span>; j++) &#123;<br>            dp[i][j] = (dp[i][j - <span class="hljs-number">1</span>] &amp;&amp; s2.charAt(j - <span class="hljs-number">1</span>) == s3.charAt(i + j - <span class="hljs-number">1</span>)) || (dp[i - <span class="hljs-number">1</span>][j] &amp;&amp; s1.charAt(i - <span class="hljs-number">1</span>) == s3.charAt(i + j - <span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[l1][l2];<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="343-整数拆分（mid）"><a href="#343-整数拆分（mid）" class="headerlink" title="343. 整数拆分（mid）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/integer-break/">343. 整数拆分</a>（mid）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//数学</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">3</span>, b = n % <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)Math.pow(<span class="hljs-number">3</span>, a);<br>        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)Math.pow(<span class="hljs-number">3</span>, a - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)Math.pow(<span class="hljs-number">3</span>, a) * <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-comment">//dp[i]表示整数i对应的最大乘积</span><br>    <span class="hljs-comment">//将 i 拆分成 j 和 i−j 的和，且 i−j 不再拆分成多个正整数，此时的乘积是 j×(i−j)</span><br>    <span class="hljs-comment">//将 i 拆分成 j 和 i−j 的和，且 i−j 继续拆分成多个正整数，此时的乘积是 j×dp[i−j]</span><br>    <span class="hljs-comment">//dp[i] = Max(dp[i],j*(i-j),j*dp[i-j]) j=[1,i-1]</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i-<span class="hljs-number">1</span>;j&gt;=<span class="hljs-number">1</span>;j--)&#123;<br>                dp[i] = Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>动态规划</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">curMax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; i; j++) &#123;<br>                curMax = Math.max(curMax, Math.max(j * (i - j), j * dp[i - j]));<br>            &#125;<br>            dp[i] = curMax;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="673-最长递增子序列的个数（mid）"><a href="#673-最长递增子序列的个数（mid）" class="headerlink" title="673. 最长递增子序列的个数（mid）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/">673. 最长递增子序列的个数</a>（mid）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//dp[i]表示以nums[i]结尾的最长递增子序列，dp[j]表示[0,i)时</span><br>    <span class="hljs-comment">//dp[i] = Math.max(dp[i],dp[j]+1) i for (0,n-1), j for (0,i)</span><br>    <span class="hljs-comment">//本题求的是最长递增子序列个数，不是长度</span><br>    <span class="hljs-comment">//在基于长度的算法上通过记录其最长长度的个数即可</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findNumberOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)dp[i] = count[i] = <span class="hljs-number">1</span>;<span class="hljs-comment">//初始化默认最少1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-comment">//如果nums[i]&gt;nums[j]则说明当前j可取</span><br>                <span class="hljs-keyword">if</span>(nums[i]&gt;nums[j])&#123;<br>                     <span class="hljs-comment">//dp[j]+1&gt;dp[I]则说明当前去nums[j]会比dp[i]大，增加最长长度</span><br>                    <span class="hljs-keyword">if</span>(dp[j]+<span class="hljs-number">1</span>&gt;dp[I])&#123;<br>                        dp[i] = dp[j]+<span class="hljs-number">1</span>;<br>                        count[i] = count[j];<span class="hljs-comment">//更新最长子序列个数为count[j]</span><br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[j]+<span class="hljs-number">1</span>==dp[i])&#123;如果dp[j]+<span class="hljs-number">1</span>==dp[I]则存在相同长度的递增子序列<br>                        count[i]+=count[j];<span class="hljs-comment">//合计两个长度一样的个数</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>            max = Math.max(max,dp[i]);<span class="hljs-comment">//记录max</span><br>        &#125;<br>        <span class="hljs-comment">//遍历dp和count获取结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-keyword">if</span>(dp[i]==max)ret+=count[i];<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/distinct-subsequences/">不同的子序列</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//dp[i][j]表示以s[i]和t[j]结尾的s,t的不同序列个数</span><br>    <span class="hljs-comment">//s[i] == t[j] 时 dp[i][j] = dp[i-1][j-1](选择当前s[i]) + dp[i-1][j](不选择当前s[i])</span><br>    <span class="hljs-comment">//s[i] != t[j] 时 dp[i][j] = dp[i-1][j](不选择当前s[i])</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDistinct</span><span class="hljs-params">(String s, String t)</span> &#123;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> t.length();<br>        <span class="hljs-keyword">if</span> (m &lt; n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>][m+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;i++)dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>                <span class="hljs-keyword">if</span>(s.charAt(j-<span class="hljs-number">1</span>)==t.charAt(i-<span class="hljs-number">1</span>))dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+dp[i][j-<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">else</span> dp[i][j] = dp[i][j-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][m];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="剑指-Offer-II-097-子序列的数目（hard"><a href="#剑指-Offer-II-097-子序列的数目（hard" class="headerlink" title="剑指 Offer II 097. 子序列的数目（hard)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/21dk04/">剑指 Offer II 097. 子序列的数目</a>（hard)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[i][j] 表示在 s[i:]的子序列中 t[j:] 出现的个数。(s[i:] 表示 s 从下标 i 到末尾的子字符串，t[j:] 表示 t 从下标 j 到末尾的子字符串)<br>s的长度为m，t的长度为n<br><br>边界情况：<br><span class="hljs-number">1.</span>当j==n时，t[j:]为空字符串，由于空字符串是任何字符串的子序列，因此对任意 <span class="hljs-number">0</span>≤i≤m，有 dp[i][n]=<span class="hljs-number">1</span>；<br><span class="hljs-number">2.</span>当i==m时且j&lt;n，s[i:]为空字符串，t[j:]为非空字符串，由于空字符串不可能是任何非空字符串的子序列，因此对任意 <span class="hljs-number">0</span>≤j≤n，有 dp[m][j]=<span class="hljs-number">0</span>；<br><br>当 i&lt;m 且 j&lt;n 时，考虑 dp[i][j] 的计算：<br><span class="hljs-number">1.</span>当s[i]==t[j]时，<br>  <span class="hljs-number">1.1</span> 如果 s[i] 和 t[j] 匹配，则考虑 t[j+<span class="hljs-number">1</span>:] 作为 s[i+<span class="hljs-number">1</span>:] 的子序列，子序列数为 dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]；<br>  <span class="hljs-number">1.2</span> 如果 s[i] 和 t[j] 不匹配，则考虑 t[j:] 作为 s[i+<span class="hljs-number">1</span>:] 的子序列（前面一个s），子序列数为 dp[i+<span class="hljs-number">1</span>][j]。<br>  因此当 s[i]=t[j] 时，有 dp[i][j]=dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]+dp[i+<span class="hljs-number">1</span>][j]。<br><br><span class="hljs-number">2.</span>当s[i]!=t[j]时，s[i] 不能和 t[j] 匹配，因此只考虑 t[j:] 作为 s[i+<span class="hljs-number">1</span>:] 的子序列，子序列数为 dp[i+<span class="hljs-number">1</span>][j]。<br><br>最终计算得到 dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] 即为在 s 的子序列中 t 出现的个数。<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//二维dp[i][j]表示</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDistinct</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> t.length();<br>        <span class="hljs-comment">//dp[i][j]表示s[i:],t[j:]</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//处理边界 t=&#x27;&#x27;(dp[i][n]=1) 和 s=&#x27;&#x27;(i&lt;n时dp[m][i]=0(java数组默认是0无需处理))</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;i++)dp[i][n] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n-<span class="hljs-number">1</span>;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>                <span class="hljs-keyword">if</span>(s.charAt(i)==t.charAt(j))&#123;<br>                    dp[i][j] = dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]+dp[i+<span class="hljs-number">1</span>][j];<br>                &#125; <span class="hljs-keyword">else</span> dp[i][j]=dp[i+<span class="hljs-number">1</span>][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="1235-规划兼职工作（hard"><a href="#1235-规划兼职工作（hard" class="headerlink" title="1235. 规划兼职工作（hard)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-profit-in-job-scheduling/">1235. 规划兼职工作</a>（hard)</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs sql">class Solution &#123;<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i]表示到第i天工作所获得的最大值<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i]共两种选择<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">1.</span>选择当天工作<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">2.</span>不选择当天工作<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i] <span class="hljs-operator">=</span> Math.<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>],dp[pre]<span class="hljs-operator">+</span>profit[i]) pre表示前面最近一次完成的工作结束时间<br>    public <span class="hljs-type">int</span> jobScheduling(<span class="hljs-type">int</span>[] startTime, <span class="hljs-type">int</span>[] endTime, <span class="hljs-type">int</span>[] profit) &#123;<br>        <span class="hljs-type">int</span> n<span class="hljs-operator">=</span>startTime.length;<br>        <span class="hljs-type">int</span>[][] arr<span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n][<span class="hljs-number">3</span>];<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>构造开始、结束时间、收益的数组<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i<span class="hljs-operator">=</span><span class="hljs-number">0</span>;i<span class="hljs-operator">&lt;</span>n;i<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)&#123;<br>            arr[i]<span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[]&#123;startTime[i],endTime[i],profit[i]&#125;;<br>        &#125;<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>对结束时间进行排序<br>        Arrays.sort(arr,(x,y)<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>x[<span class="hljs-number">1</span>]<span class="hljs-operator">-</span>y[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span>[] dp<span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i<span class="hljs-operator">=</span><span class="hljs-number">0</span>;i<span class="hljs-operator">&lt;</span>n;i<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)&#123;<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span>查找上一次结束的时间<br>            <span class="hljs-type">int</span> pre<span class="hljs-operator">=</span> binarySearch(arr,i);<br>            dp[i]<span class="hljs-operator">=</span>Math.<span class="hljs-built_in">max</span>(i<span class="hljs-operator">&gt;</span><span class="hljs-number">0</span>?dp[i<span class="hljs-number">-1</span>]:<span class="hljs-number">0</span>,(pre<span class="hljs-operator">&gt;=</span><span class="hljs-number">0</span>?dp[pre]:<span class="hljs-number">0</span>)<span class="hljs-operator">+</span>arr[i][<span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>];<br>    &#125;<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>二分搜索<br>    <span class="hljs-type">int</span> binarySearch(<span class="hljs-type">int</span>[][] arr, <span class="hljs-type">int</span> i)&#123;<br>        <span class="hljs-type">int</span> l<span class="hljs-operator">=</span><span class="hljs-number">0</span>,r<span class="hljs-operator">=</span>i<span class="hljs-number">-1</span>;<br>        while(l<span class="hljs-operator">&lt;</span>r)&#123;<br>            <span class="hljs-type">int</span> mid<span class="hljs-operator">=</span>l<span class="hljs-operator">+</span>r<span class="hljs-operator">+</span><span class="hljs-number">1</span><span class="hljs-operator">&gt;&gt;</span><span class="hljs-number">1</span>;<br>            if(arr[mid][<span class="hljs-number">1</span>]<span class="hljs-operator">&lt;=</span>arr[i][<span class="hljs-number">0</span>])l<span class="hljs-operator">=</span>mid;<br>            <span class="hljs-keyword">else</span> r<span class="hljs-operator">=</span>mid<span class="hljs-number">-1</span>;<br>        &#125;<br>        if(l<span class="hljs-operator">&lt;</span>i<span class="hljs-operator">&amp;&amp;</span>arr[l][<span class="hljs-number">1</span>]<span class="hljs-operator">&lt;=</span>arr[i][<span class="hljs-number">0</span>])<span class="hljs-keyword">return</span> l;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="64-最小路径和（mid）"><a href="#64-最小路径和（mid）" class="headerlink" title="64. 最小路径和（mid）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-path-sum/">64. 最小路径和</a>（mid）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql">class Solution &#123;<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i][j]表示到达grid[i][j]的最短路径<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>通过条件分析可知每次只能往右和下走所以每次遍历去左边和上边两者的较小值<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i][j] <span class="hljs-operator">=</span> grid[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<span class="hljs-operator">+</span>Math.<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]);<br>    public <span class="hljs-type">int</span> minPathSum(<span class="hljs-type">int</span>[][] grid) &#123;<br>        <span class="hljs-type">int</span> m <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> n <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] dp <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[m][n];<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>初始化第一行和第一列<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i<span class="hljs-operator">=</span><span class="hljs-number">1</span>;i<span class="hljs-operator">&lt;</span>m;i<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)dp[i][<span class="hljs-number">0</span>]<span class="hljs-operator">=</span>dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]<span class="hljs-operator">+</span>grid[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i<span class="hljs-operator">=</span><span class="hljs-number">1</span>;i<span class="hljs-operator">&lt;</span>n;i<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)dp[<span class="hljs-number">0</span>][i]<span class="hljs-operator">=</span>dp[<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>]<span class="hljs-operator">+</span>grid[<span class="hljs-number">0</span>][i];<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>遍历<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i<span class="hljs-operator">=</span><span class="hljs-number">1</span>;i<span class="hljs-operator">&lt;</span>m;i<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j<span class="hljs-operator">=</span><span class="hljs-number">1</span>;j<span class="hljs-operator">&lt;</span>n;j<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)&#123;<br>                dp[i][j] <span class="hljs-operator">=</span> grid[i][j] <span class="hljs-operator">+</span> Math.<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="圆环回原点问题"><a href="#圆环回原点问题" class="headerlink" title="圆环回原点问题"></a>圆环回原点问题</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 圆环上有10个点，编号为0~9。从0点出发，每次可以逆时针和顺时针走一步，问走n步回到0点共有多少种走法。</span><br><span class="hljs-comment"> * 输入: 2</span><br><span class="hljs-comment"> * 输出: 2</span><br><span class="hljs-comment"> * 解释：有2种方案。分别是0-&gt;1-&gt;0和0-&gt;9-&gt;0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>类似爬楼梯<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>走n步到<span class="hljs-number">0</span>的方案数<span class="hljs-operator">=</span>走n<span class="hljs-number">-1</span>步到<span class="hljs-number">1</span>的方案数<span class="hljs-operator">+</span>走n<span class="hljs-number">-1</span>步到<span class="hljs-number">9</span>的方案数。<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i][j]为从<span class="hljs-number">0</span>点出发走i步到j点的方案数，则递推式为：dp[i][j]<span class="hljs-operator">=</span>dp[i<span class="hljs-number">-1</span>][(j<span class="hljs-number">-1</span><span class="hljs-operator">+</span>length)<span class="hljs-operator">%</span>length]<span class="hljs-operator">+</span>dp[i<span class="hljs-number">-1</span>][j<span class="hljs-operator">+</span><span class="hljs-number">1</span><span class="hljs-operator">+</span>length)<span class="hljs-operator">%</span>length]<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>ps:公式之所以取余是因为j<span class="hljs-number">-1</span>或j<span class="hljs-operator">+</span><span class="hljs-number">1</span>可能会超过圆环<span class="hljs-number">0</span><span class="hljs-operator">~</span><span class="hljs-number">9</span>的范围<br>public <span class="hljs-type">int</span> rating(<span class="hljs-type">int</span> n)&#123;<br>    <span class="hljs-type">int</span> length <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span>[][] dp <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n][n];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i <span class="hljs-operator">&lt;</span> n; i<span class="hljs-operator">+</span><span class="hljs-operator">+</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j <span class="hljs-operator">&lt;</span> length; j<span class="hljs-operator">+</span><span class="hljs-operator">+</span>) &#123;<br>            dp[i][j]<span class="hljs-operator">=</span>dp[i<span class="hljs-number">-1</span>][(j<span class="hljs-number">-1</span><span class="hljs-operator">+</span>length)<span class="hljs-operator">%</span>length]<span class="hljs-operator">+</span>dp[i<span class="hljs-number">-1</span>][(j<span class="hljs-operator">+</span><span class="hljs-number">1</span><span class="hljs-operator">+</span>length)<span class="hljs-operator">%</span>length];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="42-接雨水（hard）"><a href="#42-接雨水（hard）" class="headerlink" title="42. 接雨水（hard）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a>（hard）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>首、尾开始遍历取max，ret<span class="hljs-operator">+</span><span class="hljs-operator">=</span>Math.<span class="hljs-built_in">min</span>(leftMax[i],rightMax[i])<span class="hljs-operator">-</span>height[i];<br>public <span class="hljs-type">int</span> trap(<span class="hljs-type">int</span>[] height) &#123;<br>    <span class="hljs-type">int</span> n <span class="hljs-operator">=</span> height.length;<br>    if (n<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>[] leftMax <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br>    <span class="hljs-type">int</span>[] rightMax <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br>    leftMax[<span class="hljs-number">0</span>] <span class="hljs-operator">=</span> height[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i <span class="hljs-operator">&lt;</span> n; i<span class="hljs-operator">+</span><span class="hljs-operator">+</span>) &#123;<br>        leftMax[i] <span class="hljs-operator">=</span> Math.<span class="hljs-built_in">max</span>(leftMax[i<span class="hljs-number">-1</span>],height[i]);<br>    &#125;<br>    rightMax[n<span class="hljs-number">-1</span>] <span class="hljs-operator">=</span> height[n<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i <span class="hljs-operator">=</span> n<span class="hljs-number">-2</span>; i <span class="hljs-operator">&gt;=</span> <span class="hljs-number">0</span>; i<span class="hljs-comment">--) &#123;</span><br>        rightMax[i] <span class="hljs-operator">=</span> Math.<span class="hljs-built_in">max</span>(rightMax[i<span class="hljs-operator">+</span><span class="hljs-number">1</span>],height[i]);<br>    &#125;<br>    <span class="hljs-type">int</span> ret <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i <span class="hljs-operator">&lt;</span> n; i<span class="hljs-operator">+</span><span class="hljs-operator">+</span>) &#123;<br>        ret<span class="hljs-operator">+</span><span class="hljs-operator">=</span>Math.<span class="hljs-built_in">min</span>(leftMax[i],rightMax[i])<span class="hljs-operator">-</span>height[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="1751-最多可以参加的会议数目-II（hard）"><a href="#1751-最多可以参加的会议数目-II（hard）" class="headerlink" title="1751. 最多可以参加的会议数目 II（hard）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-number-of-events-that-can-be-attended-ii/">1751. 最多可以参加的会议数目 II</a>（hard）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs sql">class Solution &#123;<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i][j] 表示考虑前i个会议，不超过j的最大值<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i][j] <span class="hljs-operator">=</span> Math.<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j],dp[<span class="hljs-keyword">last</span>][j<span class="hljs-number">-1</span>]<span class="hljs-operator">+</span>events[i][<span class="hljs-number">2</span>]);<br>    public <span class="hljs-type">int</span> maxValue(<span class="hljs-type">int</span>[][] events, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span> n <span class="hljs-operator">=</span> events.length;<br>        <span class="hljs-type">int</span>[][] dp <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n<span class="hljs-operator">+</span><span class="hljs-number">1</span>][k<span class="hljs-operator">+</span><span class="hljs-number">1</span>];<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>按照结束时间排序<br>        Arrays.sort(events,(x,y)<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>x[<span class="hljs-number">1</span>]<span class="hljs-operator">-</span>y[<span class="hljs-number">1</span>]);<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>遍历<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i<span class="hljs-operator">=</span><span class="hljs-number">1</span>;i<span class="hljs-operator">&lt;=</span>n;i<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)&#123;<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span>当前会议<br>            <span class="hljs-type">int</span>[] event <span class="hljs-operator">=</span> events[i<span class="hljs-number">-1</span>];<br>            <span class="hljs-type">int</span> s <span class="hljs-operator">=</span> event[<span class="hljs-number">0</span>], e <span class="hljs-operator">=</span> event[<span class="hljs-number">1</span>],v <span class="hljs-operator">=</span> event[<span class="hljs-number">2</span>];<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 通过「二分」，找到第 i 件事件之前，与第 i 件事件不冲突的事件<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 对于当前事件而言，冲突与否，与 j 无关<br>            <span class="hljs-type">int</span> <span class="hljs-keyword">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>,<span class="hljs-keyword">right</span> <span class="hljs-operator">=</span> i <span class="hljs-operator">-</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span>搜索<br>            while(<span class="hljs-keyword">left</span><span class="hljs-operator">&lt;</span><span class="hljs-keyword">right</span>)&#123;<br>                <span class="hljs-type">int</span> mid <span class="hljs-operator">=</span> (<span class="hljs-keyword">left</span><span class="hljs-operator">+</span><span class="hljs-keyword">right</span><span class="hljs-operator">+</span><span class="hljs-number">1</span>)<span class="hljs-operator">&gt;&gt;</span><span class="hljs-number">1</span>;<br>                <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">-1</span>是因为上面进行了<span class="hljs-operator">+</span><span class="hljs-number">1</span><br>                <span class="hljs-type">int</span>[] prev<span class="hljs-operator">=</span> events[mid<span class="hljs-number">-1</span>];<br>                <span class="hljs-operator">/</span><span class="hljs-operator">/</span>如果prev[<span class="hljs-number">1</span>]<span class="hljs-operator">&lt;</span>s说明第mid<span class="hljs-number">-1</span>的结束时间小于当前会议时间，可选，但是为了保证查找最靠近右边，所以<span class="hljs-keyword">left</span><span class="hljs-operator">=</span>mid需要再次逼近右边<br>                if(prev[<span class="hljs-number">1</span>]<span class="hljs-operator">&lt;</span>s) <span class="hljs-keyword">left</span> <span class="hljs-operator">=</span> mid;<br>                <span class="hljs-operator">/</span><span class="hljs-operator">/</span>否则mid<span class="hljs-number">-1</span>不小于当前会议开始时间，向左移一位<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">right</span> <span class="hljs-operator">=</span> mid <span class="hljs-operator">-</span> <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span>上次可选的会议<br>            <span class="hljs-type">int</span> <span class="hljs-keyword">last</span> <span class="hljs-operator">=</span> (<span class="hljs-keyword">right</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-operator">&amp;&amp;</span> events[<span class="hljs-keyword">right</span> <span class="hljs-operator">-</span> <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] <span class="hljs-operator">&lt;</span> s) ? <span class="hljs-keyword">right</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j<span class="hljs-operator">=</span><span class="hljs-number">1</span>;j<span class="hljs-operator">&lt;=</span>k;j<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)&#123;<br>                dp[i][j] <span class="hljs-operator">=</span> Math.<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j],dp[<span class="hljs-keyword">last</span>][j<span class="hljs-number">-1</span>]<span class="hljs-operator">+</span>v);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][k];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="1235-规划兼职工作（hard）"><a href="#1235-规划兼职工作（hard）" class="headerlink" title="1235. 规划兼职工作（hard）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-profit-in-job-scheduling/">1235. 规划兼职工作</a>（hard）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs sql">class Solution &#123;<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i]表示前i个可选的最大值<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i] <span class="hljs-operator">=</span> Math.<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>],dp[<span class="hljs-keyword">last</span>]<span class="hljs-operator">+</span>profit)<br>    public <span class="hljs-type">int</span> jobScheduling(<span class="hljs-type">int</span>[] startTime, <span class="hljs-type">int</span>[] endTime, <span class="hljs-type">int</span>[] profit) &#123;<br>        <span class="hljs-type">int</span> n <span class="hljs-operator">=</span> startTime.length;<br>        <span class="hljs-type">int</span>[][] arr <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n][<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i<span class="hljs-operator">=</span><span class="hljs-number">0</span>;i<span class="hljs-operator">&lt;</span>n;i<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)arr[i] <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[]&#123;startTime[i],endTime[i],profit[i]&#125;;<br>        Arrays.sort(arr,(x,y)<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>x[<span class="hljs-number">1</span>]<span class="hljs-operator">-</span>y[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span>[] dp <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br>        dp[<span class="hljs-number">0</span>] <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i<span class="hljs-operator">=</span><span class="hljs-number">1</span>;i<span class="hljs-operator">&lt;</span>n;i<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)&#123;<br>            <span class="hljs-type">int</span>[] cur <span class="hljs-operator">=</span> arr[i];<br>            <span class="hljs-type">int</span> s <span class="hljs-operator">=</span> cur[<span class="hljs-number">0</span>],e <span class="hljs-operator">=</span> cur[<span class="hljs-number">1</span>],p <span class="hljs-operator">=</span> cur[<span class="hljs-number">2</span>];<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span>二分搜索之前最近一个可兼职的工作<br>            <span class="hljs-type">int</span> <span class="hljs-keyword">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-keyword">right</span> <span class="hljs-operator">=</span> i <span class="hljs-operator">-</span> <span class="hljs-number">1</span>;<br>            dp[i] <span class="hljs-operator">=</span> arr[i][<span class="hljs-number">2</span>];<br>            while (<span class="hljs-keyword">left</span> <span class="hljs-operator">&lt;</span> <span class="hljs-keyword">right</span>) &#123;<br>                <span class="hljs-type">int</span> mid <span class="hljs-operator">=</span> (<span class="hljs-keyword">left</span> <span class="hljs-operator">+</span> <span class="hljs-keyword">right</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span>) <span class="hljs-operator">&gt;&gt;</span> <span class="hljs-number">1</span>;<br>                if (arr[mid][<span class="hljs-number">1</span>] <span class="hljs-operator">&lt;=</span> s) &#123;<br>                    <span class="hljs-keyword">left</span> <span class="hljs-operator">=</span> mid;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">right</span> <span class="hljs-operator">=</span> mid <span class="hljs-operator">-</span> <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span>如果二分搜索到前面有可兼职的工作<br>            if (arr[<span class="hljs-keyword">left</span>][<span class="hljs-number">1</span>] <span class="hljs-operator">&lt;=</span> arr[i][<span class="hljs-number">0</span>]) &#123;<br>                dp[i] <span class="hljs-operator">+</span><span class="hljs-operator">=</span> dp[<span class="hljs-keyword">left</span>];<br>            &#125;<br>            dp[i] <span class="hljs-operator">=</span> Math.<span class="hljs-built_in">max</span>(dp[i], dp[i <span class="hljs-operator">-</span> <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="279-完全平方数（mid）"><a href="#279-完全平方数（mid）" class="headerlink" title="279. 完全平方数（mid）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a>（mid）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">class Solution &#123;<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i]表示整数i完全平方数的最少数量<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i] <span class="hljs-operator">=</span> dp[i<span class="hljs-operator">-</span>[j<span class="hljs-operator">*</span>j]]<span class="hljs-operator">+</span><span class="hljs-number">1</span>  j<span class="hljs-operator">*</span>j<span class="hljs-operator">&lt;=</span>i<br>    public <span class="hljs-type">int</span> numSquares(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span>[] dp <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n<span class="hljs-operator">+</span><span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i<span class="hljs-operator">=</span><span class="hljs-number">1</span>;i<span class="hljs-operator">&lt;=</span>n;i<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)&#123;<br>            <span class="hljs-type">int</span> min <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j<span class="hljs-operator">=</span><span class="hljs-number">1</span>;j<span class="hljs-operator">*</span>j<span class="hljs-operator">&lt;=</span>i;j<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)&#123;<br>                min <span class="hljs-operator">=</span> Math.<span class="hljs-built_in">min</span>(min,dp[i<span class="hljs-operator">-</span>(j<span class="hljs-operator">*</span>j)]);<br>            &#125;<br>            dp[i] <span class="hljs-operator">=</span> min<span class="hljs-operator">+</span><span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="516-最长回文子序列（mid）"><a href="#516-最长回文子序列（mid）" class="headerlink" title="516. 最长回文子序列（mid）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a>（mid）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql">class Solution &#123;<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i][j]表示s[i,j]最长回文串长度<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i][j]<span class="hljs-operator">=</span> dp[i<span class="hljs-operator">+</span><span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]<span class="hljs-operator">+</span><span class="hljs-number">2</span> (s[i]<span class="hljs-operator">=</span><span class="hljs-operator">=</span>s[j])<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>dp[i][j]<span class="hljs-operator">=</span> <span class="hljs-built_in">max</span>(dp[i<span class="hljs-operator">+</span><span class="hljs-number">1</span>][j],dp[i][j<span class="hljs-number">-1</span>],dp[i][j]) (s[i]<span class="hljs-operator">!=</span>s[j])<br>    public <span class="hljs-type">int</span> longestPalindromeSubseq(String s) &#123;<br>        <span class="hljs-type">int</span> n <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[][] dp <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n<span class="hljs-operator">+</span><span class="hljs-number">1</span>][n<span class="hljs-operator">+</span><span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i<span class="hljs-operator">=</span>n<span class="hljs-number">-1</span>;i<span class="hljs-operator">&gt;=</span><span class="hljs-number">0</span>;i<span class="hljs-comment">--)&#123;</span><br>            dp[i][i] <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j<span class="hljs-operator">=</span>i<span class="hljs-operator">+</span><span class="hljs-number">1</span>;j<span class="hljs-operator">&lt;</span>n;j<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)&#123;<br>                if(s.charAt(i)<span class="hljs-operator">=</span><span class="hljs-operator">=</span>s.charAt(j))&#123;<br>                    dp[i][j] <span class="hljs-operator">=</span> dp[i<span class="hljs-operator">+</span><span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]<span class="hljs-operator">+</span><span class="hljs-number">2</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] <span class="hljs-operator">=</span> Math.<span class="hljs-built_in">max</span>(dp[i<span class="hljs-operator">+</span><span class="hljs-number">1</span>][j],Math.<span class="hljs-built_in">max</span>(dp[i][j],dp[i][j<span class="hljs-number">-1</span>]));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="357-统计各位数字都不同的数字个数（mid）"><a href="#357-统计各位数字都不同的数字个数（mid）" class="headerlink" title="357. 统计各位数字都不同的数字个数（mid）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-numbers-with-unique-digits/">357. 统计各位数字都不同的数字个数</a>（mid）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * f(0)=1 </span><br><span class="hljs-comment">    * f(1)=10</span><br><span class="hljs-comment">    * f(2)=9*9+f(1)</span><br><span class="hljs-comment">    * f(3)=9*9*8+f(2)</span><br><span class="hljs-comment">    * f(4)=9*9*8*7+f(3)</span><br><span class="hljs-comment">    * 左边开始数</span><br><span class="hljs-comment">    * 首位数不取 0 其他位数可以取 0，下一位比前一位取法少一种，因为不能重复</span><br><span class="hljs-comment">    * 首位数取 0 时就是 f(n-1)的数量</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNumbersWithUniqueDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; = n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>; j &gt; <span class="hljs-number">9</span>-(i-<span class="hljs-number">1</span>) ; j--) &#123;<br>                x = x * j;<br>            &#125;<br>            dp[i] = dp[i-<span class="hljs-number">1</span>] + x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="494-目标和（mid）"><a href="#494-目标和（mid）" class="headerlink" title="494. 目标和（mid）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a>（mid）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//将数组分为两个子集 (sum−neg)−neg=sum−2⋅neg=target  所以 neg = (sum-target)/2</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)sum+=num;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> sum-target;<br>        <span class="hljs-comment">//如果diff是负数 或者 不是偶数 说明neg不是整数,无法找到成立的等式</span><br>        <span class="hljs-keyword">if</span>(diff &lt; <span class="hljs-number">0</span> || diff % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//如果以上成立，则可转变为在数组中找若干个数，使其和等于neg</span><br>        <span class="hljs-comment">//定义二维dp[i][j]表示在数组nums的前i个数中选取元素，使其这些元素组成j的方案数。</span><br>        <span class="hljs-comment">//假设数组长度=n,最终答案dp[n][neg]</span><br>        <span class="hljs-comment">//当(nums[i] &gt;j) 此时nums[i]不能选   dp[i][j] = dp[i-1][j] </span><br>        <span class="hljs-comment">//当(nums[i]&lt;=j) 此时nums[i]不选 dp[i][j] = dp[i-1][j] 选nums[i] 共 dp[i][j] = dp[i-1][j-nums[i]]</span><br>        <span class="hljs-comment">//dp[i][j] = dp[i-1][j]+dp[i-1][j-nums[i]]</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">neg</span> <span class="hljs-operator">=</span> (sum-target)/<span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>][neg+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//basecase</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=neg;j++)&#123;<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j];<br>                <span class="hljs-keyword">if</span>(nums[i-<span class="hljs-number">1</span>]&lt;=j)&#123;<br>                    dp[i][j] += dp[i-<span class="hljs-number">1</span>][j-nums[i-<span class="hljs-number">1</span>]];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][neg];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="1014-最佳观光组合（mid）"><a href="#1014-最佳观光组合（mid）" class="headerlink" title="1014. 最佳观光组合（mid）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-sightseeing-pair/">1014. 最佳观光组合</a>（mid）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//values[i] + values[j] + i - j 变形一下 values[i] + i + values[j] - j (i&lt;j)</span><br>    <span class="hljs-comment">//这样就可以看成是左A[i]+i和右A[j]-j两部分和的最大值。随着遍历数组，我们对两部分和取最大值</span><br>    <span class="hljs-comment">//并且若当前的值—下标对之和比之前更大，我们就更新left部分的值即可。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxScoreSightseeingPair</span><span class="hljs-params">(<span class="hljs-type">int</span>[] values)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> values.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftMax</span> <span class="hljs-operator">=</span> values[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            ret = Math.max(leftMax+values[i]-i,ret);<br>            leftMax = Math.max(leftMax,values[i]+i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-comment">//bf超时</span><br>    <span class="hljs-comment">// public int maxScoreSightseeingPair(int[] values) &#123;</span><br>    <span class="hljs-comment">//     int n = values.length;</span><br>    <span class="hljs-comment">//     int ret = 0;</span><br>    <span class="hljs-comment">//     for(int i=0;i&lt;n;i++)&#123;</span><br>    <span class="hljs-comment">//         for(int j=i+1;j&lt;n;j++)&#123;</span><br>    <span class="hljs-comment">//             ret = Math.max(ret,values[i] + values[j] + i - j);</span><br>    <span class="hljs-comment">//         &#125;</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">//     return ret;</span><br>    <span class="hljs-comment">// &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="396-旋转函数（mid）"><a href="#396-旋转函数（mid）" class="headerlink" title="396. 旋转函数（mid）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-function/">396. 旋转函数</a>（mid）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25</span><br>    <span class="hljs-comment">//F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16</span><br>    <span class="hljs-comment">//F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23</span><br>    <span class="hljs-comment">//F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26</span><br>    <br>    <span class="hljs-comment">//F(0)=0×nums[0]+1×nums[1]+…+(n−1)×nums[n−1]</span><br>    <span class="hljs-comment">//F(1)=1×nums[0]+2×nums[1]+…+0×nums[n−1]=F(0)+numSum−n×nums[n−1]</span><br>    <span class="hljs-comment">//F(2)=2×nums[0]+3×nums[1]+…+1×nums[n−1]=F(1)+numSum−n×nums[n−2]</span><br>    <span class="hljs-comment">//F(k)=F(k−1)+numSum−n×nums[n−k]</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxRotateFunction</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)sum+=num;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)numSum+=i*nums[i];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> numSum;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> numSum;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> prev + sum - n * nums[n-i];<br>            ret = Math.max(ret,cur);<br>            prev = cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="467-环绕字符串中唯一的子字符串（mid）"><a href="#467-环绕字符串中唯一的子字符串（mid）" class="headerlink" title="467. 环绕字符串中唯一的子字符串（mid）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-substrings-in-wraparound-string/">467. 环绕字符串中唯一的子字符串</a>（mid）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 给定字符串s=&quot;abcdefghijklmnopqrstuvwxyzabcd...&quot;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 输入一个字符串 p，输出 p 的子串的数量，满足条件</span><br><span class="hljs-comment"> * 1，子串同时是 s 的子串</span><br><span class="hljs-comment"> * 2，重复的子串不计数</span><br><span class="hljs-comment"> * 3，子串在 p 中是连续的</span><br><span class="hljs-comment"> * 4，子串在 s 中是连续的</span><br><span class="hljs-comment"> * 5，子串是非空的</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 注意：p 不是无限循环字符串的根</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 举例</span><br><span class="hljs-comment"> * 输入 p=&quot;a&quot;，p 的子串有 &quot;&quot;, &quot;a&quot;</span><br><span class="hljs-comment"> * 满足条件的子串的数量是 1</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 输入 p=&quot;cac&quot;，p的子串有 &quot;&quot;, &quot;c&quot;, &quot;a&quot;, &quot;ca&quot;, &quot;ac&quot;, &quot;cac&quot;</span><br><span class="hljs-comment"> * 满足条件的子串的数量是 2，也就是说 &quot;ca&quot;、&quot;ac&quot;、&quot;cac&quot;不是 s 的子串</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 输入 p=&quot;zab&quot;，p的子串有 &quot;&quot;, &quot;z&quot;, &quot;a&quot;, &quot;b&quot;, &quot;za&quot;, &quot;ab&quot;, &quot;zab&quot;</span><br><span class="hljs-comment"> * 满足条件的子串的数量是 6，也就是说 &quot;z&quot;, &quot;a&quot;, &quot;b&quot;, &quot;za&quot;, &quot;ab&quot;, &quot;zab&quot; 都是 s 的子串</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 由于 s 是周期字符串，对于在 s 中的子串，只要知道子串的第一个字符（或最后一个字符）和子串长度，就能确定这个子串。例如子串以 ‘d’ 结尾，长度为 3，那么该子串为 “bcd”。</span><br><span class="hljs-comment"> * 题目要求不同的子串个数，那么对于两个以同一个字符结尾的子串，长的那个子串必然包含短的那个。例如 “abcd” 和 “bcd” 均以 ‘d’ 结尾，“bcd” 是 “abcd” 的子串。</span><br><span class="hljs-comment"> * 据此，我们可以定义 dp[α] 表示 p 中以字符 α 结尾且在 s 中的子串的最长长度，知道了最长长度，也就知道了不同的子串的个数。</span><br><span class="hljs-comment"> * 如何计算 dp[α] 呢？我们可以在遍历 p 时，维护连续递增的子串长度 k。具体来说，遍历到 p[i] 时，如果 p[i] 是 p[i−1] 在字母表中的下一个字母，则将 k 加一，</span><br><span class="hljs-comment"> * 否则将 k 置为 1，表示重新开始计算连续递增的子串长度。然后，用 k 更新 dp[p[i]] 的最大值。</span><br><span class="hljs-comment"> * 遍历结束后，p 中以字符 c 结尾且在 s 中的子串有 dp[c] 个。例如 dp[‘d’]=3 表示子串 “bcd”、“cd” 和 “d”。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 最后答案为 </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//dp[i]表示i结尾的非空子串的数量</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findSubstringInWraproundString</span><span class="hljs-params">(String p)</span> &#123;<br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; p.length(); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (p.charAt(i) - p.charAt(i - <span class="hljs-number">1</span>) + <span class="hljs-number">26</span>) % <span class="hljs-number">26</span> == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 字符之差为 1 或 -25</span><br>            ++k;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            k = <span class="hljs-number">1</span>;<br>        &#125;<br>        dp[p.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] = Math.max(dp[p.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>], k);<br>    &#125;<br>    <span class="hljs-keyword">return</span> Arrays.stream(dp).sum();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="926-将字符串翻转到单调递增（mid）"><a href="#926-将字符串翻转到单调递增（mid）" class="headerlink" title="926. 将字符串翻转到单调递增（mid）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flip-string-to-monotone-increasing/">926. 将字符串翻转到单调递增</a>（mid）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//dp[i][0] 表示第i位如果是0结尾最小翻转次数</span><br>    <span class="hljs-comment">//dp[i][1] 表示第i位如果是1结尾最小翻转次数</span><br>    <span class="hljs-comment">//dp[0][0] = dp[0][1] = 0</span><br>    <span class="hljs-comment">//状态转移方程：分为两种情况</span><br>    <span class="hljs-comment">//if(s[i]==&#x27;0&#x27;)</span><br>    <span class="hljs-comment">//dp[i][0] = dp[i-1][0]     //如果当前是s[i]==&#x27;0&#x27;则dp[i][0]直接取dp[i-1][0]</span><br>    <span class="hljs-comment">//dp[i][1] = min(dp[i-1][0],dp[i-1][1])+1     //因为当前是s[i]==&#x27;0&#x27;,且dp[i][1]表示第i位如果是1结尾最小翻转次数,那么要变为&#x27;1&#x27;必须+1,则dp[i][1]可取的情况是 min(dp[i-1][0],dp[i-1][1])+1 </span><br>    <span class="hljs-comment">//if(s[i]==&#x27;1&#x27;)</span><br>    <span class="hljs-comment">//dp[i][0] = dp[i-1][0] + 1;      //如果当前是s[i]==&#x27;1&#x27;则dp[i][0]直接取dp[i-1][0]+1（把1变成0）</span><br>    <span class="hljs-comment">//dp[i][1] = min(dp[i-1][0],dp[i-1][1])       //因为当前是s[i]==&#x27;1&#x27;,此时不管是s[i-1]是&#x27;0&#x27;还是&#x27;1&#x27;都不需要改动,只需取其两者的最小值即可</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFlipsMonoIncr</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i-<span class="hljs-number">1</span>)==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                dp[i][<span class="hljs-number">0</span>] = dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>                dp[i][<span class="hljs-number">1</span>] = Math.min(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(s.charAt(i-<span class="hljs-number">1</span>)==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                dp[i][<span class="hljs-number">0</span>] = dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<br>                dp[i][<span class="hljs-number">1</span>] = Math.min(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.min(dp[n][<span class="hljs-number">0</span>],dp[n][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="1289-下降路径最小和-II（hard）"><a href="#1289-下降路径最小和-II（hard）" class="headerlink" title="1289. 下降路径最小和  II（hard）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-falling-path-sum-ii/">1289. 下降路径最小和  II</a>（hard）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//dp[i][j] = for j in n Math.min(dp[i-1]+grid[i][j],) j!=i</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFallingPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)dp[<span class="hljs-number">0</span>][i] = grid[<span class="hljs-number">0</span>][i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++)&#123;<br>                    <span class="hljs-keyword">if</span>(k==j)<span class="hljs-keyword">continue</span>;<br>                    v = Math.min(v,dp[i-<span class="hljs-number">1</span>][k]+grid[i][j]);<br>                &#125;<br>                dp[i][j] = v;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> dp[n-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)ret = Math.min(dp[n-<span class="hljs-number">1</span>][i],ret);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1>
              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" class="category-chain-item">算法相关</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">#动态规划</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>算法学习-动态规划</div>
      <div>https://mikeygithub.github.io/2020/09/09/yuque/ybn65e/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Mikey</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2020年9月9日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/10/10/yuque/ise7a7/" title="Linux篇-文本三剑客grep/sed/awk">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Linux篇-文本三剑客grep/sed/awk</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/09/01/yuque/vsbnw5/" title="刷题笔记-二分搜索">
                        <span class="hidden-mobile">刷题笔记-二分搜索</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'mikeygithub/commit-utterance');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  





  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.13.10/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});
  });
</script>




  <!-- Custom -->
  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" lazyload class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       Copyright © 麦奇 Powered by <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> and <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> core on github page 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      桂ICP备2020009931号-1
    </a>
  </span>
  
    
      <span>
        <a
          href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=2020009931"
          rel="nofollow noopener"
          class="beian-police"
          target="_blank"
        >
          
            <span style="visibility: hidden; width: 0">|</span>
            <img src="/img/police_beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
          
          <span>桂公网安备2020009931号</span>
        </a>
      </span>
    
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?74301a15e5497361e93588eeee69f4b2";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  

  

  

  

  

  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        MathJax = {
          tex    : {
            inlineMath: { '[+]': [['$', '$']] }
          },
          loader : {
            load: ['ui/lazy']
          },
          options: {
            renderActions: {
              findScript    : [10, doc => {
                document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                  const display = !!node.type.match(/; *mode=display/);
                  const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                  const text = document.createTextNode('');
                  node.parentNode.replaceChild(text, node);
                  math.start = { node: text, delim: '', n: 0 };
                  math.end = { node: text, delim: '', n: 0 };
                  doc.math.push(math);
                });
              }, '', false],
              insertedScript: [200, () => {
                document.querySelectorAll('mjx-container').forEach(node => {
                  let target = node.parentNode;
                  if (target.nodeName.toLowerCase() === 'li') {
                    target.parentNode.classList.add('has-jax');
                  }
                });
              }, '', false]
            }
          }
        };
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.0/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
