

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <meta name="referrer" content="no-referrer"/>
  <link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/favicon.png">
  <link rel="icon" href="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Mikey">
  <meta name="keywords" content="">
  
    <meta name="description" content="第 1 章 介绍1.1 并发的(非常)简短历史 在发展的初期，计算机还没有操作系统;它们自始至终执行一个程序，这个程序直接访问机器的所有资源。这样-个程序运行 在无保护的金属器件上，不仅写起来困难，而且每次只运行一个程序，不能很好地利用昂贵且稀缺的计算机资源。   操作系统的发展使得多个程序能够同时运行，程序在各自的进程(processes)中运行:相互分离，各自独立执行，由操作系统来分配资源，">
<meta property="og:type" content="article">
<meta property="og:title" content="读书笔记篇-Java并发编程实战">
<meta property="og:url" content="https://mikeygithub.github.io/2021/05/19/yuque/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AF%87-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/index.html">
<meta property="og:site_name" content="麦奇">
<meta property="og:description" content="第 1 章 介绍1.1 并发的(非常)简短历史 在发展的初期，计算机还没有操作系统;它们自始至终执行一个程序，这个程序直接访问机器的所有资源。这样-个程序运行 在无保护的金属器件上，不仅写起来困难，而且每次只运行一个程序，不能很好地利用昂贵且稀缺的计算机资源。   操作系统的发展使得多个程序能够同时运行，程序在各自的进程(processes)中运行:相互分离，各自独立执行，由操作系统来分配资源，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/2630542/1622007928788-e0c9bebc-b0ce-4bed-9b6a-c9d6ca8fdba7.png">
<meta property="article:published_time" content="2021-05-19T09:24:22.000Z">
<meta property="article:modified_time" content="2023-02-13T05:46:25.801Z">
<meta property="article:author" content="Mikey">
<meta property="article:tag" content="并发">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2021/png/2630542/1622007928788-e0c9bebc-b0ce-4bed-9b6a-c9d6ca8fdba7.png">
  
  
<!--    <meta name="referrer" content="no-referrer-when-downgrade">-->
  
  
  <title>读书笔记篇-Java并发编程实战 - 麦奇</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"mikeygithub.github.io","root":"/","version":"1.9.1","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":200}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"74301a15e5497361e93588eeee69f4b2","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="麦奇" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>麦奇</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/photo/">
                <i class="iconfont icon-image"></i>
                照片
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/music/">
                <i class="iconfont icon-music"></i>
                音乐
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/atom.xml">
                <i class="iconfont icon-rss"></i>
                RSS
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="读书笔记篇-Java并发编程实战"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Mikey
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-05-19 17:24" pubdate>
          2021年5月19日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          53k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          444 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">读书笔记篇-Java并发编程实战</h1>
            
            <div class="markdown-body">
              
              <p><img src="https://cdn.nlark.com/yuque/0/2021/png/2630542/1622007928788-e0c9bebc-b0ce-4bed-9b6a-c9d6ca8fdba7.png#averageHue=%23febe18&clientId=u437d290e-2655-4&errorMessage=unknown%20error&from=paste&height=549&id=u8e6aa1d1&name=image.png&originHeight=549&originWidth=900&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=254559&status=error&style=none&taskId=u2c6f5f5c-5b2c-40a3-b3db-45c6be03d89&title=&width=900" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h1 id="第-1-章-介绍"><a href="#第-1-章-介绍" class="headerlink" title="第 1 章 介绍"></a>第 1 章 介绍</h1><h2 id="1-1-并发的-非常-简短历史"><a href="#1-1-并发的-非常-简短历史" class="headerlink" title="1.1 并发的(非常)简短历史"></a>1.1 并发的(非常)简短历史</h2><blockquote>
<p>在发展的初期，计算机还没有操作系统;它们自始至终执行一个程序，这个程序直接访问机器的所有资源。这样-个程序运行 在无保护的金属器件上，不仅写起来困难，而且每次只运行一个程序，不能很好地利用昂贵且稀缺的计算机资源。</p>
</blockquote>
<blockquote>
<p>操作系统的发展使得多个程序能够同时运行，程序在各自的进程(processes)中运行:相互分离，各自独立执行，由操作系统来分配资源，比如内存、文件句柄、安全证书。</p>
</blockquote>
<blockquote>
<p>如果需要的话，进程会通过-些原始的机制相互通信: Socket. 信号处理(signal handlers)、共享内存(shared memory)、信号量(semaphores) 和文件。</p>
</blockquote>
<h2 id="1-2-线程的优点"><a href="#1-2-线程的优点" class="headerlink" title="1.2 线程的优点"></a>1.2 线程的优点</h2><blockquote>
<p>恰当的使用线程，可以降低开发和维护的开销，线程通过异步的工作流程转化为普遍存在的顺序流程，使程序模拟人类和交互变得容易。</p>
</blockquote>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><blockquote>
<p>因为程序调度的基本单位是线程，一个单线程应用程序一次只能运行在一个处理器上。在双核处理器系统中，一个单线程程序，放弃了其中一半的空闲 CPU 资源。如果让每个 CPU 都得到有效的利用，其效率更加高。</p>
</blockquote>
<h3 id="1-3-线程的风险"><a href="#1-3-线程的风险" class="headerlink" title="1.3 线程的风险"></a>1.3 线程的风险</h3><ul>
<li>安全危险</li>
<li>活跃度的危险</li>
<li>性能危险</li>
</ul>
<h3 id="1-4-线程无处不在"><a href="#1-4-线程无处不在" class="headerlink" title="1.4 线程无处不在"></a>1.4 线程无处不在</h3><blockquote>
<p>通过从框架线程中调用应用程序的组件，框架把并发引入了应用程序。组件总是需要访问程序的状态。因此要求在所有的代码路径访问状态时，必须是线程安全的。</p>
</blockquote>
<h1 id="第-2-章-线程安全"><a href="#第-2-章-线程安全" class="headerlink" title="第 2 章 线程安全"></a>第 2 章 线程安全</h1><blockquote>
<p>无论何时，只要有多于一个的线程访问给定的状态变量，而且其中某个线程会写入该变量，此时必须使用同步来协调线程对该变量的访问。</p>
</blockquote>
<h2 id="2-1-什么是线程安全性"><a href="#2-1-什么是线程安全性" class="headerlink" title="2.1 什么是线程安全性"></a>2.1 什么是线程安全性</h2><blockquote>
<p>当多个线程访问一个类时，如果不用考虑这些线程在运行时环境下的调度和交替执行，并且不需要额外的同步及在调用方代码不必作其他的协调，这个类的行为仍然是正确的，那么称这个类是线程安全的。</p>
</blockquote>
<blockquote>
<p>有状态对象(Stateful Bean) ：就是有实例变量的对象，可以保存数据，是非线程安全的。每个用户有自己特有的一个实例，在用户的生存期内，bean 保持了用户的信息，即“有状态”；一旦用户灭亡（调用结束或实例结束），bean 的生命期也告结束。即每个用户最初都会得到一个初始的 bean。</p>
</blockquote>
<p>无状态对象永远是线程安全的。多数 Servlet 都可以实现为无状态的，这一事实 极大地降低了确保 Servlet 线程安<br>全的负担，只有当 Servlet 要为不同的请求记录一些信 息时，才会将线程安全的需求提到日程上来。</p>
<h2 id="2-2-原子性"><a href="#2-2-原子性" class="headerlink" title="2.2 原子性"></a>2.2 原子性</h2><blockquote>
<p>原子性，顾名思义就是不可再分的单位。在这里指的是原子操作，其指的是在对数据操作的过程中不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）</p>
</blockquote>
<h4 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h4><blockquote>
<p>当计算的正确性依赖于运行时中相关的时许或者多线程的交替时，会产生竞争条件。</p>
</blockquote>
<blockquote>
<p>最常见的竞争条件是“检查再运行”（check then act），使用一个潜在的过期值作为决定下一步操作的依据。</p>
</blockquote>
<blockquote>
<p>检查再运行的的常用用法就是<strong>惰性初始化</strong>，惰性初始化的目的是延迟对象的初始化，直到程序真正使用它，同时确保它只初始化<strong>一次</strong>。</p>
</blockquote>
<h4 id="复合操作"><a href="#复合操作" class="headerlink" title="复合操作"></a>复合操作</h4><blockquote>
<p>将“检查再运行”和“读-写-改”操作的全部执行过程看作是复合操作</p>
</blockquote>
<blockquote>
<p>假设有操作 A 和 B,如果从执行 A 的线程的角度看，当其他线程执行 B 时，要么 B 全部执行完成，要么一点都没有执行，这样 A 和 B 互为原子操作。一个原子操作是指:该操作对于所有的操作，包括它自己，都满足前面描述的状态。</p>
</blockquote>
<h2 id="2-3-锁"><a href="#2-3-锁" class="headerlink" title="2.3 锁"></a>2.3 锁</h2><blockquote>
<p>为了保护状态的一致性，要在单一的原子操作中更新相互关联的状态变量。</p>
</blockquote>
<h4 id="内部锁"><a href="#内部锁" class="headerlink" title="内部锁"></a>内部锁</h4><blockquote>
<p>Java 提供了强制原子性的内置锁机制：synchronized 块。有两种作用：1.是锁饮用的对象 2.锁代码块。</p>
</blockquote>
<p>每个 Java 对象都可以隐式地扮演一个用于同步的锁的角色:这些内置的锁被称作内部锁(intrinsic locks)或监视器锁(monitor locks)。执行线程进入 synchronized 块之前会自动获得锁;而无论通过正常控制路径退出，还是从块中抛出异常，线程都在放弃对 synchronized 块的控制时自动释放锁。获得内部锁的唯一途径是: 进入这个内部锁保护的同步块或方法。</p>
<p>内部锁在 Java 中扮演了互斥锁(mutual exclusion lock,也称作 mutex)的角色，意味着至多只有一个线程可以拥有锁，当线程 A 尝试请求一个被线程 B 占有的锁时，线程 A 必须等待或者阻塞，直到 B 释放它。如果 B 永远不释放锁，A 将永远等下去。</p>
<h4 id="重进入-Reentrancy"><a href="#重进入-Reentrancy" class="headerlink" title="重进入(Reentrancy)"></a>重进入(Reentrancy)</h4><p>当一个线程请求其他线程已经占有的锁时，请求线程将被阻塞。然而内部锁是可重进入的，因此线程在试图获得它自已占有的锁时，请求会成功。重进入意味着所的请求是基于“每线程(per-thread) ”，而不是基于“每调用(per invocation) ”的。重进入的实现是通过为每个锁关联-个请求计数(acquisition count)和-个占有它的线程。当计数为 0 时，认为锁是未被占有的。线程请求-个未被占有的锁时，JVM 将记录锁的占有者，并且将请求计数置为 1。如果同一线程再次请求这个锁，计数将递增:每次占用线程退出同步块，计数器值将递减。直到计数器达到 0 时，锁被释放。</p>
<h3 id="2-4-用锁来保护状态"><a href="#2-4-用锁来保护状态" class="headerlink" title="2.4 用锁来保护状态"></a>2.4 用锁来保护状态</h3><blockquote>
<p>对于每个可被多个线程访问的可变状态变量，如果所有访问它的线程在执行时都占有同一个锁，这种情况下，我们称这个变量是由这个锁保护的。</p>
</blockquote>
<p>对象的内部锁与它的状态之间没有内在的关系。尽管大多数类普遍使用这样一种非常有效的锁机制:</p>
<blockquote>
<p>用对象的内部锁来保护所有的域，然而这并不是必需的。即使获得了与对象关联的锁也不能阻止其他线程访问这个对象一-获得 对象的锁后，唯-可以做的事情是阻止其他线程再获得相同的锁。作为一种便利， 每个对象都有一个内部锁，所以你不需要显式地创建锁对象。你可以构造自己的锁协议或同步策略，使你可以安全地访问共享状态，并且贯穿程序都始终如一地使用它们。</p>
</blockquote>
<blockquote>
<p>每个共享的可变变量都需要由唯一一个确定 的锁保护。而维护者应该清楚这个锁。</p>
</blockquote>
<blockquote>
<p>锁保护的变量，意味着每次访问变量都需要获得改锁，确保在同一时刻只有一个线程可以访问这个变量。</p>
</blockquote>
<h3 id="2-5-活跃度与性能"><a href="#2-5-活跃度与性能" class="headerlink" title="2.5 活跃度与性能"></a>2.5 活跃度与性能</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2630542/1622000498030-453fb26b-90a7-4c7a-a9c3-66e4fd9ce7ce.png#averageHue=%23f8f8f8&clientId=u437d290e-2655-4&errorMessage=unknown%20error&from=paste&height=196&id=uc503b894&name=image.png&originHeight=196&originWidth=489&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=10428&status=error&style=none&taskId=u1742a538-e8ec-491d-88f9-17e3cb4d265&title=&width=489" srcset="/img/loading.gif" lazyload alt="image.png"><br>上图表示多个请求到达同步的 Factoring Servlet 时所发生的事情:这些请求排队等候并依次被处理。我们把这种 Web 应用的运行方式描述为**弱并发(poor concurrency) **的。</p>
<p>一种表现:限制并发调用数量的，并非可用的处理器资源，而恰恰是应用程序自身的结构。幸运的是，通过缩小 synchronized 块的范围来维护线程安全性，我们很容易提升 Servlet 的并发性。你应该谨慎地控制 synchronized 块不要过小:你不可以将-个原子操作分解到多个 synchronized 块中。不过你应该尽量从 synchroni zed 块中分离耗时的且不影响共享状态的操作。这样即使在耗时操作的执行过程中,也不会阻止其他线程访问共享状态。</p>
<blockquote>
<p>有些耗时的计算或操作，比如网络或控制台 I/O,难以快速完成。执行这些操作期间不要占有锁。</p>
</blockquote>
<h1 id="第-3-章-共享对象"><a href="#第-3-章-共享对象" class="headerlink" title="第 3 章 共享对象"></a>第 3 章 共享对象</h1><h2 id="3-1-可见性"><a href="#3-1-可见性" class="headerlink" title="3.1 可见性"></a>3.1 可见性</h2><p>Java 内存模型（JMM）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2630542/1622001334623-b3c24416-58bc-4025-95e4-80e6025c2eb0.png#averageHue=%23faf8f8&clientId=u437d290e-2655-4&errorMessage=unknown%20error&from=paste&height=318&id=ueea0a783&name=image.png&originHeight=636&originWidth=821&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=43328&status=error&style=none&taskId=uef1cdcb1-394b-42b3-aa4f-e02bc2e6f10&title=&width=411" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<blockquote>
<p>Java 的内存模型如上图所示，在多线程进行操作数据的时候，会先从主内存中拷贝一份到自己的工作内存中，在处理数据完成后，再将其写入主内存中，完成操作。</p>
</blockquote>
<h3 id="过期数据"><a href="#过期数据" class="headerlink" title="过期数据"></a>过期数据</h3><blockquote>
<p>当线程读取数据时，可能读取到的是一个过期的数据，除非每一次访问数据都是同步的，否则很肯读取到过期数据。</p>
</blockquote>
<h3 id="非原子的-64-位操作"><a href="#非原子的-64-位操作" class="headerlink" title="非原子的 64 位操作"></a>非原子的 64 位操作</h3><blockquote>
<p>当一个线程在没有同步的情况下读取变量，它可能会得到一个过期值。但是至少它可以看到某个线程在那里设定的一个真实数值，而不是一个凭空而来的值。这样的安全保证被称为是最低限的安全性(out- of-thin- air safety)</p>
</blockquote>
<p>最低限的安全性应用于所有的变量，除了一个例外:没有声明为 volatile 的 64 位数值变量(double 和 long) 。Java 存储模型要求获取和存储操作都为原子的，但是对于非 volatile 的 long 和 double 变量，JVM 允许将 64 位的读或写划分为两个 32 位的操作。如果读和写发生在不同的线程,这种情况读取-一个非 volatile 类型 long 就可能会出现得到一个值的高 32 位和另一个值的低 32 位 3。因此，即使你并不关心过期数据，但仅仅在多线程程序中使用共享的、可变的 long 和 double 变量也可能是不安全的，除非将它们声明为 volatile 类型，或者用锁保护起来。</p>
<h3 id="锁和可见性"><a href="#锁和可见性" class="headerlink" title="锁和可见性"></a>锁和可见性</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2630542/1622008382846-1f6d688f-4c0e-4618-9980-7c0296065574.png#averageHue=%23f0f0f0&clientId=u437d290e-2655-4&errorMessage=unknown%20error&from=paste&height=376&id=ub514f93d&name=image.png&originHeight=376&originWidth=563&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=58325&status=error&style=none&taskId=u9d6aa4ec-3108-4e4b-981d-d1e28d64351&title=&width=563" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<blockquote>
<p>当访问一个共享的可变变量时，为什么要求所有线程由同一个锁进行同步，我们现在可以给出另一个理由一为 了保证一个线程对数值进行的写入，其他线程也都可见。另一方面，如果一个线程在没有恰当地使用锁的情况下读取了变量，那么这个变量很可能是一个过期的数据。</p>
</blockquote>
<blockquote>
<p>锁不仅仅是关于同步与互斥的，也是关于内存可见的。为了保证所有线程都能够看到共享的、可变变量的最新值，读取和写入线程必须使用公共的锁进行同步.</p>
</blockquote>
<h3 id="volatile-变量"><a href="#volatile-变量" class="headerlink" title="volatile 变量"></a>volatile 变量</h3><blockquote>
<p>在 Java 中 volatile 关键字确保对一个变量的更新以可预见的方式告知其他线程。</p>
</blockquote>
<p>加锁可以保证可见性与原子性; volatile 变量只能保证可见性。</p>
<p>只有满足了下面所有的标准后，你才能使用 volatile 变量:</p>
<ul>
<li>写入变量时 并不依赖变量的当前值:或者能够确保只有单一的线程修改变量的值:</li>
<li>变量不需 要与其他的状态变量共同参与不变约束;</li>
<li>而且，访问变量时，没有其他的原因需要加锁。</li>
</ul>
<h3 id="发布和逸出"><a href="#发布和逸出" class="headerlink" title="发布和逸出"></a>发布和逸出</h3><p>发布(publishing)一个对象的意思是使它能够被当前范围之外的代码所使用。比如将一个引用存储到其他代码可以访问的地方，在-一个非私有的方法中返回这个引用，也可以把它传递到其他类的方法中。在很多情况下，我们需要确保对象及它们的内部状态不被暴露(publish)。在另外-些情况下，为了正当的使用目的，我们又的确希望发布一个对象，但是用线程安全的方法完成这些工作时，可能需要同步。如果变量发布了内部状态，就可能危及到封装性，并使程序难以维持稳定:如果发布对象时，它还没有完成构造，同样危及线程安全。一个对象在尚未准备好时就将它发布，这种情况称作逸出(escape) 。</p>
<p>让我们看看一个对象是如何逸出的。</p>
<blockquote>
<p>最常见的发布对象方式就是将对象的引用存储到公共静态域中，任何类和线程都可以看到这个域。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsafeStatus</span></span>&#123;<br>	<span class="hljs-keyword">private</span> String[] status = <span class="hljs-keyword">new</span> String()&#123;<br>    	<span class="hljs-string">&quot;MIKEY&quot;</span>,<span class="hljs-string">&quot;LEO&quot;</span>,<span class="hljs-string">&quot;DON&quot;</span>,<br>    &#125;;<br>    <span class="hljs-keyword">public</span> String[] getStatus()&#123;<span class="hljs-keyword">return</span> status;&#125;<span class="hljs-comment">//当别的类调用这个方法时，就可以获取到status，可以对其进行修改操作。</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>不要让 this 引用在构造期间逸出。</p>
</blockquote>
<h2 id="3-3-线程封闭"><a href="#3-3-线程封闭" class="headerlink" title="3.3 线程封闭"></a>3.3 线程封闭</h2><p>访问共享的、可变的数据要求使用同步。-个可以避免同步的方式就是不共享数据。如果数据仅在单线程中被访问，就不需要任何同步。线程封闭(Thread confinement)技术是实现线程安全的最简单的方式之-。 当对象封闭在一个线程中时，这种做法会自动成为线程安全的，即使被封闭的对象本身并不是。</p>
<blockquote>
<p>Swing 发展了线程封闭技术。Swing 的可视化组件和数据模型对象并不是线程安全的，它们是通过将它们限制到 Swing 的事件分发线程中，实现线程安全的。为了正确地使用 Swing,运行在不同于事件线程(event thread)的其他线程中的代码不应该访问这些对象(为了简化这些, Swing 提供了 invokelater 机制,用于在事件线程中安排执行 Runnable 实例)。</p>
</blockquote>
<h4 id="Ad-hoc-线程限制"><a href="#Ad-hoc-线程限制" class="headerlink" title="Ad-hoc 线程限制"></a>Ad-hoc 线程限制</h4><p>Ad-boc 线程限制 10 是指维护线程限制性的任务全部落在实现上的这种情况。因为没有可见性修饰符与本地变量等语言特性协助将对象限制在目标线程上,所以这种方式是非常容易出错的。事实上,对于像 GUI 应用中的可视化组件或者数据模型这些线程限制对象，对它们的引用通常是公用域。</p>
<p>如果决定将一个像 GUI 这样特定的子系统实现为“单线程化”的子系统，通常就要使用线程限制技术。单线程化子系统有时所带来的简便性的好处远远胜过 ad-hoc 线程限制的易损性”。</p>
<p>线程限制的一种特例是将它用于 volatile 变量。只要你确保只通过单一线程写入共享的 volatile 变量，那么在这些 volaile 变量上执行“读-改-写”操作就是安全的。在这种情况下，你就将修改操作限制在单- -的线程中， 从而阻止了竞争条件。并且，可见性保证 volatile 变量能够确保其他线程能看到最新的值。</p>
<p>鉴于 ad-hoc 线程限制固有的易损性，因此应该有节制地使用它。如果可能的话，用一种线程限制的强形式(栈限制或者 Thread Local)取代它。</p>
<h4 id="栈限制"><a href="#栈限制" class="headerlink" title="栈限制"></a>栈限制</h4><blockquote>
<p>栈限制是线程限制的一种特例，在栈限制中，只能通过本地变量才可以触及对象。正如封装使不变约束更容易被保持，本地变量使对象更容易被限制在线程本地中。本地变量本身就被限制在执行线程中:它们存在于执行线程栈。其他线程无法访问这个栈。</p>
</blockquote>
<blockquote>
<p>栈限制(也称线程内部或者线程本地用法，但是不要与核心库类的 ThreadLocal 混淆)与 ad-hoc 线程限制相比，更易维护，更健壮。.</p>
</blockquote>
<h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><blockquote>
<p>一种维护线程限制的更 加规范的方式是使用 ThreadLocal,它允许你将每个线程与持有数值的对象关联在一起。ThreadLocal 提供了 get 与 set 访问器，为每个使用它的线程维护一份单独的拷贝。所以 get 总是返回由当前执行线程通过 set 设置的最新值。</p>
</blockquote>
<p>线程本地(Thread Local)变量通常用于防止在基于可变的单体(Singleton) 或全局变量的设计中，出现(不正确的)共享。比如说，一个单线程化的应用程序可能会维护-个全局的数据库连接，这个 Connection 在启动时就已经被初始化了。这样就可以避免为每个方法都传递一个 Connection. 因为 JDBC 规范并未要求 Connection;自身一定是线程安全的，因此，如果没有额外的协调时，使用全局变量的多线程应用程序同样不是线程安全的。通过利用 ThreadLocal 存储 JDBC 连接，每个线程都会拥有属于自己的 Connection.<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2630542/1622011370030-cce891ae-b014-4b04-b7f6-b60618ecf680.png#averageHue=%23f2f2f2&clientId=u2ff06500-278a-4&errorMessage=unknown%20error&from=paste&height=180&id=ua2312ea1&name=image.png&originHeight=180&originWidth=536&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=24317&status=error&style=none&taskId=ua9333b6c-f3af-494f-930f-e6e4aadec1a&title=&width=536" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>ThreadLocal 的 ThreadLocalMap  中 key 为什么使用 WeakReference ?</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> class ThreadLocalMap &#123;<br><br>	private Entry[] table;<br><br>	<span class="hljs-keyword">static</span> class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>	    <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>	    Object value;<br>	    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>	        <span class="hljs-keyword">super</span>(k);<span class="hljs-comment">//注意这里只是设置了key为weakreference类型，value并不是</span><br>	        value = v;<br>	    &#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到 Entry 是继承 WeakReference（弱引用类型），其传入的 ThreadLocal&lt;?&gt;（也就是 key）在 GC 时会被收集掉，但 value 并不是，那为啥要这么设计呢 ？</p>
<blockquote>
<p>WeakReference 的定义是如果没有强引用指向它，在 JVM 进行 GC 的时候会被收集掉(无论内存是否满)</p>
</blockquote>
<p><strong>设计原理</strong></p>
<p>先来看看 ThreadLocal 的组成，可以发现 ThreadLocal 类中的<strong>ThreadLocalMap  是由 Thread 类持有的</strong>，每个 Thread 有自己的 ThreadLocalMap 实例，ThreadLocalMap 的键是 ThreadLocal，值是 T，也就是说在当前线程中可以存在多个 ThreadLoca 存储与 ThreadLocalMap 中。其生命周期也就是说只有线程 Thread 被销毁了，其 ThreadLocalMap 才会被回收。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//ThreadLocalMap是由Thread类持有的</span><br>public class Thread implements Runnable &#123;<br>    ThreadLocal.ThreadLocalMap threadLocals = null;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>get 方法，获取值时是通过先拿到当前线程，再获取当前线程中的 ThreadLocalMap，再通过当前 ThreadLocal 类作为 key 去获取对应的 value</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust">public T get() &#123;<br>    Thread t = Thread.currentThread();<br>    ThreadLocalMap map = getMap(t);<br>    <span class="hljs-keyword">if</span> (map != null) &#123;<br>        ThreadLocalMap.Entry e = map.getEntry(this);<span class="hljs-comment">//以当前ThreadLocal对象为key取哈希获取对应的槽位再获取对应的entry</span><br>        <span class="hljs-keyword">if</span> (e != null) &#123;<br>            @SuppressWarnings(<span class="hljs-string">&quot;unchecked&quot;</span>)<br>            T result = (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br><span class="hljs-comment">//返回的是当前线程的threadLocals（ThreadLocalMap）</span><br>ThreadLocalMap getMap(Thread t) &#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br><span class="hljs-comment">//获取对应的entry</span><br>private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;<br>    int i = key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);<span class="hljs-comment">//确定桶下标</span><br>    Entry e = table[i];<br>    <span class="hljs-keyword">if</span> (e != null &amp;&amp; e.get() == key) <span class="hljs-keyword">return</span> e;<span class="hljs-comment">//如果桶下标不为空且key值相同则直接返回</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);<span class="hljs-comment">//否则如果是改桶为空或者key不相同</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>set 方法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs rust">public void set(T value) &#123;<br>    Thread t = Thread.currentThread();<br>    ThreadLocalMap map = getMap(t);<span class="hljs-comment">//获取当前线程的ThreadLocalMap（其实是从当前Thread中获取）</span><br>    <span class="hljs-keyword">if</span> (map != null) map.set(this, value);<span class="hljs-comment">//设置值</span><br>    <span class="hljs-keyword">else</span> createMap(t, value);<span class="hljs-comment">//如果当前线程的ThreadLocalMap未创建则进行创建</span><br>&#125;<br><br> private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;<br>     Entry[] tab = table;<br>     int len = tab.length;<br>     int i = key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>     <span class="hljs-keyword">for</span> (Entry e = tab[i];<br>          e != null;<br>          e = tab[i = nextIndex(i, len)]) &#123;<br>         ThreadLocal&lt;?&gt; k = e.get();<br>         <span class="hljs-keyword">if</span> (k == key) &#123;<br>             e.value = value;<br>             <span class="hljs-keyword">return</span>;<br>         &#125;<br>         <span class="hljs-keyword">if</span> (k == null) &#123;<span class="hljs-comment">//如果key为空则说明key已经没有地方引用被回收了</span><br>             replaceStaleEntry(key, value, i);<br>             <span class="hljs-keyword">return</span>;<br>         &#125;<br>     &#125;<br>     tab[i] = new Entry(key, value);<br>     int sz = ++size;<br>     <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>         rehash();<br> &#125;<br></code></pre></td></tr></table></figure>

<p>remove 方法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs rust">public void remove() &#123;<br>    ThreadLocalMap m = getMap(Thread.currentThread());<br>    <span class="hljs-keyword">if</span> (m != null)m.remove(this);<br>&#125;<br><br>private void remove(ThreadLocal&lt;?&gt; key) &#123;<br>    Entry[] tab = table;<br>    int len = tab.length;<br>    int i = key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (Entry e = tab[i];e != null;e = tab[i] = nextIndex(i, len)]) &#123;<br>        <span class="hljs-keyword">if</span> (e.get() == key) &#123;<br>            e.clear();<span class="hljs-comment">//清空当前引用</span><br>            expungeStaleEntry(i);<span class="hljs-comment">//清理掉槽位为i的null引用值</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//清理无引用的value，staleSlot槽位</span><br>private int expungeStaleEntry(int staleSlot) &#123;<br>    Entry[] tab = table;<br>    int len = tab.length;<br>    <span class="hljs-comment">// expunge entry at staleSlot</span><br>    tab[staleSlot].value = null;<br>    tab[staleSlot] = null;<br>    size--;<br>    <span class="hljs-comment">// Rehash until we encounter null</span><br>    Entry e;<br>    int i;<br>    <span class="hljs-keyword">for</span> (i = nextIndex(staleSlot, len);<br>         (e = tab[i]) != null;<br>         i = nextIndex(i, len)) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-keyword">if</span> (k == null) &#123;<span class="hljs-comment">//如果引用已经被清理则把value也清理了</span><br>            e.value = null;<br>            tab[i] = null;<br>            size--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            int h = k.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (h != i) &#123;<br>                tab[i] = null;<br>                <span class="hljs-comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span><br>                <span class="hljs-comment">// null because multiple entries could have been stale.</span><br>                <span class="hljs-keyword">while</span> (tab[h] != null)<br>                    h = nextIndex(h, len);<br>                tab[h] = e;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面的的三个方法中 get、set、remove 中都会去调用 expungeStaleEntry  方法，其实这个方法就是清理无引用的 value（或者是被 GC 收集掉 key 的 value）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/2630542/1665458778447-9e655b5e-7677-4de1-b206-71618103b5f6.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>现在我们再回过头来看我们的问题 ，为什么 ThreadLocalMap 的 key 是 weakReference 类型的 ？</p>
<blockquote>
<p>首先如果我们代码中对 ThreadLocal 已经无需使用了，那么在 ThreadLocalMap 中的 key 也就没有强引用了，所以在 GC 时就会被收集掉了，同时我们的 get、set、remove 方法进行操作时也是根据 key==null 来清理 value 的，所以其作用体现在这里。</p>
</blockquote>
<p>如果我的 ThreadLocal 没有被回收但是他的 key 却被 GC 收集掉了会不会无法获取到我需要的值？不会的大哥，只要你还有非弱引用指向 ThreadLocal 就不会被回收的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Entry <span class="hljs-title">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);<span class="hljs-comment">//获取对应的桶位置</span><br>    Entry e = table[i];<br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span> &amp;&amp; e.get() == key)<span class="hljs-keyword">return</span> e;<span class="hljs-comment">//如果已经存在则直接返回</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);<span class="hljs-comment">//否则需要判断在改链表下是否有对应的节点（拉链法解决哈希冲突）</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> Entry <span class="hljs-title">getEntryAfterMiss</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, <span class="hljs-keyword">int</span> i, Entry e)</span> </span>&#123;<br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br>    <span class="hljs-keyword">while</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-keyword">if</span> (k == key) <span class="hljs-keyword">return</span> e;<span class="hljs-comment">//在链表中找到匹配的节点直接返回</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-keyword">null</span>) expungeStaleEntry(i);<span class="hljs-comment">//如果key为空则说明该ThreadLocal已经被回收了，对其值进行清空操作</span><br>        <span class="hljs-keyword">else</span> i = nextIndex(i, len);<span class="hljs-comment">//否则继续往链表下一个节点搜索</span><br>        e = tab[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<span class="hljs-comment">//找不到</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>所以说 key 设置为 weakReference 是在一定程度上防止发生内存泄露的，方便对象的回收。</p>
<p>Entry 为啥还要存储 key ? 这个就比较简单了主要是为了解决在我们进行哈希的时候可能会有冲突，ThreadLocal 会往后去查找空桶，在 get 的时候通过 key 进行匹配。</p>
<p>什么情况下使用 ThreadLocal 会产生内存泄露 ？这种情况当然是存在的，当你不正确使用时，如直接将 ThreadLocal 引用指向空，就会导致内存泄露后内存溢出</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//-XX:+PrintGC -Xmx2m</span><br>public class ThreadLocalTest &#123;<br>    public <span class="hljs-keyword">static</span> void main(<span class="hljs-built_in">String</span>[] args) &#123;<br>        ThreadLocal&lt;<span class="hljs-built_in">String</span>&gt; threadLocal = new ThreadLocal&lt;&gt;();<br>        threadLocal.set(<span class="hljs-string">&quot;hello&quot;</span>);<br>        threadLocal = null;<br><span class="hljs-comment">//        threadLocal.remove();//正确的做法</span><br>        System.gc();<span class="hljs-comment">//此时key已经没了强引用会被回收，但是value不包含被回收造成内存泄露（除非添加新的ThreadLocal且哈希桶下标与当前的一致会触发清理val）</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-4-不可变性"><a href="#3-4-不可变性" class="headerlink" title="3.4 不可变性"></a>3.4 不可变性</h2><blockquote>
<p>不可变对象永远是线程安全的。</p>
</blockquote>
<p>只有满足如下状态，一个对象才是不可变的:</p>
<ul>
<li>它的状态不能在创建后再被修改;</li>
<li>所有城都是 final 类型 3:并且，</li>
<li>它被正确创建(创建期间没有发生 this 引用的逸出)。</li>
</ul>
<blockquote>
<p>从技术上讲，不可变对象的城并未全部声明为 final 类型，这样的情况是可能存在的，string 就是这种类。设计这种类依赖于对良性数据竞争的精准分析，还需要对 Java 存储模型有深入的理解。(满足一 下你的好奇心: string 会惰性地 (Lazily)计算哈希值:当第一次调用 hashcode 时，string 计算哈希值，并将它缓存在一个非 final 域中。之所以可以这样做，仅是因为这个城所表现的非默认的( nondefault)值，在每次计算后都得到相同的结果，因为该结果来自一个已经确定的不可变的状态。但请不要自己这样做! )</p>
</blockquote>
<h4 id="Final-域"><a href="#Final-域" class="headerlink" title="Final 域"></a>Final 域</h4><p>final 关键字源于 C++的 const 机制，不过受到了更多的限制。它对不可变性对象的创建提供了支持。final 域是不能修改的(尽管如果 final 域指向的对象是可变的，这个对象仍然可被修改)，然而它在 Java 存储模型中还有着特殊的语义。final 域使得确保初始化安全性(initialization safety) 成为可能，初始化安全性让不可变性对象不需要同步就能自由地被访问和共享。</p>
<p>3.5 安全发布</p>
<blockquote>
<p>不可变对象可以在没有额外同步的情况下，安全地用于任意线程;甚至发布它们时亦不需要同步。</p>
</blockquote>
<p>如果一个对象不是不可变的，它就必须被安全地发布，通常发布线程与消费线程都必须同步化。此刻让我们关注一下， 如何确保消费线程能够看到处于发布当时的对象状态;我们要解决对象发布后对其修改的可见性问题。<br>为了安全地发布对象，对象的引用以及对象的状态必须同时对其他线程可见。</p>
<p>一个正确创建的对象可以通过下列条件安全地发布:</p>
<ul>
<li>通过静态初始化器初始化对象的引用;</li>
<li>将它的引用存储到 volatile 域或 AtomicReference;</li>
<li>将它的引用存储到正确创建的对象的 final 域中;</li>
<li>或者将它的引用存储到由锁正确保护的城中。</li>
</ul>
<h1 id="第-4-章组合对象"><a href="#第-4-章组合对象" class="headerlink" title="第 4 章组合对象"></a>第 4 章组合对象</h1><h2 id="4-1-设计线程安全的类"><a href="#4-1-设计线程安全的类" class="headerlink" title="4.1 设计线程安全的类"></a>4.1 设计线程安全的类</h2><p>三要素</p>
<ul>
<li>确定对象状态由哪些变量构成的。</li>
<li>确定限制状态变量的不变约束。</li>
<li>制定一个管理并发访问对象状态的策略。</li>
</ul>
<blockquote>
<p>如果对象的域都是基本类型(primitive)的，那么这些域就组成了对象的完整状态。如果一个对象的域引用了其他对象，那么他的状态也同时包含了被引用对象的域。LinkedList 的状态包括了所有存储在链表中的节点对象的状态。</p>
</blockquote>
<p>同步策略（synchronization policy）</p>
<blockquote>
<p>定义了对象如何协调对其状态的访问，并且不会违反他的不变约束或后验条件。它规定了如何把不可变性、线程限制和锁结合起来，从而维护线程的安全性，还指明了哪些锁保护哪些变量。为了保证开发者于维护者可以分析并维护类，应该将类的同步策略写入文档。</p>
</blockquote>
<h2 id="4-2-实例限制"><a href="#4-2-实例限制" class="headerlink" title="4.2 实例限制"></a>4.2 实例限制</h2><blockquote>
<p>即使一个对象不是线程安全的，仍有许多技术可以让它安全的用于多线程程序。比如你可以确保它只被单一的线程访问（线程限制），也可以确保所有的访问都正确的被锁保护。</p>
</blockquote>
<blockquote>
<p>将数据封装走对象内部，把对数据的访问限制在对象的方法上，更易确保线程在访问数据时总能获得正确的锁。</p>
</blockquote>
<blockquote>
<p>限制性使构造线程安全的类变得更容易，因为类的状态被限制后，分析它的线程安全时，就不必检查完整的程序。</p>
</blockquote>
<h3 id="Java-监视器模式"><a href="#Java-监视器模式" class="headerlink" title="Java 监视器模式"></a>Java 监视器模式</h3><blockquote>
<p>线程限制原则的直接推论之一是 Java 监视器（Java monitor pattern）。遵循 Java 监视器模式的对象封装了所有的可变状态，并由对象自己的内部锁保护。</p>
</blockquote>
<p>私有锁保护状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrivateLock</span></span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();<br>    Widget widget;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">someMethod</span><span class="hljs-params">()</span></span>&#123;<br>    	<span class="hljs-keyword">synchronized</span>(lock)&#123;<br>        	<span class="hljs-comment">//访问或修改Widget的状态</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>使用私有锁对象，而不是对象的内部锁(或任何其他可公共访问的锁)，有很多好处。私有的锁对象可以封装锁，这样客户代码无法得到它。然而可公共访问的锁允许客户代码涉足它的同步策略一-正 确地或不正确地。客户不正确地得到另一一个对象的锁，会引起活跃度方面的问题。另外要验证程序是正确地使用着一个可公共访问的锁，需要检查完整的程序，而不是一个单独的类。</p>
</blockquote>
<h2 id="4-3-委托线程安全"><a href="#4-3-委托线程安全" class="headerlink" title="4.3 委托线程安全"></a>4.3 委托线程安全</h2><blockquote>
<p>可以将线程的安全委托于一些安全的类或者容器、如 JUC 下的一些并发类。</p>
</blockquote>
<p>非状态依赖变量</p>
<blockquote>
<p>我们可以将线程安全委托到多个隐含的状态变量上，只要这些变量彼此独立的，这意味组合对象并未增加任何涉及多个状态变量的不变约束。</p>
</blockquote>
<p>当委托无法胜任时</p>
<blockquote>
<p>如果一个类由多个彼此独立的线程安全的状态变量组成，并且类的操作不包含任何无效状态转换时，可以将线程安全委托给这些状态变量。</p>
</blockquote>
<h2 id="4-4-向已有的线程安全类添加功能"><a href="#4-4-向已有的线程安全类添加功能" class="headerlink" title="4.4 向已有的线程安全类添加功能"></a>4.4 向已有的线程安全类添加功能</h2><ul>
<li>客户端加锁<blockquote>
<p>对于一个由 Collections.synchronizedList 封装的 ArrayList，向原始类中加入方法或者拓展类都不正确，因为客户代码不知道同步封装工厂方法返回 List 对象的类型。第三个策略是拓展功能，而不是拓展类本身，并将拓展代码置入一个“助手（helper）”类。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListHelper</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br>	<span class="hljs-keyword">public</span> List&lt;E&gt; list = Collections.synchronizedList(<span class="hljs-keyword">new</span> ArrayList&lt;E&gt;());<br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">putIfAbsent</span><span class="hljs-params">(E x)</span></span>&#123;<br>    	<span class="hljs-keyword">synchronized</span>(list)&#123;<br>        	<span class="hljs-keyword">boolean</span> absent = !list.contains(x);<br>            <span class="hljs-keyword">if</span>(absent)list.add(x);<br>            <span class="hljs-keyword">return</span> absent;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-5-同步策略的文档化"><a href="#4-5-同步策略的文档化" class="headerlink" title="4.5 同步策略的文档化"></a>4.5 同步策略的文档化</h2><blockquote>
<p>为类的用户编写类线程安全性担保的文档；为类的维护编写类的同步策略文档。</p>
</blockquote>
<h1 id="第-5-章构建块"><a href="#第-5-章构建块" class="headerlink" title="第 5 章构建块"></a>第 5 章构建块</h1><h2 id="5-1-同步容器"><a href="#5-1-同步容器" class="headerlink" title="5.1 同步容器"></a>5.1 同步容器</h2><ul>
<li>Vector</li>
<li>Hashtable</li>
<li>Collections.synchronizedXxx 工厂方法创建的容器</li>
</ul>
<h2 id="5-2-并发容器"><a href="#5-2-并发容器" class="headerlink" title="5.2 并发容器"></a>5.2 并发容器</h2><blockquote>
<p>用并发容器替换同步容器，这种做法以很小的风险带来了可拓展性显著的提高。</p>
</blockquote>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><blockquote>
<p>  同步容器类在每个操作的执行期间都持有一个锁。有-些操作，比如 HashMap.get 或者 List.contains,可能会涉及到比预想更多的工作量:为寻找一个特定对象而遍访整个哈希容器或清单，必须调用大量候选对象 equals(equals 本身还涉及相当数量的计算)。在一个哈希容器中，如果 hashCode 没有能很好地分散哈希值，元素很可能不均衡地分布到整个容器中:最极端的情况是，一个不良的哈希函数将会把一个哈希表转化为一个线性链表。遍历一个很长的清单并调用其中部分或者全部元素的 equals 方法，这会花费很长时间，并且在这段时间内，其他线程都不能访问这个容器。</p>
</blockquote>
<p>ConcurrentHashMap 和 HashMap 一样是个哈希表，但是它使用了完全不同的锁策略，可以提供更好的并非性和可伸缩性。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2630542/1622704572912-e4889304-4f3f-45f8-a2d5-bef48f645909.png#averageHue=%232f2e2d&clientId=u597c5ab6-e523-4&errorMessage=unknown%20error&from=paste&height=285&id=u41257d8d&name=image.png&originHeight=285&originWidth=599&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=13262&status=error&style=none&taskId=u35d25790-d915-4eea-9777-b6d01706e67&title=&width=599" srcset="/img/loading.gif" lazyload alt="image.png"><br>总体设计</p>
<blockquote>
<p>ConcurrentHashMap 的设计主要是对 HashMap 进行</p>
</blockquote>
<p>插入元素分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//插入数据</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;<br>    <span class="hljs-comment">//键值非空</span><br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span> || value == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>        <span class="hljs-keyword">int</span> hash = spread(key.hashCode());<br>        <span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>            Node&lt;K,V&gt; f; <span class="hljs-keyword">int</span> n, i, fh;<br>            <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>                tab = initTable();<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-keyword">null</span>,<br>                             <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="hljs-keyword">null</span>)))<br>                    <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>                tab = helpTransfer(tab, f);<br>            <span class="hljs-keyword">else</span> &#123;<br>                V oldVal = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                    <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                        <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                            binCount = <span class="hljs-number">1</span>;<br>                            <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>                                K ek;<br>                                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                                    ((ek = e.key) == key ||<br>                                     (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;<br>                                    oldVal = e.val;<br>                                    <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                        e.val = value;<br>                                    <span class="hljs-keyword">break</span>;<br>                                &#125;<br>                                Node&lt;K,V&gt; pred = e;<br>                                <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-keyword">null</span>) &#123;<br>                                    pred.next = <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key,<br>                                                              value, <span class="hljs-keyword">null</span>);<br>                                    <span class="hljs-keyword">break</span>;<br>                                &#125;<br>                            &#125;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                            Node&lt;K,V&gt; p;<br>                            binCount = <span class="hljs-number">2</span>;<br>                            <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,<br>                                                           value)) != <span class="hljs-keyword">null</span>) &#123;<br>                                oldVal = p.val;<br>                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                    p.val = value;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)<br>                        treeifyBin(tab, i);<br>                    <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-keyword">null</span>)<br>                        <span class="hljs-keyword">return</span> oldVal;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        addCount(<span class="hljs-number">1L</span>, binCount);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><blockquote>
<p>CopyOnWriterrayList 是同步 List 的一个并发替代品，通常情况下它提供了更好的并发性，并避免了在迭代期间对容器加锁和复制。( 相似地，CopyOnWriteArraySet 是同步 set 的一个并发替代品。)</p>
</blockquote>
<p>“写入时复制(copy-on-write) ”容器的线程安全性来源于这样一个事实，只要有效的不可变对象被正确发布，那么访问它将不再需要更多的同步。<strong>在每次需要修改时，它们会创建并重新发布一个新的容器拷贝,以此来实现可变性</strong>。“写入时复制(copy-on-write)”容器的迭代器保留一个底层基础数组(the backing aray)的引用。这个数组作为迭代器的起点。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2630542/1623549080301-33b5e431-9870-4741-bd85-0c89e0647569.png#averageHue=%23514c42&clientId=uffaf0c43-6ae9-4&errorMessage=unknown%20error&from=ui&id=uc1e5b8f6&name=QQ%E5%9B%BE%E7%89%8720210613095054.png&originHeight=498&originWidth=830&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=86230&status=error&style=none&taskId=ub88782ed-6455-42ec-944f-5d8afb4d962&title=" srcset="/img/loading.gif" lazyload alt="QQ图片20210613095054.png"></p>
<h2 id="5-3-阻塞队列和生产者-消费者模式"><a href="#5-3-阻塞队列和生产者-消费者模式" class="headerlink" title="5.3 阻塞队列和生产者-消费者模式"></a>5.3 阻塞队列和生产者-消费者模式</h2><p>阻塞队列提供可阻塞的 put 和 take 方法，他们与可定时的 offer 和 poll 是等价的。如果 Queue 已经满了，则 put 方法被阻塞到有用空间。如果 Queue 是空的那么 take 方法会被阻塞，直到有元素可用。Queue 的长度可以有限也可以无限，无线长度 Queue 永远不会满，put 方法永远不会阻塞。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2630542/1623550133491-8d46cdc3-b4cd-4284-8f21-f32c8f77150c.png#averageHue=%233d3b36&clientId=uffaf0c43-6ae9-4&errorMessage=unknown%20error&from=ui&id=u6a3248df&name=BlockingQueue.png&originHeight=1240&originWidth=482&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=84248&status=error&style=none&taskId=u00657c66-5ae2-43af-8bf0-af75ac00245&title=" srcset="/img/loading.gif" lazyload alt="BlockingQueue.png"><br>阻塞队列支持<strong>生产者－消费者设计模式</strong>。</p>
<p><img src="https://cdn.nlark.com/yuque/__puml/eeb9823f1ba3c6b577a17366909f3ae6.svg#lake_card_v2=eyJ0eXBlIjoibWVybWFpZCIsImNvZGUiOiJncmFwaCBMUjtcbueUn-S6p-iAhS0tPumYu-WhnumYn-WIly0tPua2iOi0ueiAhSIsInVybCI6Imh0dHBzOi8vY2RuLm5sYXJrLmNvbS95dXF1ZS9fX3B1bWwvZWViOTgyM2YxYmEzYzZiNTc3YTE3MzY2OTA5ZjNhZTYuc3ZnIiwiaWQiOiJQY2RwWSIsIm1hcmdpbiI6eyJ0b3AiOnRydWUsImJvdHRvbSI6dHJ1ZX0sImNhcmQiOiJkaWFncmFtIn0=" srcset="/img/loading.gif" lazyload>BlockingQueue 的实现是 SynchronousQueue，它根本上不是一个真正的队列，因为他不会为队列元素维护任何存储空间。不过他维护的是一个排队的线程清单，这些线程等待把元素加入（enqueue）队列或者移出（dequeue）队列。</p>
<h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p>Dequeue 是一个双端队列，允许高效的在头和尾分别进行插入和移除。实现有 ArrayDeque 和 LinkedBlockingDeque</p>
<h2 id="5-4-阻塞和可中断的方法"><a href="#5-4-阻塞和可中断的方法" class="headerlink" title="5.4 阻塞和可中断的方法"></a>5.4 阻塞和可中断的方法</h2><p>线程中断的原因</p>
<ul>
<li>等待 I/O 操作结束</li>
<li>等待获得一个锁</li>
<li>等待从 Thread.sleep 中唤醒</li>
<li>等待另一个线程线程的计算结果<blockquote>
<p>Thread 提供了 Interrupt 方法，用来中断一个线程，或者查询某线程是否已经被中断。</p>
</blockquote>
</li>
</ul>
<h2 id="5-5-Synchronizer"><a href="#5-5-Synchronizer" class="headerlink" title="5.5 Synchronizer"></a>5.5 Synchronizer</h2><p>阻塞队列在容器类中是独一无二的:它们不仅作为对象的容器，而且能够协调生产者线程和消费者线程之间的控制流，这是因为 take 和 put 会保持阻止状态直到队列进入了期望的状态(不空也不满)。</p>
<p>Synchronizer 是一个对象，它根据本身的状态调节线程的控制流。阻塞队列可以扮演一个 Synchronizer 的角色;其他类型的 Synchronizer 包括信号量( semaphore)、关卡( barrier)以及闭锁(latch)。在平台类库中存在一些 Synchronizer 类;如果这些不能满足你的需要，你同样可以创建-个你自己的 Synchronizer。</p>
<p>所有 Synchronizer 都享有类似的结构特性:它们封装状态，而这些状态决定着线程执行到在某-点时是通过还是被迫等待;它们还提供操控状态的方法，以及高效地等待 Synchronizer 进入到期望状态的方法。</p>
<h3 id="闭锁"><a href="#闭锁" class="headerlink" title="闭锁"></a>闭锁</h3><blockquote>
<p>闭锁(latch)是一-种 Synchronizer,它可以延迟线程的进度直到线程到达终止( terminal)状态[CPJ3.4.2] 。一个闭锁工作起来就像- -道大门:直到闭锁达到终点状态之前，门一直是关闭的，没有线程能够通过，在终点状态到来的时候，门开了，允许所有线程都通过。一但闭锁到达了终点状态，它就不能够再改变状态了，所以它会永远保持敞开状态。闭锁可以用来确保特定活动直到其他的活动完成后才发生，比如:</p>
</blockquote>
<ul>
<li>确保一个计算不会执行，直到它需要的资源被初始化。一个二元闭锁(两个状态)可以用来表达“资源 R 已经被初始化”，并且所有需要用到 R 的活动首先都要在闭锁中等待。</li>
<li>确保一个服务不会 开始，直到它依赖的其他服务都已经开始。每-个服务会包含一个相关的二元闭锁;开启服务 S 会首先开始等待闭锁 S 中所依赖的其他服务，在启动结束后，会释放闭锁 S,这样所有依赖 S 的服务也可以开始处理了。</li>
<li>等待，直到活动的所有部分都为继续处理作好充分准备，比如在多玩家的游戏中的所有玩家是否都准备就绪。这样的闭锁会在所有玩家准备就绪时，达到终点状态。</li>
</ul>
<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>CountDownLatch 是一个灵活的闭锁实现，用于， 上述各种情况;允许一个 或多个线程等待一个事件集的发生。闭锁的状态包括一个计数器，初始化为一个正数，用来表现需要等待的事件数。</p>
<p>countDown 方法对计数器做减操作，表示一个事件已经发生了，而 await 方法等待计数器达到零,此时所有需要等待的事件都已发生。如果计数器入口时值为非零,await 会一直阻塞直到计数器为零，或者等待线程中断以及超时。</p>
<h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><p>FutureTask 同样可以作为闭锁。FutureTask 的计算是通过 Callable 实现的，它等价于一个可携带结果的 Runnable,并且有 3 个状态:等待、运行和完成。完成包括所有计算以任意的方式结束，包括正常结束、取消和异常。一旦 FutureTask 进入完成状态，它会永远停止在这个状态上。Future.get 的行为依赖于任务的状态。如果它已经完成，get 可以立刻得到返回结果,否则会被阻塞直到任务转入完成状态，然后会返回结果或者抛出异常。FutureTask 把计算</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash">import java.util.concurrent.CountDownLatch;<br><br>public class CountDownLatchHarness &#123;<br><br>    public long timeTasks(int nThreads, final Runnable task) throws InterruptedException &#123;<br>        final CountDownLatch startGate = new CountDownLatch(1);<br>        final CountDownLatch endGate = new CountDownLatch(nThreads);<br>        <span class="hljs-keyword">for</span> (int i = 0; i &lt; nThreads; i++) &#123;<br>            Thread t = new <span class="hljs-function"><span class="hljs-title">Thread</span></span>() &#123;<br><br>                @Override<br>                public void <span class="hljs-function"><span class="hljs-title">run</span></span>() &#123;<br>                    try &#123;<br>                        startGate.await();<br>                        try &#123;<br>                            task.run();<br>                        &#125; finally &#123;<br>                            endGate.countDown();<br>                        &#125;<br>                    &#125; catch (InterruptedException e) &#123; &#125;<br>                &#125;<br>            &#125;;<br>            t.start();<br>        &#125;<br>        long start = System.nanoTime();<br>        startGate.countDown();<br>        endGate.await();<br>        long end = System.nanoTime();<br>        <span class="hljs-built_in">return</span> end-start;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Executor 框架利用 FutureTask 来完成异步任务，并可以用来进行任何潜在的耗时计算，而且可以在真正上需要计算结果之前就启动他们开始计算。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><blockquote>
<p>计数信号量用来控制能够访问某特定资源的活动的数量，或者同时执行某一给定操作的数量。计数信号量可以用来实现资源池或者给一个容器限定边界。</p>
</blockquote>
<p>一个 semaphore 管理-个有效的许可(permit)集;许可的初始量通过构造函数传递给 Semaphore.活动能够获得许可(只要还有剩余许可)，并在使用之后释放许可。如果已经没有可用的许可了，那么 acquire 会被阻塞,直到有可用的为止(或者直到被中断或者操作超时)。release 方法向信号量返回一个许可 4。计算信号量的一种退化形式是二元信号量:一个计数初始值为 1 的 Semaphore。二元信号量可用作互斥(mutex) 锁，它有不可重入锁的语意;谁拥有这个唯一的许可， 就拥有了互斥锁。.</p>
<h3 id="关卡"><a href="#关卡" class="headerlink" title="关卡"></a>关卡</h3><p>关卡(barrier )类似于闭锁,它们都能够阻塞一组线程， 直到某些事件发生。其中关卡与闭锁关键的不同在于，<strong>所有线程必须同时到达关卡点，才能继续处理。闭锁等待的是事件;关卡等待的是其他线程。</strong>关卡实现的协议，就像一些家庭成员指定商场中的集合地点:“我们每个人 6:00 在麦当劳见，到了以后不见不散，之后我们再决定接下来做什么。”</p>
<p>cyclicBarrier 允许一个给 定数量的成员多次集中在一个关卡点，这在并行迭代算法中非常有用，这个算法会把一个问题拆分成一系列相互独立的子问题。当线程到达关卡点时，调用 await, await 会被阻塞，直到所有线程都到达关卡点。如果所有线程都到达了关卡点，关卡就被成功地突破，这样所有线程都被释放，关卡会重置以备下一次使用。如果对 await 的调用超时，或者阻塞中的线程被中断，那么关卡就被认为是失败的，所有对 await 未完成的调用都通过 BrokenBarrierException 终止。如果成功地通过关卡, await 为每一个线程返回一个唯一的到<strong>达索引号</strong>，可以用它来“选举”产生一个领导，在下一次迭代中承担一些特殊工作.CyclicBarrier 也允许你向构造函数传递一个关卡行为 barrier action) ;这是一个 Runnable,当成功通过关卡的时候，会(在一个子任务线程中)执行，但是在阻塞线程被释放之前是不能执行的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">import</span> java.util.concurrent.Semaphore;<br><span class="hljs-comment">//使用信号量来约束容器</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BoundedHashSet</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;T&gt; set;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Semaphore sem;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BoundedHashSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> bound)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.set = Collections.synchronizedSet(<span class="hljs-keyword">new</span> HashSet&lt;&gt;());<br>        sem = <span class="hljs-keyword">new</span> Semaphore(bound);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> o</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> InterruptedException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(T o)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        sem.acquire();<br>        <span class="hljs-keyword">boolean</span> wasAdded = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            wasAdded = set.add(o);<br>            <span class="hljs-keyword">return</span> wasAdded;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (!wasAdded)&#123;<br>                sem.release();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> o</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span></span>&#123;<br>        <span class="hljs-keyword">boolean</span> wasRemoved = set.remove(o);<br>        <span class="hljs-keyword">if</span> (wasRemoved)&#123;<br>            sem.release();<br>        &#125;<br>        <span class="hljs-keyword">return</span> wasRemoved;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="5-6-为计算结果建立高效、可伸缩的高速缓存"><a href="#5-6-为计算结果建立高效、可伸缩的高速缓存" class="headerlink" title="5.6 为计算结果建立高效、可伸缩的高速缓存"></a>5.6 为计算结果建立高效、可伸缩的高速缓存</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2630542/1623682534957-efc02e83-44ab-40be-a776-79ba76636fe1.png#averageHue=%23f1f1f1&clientId=u709f50b1-7964-4&errorMessage=unknown%20error&from=paste&height=246&id=u97c57717&name=image.png&originHeight=246&originWidth=879&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=32437&status=error&style=none&taskId=u660e08bc-98d9-40c5-9520-69835b87420&title=&width=879" srcset="/img/loading.gif" lazyload alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/2630542/1623682952230-4f82820c-17ae-4550-bea3-72978afcae43.png#averageHue=%23ededed&clientId=u709f50b1-7964-4&errorMessage=unknown%20error&from=paste&height=236&id=u3fc1abfc&name=image.png&originHeight=236&originWidth=869&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=39103&status=error&style=none&taskId=u604ce2bd-cfcb-4af1-9a13-d745b05da03&title=&width=869" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="一些总结"><a href="#一些总结" class="headerlink" title="一些总结"></a>一些总结</h4><ul>
<li>可变状态，伙计们’!所有并发问题都归结为如何协调访问并发状态。可变状态越少，保证线程安全就越容易。</li>
<li>尽量将域声明为 final 类型，除非它们的需要是可变的。</li>
<li>不可变对象天生是线程安全的。不可变对象极大地减轻了并发编程的压力。它们简单而且安全，可以在没有锁或者防御性复制的情况下自由地共享。</li>
<li>封装使管理复杂度变得更可行。你固然可以用存储于全局变量的数据来写一个线程安全类。但是你为什么要这样做?在对象中装封数据，让它们能够更加容易地保持不变;在对象中封装同步，使它能够更容易地遵守同步策略。</li>
<li>用锁来守护每一个可变变量。</li>
<li>对同一不变约束中的所有变量都使用相同的锁。</li>
<li>在运行复合操作期间持有锁。</li>
<li>在非同步的多线程情况下，访问可变变量的程序是存在隐患的。</li>
<li>不要依赖于可以需要同步的小聪明。</li>
<li>在设计过程中就考虑线程安全。或者在文档中明确地说明它不是线程安全的。</li>
<li>文档化你的同步策略。</li>
</ul>
<h1 id="第-6-章-任务执行"><a href="#第-6-章-任务执行" class="headerlink" title="第 6 章 任务执行"></a>第 6 章 任务执行</h1><h2 id="6-1-在线程中执行任务"><a href="#6-1-在线程中执行任务" class="headerlink" title="6.1 在线程中执行任务"></a>6.1 在线程中执行任务</h2><p>1.单线程执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleThreadWebServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ServerSocket socket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">80</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>            Socket connection = socket.accept();<br>            handleRequest(connection);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>一个 web 请求的处理包括执行运算和 I/O 操作．对于一个单线程的服务器，阻塞不仅延迟了当前请求的完成，而且还完全阻止了需要被处理的等待请求．</p>
<p>顺序化处理几乎不能为服务器应用程序提供良好的吞吐量或快速的响应性。不过也有少数的特例—比如，当任务的数量很少但生命周期很长时，或者当服务器只服务于唯一的用户时，服务器在同一时间内只需同时处理一个请求一但是 大多数服务器应用程序都不是以这种方式工作的。</p>
<p>2.显示地为任务创建线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleThreadWebServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ServerSocket socket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">80</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-keyword">final</span> Socket connection = socket.accept();<br>            Runnable task = <span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    handleRequest(connection);<br>                &#125;<br>            &#125;;<br>            <span class="hljs-keyword">new</span> Thread(task).start();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>执行任务的负载已经脱离 了主线程，这让主循环能够更迅速地重新开始等待下一个连接。这使得程序可以在完成前面的请求之前接受新的请求，从而提高了响应性。</li>
<li>并行处理任务， 这使得多个请求可以同时得到服务。如果有多个处理器，或者出于 IO 未完成、锁请求以及资源可用性等任何因素需要阻塞任务时，程序的吞吐量会得到提高。</li>
<li>任务处理代码必须是线程安全的，因为有多个任务会并发地调用它。在中等强度的负载水平下，“ 每任务每线程(thread-per-task) ”方法是对顺序化执行的良好改进。只要请求的到达速度尚未超出服务器的请求处理能力，那么这种方法可以同时带来更快的响应性和更大的吞吐量。</li>
</ul>
<p>考虑因素:</p>
<ul>
<li>线程生命周期的开销</li>
<li>资源消耗量</li>
<li>稳定性<blockquote>
<p>顺序执行会产生糟糕的响应性和吞吐量，每个任务创建一个线程会给资源管理带来麻烦．</p>
</blockquote>
</li>
</ul>
<h2 id="6-2-Executor-框架"><a href="#6-2-Executor-框架" class="headerlink" title="6.2 Executor 框架"></a>6.2 Executor 框架</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Executor</span></span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable commond)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Executor 只是个简单的接口，但它却为一个灵活而且强大的框架创造了基础，这个框架可以用于异步任务执行，而且支持很多不同类型的任务执行策略。它还为任务提交和任务执行之间的解耦提供了标准的方法，为使用 Runnable 描述任务提供了通用的方式。Executor 的实现还提供了对生命周期的支持以及钩子函数，可以添加诸如统计收集、应用程序管理机制和监视器等扩展。</p>
<p>Executor 基于生产者-消费者模式</p>
<p>使用线程池的 Web Server</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskExecutionWebServer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> NTHREADS = <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Executor exec = Executors.newFixedThreadPool(NTHREADS);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ServerSocket socket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">80</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-keyword">final</span> Socket connection = socket.accept();<br>            Runnable task = <span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    handleRequest(connection);<br>                &#125;<br>            &#125;;<br>            exec.execute(task);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>为每一个任务启动一个新线程的 Executor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPerTaskExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Executor</span></span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable r)</span></span>&#123;<br>    	<span class="hljs-keyword">new</span> Thread(r).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行策略</p>
<blockquote>
<p>将任务的提交与任务的执行体进行解耦，它的价值在于让你可以简单地为-一个类给定的任务制定执行策略，并且保证后续的修改不至于太困难。一个执行策略指明了任务执行的“what, where, when, how”几个因素．</p>
</blockquote>
<p>线程池</p>
<blockquote>
<p>在线程池中执行任务线程，这种方法有很多“每任务每线程”无法比拟的优势。重用存在的线程，而不是创建新的线程，这可以在处理多请求时抵消线程创建、消亡产生的开销。另一项额外的好处就是，在请求到达时，工作者线程通常已经存在，用于创建线程的等待时间并不会延迟任务的执行，因此提高了响应性。通过适当地调整线程池的大小，你可以得到足够多的线程以保持处理器忙碌，同时可以还防止过多的线程相互竞争资源，导致应用程序耗尽内存或者失败。</p>
</blockquote>
<p>类库提供了一个灵活的线程池实现和一些有用的预设配置。你可以通过调用 Executors 中的某个静态工厂方法来创建一个线程池:</p>
<ul>
<li><strong>newFixedThreadpool</strong>创建一个定长的线程池，每当提交- -个任务就创建-一个线程，直到达到池的最大长度，这时线程池会保持长度不再变化(如果一个线程由于非预期的 Exception 而结束，线程池会补充一个新的线程)。</li>
<li><strong>newCachedThreadPool</strong>创建一个可缓存的线程池，如果当前线程池的长度超过了处理的需要时，它可以灵活地回收空闲的线程，当需求增加时，它可以灵活地添加新的线程，而并不会对池的长度作任何限制。</li>
<li><strong>newsingleThreadExecutor</strong>创建-一个 单线程化的 executor,它只创建唯-的工作者线程来执行任务，如果这个线程异常结束，会有另一个取代它。executor 会保证任务依照任务队列所规定的顺序(FIFO, LIFO, 优先级)执行。</li>
<li><strong>newscheduledThreadPool</strong>创建一个定长的线程池，而且支持定时的以及周期性的任务执行，类似于 Timer。</li>
</ul>
<h3 id="Executor-的生命周期"><a href="#Executor-的生命周期" class="headerlink" title="Executor 的生命周期"></a>Executor 的生命周期</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2630542/1623860858042-aa7ad62f-5bc8-4198-a87f-dffc222d7f3c.png#averageHue=%23504c41&clientId=u0c5e3077-ecd2-4&errorMessage=unknown%20error&from=paste&height=159&id=u9df7765b&name=image.png&originHeight=159&originWidth=576&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=15797&status=error&style=none&taskId=ua4be8ab8-07f6-4454-aad9-a9f676a9548&title=&width=576" srcset="/img/loading.gif" lazyload alt="image.png"><br>三种生命周期状态: 运行(running)，关闭(shutting down)，终止(terminated)</p>
<p>案例：支持关闭的 Web Server</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LifecyleWebServer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> NTHREADS = <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ExecutorService exec = Executors.newFixedThreadPool(NTHREADS);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ServerSocket socket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">80</span>);<br>        <span class="hljs-keyword">while</span> (!exec.isShutdown()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">final</span> Socket connection = socket.accept();<br>                Runnable task = () -&gt; handleRequest(connection);<br>                exec.execute(task);<br><br>            &#125;<span class="hljs-keyword">catch</span> (ReflectiveOperationException e)&#123;<br>                <span class="hljs-keyword">if</span> (!exec.isShutdown())&#123;<br>                    System.out.printf(<span class="hljs-string">&quot;task submission rejected&quot;</span>,e);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        exec.shutdown();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">(Socket connection)</span></span>&#123;<br>        Request request = readRequest(connection);<br>        <span class="hljs-keyword">if</span> (isShutdownRequest(request))&#123;<br>            stop();<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            dispachRequest(request);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="6-3-寻找可强化的并行性"><a href="#6-3-寻找可强化的并行性" class="headerlink" title="6.3 寻找可强化的并行性"></a>6.3 寻找可强化的并行性</h2><ul>
<li>顺序执行的页面渲染器</li>
<li>可携带结果的任务：Callable 和 Future</li>
<li>CompletionService 的页面渲染器</li>
<li>为任务设置时限</li>
</ul>
<blockquote>
<p>围绕任务的执行来构造应用程序，可以简化开发，便于同步。Executor 框架有助于你在任务的提交与任务的执行策略之间进行解耦，同时还支持很多不同类型的执行策略。你发现自己为执行任务而创建线程时，可以考虑使用 Executor 取代以前的方法。把应用程序分解为不同的任务，为了使这一行为产生最大的效益，你必须指明一个清晰的任务边界。在一些应用程序中，存在明显的工作良好的任务边界，然而还有一些程序，你需要作<br>进一步的分析，以揭示更多可加强的并行性。</p>
</blockquote>
<h1 id="第-7-章-取消和关闭"><a href="#第-7-章-取消和关闭" class="headerlink" title="第 7 章 取消和关闭"></a>第 7 章 取消和关闭</h1><p><strong>可取消的</strong>:当外部代码能够在活动自然完成之前，把他更改为完成状态，那么这个活动被称为可取消的．</p>
<p>用户请求的取消</p>
<blockquote>
<p>用户点击程序界面上的“cancel” 按钮，或者通过管理接口请求取消，比如 JMX(Java Management Extensions)。</p>
</blockquote>
<p>限时活动。</p>
<blockquote>
<p>一个应用程序，需要在有限的时间内搜索问题空间，并且在规定时间内选择最好的解决方案。如果计时器超时，正在搜索的任务会被取消。</p>
</blockquote>
<p>应用程序事件</p>
<blockquote>
<p>一个应用程序对问题空间进行分解搜索，使不同的任务搜索问题空间中不同的区域。当-一个任务发现了解决方案，所有其他仍在工作的搜索会被取消。</p>
</blockquote>
<p>错误</p>
<blockquote>
<p>一个 Web Crawler 搜索几个相关页面，并把页面或概要数据存储到硬盘。当 Crawler 的任务遭遇错误(比如，磁盘空间已满)，那么所有的搜索任务都会被取消，不过很可能会记录它们当前的状态，这样稍后可以重新启动。</p>
</blockquote>
<p>关闭</p>
<blockquote>
<p>当一个程序或者服务关闭时，必须对正在处理的和等待处理的工作进行一些操作。一个优雅的关闭，可能允许当前的任务完成;在一个更加紧迫的关闭中，当前的任务就可能被取消了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用volatle域保持取消状态</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrimeGenerator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;BigInteger&gt; primes = <span class="hljs-keyword">new</span> ArrayList&lt;BigInteger&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> cancelled;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>    	BigInteger p = Biginteger.ONE;<br>        <span class="hljs-keyword">while</span>(!cancelled)&#123;<br>        	p = p.nextProbablePrime();<br>            <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;<br>            	primes.add(p);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span></span>&#123;<br>    	cancelled = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> List&lt;BigInteger&gt; <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>    	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;BigInteger&gt;(primes);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//生成素数的程序运行一秒钟</span><br><span class="hljs-function">List&lt;BigInteger&gt; <span class="hljs-title">aSecondOfPrimes</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>	PrimeGenerator generator = <span class="hljs-keyword">new</span> PrimeGenerator();<br>    <span class="hljs-keyword">new</span> Thread(generator).start();<br>    <span class="hljs-keyword">try</span>&#123;<br>      SECONDS.sleep(<span class="hljs-number">1</span>);<br>    &#125;<span class="hljs-keyword">finally</span>&#123;<br>      generator.cancel();<br>    &#125;<br>    <span class="hljs-keyword">return</span> generator.get();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><blockquote>
<p>线程中断是一个协作机制，一个线程给另一个线程发送信号（signal）通知它在方便或者可能的情况下停止正在做的工作，去做其他事情．</p>
</blockquote>
<blockquote>
<p>调用 interrupt 并不意味着必然停止目标线程正在进行的工作，它仅仅传递了请求中断的消息．</p>
</blockquote>
<p>划重点</p>
<blockquote>
<p>我们对中断本身最好的理解应该是:它并不会真正中断一个正在运行的线程:它仅仅发出<strong>中断请求</strong>，线程自己会在下一个方便的时刻中断(这些时刻被称为取消点, eanelltion point)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.math.BigInteger;<br><span class="hljs-keyword">import</span> java.util.concurrent.BlockingQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrimeProducer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;BigInteger&gt; queue;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PrimeProducer</span><span class="hljs-params">(BlockingQueue&lt;BigInteger&gt; queue)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.queue = queue;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            BigInteger p = BigInteger.ONE;<br>            <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted())&#123;<br>                queue.put(p = p.nextProbablePrime());<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (InterruptedException consumed)&#123;<br>            <span class="hljs-comment">//允许线程退出</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span> </span>&#123;<br>        interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>中断策略</p>
<blockquote>
<p>因为每一个线程都有其自己的中断策略，所以你不应该中断线程，除非你知道中断对这个线程意味着什么。批评者嘲笑 Java 的中断工具，因为它没有提供优先中断的能力，而且还强迫开发者处理 InterruptedException。但是推迟中断请求的能力使开发者能够制定更灵活的中断策略，从而实现适合于程序的响应性和健壮性之间的平衡。</p>
</blockquote>
<p>只有实现了线程中断策略的代码才可以接收中断请求。通用目的的任务和库的代码绝不应该接收中断请求。</p>
<h3 id="处理不可中断阻塞"><a href="#处理不可中断阻塞" class="headerlink" title="处理不可中断阻塞"></a>处理不可中断阻塞</h3><p>很多可阻塞的库方法通过提前返回和抛出 Interrupt edException 来实现对中断的响应，这使得构建可以响应取消的任务更加容易了。但是，并不是所有的阻塞方法或阻塞机制都响应中断:如果一个线程是由于进行同步 SocketIO 或者等待获得内部锁而阻塞的，那么中断除了能够设置线程的中断状态以外，什么都不能改变。对于那些被不可中断的活动所阻塞的线程，我们可以使用与中断类似的手段，来确保可以停止这些线程。但是这需要我们更清楚地知道线程为什么会被阻塞。</p>
<p><strong>java. IO 中的同步 Socket I/O</strong>.在服务器应用程序中，阻塞 I/O 最常见的形式是读取和写入 Socket.不幸的是，InputStream 和 OutputStream 中的 read 和 write 方法都不响应中断，但是通过关闭底层的 Socket， 可以让 read 或 write 所阻塞的线程抛出一个 SocketException。</p>
<p><strong>java.nio 中的同步 I/O</strong>.中断一个等待 InterruptibleChannel 的线程，会导致抛出 ClosedBy InterruptException,并关闭链路( 也会导致其他线程在这条链路的阻塞，抛出 ClosedByInterruptException) 。关闭一个 Interrupt ibleChannel 导致多个阻塞在链路操作上的线程抛出 AsynchronousCloseExcept ion。<br>大多数标准 Channels 都实现 Inter ruptibl eChannel。</p>
<p><strong>selector 的异步 I/O</strong>。 如果一个线程阻塞于 Selector.select 方法(在 java. nio.channels 中)，close 方法会导致它通过抛出 ClosedselectorException 提前返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在Thread中，通过覆写interrupt来封装非标准取消</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReaderThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Socket socket;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> InputStream in;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReaderThread</span><span class="hljs-params">(Socket socket, InputStream in)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.socket = socket;<br>        <span class="hljs-keyword">this</span>.in = in;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interrupt</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            socket.close();<br>        &#125;<span class="hljs-keyword">catch</span> (IOException ignored)&#123;<br><br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">super</span>.interrupt();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">byte</span> buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[BUFSZ];<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>                <span class="hljs-keyword">int</span> count = in.read(buf);<br>                <span class="hljs-keyword">if</span>(count&lt;<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count&gt;<span class="hljs-number">0</span>)&#123;<br>                    processBuffer(buf,count);<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            <span class="hljs-comment">//允许线程退出</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="7-2-停止基于线程的服务"><a href="#7-2-停止基于线程的服务" class="headerlink" title="7.2 停止基于线程的服务"></a>7.2 停止基于线程的服务</h2><p>正如其他被封装的对象-样，线程的所有权是不可传递的:应用程序可能拥有服务，服务可能拥有工作者线程，但是应用程序并不拥有工作者线程，因此应用程序不应该试图直接停止工作者线程。相反，服务应该提供生命周期方法(iecycle methods)来关闭它自己，并关闭它所拥有的线程:那么当应用程序关闭这个服务时，服务就可以关闭所有的线程了。ExecutorService 提供了 shutdown 和 shutdownNow 方法，其他线程持有的服务<br>也应该都提供类似的关闭机制。</p>
<blockquote>
<p>对于线程持有的服务，只要服务的存在时间大于创建线程的方法存在的时间，那么就应该提供生命周期方法。</p>
</blockquote>
<h3 id="7-3-处理反常的线程终止"><a href="#7-3-处理反常的线程终止" class="headerlink" title="7.3 处理反常的线程终止"></a>7.3 处理反常的线程终止</h3><p>当一个单线程化的控制台程序因为未捕获的异常终止的时候，程序停止运行，并产生，了栈追踪，这与典型的程序输出有很大的不同一这是很明显的。并发程序中线程的失败往往就没有这么明显了。栈追踪可能会从控制台输出，但是没有人会去观察控制台，并且，当线程失败的时候，应用程序可能看起来仍在工作，所以它的失败可能就会被忽略。幸运的是，我们有方法可以监测和防止线程从程序中“泄漏”。</p>
<p>导致线程死亡的最主要原因是 Runt imeException。因为这些异常表明一个程序错误或者其他不可修复的错误，它们通常是不能被捕获的。它们不会顺着栈的调用传递，此时，默认的行为是在控制台打印栈追踪的信息，并终止线程。</p>
<p>线程非正常退出的后果包括良性的与恶性的，取决于线程在应用程序中的角色，但是程序能跑在 50 个线程的线程池上，通常也能够安全地跑在 49 个线程的线程池上。然而在 GUI 程序中，失去分派事件的线程会非常显著应用程序会停止处理事件，GUI 会被冻结。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//典型线程池的工作者线程的构建</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>    Throwable thrown = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span>&#123;<br>      <span class="hljs-keyword">while</span>(!isInterrupted())<br>          runTask(getTaskFormWorkQueue());<br>    &#125;<span class="hljs-keyword">catch</span>(Throwable e)&#123;<br>        thrown = e;<br>    &#125;<span class="hljs-keyword">finally</span>&#123;<br>        threadExited(<span class="hljs-keyword">this</span>,thrown);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>在一个长时间运行的应用程序中，所有的线程都要给未捕获异常设置一个处理器，这个处理器至少要将异常信息记入日志中。</p>
</blockquote>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h2 id="7-4-JVM-关闭"><a href="#7-4-JVM-关闭" class="headerlink" title="7.4 JVM 关闭"></a>7.4 JVM 关闭</h2><p>JVM 既可以通过正常手段关闭，也可以强行关闭。当最后-一个“正常(非精灵)”线程终结时，或者当有人调用了 system.exit 时，以及通过使用其他与平台相关手段时(比如发送了 SIGINT,或键入 ctr1-c)，都可以开始-一个正常的关闭。尽管 JVM 可以通过这些标准的首选方法关闭，它仍然能够通过调用 Runtime.halt 或者“杀死”JVM 的操作<br>系统进程被强行关闭(比如发送 SIGKILL)。</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>有时你想要创建一个线程，执行一些<strong>辅助工作</strong>， 但是你不希望这个线程的存在阻碍 JVM 的关闭。这时你需要用到精灵线程(daemon thread)。</p>
<p>线程被分为两种:普通线程和精灵线程。JVM 启动的时创建所有的线程,除了主线程以外，其他的都是精灵线程(比如垃圾回收器和其他类似线程)。当一个新的线程创建时，新线程继承了创建它的线程的后台状态，所以默认情况下，任何主线程创建的线程都是普通线程。</p>
<p>普通线程和精灵线程之间的差别仅仅在于退出时会发生什么。当一个线程退出时，JVM 会检查-一个运行中线程的详细清单， 如果仅剩下精灵线程，它会发起正常的退出。当 JVM 停止时，所有仍然存在的精灵线程都会被抛弃一不会执行 finally 块，也不会释放栈一 JVM 直接退出。</p>
<p>精灵线程应该小心使用一在任何时候， 几乎没有哪些活动的处理可以在不进行清理的情况下，被安全地抛弃。特别是执行 I/O 操作的任务运行在精灵线程中是很危险的。精灵线程最好用于“家务管理(housekeeping) ”的任务，比如一个背景线程可以从内存的缓存中周期性地移除过期的访问。</p>
<p>应用程序中，精灵线程不能替代对服务的生命周期恰当、良好的管理。</p>
<h3 id="Finalizer"><a href="#Finalizer" class="headerlink" title="Finalizer"></a>Finalizer</h3><p>当我们已经不再需要资源后，垃圾回收器重新获得内存资源是非常有益的，但是一些资源，比如文件或者 Socket 句柄，当我们不再需要时，必须显式地归还给操作系统。</p>
<p>为了在这方面提供帮助，垃圾回收器对那些具有特殊 finalize 方法的对象会进行特殊对待:<strong>在回收器获得它们后，finalize 被调用，这样就能保证持久化的资源可以被释放</strong>。<strong>因为 finalizer 可以运行在一个 JVM 管理的线程中，任何 finalizer 访问的状态都会被多个线程访问，因此必须被同步。finalizer 运行时不提供任何保证，并且拥有复杂的 finalizer 会带来对象巨大的性能开销</strong>。正确的书写 finalizer 也十分困难。在大多数情况下，<strong>使用 finally 块和显式 close 方法的结合来管理资源，会比使用 finalizer 起到更好的作用</strong>。当你需要管理对象，并且这个对象持有的资源是通过本地方法获得的，这时会产生独特的异常。鉴于这些原因，和其他些原因，应努力的避免编写或者使用包含 finalizer 的类(除非是在平台库的类中) 。</p>
<blockquote>
<p>避免使用 finalizer。</p>
</blockquote>
<h1 id="第-8-章应用线程池"><a href="#第-8-章应用线程池" class="headerlink" title="第 8 章应用线程池"></a>第 8 章应用线程池</h1><h2 id="8-1-任务与执行策略间的隐性耦合"><a href="#8-1-任务与执行策略间的隐性耦合" class="headerlink" title="8.1 任务与执行策略间的隐性耦合"></a>8.1 任务与执行策略间的隐性耦合</h2><p>并非所有的任务都适合所有的执行策略，有的类型的任务需要明确的指定一个执行策略，包括：</p>
<ul>
<li>依赖性任务．</li>
<li>采用线程限制的任务．</li>
<li>对响应时间敏感的任务．</li>
<li>使用 ThreadLocal 的任务．</li>
</ul>
<h3 id="线程饥饿死锁"><a href="#线程饥饿死锁" class="headerlink" title="线程饥饿死锁"></a>线程饥饿死锁</h3><blockquote>
<p>在线程池中如果一个任务依赖于其他任务的执行，就可能产生死锁．</p>
</blockquote>
<blockquote>
<p>无论何时，你提交了一个非独立的 Executor 任务，要明确出现线程饥饿死锁的可能性，并且，在代码或者配置文件以及其他可以配置 Executor 的地方，任何有关池的大小和配置约束都要写入文档。</p>
</blockquote>
<h3 id="耗时操作"><a href="#耗时操作" class="headerlink" title="耗时操作"></a>耗时操作</h3><p>如果任务由于过长的时间周期而阻塞，那么即使不可能出现死锁，线程池的响应性也会变得很差。耗时任务会造成线程池堵塞，还会拖长服务时间，即使小任务也不能幸免。</p>
<p>耗时操作的数目会期望线程有一个稳定的数量,如果线程池的大小相对于这个数字来说太小，那么最后可能所有的线程都会处于运行耗时任务的状态中，从而就会影响响应性。</p>
<p>有一项技术可以用来缓解耗时操作带来的影响，这就是限定任务等待资源的时间，而不要无限制地等下去。大多数平台类库中的阻塞方法，都同时有限时的和非限时两个版本，比如 Thread. join、BlockingQueue . put、CountDownLatch . await 和 Selector . select。</p>
<p>如果等待超时，你可以把任务标识为失败，中止它或者把它重新放回队列，准备之后执行。这样，无论每个任务的最终结果是成功还是失败，该办法都保证了任务总会向前发展，这样可以更快地将线程从任务中解放出来。如果线程池频频被阻塞的任务充满，这同样也可能是池太小的一个信号。</p>
<h2 id="8-2-定制线程池的大小"><a href="#8-2-定制线程池的大小" class="headerlink" title="8.2 定制线程池的大小"></a>8.2 定制线程池的大小</h2><p>定制线程池考虑的因素:</p>
<ul>
<li>计算环境</li>
<li>资源预算</li>
<li>任务特性</li>
<li>CPU 个数</li>
<li>内存大小</li>
<li>应用场景:计算型或 I/O 型</li>
</ul>
<p><strong>计算密集型</strong>：N 个处理器的系统通常通过使用一个<strong>N+1</strong>个线程的线程池来获取最优的利用率（计算密集型的线程恰好在某时因为发生一个页错误或因为其他原因暂停，刚好有一个＂额外＂的线程，可以确保在这种情况下 CPU 周期不会中断工作）</p>
<p><strong>I/O 型</strong>：对于包含 I/O 和其他阻塞操作的任务，不是所有的线程都会在所有的时间被调度，因此需要一个更大的池．</p>
<ul>
<li>N=CPU 的数量</li>
<li>U=目标 CPU 的使用率，０&lt;=U&lt;=1</li>
<li>W/C=等待时间与计算时间的比率</li>
</ul>
<p>为了保持处理器达到期望的使用率，最优的池的大小等于：<strong>T=N<em>U</em>(1+W/C)</strong>;</p>
<h2 id="8-3-配置-ThreadPoolExecutor"><a href="#8-3-配置-ThreadPoolExecutor" class="headerlink" title="8.3 配置 ThreadPoolExecutor"></a>8.3 配置 ThreadPoolExecutor</h2><p>ThreadPoolExecutor 为一些 Executor 提供了基本的实现，这些 Executor 是由 Executors 中的工厂 newCachedThreadPool、 newFixedThreadPool 和 newScheduledThreadExecutor 返回的。ThreadPoolExecutor 是一个灵活的、健壮的池实现，允许各种各样的用户定制。</p>
<p>如果默认的执行策略不能满足你的需要，你可以通过构造函数实例化一个 ThreadPoolExecutor,自己定制它直到你满意为止;你可以参考 Executors 的源代码是如何实现默认配置的执行策略的，然后以它们为起点开始你自己的实现。ThreadPoolExecutor 有很多个构造函数.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,//核心线程大小</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">int</span> maximumPoolSize,//最大线程大小</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">long</span> keepAliveTime,//当线程数大于核心时，这是多余的空闲线程在终止前等待新任务的最长时间</span></span><br><span class="hljs-params"><span class="hljs-function">                          TimeUnit unit,//时间单位</span></span><br><span class="hljs-params"><span class="hljs-function">                          BlockingQueue&lt;Runnable&gt; workQueue,//用于在执行任务之前保存任务的队列。该队列将仅保存由方法提交的任务。</span></span><br><span class="hljs-params"><span class="hljs-function">                          ThreadFactory threadFactory,//线程工厂</span></span><br><span class="hljs-params"><span class="hljs-function">                          RejectedExecutionHandler handler)</span> </span>&#123;<span class="hljs-comment">//拒绝策略</span><br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt; corePoolSize ||<br>        keepAliveTime &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-keyword">null</span> || threadFactory == <span class="hljs-keyword">null</span> || handler == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <span class="hljs-keyword">this</span>.acc = System.getSecurityManager() == <span class="hljs-keyword">null</span> ?<br>            <span class="hljs-keyword">null</span> :<br>            AccessController.getContext();<br>    <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;<br>    <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;<br>    <span class="hljs-keyword">this</span>.workQueue = workQueue;<br>    <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>    <span class="hljs-keyword">this</span>.threadFactory = threadFactory;<br>    <span class="hljs-keyword">this</span>.handler = handler;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="管理队列任务"><a href="#管理队列任务" class="headerlink" title="管理队列任务"></a>管理队列任务</h3><blockquote>
<p>有限线程池限制了可以并发执行的任务的数量(单线程化的 Executor 是一个值得注意的特例:它们保证没有并发执行的任务,通过线程限制,提供了获得线程安全的可能性)。</p>
</blockquote>
<ul>
<li>无限队列</li>
<li>有限队列</li>
<li>同步移交</li>
</ul>
<h3 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h3><ul>
<li><strong>AbortPolicy</strong>中止策略，直接抛出 RejectedExecutionException，调用者捕获这个异常然后编写自己处理代码</li>
<li><strong>CallerRunsPolicyd</strong>调用者运行，既不会丢弃哪个任务，也不会抛出任何异常．把一些任务退会调用者那里，减缓新任务流．</li>
<li><strong>DiscardPolicy</strong>遗弃默认放弃这个任务</li>
<li><strong>DiscardOldestPolicy</strong>遗弃旧的任务</li>
</ul>
<h3 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h3><p>无论何时，线程池需要创建一个线程， 都要通过一个线程工厂 (thread factory, 参见清单)来完成。默认的线程工厂创建一个新的、非后台(nondaemon) 的线程，并没有特殊的配置。详细指明一个线程工厂，能允许你定制池线程的配置信息。ThreadFactory 只有唯一的方法 newThread,它会在线程池需要创建一个新线程时调用。<br>有很多原因需要使用定制的线程工厂。你可能希望为池线程指明一个 Uncaught Except ionHandler,或者实例化一个定 制 Thread 类的实例，比如用来执行调试日志的线程。你也可能希望修改池线程的优先级(通常这不是一个非 常好的主意)或者后台状态(daemon status,同上)。或者你可能只是希望给池线程一个更有意义的名称，来简化对线程转储和错误日志的解释。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Executor;<br><span class="hljs-keyword">import</span> java.util.concurrent.RejectedExecutionException;<br><span class="hljs-keyword">import</span> java.util.concurrent.Semaphore;<br><span class="hljs-comment">//使用信号量来遏制任务的提交</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BoundedExecutor</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Executor exec;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Semaphore semaphore;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BoundedExecutor</span><span class="hljs-params">(Executor exec, Semaphore semaphore)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.exec = exec;<br>        <span class="hljs-keyword">this</span>.semaphore = semaphore;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">submitTask</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Runnable command)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        semaphore.acquire();<br>        <span class="hljs-keyword">try</span> &#123;<br>            exec.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        command.run();<br>                    &#125;<span class="hljs-keyword">finally</span> &#123;<br>                        semaphore.release();<br>                    &#125;<br>                &#125;<br>            &#125;);<br>        &#125;<span class="hljs-keyword">catch</span> (RejectedExecutionException e)&#123;<br>            semaphore.release();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="8-4-扩展-ThreadPoolExecutor"><a href="#8-4-扩展-ThreadPoolExecutor" class="headerlink" title="8.4 扩展 ThreadPoolExecutor"></a>8.4 扩展 ThreadPoolExecutor</h2><p>ThreadPool Executor 的设计是可扩展的，它提供了几个“钩子”让子类去覆写 beforeExecute、afterExecute 和 terminate 这些可以用来扩 展 ThreadPoolExecutor 行为。</p>
<p>执行任务的线程会调用钩子函数 beforeExecute 和 afterExecute,用它们添加日志、时序、监视器或统计信息收集的功能。无论任务是正常地从 run 中返回，还是抛出一个异常，afterExecute 都会被调用。(如果任务 完成后抛出一一个 Error,则 afterExecute 不会被调用。)如果 beforeExecute 抛出一个 Runt imeExcept ion,任务将不被执行,after Execute 也不会被调用。</p>
<p>terminatea 钩子会在线程池完成关闭动作后调用，也就是当所有任务都已完成并且所有工作者线程也已经关闭后，会执行 terminated. terminated 可以用来释放 Executor 在生命周期里分配到的资源，还可以发出通知、记录日志或者完成统计信息。</p>
<h2 id="8-5-并行递归算法"><a href="#8-5-并行递归算法" class="headerlink" title="8.5 并行递归算法"></a>8.5 并行递归算法</h2><p>对于并发执行的任务，Executor 框架是强大且灵活的。它提供了大量可调节的选项，比如创建和关闭线程的策略，处理队列任务的策略，处理过剩任务的策略，并且提供了几个钩子函数用于扩展它的行为。然而，和大多数强大的框架-样，草率地将-些设定组合在一起，并不能很好地工作;一些类型的任务需要特定的执行策略，而一些调节参数组合在一起后可能产生意外的结果。</p>
<h1 id="第-9-章-GUI-应用程序"><a href="#第-9-章-GUI-应用程序" class="headerlink" title="第 9 章 GUI 应用程序"></a>第 9 章 GUI 应用程序</h1><h2 id="9-1-为什么-GUI-是单线程化的"><a href="#9-1-为什么-GUI-是单线程化的" class="headerlink" title="9.1 为什么 GUI 是单线程化的"></a>9.1 为什么 GUI 是单线程化的</h2><p>早期的 GUI 应用程序就是单线程化的，GUI 事件在“主事件循环” 进行处理。现代的 GUI 框架使用了-一个略微不同的模型:模型创建了一个专门的线程,<strong>事件派发线程</strong>(event dispatch thread, EDT)来处理 GUI 事件。</p>
<p>单线程化的 GUI 框架并不仅仅存在于 Java 中; Qt、 NextStep、 MacOS Cocoa、 xWindows,等等都是单线程化的。也并不缺少反面的尝试;有很多试图写出多线程的 GUI 框架的努力，最终都由于竞争条件和死锁导致的稳定性问题，又回到了单线程化的事件队列模型的老路上来:<strong>采用一一个专门的线程从队列中抽取事件，并把它们转发给应用程序定义的事件处理器</strong>。(AWT 最初曾尝试在某种程度上支持多线程访问，单线程化地实现 Swing 的决定主要基于 AWT 中的经验和教训。)</p>
<blockquote>
<p>Swing 的单线程规则: Swing 的组件和模型只能在事件分派线程中被创建、修改和请求。</p>
</blockquote>
<h2 id="9-2-短期的-GUI-任务"><a href="#9-2-短期的-GUI-任务" class="headerlink" title="9.2 短期的 GUI 任务"></a>9.2 短期的 GUI 任务</h2><p>在 GUI 应用程序中,事件起源于事件线程,冒泡似的传递到达应用程序提供的监听器，监听器进而可能会执行一些影响表现模型 (presentation object) 的运算。为了简单起见，短期的任务可以把全部动作留在事件线程中完成;而对于耗时的任务，则应该将- -些工作负荷分压到另一个线程中。.</p>
<h2 id="9-3-耗时-GUI-任务"><a href="#9-3-耗时-GUI-任务" class="headerlink" title="9.3 耗时 GUI 任务"></a>9.3 耗时 GUI 任务</h2><p>如果所有的任务都是短期的(而且应用程序不存在重要的非 GUI 的部分) ,那么整个应用程序就可以在事件线程内部运行，你可以完全不必关心线程。但是，成熟的 GUI 应用程序可能会运行一些耗时的任务，以致于超过了用户预期的时间，比如拼写检查、后台编辑或者获取远程资源。这些任务必须在另外的线程中运行，而使 GUI 在它们运行中可以作出响应。</p>
<h2 id="9-4-共享数据模型"><a href="#9-4-共享数据模型" class="headerlink" title="9.4 共享数据模型"></a>9.4 共享数据模型</h2><p>Swing 的表现对象(包括 Tabl eModel、TreeModel 这些数据模型)是被限制在事件线程中的。在简单的 GUI 程序中，所有的可变对象都保存在表现对象中，事件线程之外唯一的线程就只有主线程。强制这些程序遵守单线程规则很容易:不要在主线程中访问数据模型或表现组件(presentation component)。更多的复杂程序可能要从持久化存储中移出或移入数据，比如文件系统、数据库，这就要使用其他线程，以免破坏了响应性。</p>
<h2 id="9-5-其他形式的单线程子系统"><a href="#9-5-其他形式的单线程子系统" class="headerlink" title="9.5 其他形式的单线程子系统"></a>9.5 其他形式的单线程子系统</h2><p>线程限制不仅仅限制在 GUI 系统:无论何时，它都可以用作实现单线程化子系统的便利工具。有时当程序员对避免同步与死锁束手无策的时候，使用线程限制成为了他们不得不使用的办法。比如，一些原生库(native librarie) 要求所有对库的访问，甚至 System. loadLibrary 加载库时，必须在同一个线程中运行。</p>
<p>借用 GUI 框架中的方法，你可以简单地为访问原生库创建一个专 门的线程或者一个单线程化的 Executor,然后提供一个代理对象拦截所有对线程限制对象的调用，把拦截的调用当作任务提交给前面创建的线程中。Future 和 newsingleThreadExecutor 的组合可以简化这项工作;代理方法调用 submit 提交任务，然后立即调用 Future .get 等待结果。(如果线程限制的类实现了一个的接口，你就可以自动完成每次方法向后台线程 Executor 提交 Callable 的过程，然后利用动态代理收集结果。) (译注: Java 中的动态代理功能只支持 interface。)</p>
<h1 id="第-10-章-避免活跃度危险"><a href="#第-10-章-避免活跃度危险" class="headerlink" title="第 10 章 避免活跃度危险"></a>第 10 章 避免活跃度危险</h1><h2 id="10-1-死锁"><a href="#10-1-死锁" class="headerlink" title="10.1 死锁"></a>10.1 死锁</h2><p>经典的“哲学家进餐”问题很好地阐示了死锁，尽管这有点影响食欲。5 个哲学家一起出门去吃中餐，他们围坐在一个圆桌边。他们有 5 只筷子(不是 5 双)，每两个人中间放有一只。哲学家边吃边思考，交替进行。每个人都需要获得两只筷子才能吃东西，但是吃后要把筷子放回原处继续思考。有一些管理筷子的算法，使每一个人都能够或多或少, 及时吃到东西(<strong>一个饥饿的哲学家试图获得两只邻近的筷子，但是如果其中的一只正在被别人占用，那么他应该放弃其中-一只可用的筷子，等待几分钟再尝试</strong>)。</p>
<p>但是这样做可能导致一些哲学家或者所有哲学家都“饿死”(每个人都迅速抓住自己左边的筷子，然后等待自己右边的筷子变为可用，同时并不放下左边的筷子)。这后一种情况，当每个人都拥有他人需要的资源，并且等待其他人正在占有的资源，如果大家一直占有资源，直到获得自己需要却没被占有的其他资源，那么就会产生死锁。</p>
<p><strong>当一个线程永远占有一个锁，而其他线程尝试去获得这个锁，那么它们将永远被阻塞。当线程 A 占有锁 L 时，想要获得锁 M,但是同时，线程 B 持有 M,并尝试获得 L，两个线程将永远等待下去。这种情况是死锁最简单的形式(或称致命的拥抱，deadly embrace)，</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//容易产生死锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeftRightDeadlock</span></span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object left = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object right = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leftRight</span><span class="hljs-params">()</span></span>&#123;<br>    	<span class="hljs-keyword">synchronized</span>(left)&#123;<br>           	<span class="hljs-keyword">synchronized</span>(right)&#123;<br>                doSomething();<br>        	&#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rightRight</span><span class="hljs-params">()</span></span>&#123;<br>    	<span class="hljs-keyword">synchronized</span>(right)&#123;<br>           	<span class="hljs-keyword">synchronized</span>(left)&#123;<br>                doSomething();<br>        	&#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2630542/1624024645467-fb3ab95c-500a-4f53-bd13-dc3bf803e499.png#averageHue=%23f0f0f0&clientId=u37af253a-5294-4&errorMessage=unknown%20error&from=paste&height=212&id=ua458657d&name=image.png&originHeight=212&originWidth=654&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=23761&status=error&style=none&taskId=u36314a38-8f41-4f9b-ae72-cf01096db73&title=&width=654" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//动态加锁顺序产生的死锁(如果两个线程同时调用该方法，一个X向y转账，一个y向x转账)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transferMoney</span><span class="hljs-params">(Account formAccount,Account toAccount,DollarAmount amount)</span> <span class="hljs-keyword">throws</span> InsufficientFundsException </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (formAccount)&#123;<br>            <span class="hljs-keyword">synchronized</span> (toAccount)&#123;<br>                <span class="hljs-keyword">if</span> (formAccount.getBalance().compareTo(amount)&lt;<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InsufficientFundsException();<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    formAccount.debit(amount);<br>                    toAccount.credit(amount);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2630542/1624027814843-606f6e83-c4ac-495d-8ae4-73824abcc891.png#averageHue=%23f5f5f5&clientId=u37af253a-5294-4&errorMessage=unknown%20error&from=paste&height=886&id=u30ddaed7&name=image.png&originHeight=886&originWidth=803&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=143553&status=error&style=none&taskId=ud5315662-4492-49c6-be6b-bc1f13e667e&title=&width=803" srcset="/img/loading.gif" lazyload alt="image.png"><br>如果 Account 具有一一个唯一-的， 不可变的，并具有可比性的 key,比如账号，那么制定锁的顺序就更加容易了:通过 key 来排定对象顺序,这样能省去“加时赛”锁的需要。</p>
<h3 id="协作对象间的死锁"><a href="#协作对象间的死锁" class="headerlink" title="协作对象间的死锁"></a>协作对象间的死锁</h3><p>在持有锁的时候调用外部方法是在挑战活跃度问题。外部方法可能会获得其他锁(产生死锁的风险)，或者遭遇严重超时的阻塞。当你持有锁的时候会延迟其他试图获得该锁的线程。</p>
<h3 id="开放调用"><a href="#开放调用" class="headerlink" title="开放调用"></a>开放调用</h3><blockquote>
<p>当调用的方法不需要持有锁时，这被称为开放调用（open call）在程序中尽量使用开放调用。依赖于开放调用的程序，相比于那些在持有锁的时候还调用外部方法的程序，更容易进行死锁自由度( deadlock-freedom)的分析。</p>
</blockquote>
<h3 id="资源死锁"><a href="#资源死锁" class="headerlink" title="资源死锁"></a>资源死锁</h3><blockquote>
<p>当线程间相互等待对方持有的锁，并且谁都不会释放自己的锁时就会发生死锁，当线程持有和等待的目标变为资源时，会发生与之相类似的死锁。</p>
</blockquote>
<h2 id="10-2-避免和诊断死锁"><a href="#10-2-避免和诊断死锁" class="headerlink" title="10.2 避免和诊断死锁"></a>10.2 避免和诊断死锁</h2><p>如果一个程序一次至多获得一个锁， 那么就不会产生锁顺序死锁。当然，这通常并不现实，但是如果你能够避免这个情况，就能够省去很多工作。如果你必须获得多个锁，那么锁的顺序必须是你设计工作的一部分:尽量减少潜在锁之间的交互数量,遵守并文档化该锁顺序协议，这些缺一不可。</p>
<p>在使用定义良好的锁的程序中，监测代码中死锁自由度的策略分为两个部分:首先识别什么地方会获取多个锁(使这个集合尽量小)，对这些示例进行全局的分析，确保它们锁的顺序在程序中保持一致。尽可能使用开放调用，这样做能够从根本上简化分析的难度。</p>
<p>在没有非开放调用的程序中，发现那些获得多重锁的实例是非常简单的，既可以通过复查代码，也可以通过对字节码或源代码自动地进行分析来完成。</p>
<ul>
<li>尝试定时的锁</li>
<li>通过线程转存储分析死锁<blockquote>
<p>预防死锁是你面临的最大问题，JVM 使用线程转储(thread dump)来帮助你识别死锁的发生。线程转储包括每个运行中线程的栈追踪信息，以及与之相似并随之发生的异常。线程转储也包括锁的信息，比如，哪个锁由哪个线程获得，其中获得这些锁的栈结构，以及阻塞线程正在等待的锁究竟是哪一个。</p>
</blockquote>
</li>
</ul>
<h2 id="10-3-其他的活跃度危险"><a href="#10-3-其他的活跃度危险" class="headerlink" title="10.3 其他的活跃度危险"></a>10.3 其他的活跃度危险</h2><h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><blockquote>
<p>当线程访问它所需要的资源时却被永久拒绝，以至于不能再继续进行，这样就发生了饥饿(starvation) ;</p>
</blockquote>
<p>最常见的引发饥饿的资源是 CPU 周期。在 Java 应用程序中，使用线程的优先级不当可能引起饥饿。在锁中执行无终止的构建也可能引起饥饿(无限循环，或者无尽等待资源)，因为其他需要这个锁的线程永远不可能得到它。</p>
<p><strong>抵制使用线程优先级的诱惑，因为这会增加平台依赖性，并且可能引起活跃度问题。大多数并发应用程序可以对所有线程使用相同的优先级。</strong></p>
<h3 id="弱响应性"><a href="#弱响应性" class="headerlink" title="弱响应性"></a>弱响应性</h3><p>不良的锁管理也可能引起弱响应性。如果一个线程长时间占有一个锁(可能正在对一个大容器进行迭代，并对每一个元素进行耗时的工作)，其他想要访问该容器的线程就必须等待很长时间。</p>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>活愤(livelock)是线程中活跃度失败的另一种形式，尽管没有被阻塞，线程却仍然不能继续，因为它<strong>不断重试</strong>相同的操作，却<strong>总是失败</strong>。<strong>活锁通常发生在消息处理应用程序中，如果消息处理失败的话，其中传递消息的底层架构会回退整个事务，并把它置回队首</strong>。如果消息处理程序对某种特定类型的消息处理存在 bug,每次处理都会失败，那么每一次这个消息都会被从队列中取出，传递到存在问题的处理器(handler)，然后发生事务回退。</p>
<p>因为这条消息又会到队首，处理器会不断被这样重复调用，并返回重复结果。这就是通常称为毒药信息(poison message)的问题。信息处理线程并没有发生阻塞，但是永远都不会前进了。这种形式的活锁通常来源于过渡的错误恢复代码，误将不可修复的错误当作是可修复的错误。</p>
<h1 id="第-11-章-性能和可伸缩性"><a href="#第-11-章-性能和可伸缩性" class="headerlink" title="第 11 章 性能和可伸缩性"></a>第 11 章 性能和可伸缩性</h1><h2 id="11-1-性能的思考"><a href="#11-1-性能的思考" class="headerlink" title="11.1 性能的思考"></a>11.1 性能的思考</h2><p>改进性能意味着用更少的资源做更多的事情。“资源” 的概念很广泛，对于给定的活动而言，一些特定的资源通常非常缺乏，无论是 CPU 周期、内存、网络带宽、I/O 带宽、数据库请求、磁盘空间、以及其他-些资源。当活动的运行因某个特定资源受阻时，我们称之为受限于该资源:受限于 CPU,受限于数据库。</p>
<p>引入多线程总会引入一些性能的开销：</p>
<ul>
<li>与协程相关的开销（加锁，信号，内存同步）</li>
<li>增加上下文切换</li>
<li>线程的创建和消亡</li>
<li>调度的开销</li>
</ul>
<p>应用程序可以从很多个角度来衡量;比如服务时间、等待时间、吞吐量、效率、可伸缩性、生产量。有一些标准(服务时间、等待时间)是用来衡量“有多快”，即给定的任务单元需要多长时间进行处理，得到回馈;另一-些(生产量、吞吐量)用来衡量“有多少”，即限定计算资源的情况下，究竟能够完成多少工作。</p>
<blockquote>
<p>可伸缩性指的是:当增加计算资源的时候(比如增加额外 CPU 数量、内存、存储器、I/O 带宽)，吞吐量和生产量能够相应地得以改进。</p>
</blockquote>
<h2 id="11-2-AmdahI-定律"><a href="#11-2-AmdahI-定律" class="headerlink" title="11.2 AmdahI 定律"></a>11.2 AmdahI 定律</h2><p>有些问题使用越多的资源就能越快地解决一越 多的工人参与收割庄稼，那么就能越快地完成收获。另-些任务根本就是串行化的一增加更 多的工人根本不可能提高收割速度。如果我们使用线程的重要原因之一是为了支配多处理器的能力，我们必须保证问题被恰当地进行了并行化的分解，并且我们的程序有效地使用了这种并行的潜能。</p>
<p>大多数并发程序都与农耕有着很多相似之处，由一系列并行和串行化的片断组成。Amdahl 定律描述了在一个系统中，基于可并行化和串行化的组件各自所占的比重，程序通过获得额外的计算资源，理论上能够加速多少。如果 F 是必须串行化执行的比重，那么 Amdahl 定律告诉我们，在一个 N 处理器的机器中，我们最多可以加速:</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2630542/1624031225964-dcb9ee00-6adb-4887-8c4e-06be1006c7f1.png#averageHue=%23f6f6f6&clientId=u37af253a-5294-4&errorMessage=unknown%20error&from=paste&height=94&id=uae2f00bd&name=image.png&originHeight=94&originWidth=264&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=4308&status=error&style=none&taskId=ufc186a04-25c3-47bf-8638-13e0f142a69&title=&width=264" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="11-3-线程引入的开销"><a href="#11-3-线程引入的开销" class="headerlink" title="11.3 线程引入的开销"></a>11.3 线程引入的开销</h2><ul>
<li>切换上下文</li>
<li>内存同步</li>
<li>阻塞，自旋等待</li>
</ul>
<h2 id="11-4-减少锁的竞争"><a href="#11-4-减少锁的竞争" class="headerlink" title="11.4 减少锁的竞争"></a>11.4 减少锁的竞争</h2><p>我们已经看到串行化会损害可伸缩性，上下文切换会损害性能。竞争性的锁会同时导致这两种损失，所以减少锁的竞争能够改进性能和可伸缩性。访问独占锁守护的资源是串行的一次只能有一个线程访问它。当然，我们有很好的理由使用锁，比如避免数据过期，但是这样的安全性是用很大的代价换来的。对锁长期的竞争会限制可伸缩性。</p>
<blockquote>
<p>并发程序中，对可伸缩性首要的威胁是独占的资源锁。</p>
</blockquote>
<p>有两个原因影响着锁的竞争性:锁被请求的频率，以及每次持有该锁的时间。如果这两者的乘积足够小，那么大多数请求锁的尝试都是非竞争的，这样竞争性的锁将不会成为可伸缩性巨大的阻碍。但是，如果这个锁的请求量很大，线程将会阻塞以等待锁:在极端的情况下，处理器将会闲置，即使仍有大量工作等着完成。</p>
<p><strong>有 3 种方式来减少锁的竞争:</strong></p>
<ul>
<li><p>减少持有锁的时间;</p>
</li>
<li><p>减少请求锁的频率;</p>
</li>
<li><p>或者用协调机制取代独占锁，从而允许更强的并发性。</p>
</li>
<li><p>缩小锁的范围（快进快出）</p>
</li>
<li><p>减少锁的粒度</p>
</li>
<li><p>分离锁</p>
</li>
<li><p>避免热点域</p>
</li>
<li><p>独占锁的替代方法</p>
</li>
<li><p>检测 CPU 利用率（不充足负载，I/O 限制，外部限制，锁竞争）</p>
</li>
<li><p>向对象池说不</p>
</li>
</ul>
<h2 id="11-5-示例-比较-Map-的性能"><a href="#11-5-示例-比较-Map-的性能" class="headerlink" title="11.5 示例:比较 Map 的性能"></a>11.5 示例:比较 Map 的性能</h2><p>单线程化的 ConcurrentHashMap 的性能要比同步的 HashMap 的性能稍好一些，而且在并发应用中，这种作用就十分明显了。ConcurrentHashMap 的实现，假定大多数常用的操作都是获取已存在的某个值，因此它的优化是针对 get 操作，提供最好的性能和并发性。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2630542/1624031730914-96e024d7-c68f-45da-9d5f-dc07754e1dfe.png#averageHue=%23f8f8f8&clientId=u37af253a-5294-4&errorMessage=unknown%20error&from=paste&height=367&id=u7079a055&name=image.png&originHeight=367&originWidth=781&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=33771&status=error&style=none&taskId=uafcf8c51-40ec-4b91-a386-f03c9a75f57&title=&width=781" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="11-6-减少上下文切换的开销"><a href="#11-6-减少上下文切换的开销" class="headerlink" title="11.6 减少上下文切换的开销"></a>11.6 减少上下文切换的开销</h2><p>很多任务引入的操作都会发生阻塞;在运行和阻塞这两个状态之间转换需要使用上下文切换。</p>
<p>因为使用线程最主要的目的是利用多处理器资源，在并发程序性能的讨论中，我们通常更多地关注吞吐量和可伸缩性，而没有强调自然服务时间。Amdahl 定律告诉我们，程序的可伸缩性是由必须连续执行的代码比例决定的。因为 Java 程序中串行化首要的来源是独占的资源锁，所以可伸缩性通常可以通过以下这些方式提升:减少用于获取锁的时间，减小锁的粒度，减少锁的占用时间，或者用非独占或非阻塞锁来取代独占锁。</p>
<h1 id="第-12-章测试并发程序"><a href="#第-12-章测试并发程序" class="headerlink" title="第 12 章测试并发程序"></a>第 12 章测试并发程序</h1><ul>
<li><strong>吞吐</strong>:在一个并发任务集里，已完成任务所占的比例:</li>
<li><strong>响应性</strong>:从请求到完成一些动作之间的延迟(也被称作等待时间) ;</li>
<li><strong>可伸缩性</strong>:增加更多的资源(通常是指 CPU)，就能提高(或者缓解短缺)吞吐量。</li>
</ul>
<h2 id="12-1-测试正确性"><a href="#12-1-测试正确性" class="headerlink" title="12.1 测试正确性"></a>12.1 测试正确性</h2><p>为并发类开发单元测试的流程，始于和顺序类相同的分析一-识别出不变约束和后验条件，这些都要接受例行检查。如果幸运的话，它们中的大部分都明确地写在了规约中:余下的时间里，编写测试不亚于一次反复探索规约的历险。</p>
<p>为并发类创建有效的安全测试，其挑战在于:如何在程序出现问题并导致某些属性极度可能失败时，简单地识别出这些受检查的属性来，同时不要人为地让查找错误的代码限制住程序的并发性。最好能做到在检查测试的属性时，不需要任何的同步。</p>
<p>测试应该在多处理器系统上运行，以提高潜在交替运行的多样性。但是，多个 CPU 未必会使测试更加高效。为了能够最大程度地检测到时序敏感的数据竞争的发生机会，应该让测试中的线程数多于 CPU 数，这样在任何给定的时间里，都有一些线程在运行，一些被交换出执行队列，这样可以增加线程间交替行为的随机性。</p>
<h2 id="12-2-测试性能"><a href="#12-2-测试性能" class="headerlink" title="12.2 测试性能"></a>12.2 测试性能</h2><p>性能测试的第二个目标是为那些基于经验的不同界限一线程数、缓存容量等等选择-一个合适的大小。这些数值可能会非常依赖于平台的特征(比如处理器类型甚至处理器的“stepping level (译注:表示处理器部件生产工艺的，它的版本会随着这一系列处理器生产工艺的改进而增加。)”，处理器的数量，或者内存大小，需要动态地配置，这相当于为它们选择一个合理的值，可以广泛地应用在各种系统中。</p>
<ul>
<li>加入时间特性</li>
<li>比较多种算法</li>
<li>测试响应性</li>
</ul>
<h2 id="12-3-避免性能测试的陷阱"><a href="#12-3-避免性能测试的陷阱" class="headerlink" title="12.3 避免性能测试的陷阱"></a>12.3 避免性能测试的陷阱</h2><ul>
<li>垃圾回收</li>
<li>动态编译</li>
<li>代码路径的非真实取样</li>
<li>不切实际的竞争程度</li>
<li>死代码的消除</li>
</ul>
<h2 id="12-4-测试方法补遗"><a href="#12-4-测试方法补遗" class="headerlink" title="12.4 测试方法补遗"></a>12.4 测试方法补遗</h2><p>测试的目标不是更多地发现错误，而是提高信心，相信代码能够如期地工作。因为设想发现所有 bug 是不现实的，所以质量审查(quality 　 assurance, QA)计划的目标应该定为利用现有的测试资源，最大程度上获得对代码的信心。并发程序会比顺序程序出更多的问题，所以想要获得同样级别的信心，还需要更多的测试。目前为止，我们已经关注了创建有效的单元测试与性能测试时使用的主要技术。在获得对并发类正确行为的信心时，测试如此重要，但并不是 QA 的唯方法。</p>
<ul>
<li>代码审查</li>
<li>静态分析工具</li>
</ul>
<h1 id="第-13-章显式锁"><a href="#第-13-章显式锁" class="headerlink" title="第 13 章显式锁"></a>第 13 章显式锁</h1><p>在 Java 5.0 之前，用于调节共享对象访问的机制只有 synchroni zed 和 volat ile.Java5.0 提供了新的选择: Reentrantlock。 与我们已经提到过的机制相反，ReentrantLock 并不是作为内部锁机制的替代，而是当内部锁被证明受到局限时,提供可选择的高级特性。</p>
<h2 id="13-1-Lock-和-ReentrantLock"><a href="#13-1-Lock-和-ReentrantLock" class="headerlink" title="13.1 Lock 和 ReentrantLock"></a>13.1 Lock 和 ReentrantLock</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2630542/1624064272232-9a919cac-c585-4c4d-a557-bd1448e5e331.png#averageHue=%233f3d37&clientId=u581f1ab9-5f03-4&errorMessage=unknown%20error&from=paste&height=246&id=ue802094f&name=image.png&originHeight=246&originWidth=332&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=10005&status=error&style=none&taskId=ube2a138b-f721-44c6-b973-922a8e2f975&title=&width=332" srcset="/img/loading.gif" lazyload alt="image.png"><br>Lock 接口，定义了一些抽象的锁操作。与内部加锁机制不同，Lock 提供了无条件的、可轮询的、定时的、可中断的锁获取操作，所有加锁和解锁的方法都是显式的。Lock 的实现必须提供具有与内部加锁相同的内存可见性的语义。但是加锁的语义，调度算法，顺序保证，性能特性这些可以不同。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2630542/1624064424453-fb25eb31-a2e5-4f26-9239-a01343457841.png#averageHue=%233b3935&clientId=u581f1ab9-5f03-4&errorMessage=unknown%20error&from=paste&height=762&id=uf9ed21c8&name=image.png&originHeight=762&originWidth=687&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=75523&status=error&style=none&taskId=ue5f71681-e4bd-456e-838f-62af059deb2&title=&width=687" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>ReentrantLock 实现了 Lock 接口，提供了与 synchroni zed 相同的互斥和内存可见性的保证。获得 ReentrantLock 的锁与进入 synchronized 块有着相同的内存语义，释放 ReentrantLock 锁与退出 synchronized 块有相同的内存语义。</p>
<p>为什么要创建与内部锁如此相似的机制呢?内部锁在大部分情况下都能很好地工作，但是有一些功能上的局限一不能 中断那些正在等待获取锁的线程，并且在请求锁失败的情况下，必须无限等待。内部锁必须在获取它们的代码块中被释放;这很好地简化了代码,与异常处理机制能够进行良好的互动，但是在某些情况下，一个更灵活的加锁机制提供了更好的活跃度和性能。</p>
<p>忘记使用 finally 释放 Lock 是一个定时炸弹。当“不幸”发生的时候，你将很难追踪到错误的发生点，因为根本没有记录锁本应被释放的位置和时间。这就是 ReentrantLock 不能完全替代 synchronized 的原因:<strong>它更加“危险”，因为当程序的控制权离开了守护的块时，不会自动清除锁</strong>。尽管记得在 finally 块中释放锁并不困难，但忘记的可能性仍然存在。</p>
<h3 id="可轮询的和可定时的请求"><a href="#可轮询的和可定时的请求" class="headerlink" title="可轮询的和可定时的请求"></a>可轮询的和可定时的请求</h3><p>可定时的与可轮询的锁获取模式，是由<strong>tryLock 方法</strong>实现，与无条件的锁获取相比，<strong>它具有更完善的错误恢复机制</strong>。在内部锁中，死锁是致命的一唯一的恢复方法是重新启动程序，唯一的预防方法是在构建程序时不要出错，所以不可能允许不一致的锁顺序。 可定时的与可轮询的锁提供了另一个选择:可以规避死锁的发生。</p>
<h3 id="可中断的锁获取操作"><a href="#可中断的锁获取操作" class="headerlink" title="可中断的锁获取操作"></a>可中断的锁获取操作</h3><p>正如定时锁的获得操作允许在限时活动内部使用独占锁，可中断的锁获取操作允许在可取消的活动中使用。当你正在响应中断的时候，lockInterruptibly 方法能够使你获得锁，并且由于它是内置于 Lock 的，你因此不必再创建其他种类不可中断的阻塞机制。</p>
<h3 id="非块结构的锁"><a href="#非块结构的锁" class="headerlink" title="非块结构的锁"></a>非块结构的锁</h3><p>在内部锁中，获取和释放这样成对的行为是块结构的一一总 是在其获得的相同的基本程序块中释放锁，而不考虑控制权是如何退出阻塞块的。自 动释放锁简化了程序的分析，并避免了潜在的代码错误造成的麻烦，但是有时需要更灵活的加锁规则。</p>
<h2 id="13-2-对性能的考量"><a href="#13-2-对性能的考量" class="headerlink" title="13.2 对性能的考量"></a>13.2 对性能的考量</h2><p>当 ReentrantLock 被加入到 Java 5.0 中时,它提供的竞争上的性能要远远优于内部锁。对于同步原语而言，竞态时的性能是可伸缩性的关键:如果有越多的资源花费在锁的管理和调度上，那用留给应用程序的就会越少。更好的实现锁的方法会使用更少的系统调用，发生更少的上下文切换，在共享的内存总线上发起更少的内存同步通信。耗时的操作会占用本应用于程序的资源。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2630542/1624065919405-cd361172-c19f-4419-a850-211a1cc20133.png#averageHue=%23fcfcfc&clientId=u581f1ab9-5f03-4&errorMessage=unknown%20error&from=paste&height=399&id=u70c1b1dd&name=image.png&originHeight=399&originWidth=834&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=55528&status=error&style=none&taskId=u02253e95-f8c4-41c5-a85b-eda9568764e&title=&width=834" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="13-3-公平性"><a href="#13-3-公平性" class="headerlink" title="13.3 公平性"></a>13.3 公平性</h2><p>ReentrantLock 构造函数提供了两种公平性的选择:创建非公平锁(默认)或者公平锁。线程按顺序请求获得公平锁，然而一-个非公平锁允许 “闯入”:当请求这样的锁时，如果锁的状态变为可用，线程的请求可以在等待线程的队列中向前跳跃，获得该锁。(Semaphore 同样提供了公平和非公平的获取顺序。)非公平的 ReentrantLock 并不是<br>有意鼓励“闯入”一倘若遇到闯入的发生， 它们不会有意避开。在公平锁中，如果锁已经被其他线程占有，新的请求线程会加入到等待队列，或者已经有一些线程在等待锁了 ;在非公平的锁中，线程只有当锁正在被占用时才会等待。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2630542/1624066051212-1400a23f-13ab-48b8-9af8-5a1431314478.png#averageHue=%23fafafa&clientId=u581f1ab9-5f03-4&errorMessage=unknown%20error&from=paste&height=402&id=u743585c3&name=image.png&originHeight=402&originWidth=734&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=28121&status=error&style=none&taskId=u4edc9d9b-1393-4087-a62f-1f79d7b1341&title=&width=734" srcset="/img/loading.gif" lazyload alt="image.png"><br>公平锁和非公平锁性能上的对比分析</p>
<blockquote>
<p>在多数情况下非公平锁的性能优势超过了公平锁的排队</p>
</blockquote>
<p><strong>在激烈竞争的情况下，闯入锁比公平锁性能好的原因之一是:挂起的线程重新开始，与它真正开始运行，两者之间会产生严重的延迟。我们假设线程 A 持有一个锁，线程 B 请求该锁。因为此时锁正在使用中，所以 B 会被挂起。当 A 释放锁后，B 重新开始。与此同时，如果 C 请求这个锁，那么 C 得到了很好的机会获得这个锁，使用它，并且甚至可能在 B 被唤醒前就已经释放该锁了。在这样的情况下，各方面都获得了成功: B 并没有比其他任何线程晚得到锁，C 更早地得到了锁，吞吐量得到了改进。</strong></p>
<blockquote>
<p>正如默认的 ReentrantLock 一样，内部锁没有提供确定的公平性保证，但是大多数锁实现统计上的公平性保证，在大多数条件下已经足够好了。Java 语言规范并没有要求 JVM 公平地实现内部锁，JVM 也的确没有这样做。ReentrantLock 并没有减少锁的公平性一它只不过使一 些存 在的部分更显性化了。</p>
</blockquote>
<h2 id="13-4-在-synchronized-和-ReentrantLock-之间进行选择"><a href="#13-4-在-synchronized-和-ReentrantLock-之间进行选择" class="headerlink" title="13.4 在 synchronized 和 ReentrantLock 之间进行选择"></a>13.4 在 synchronized 和 ReentrantLock 之间进行选择</h2><p>在内部锁不能够满足使用时，ReentrantLock 才被作为更高级的工具。当你需要以下高级特性时，才应该使用可定时的、可轮询的与可中断的锁获取操作，公平队列，或者非块结构的锁。否则，请使用 synchronized.</p>
<ul>
<li>内部锁与 ReentrantLock 相比其线程转存储能够显示哪个调用框架获得了锁</li>
</ul>
<h2 id="13-5-读-写锁"><a href="#13-5-读-写锁" class="headerlink" title="13.5 读-写锁"></a>13.5 读-写锁</h2><p>ReentrantLock 实现了标准的互斥锁: -次最多只有一个线程能够持有相同 ReentrantLock.但是互斥通常作为保护数据一致性的很强的加锁约束，因此过分地限制了并发性。互斥是保守的加锁策略，避免了“写/写”和“写/读”的重叠，但是同样避开了“读/读”的重叠。在很多情况下，数据结构是“频繁被读取”的一它们是可变的， 有的时候会被改变，但多数访问只进行读操作。此时，如果能够放宽，允许多个读者同时访问数据结构就非常好了。只要每个线程保证能够读到最新的数据，并且在读者读取数据的时候没有其他线程修改数据，就不会发生问题。这就是读写锁允许的情况:一个资源能够被多个读者访问，或者被-一个写者访问，两者不能同时进行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ReadWriteLock</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns the lock used for reading.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the lock used for reading</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Lock <span class="hljs-title">readLock</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns the lock used for writing.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the lock used for writing</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Lock <span class="hljs-title">writeLock</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>读-写锁实现的加锁策略允许多个同时存在的读者，但是只允许一个写者。与 Lock 一样，ReadWriteLock 允许多种实现，造成了性能、调度保证、获取优先、公平性、以及加锁语义等方面的不尽相同。</p>
<p><strong>读取和写入锁之间的互动可以有很多种实现。ReadWriteLock 的-些实现选择如下:</strong></p>
<ul>
<li><strong>释放优先</strong>。当写者释放写入锁，并且读者和写者都排在队列中，应该选择哪个读者，写者，还是先请求的那个呢?</li>
<li><strong>读者闯入</strong>。如果锁由读者获得，但是有写者正在等待，那么新到达的写者应该被授予读取的权力么?还是应该等待?允许读者闯入到写者之前提高了并发性，但是却带来了写.者饥饿的风险。</li>
<li><strong>重进入</strong>。读取锁和写入锁允许重入吗?</li>
<li><strong>降级</strong>。如果线程持有写入的锁，它能够在不释放该锁的情况下获得读取锁么?这可能会造成写者“降级”为一个读取锁，同时不允许其他写者修改这个被守护的资源。</li>
<li><strong>升级</strong>。读取锁能够优先于其他的读者和写者升级为一个写入锁么?大多数读-写锁的实现并不支持升级，因为在没有显式的升级操作的情况下，很容易造成死锁。( 如果两个读者同时试图升级到同一个写入锁，并都不释放读取锁。)</li>
</ul>
<blockquote>
<p>显式的 Lock 与内部锁相比提供了一些扩展的特性，包括处理不可用的锁时更好的灵活性，以及对队列行为更好的控制。但是 ReentrantLock 不能完全替代 synchronized;只有当你需要 synchroni zed 没能提供的特性时才应该使用。读写锁允许多个读者并发访问被守护的对象，当访问多为读取数据结构的时候，它具有改进可伸缩性的潜力。</p>
</blockquote>
<h1 id="第-14-章构建自定义的同步工具"><a href="#第-14-章构建自定义的同步工具" class="headerlink" title="第 14 章构建自定义的同步工具"></a>第 14 章构建自定义的同步工具</h1><h2 id="14-1-管理状态依赖性"><a href="#14-1-管理状态依赖性" class="headerlink" title="14.1 管理状态依赖性"></a>14.1 管理状态依赖性</h2><p>在单线程化的程序中,如果调用一个方法的时候，依赖于状态的先验条件尚未满足(比如“连接池非空”)，那么这个先验条件永远无法变为真了。因此，在顺序程序中，如果类的先验条件无法满足，就将它标为失败。但是在并发程序中，基于状态的条件会在其他线程的活动中被改变:一个池在几条指令以前还是空的，现在却可以变为非空，因为另外的线程会归还一个元素。对于并发对象，依赖于状态的方法有时可以在不能满足先验条件的情况下选择失败，不过更好的选择是等待先验条件变为真。</p>
<h2 id="14-2-使用条件队列"><a href="#14-2-使用条件队列" class="headerlink" title="14.2 使用条件队列"></a>14.2 使用条件队列</h2><p>条件队列让构建有效且可响应的状态依赖类变得容易，但是把它们用错也很容易;关于如何正确使用它们，存在着很多规则，编译器和平台却并没有强制要求它们。(这是要求你尽量将程序构建于像 LinkedBlockingQueue、Latch、 Semaphore 和 FutureTask 这些类之.上的原因之一; 如果你能避免使用条件队列，可以避免很多麻烦。)</p>
<p>当使用条件等待时( object .wait 或者 Condition. await ):</p>
<ul>
<li>永远设置一个条件谓词一一- 些对象状态的测试，线程执行前必须满足它;</li>
<li>永远在调用 wait 前测试条件谓词，并且从 wait 中返回后再次测试;</li>
<li>永远在循环中调用 wait;</li>
<li>确保构成条件谓词的状态变量被锁保护，而这个锁正是与条件队列相关联的;</li>
<li>当调用 wait、notify 或者 notifyAll 时，要持有与条件队列相关联的锁;并且，</li>
<li>在检查条件谓词之后、开始执行被保护的逻辑之前，不要释放锁。</li>
</ul>
<h2 id="14-3-显式的-Condition-对象"><a href="#14-3-显式的-Condition-对象" class="headerlink" title="14.3 显式的 Condition 对象"></a>14.3 显式的 Condition 对象</h2><p>一个 Condition 和一-个 单独的 Lock 相关联，就像条件队列和单独的内部锁相关联一样;调用与 Condition 相关联的 Lock 的 Lock.newCondition 方法，可以创建一个 Condition。如同 Lock 提供了比内部加锁要丰富得多的特征集一样，Condition 也提供了比内部条件队列要丰富得多的特征集:每个锁可以有多个等待集、可中断/不可中断的条<br>件等待、基于时限的等待以及公平/非公平队列之间的选择。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2630542/1624074708588-6d2b2148-f933-4050-8078-93a6c7145241.png#averageHue=%2346433b&clientId=u581f1ab9-5f03-4&errorMessage=unknown%20error&from=paste&height=233&id=u32daefce&name=image.png&originHeight=233&originWidth=299&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=11038&status=error&style=none&taskId=uf1c5ff90-8971-4199-a844-c4af1b5165b&title=&width=299" srcset="/img/loading.gif" lazyload alt="image.png"><br>Condition 因素出 Object 监视器方法（ <a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Object.html#wait--">wait</a> ， <a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Object.html#notify--">notify</a>和<a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Object.html#notifyAll--">notifyAll</a> ）成不同的对象，以得到具有多个等待集的每个对象，通过将它们与使用任意的组合的效果<a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/locks/Lock.html">Lock 个</a>实现。 Lock 替换 synchronized 方法和语句的使用， Condition 取代了对象监视器方法的使用。条件（也称为<em>条件队列</em>或<em>条件变量</em> ）为一个线程暂停执行（“等待”）提供了一种方法，直到另一个线程通知某些状态现在可能为真。 因为访问此共享状态信息发生在不同的线程中，所以它必须被保护，因此某种形式的锁与该条件相关联。 等待条件的关键属性是它<em>原子地</em>释放相关的锁并挂起当前线程，就像 Object.wait 。</p>
<p>一个 Condition 实例本质上绑定到一个锁。 要获得特定 Condition 实例的<a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/locks/Lock.html">Condition</a>实例，请使用其<a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/locks/Lock.html#newCondition--">newCondition()</a>方法。<br>例如，假设我们有一个有限的缓冲区，它支持 put 和 take 方法。 如果在一个空的缓冲区尝试一个 take ，则线程将阻塞直到一个项目可用; 如果 put 试图在一个完整的缓冲区，那么线程将阻塞，直到空间变得可用。 我们希望在单独的等待集中等待 put 线程和 take 线程，以便我们可以在缓冲区中的项目或空间可用的时候使用仅通知单个线程的优化。 这可以使用两个<a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/locks/Condition.html">Condition</a>实例来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BoundedBuffer</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>  <span class="hljs-keyword">final</span> Condition notFull  = lock.newCondition();<br>  <span class="hljs-keyword">final</span> Condition notEmpty = lock.newCondition();<br><br>  <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">100</span>];<br>  <span class="hljs-keyword">int</span> putptr, takeptr, count;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(Object x)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//如果满了则一直阻塞</span><br>      <span class="hljs-keyword">while</span> (count == items.length)<br>        notFull.await();<br>      items[putptr] = x;<br>      <span class="hljs-keyword">if</span> (++putptr == items.length) putptr = <span class="hljs-number">0</span>;<br>      ++count;<br>      notEmpty.signal();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      lock.unlock();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//如果空了则一直阻塞</span><br>      <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>        notEmpty.await();<br>      Object x = items[takeptr];<br>      <span class="hljs-keyword">if</span> (++takeptr == items.length) takeptr = <span class="hljs-number">0</span>;<br>      --count;<br>      notFull.signal();<br>      <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      lock.unlock();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>危险警告:wait.notify 和 noti fyAll 在 Condition 对象中的对等体是 await、signal 和 signalAll.但是，Condition 继承于 Object,这意味着它也有 wait 和 notify 方法。一定要确保使用了正确的版本 await 和 signal.</p>
</blockquote>
<p>在使用显式的 Condition 和内部条件队列之间作出选择，与你在 ReentrantLock 和 synchronized 之间进行选择是一样的: 如果你需要使用需要一些高级特性， 比如使用公平队列或者让每个锁对应多个等待集，这时使用 Condition 要好于使用内部条件队列。(如果你需要 ReentrantLock 的高级特性，并已经在使用它，那么你已经作出了选择。)</p>
<h2 id="14-4-剖析-Synchronizer"><a href="#14-4-剖析-Synchronizer" class="headerlink" title="14.4 剖析 Synchronizer"></a>14.4 剖析 Synchronizer</h2><p>ReentrantLock 和 Semaphore 这两个接口有很多共同点。这些类都扮演了“阀门”的角色，每次只允许有限数目的线程通过它;线程到达阀门后，可以允许通过(lock 或 acquire 成功返回)，可以等待(lock 或 acquire 阻塞)，也可以被取消(tryLock 或 tryAcquire 返回 false,指明在允许的时间内，锁或者“许可”不可用)。更进一步，它们都允许可中断的、不可中断的、可限时的请求尝试，它们也都允许选择公平、非公平的等待线程队列。给出了这个共同点后，你可能认为 Semaphore 是实现于 ReentrantLock 之上的，或者可能 ReentrantLock 是作为只有一个许可的 semamaphore 实现的。这是完全可以的;一个很常见的练习就是使用 lock 实现一个计数信号量，以及使用计数信号量实现一个 lock。</p>
<p>事实上，它们的实现都用到一个共同的基类，AbstractQueuedsynchronizer (AQS)一和其 他很多的 Synchronizer 一样 oAQS 是一个用来构建锁和 Synchronizer 的框架，令人惊讶的是，使用 AQS 能够简单且高效地构造出应用广泛的大量的 synchronizer.不仅 ReentrantLock 和 Semaphore 是构建于 AQS 上的，其他的还有 CountDownLatch、<br>ReentrantReadWr iteLock、SynchronousQueue 1 和 FutureTask。</p>
<h2 id="14-5-AbstractQueuedSynchronizer"><a href="#14-5-AbstractQueuedSynchronizer" class="headerlink" title="14.5 AbstractQueuedSynchronizer"></a>14.5 AbstractQueuedSynchronizer</h2><p>一个基于 AQS 的 Synchronizer 所执行的基本操作,是一些不同形式的获取( acquire)和释放(release) 。获取操作是状态依赖的操作，总能够阻塞。借助锁和信号量，“ 获取”的含义变得相当直观一获取 锁或者许可一并 且调用者可能不得不去等待，直到 Synchronizer 处于可发生的状态。Count DownLatch 的请求意味着“等待，直到闭锁到达它的终止态”，FutureTask 则意味着“等待，直到任务已经完成”。“释放” 不是一个可阻塞的操作;“释放” 可以允许线程在请求执行前阻塞。</p>
<p>为了让一个类具有状态依赖性,它必须拥有一些状态。同步类中有一些状态需要管理，这项任务落在了 AQS 上:<strong>它管理一个关于状态信息的单一整数，状态信息可以通过 protected 类型的 getstate、setstate 和 compareAndSetstate 等方法进行操作</strong>。这可以用于表现任何状态;例如，ReentrantLock 用它来表现拥有它的线程已经请求了多少次锁，Semaphore 用它来表现剩余的许可数，FutureTask 用它来表现任务的状态(尚未开始、运行、完成和取消)。Synchronizer 也可以自己管理- - 些额外的状态变量;例如，ReentrantLock 保存了当前锁的所有者的追踪信息，这样它就能区分出是重进入的(reentrant)还是竞争的(contended) 条件锁。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2630542/1624077028979-30341517-276c-4d5b-8e98-a1a05d77b01e.png#averageHue=%23f4f4f4&clientId=u581f1ab9-5f03-4&errorMessage=unknown%20error&from=paste&height=440&id=uebbdc2b0&name=image.png&originHeight=440&originWidth=807&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=76610&status=error&style=none&taskId=u13647bd4-9018-455f-af79-8346760bd7d&title=&width=807" srcset="/img/loading.gif" lazyload alt="image.png"><br>支持独占获取的 synchronizer 应该实现 tryAcquire 、tryRelease 和 isHeldExclusively 这几个受保护的方法，而支持共享获取的 Synchronizer 应该实现 tryAcquireShared 和 tryReleaseShared。 AQS 中的 acquire,、acqui reShared、release 和 releaseShared 这些方法，会调用在 Synchronizer 子类中这些方法的版本(tryAcquire、tryAcquireShared 等等),以此决定是否执行该操作。Synchronizer 的子类会根据其 acquire 和 release 的语意，使用 getstate、 setstate 以及 compareAndSetState 来检查并更新状态状态,然后通过返回的状态值告知基类这次“获取”或“释放”的尝试是否成功。举例来说，从 tryAcquireShared 返回一个负值，说明获取操作失败;返回零说明 Synchronizer 是被独占获取的;返回正值说明 synchronizer. 是被非独占获取的。对于 tryRelease 和 tryReleaseShared 方法来说，如果能够释放一些正在尝试获取 synchronizer 的线程，解除这些线程的阻塞，那么这两个方法将返回 true。</p>
<blockquote>
<p>为了简化锁的实现，以支持条件队列(就像 ReentrantLock)，AQS 还提供了一些机制，用于创建与 synchronizer 相关联的条件变量。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;<br><span class="hljs-comment">//二元闭锁使用AQS</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OneShotLatch</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync = <span class="hljs-keyword">new</span> Sync();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signal</span><span class="hljs-params">()</span></span>&#123;<br>        sync.releaseShared(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        sync.acquireSharedInterruptibly(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>            <span class="hljs-comment">//如果闭锁打开则成功 (state==1)否则失败</span><br>            <span class="hljs-keyword">return</span> (getState()==<span class="hljs-number">1</span>)?<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>            setState(<span class="hljs-number">1</span>);<span class="hljs-comment">//闭锁现在已经打开</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<span class="hljs-comment">//现在其他线程可以获得闭锁</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="14-6-java-til-concurrent-的-Synchronizer-类中的-AQS"><a href="#14-6-java-til-concurrent-的-Synchronizer-类中的-AQS" class="headerlink" title="14.6 java.til.concurrent 的 Synchronizer 类中的 AQS"></a>14.6 java.til.concurrent 的 Synchronizer 类中的 AQS</h2><ul>
<li>ReentrantLock</li>
<li>Semaphore</li>
<li>CountDownLatch</li>
<li>FutureTask</li>
<li>ReentrantReadWriteLock</li>
</ul>
<p><strong>如果你需要实现一个依赖于状态的类如果不能满足依赖于状态的前提条件，类的方法必须阻塞–最佳的策略通常是将它构建于现有的库类之上，比如 Semaphore、BlockingQueue 或者 CountDownLatch,例如 187 页的 ValueLatch 那样。但是，有时现有的库类不能提供足够的功能;在这种情况之下，你可以使用内部条件队列、显式 Condition 对象或者 Abst ractQueuedSynchronizer,来构建属于自己的 synchronizer.由于“管理状态的独立性”机制必须紧密依赖于“确保状态一致性” 机制，所以内部条件队列与内部锁紧密地绑定到了-起。类似地，显式的 Condition 是与显式的 Lock 也是紧密地绑定到- -起的，相比于内部条件队列，它还提供了一个可扩展的特征集，包括“多等待集每锁”，可中断或不可中断的条件等待，公平或非公平的队列，以及基于最终时限的等待。</strong></p>
<h1 id="第-15-章原子变量与非阻塞同步机制"><a href="#第-15-章原子变量与非阻塞同步机制" class="headerlink" title="第 15 章原子变量与非阻塞同步机制"></a>第 15 章原子变量与非阻塞同步机制</h1><h2 id="15-1-锁的劣势"><a href="#15-1-锁的劣势" class="headerlink" title="15.1 锁的劣势"></a>15.1 锁的劣势</h2><blockquote>
<p>当频繁地发生锁的竞争时，调度真正用于工作的开销间的比值很可观．</p>
</blockquote>
<p>volatile 变量与锁相比是更轻量的同步机制,因为它们不会引起上下文的切换和线程调度。然而，volatile 变量与锁相比有一些局限性:尽管它们提供了相似的可见性保证，但是它们不能用于构建原子化的复合操作。</p>
<p>加锁还有其他的缺点。当一一个线程正在等待锁时，它不能做任何其他事情。如果- -个线程在持有锁的情况下发生了延迟(原因包括页错误、调度延迟，或者类似情况)，那么其他所有需要该锁的线程都不能前进了。如果阻塞的线程是优先级很高的线程，持有锁的线程优先级较低，那么会造成严重问题一性能风险，被称为优先级倒置( priority 　 inversion)。即使更高的优先级占先，它仍然需要等待锁被释放，这导致它的优先级会降低至与优先级较低的线程的水平．</p>
<h2 id="15-2-硬件对并发的支持"><a href="#15-2-硬件对并发的支持" class="headerlink" title="15.2 硬件对并发的支持"></a>15.2 硬件对并发的支持</h2><p>独占锁是一项悲观的技术一它 假设最坏情况(如果你不锁门,捣蛋鬼就会闯入，并破坏物品的秩序)，并且会通过获得正确的锁来避免其他线程的打扰，直到作出保证才能继续进行。</p>
<p>对于细粒度的操作，有另外一种选择通常更加有效一乐观的解 决方法。凭借新的方法，我们可以指望不受打扰地完成更新。这个方法依赖于冲突监测，从而能判定更新过程中是否存在来自于其他成员的干涉，在冲突发生的情况下，操作失败，并会重试(也可能不重试)。这个乐观的方案就好比我们常说的:“宽恕 比准许更容易”，其中“更容易”意味着“更有效率”。</p>
<p>针对多处理器系统设计的处理器提供了特殊的指令，用来管理并发访问的共享数据。早期处理器具有原子化的测试并设量 r ( test-and-set)，获取并增加(fetch-and-increment)以及交换(swap)指令，这些对于实现互斥已经足够了，并能够用于实现更成熟的并发对象。如今，几乎所有现代的处理器都具有-些形式的原子化的读-改写指令，比如比较并交换(compare-and-swap)和加链搂/存储条件(load-linked/store conditional)操作系统和 JVM 使用这些指令来实现锁和并发的数据结构，但是直到 Java5.0 以前这些还不能直接为 Java 类所使用。</p>
<h2 id="15-3-原子变量类"><a href="#15-3-原子变量类" class="headerlink" title="15.3 原子变量类"></a>15.3 原子变量类</h2><blockquote>
<p>原子变量是更佳的 volatile</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2630542/1624078248698-7fb56362-d206-4972-b3de-dd3b9ec72873.png#averageHue=%23fafafa&clientId=u581f1ab9-5f03-4&errorMessage=unknown%20error&from=paste&height=404&id=u80031bc1&name=image.png&originHeight=404&originWidth=742&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=31030&status=error&style=none&taskId=uc04e43e2-29d7-4607-873f-a3ebf1cc10a&title=&width=742" srcset="/img/loading.gif" lazyload alt="image.png"><br>Lock 和 AtomicInteger 在激烈竞争下的性能比较<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2630542/1624078314773-8c82472e-8c37-40e7-a80b-da71537354bb.png#averageHue=%23f9f9f9&clientId=u581f1ab9-5f03-4&errorMessage=unknown%20error&from=paste&height=416&id=uab0afd30&name=image.png&originHeight=416&originWidth=735&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=31732&status=error&style=none&taskId=uf260ce57-b4dd-463f-b11b-a63311b94a6&title=&width=735" srcset="/img/loading.gif" lazyload alt="image.png"><br>Lock 和 AtomicInteger 在中等竞争下的性能比较</p>
<h2 id="15-4-非阻塞算法"><a href="#15-4-非阻塞算法" class="headerlink" title="15.4 非阻塞算法"></a>15.4 非阻塞算法</h2><p>基于锁的算法会带来-些活跃度失败的风险。如果线程在持有锁的时候因为阻塞 I/O,页面错误，或其他原因发生延迟，很可能所有线程都不能前进了。一个线程的失败或挂起不应该影响其他线程的失败或挂起，这样的算法被称为非阻塞(nonblocking)算法;如果算法的每一步骤中都有一-些线程 能够继续执行，那么这样的算法称为债自由(lock-free)算法。在线程间使用 CAS 进行协调，这样的算法如果能构建正确的话，它既是非阻塞的，又是锁自由的。非竞争的 CAS 总是能够成功，如果多个线程以一个 CAS 竞争，总会有一个胜出并前进。非阻塞算法对死锁和优先级倒置有“免疫性”(但它们可能会出现饥饿和活锁，因为它们允许重进入)。到目前为止，我们已经见到一个非阻塞算法:<strong>CasCounter</strong>.好的非阻塞算法已经在多种常见的数据结构上现身，包括栈、队列、优先级队列、哈希表．</p>
<h2 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h2><p>ABA 问题是因为在算法中误用比较并交换而引起的反常现象，节点被循环使用(主要存在于不能被垃圾回收的环境中)。CAS 有效地请求“V 的值仍为 A 么?”，并且如果成立就继续处理更新。在大多数情况下，包括这一章展示的例子，已经足够使用了。但是有时我们还想询问“V 在我上次观察过后发生了改变么?”在某些算法中，把 V 的值由 A 转换为 B，再转换为 A 仍然记为一次改变， 需要我们重新进行算法中的某些步骤。</p>
<p>算法中如果进行自身链接节点对象的内存管理，那么可能出现 ABA 问题。在这种情况下，即使列表的头仍然指向之前观察到的节点，这也不足以说明列表的内容没有发生改变。如果让垃圾回收器为你管理链表的节点，仍然不能避免 ABA 问题，还有-一个相对简单的解决方案:更新一对值，包括引用和版本号，而不是仅更新该值的引用。即使值由 A 改为 B，又再改回 A，版本号也是不同的。AtomicstampedReference (以及它的同系 AtomicMarkableReference)提供了一对变量原子化的条件更新 AtomicstampedReference 更新对象引用的整数对，允许“版本化”引用是能够避免 ABA 问题的。类似地，Atomi cMarkableReference :更新一个对象引用的布尔对，它能够用于一些算法，使节点在被标记为“deleted”后仍保留在列表中。</p>
<p><strong>非阻塞算法通过使用低层级并发原语，比如比较并交换，取代了锁。原子变量类向用户提供了这些低层级原语，也能够当作“更佳的 volatile 变量”使用，同时提供了整数类和对象引用的原子化更新操作。非阻塞算法在设计和实现中很困难，但是在典型条件下能够提供更好的可伸缩性，并能更好地预防活跃度失败。从 JVM 的一个版本到下一个版本间并发性能的提升很大程度上来源于非阻塞算法的使用，包括在 JVM 内部以及平台类库。</strong></p>
<h1 id="第-16-章-Java-存储模型"><a href="#第-16-章-Java-存储模型" class="headerlink" title="第 16 章 Java 存储模型"></a>第 16 章 Java 存储模型</h1><h2 id="16-1-什么是存储模型"><a href="#16-1-什么是存储模型" class="headerlink" title="16.1 什么是存储模型"></a>16.1 什么是存储模型</h2><h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2630542/1624078695322-12ce6f99-713d-4ed5-8347-5e78a9a06903.png#averageHue=%23f5f5f5&clientId=u581f1ab9-5f03-4&errorMessage=unknown%20error&from=paste&height=710&id=u9349f69f&name=image.png&originHeight=710&originWidth=757&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=93793&status=error&style=none&taskId=u71299997-a83b-4964-81f7-b0fdeb13f54&title=&width=757" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p><strong>happens-before 的法则包括:</strong></p>
<ul>
<li><strong>程序次序法则</strong>:线程中的每个动作 A 都 happens-before 于该线程中的每一个动作 B,其中，在程序中，所有的动作 B 都出现在动作 A 之后。</li>
<li><strong>监视器锁法则</strong>:对一个监视器锁的解锁 happens-before 于每一个后续对同一监视器锁的加锁。</li>
<li><strong>volatile 变量法则</strong>:对 volatile 域的写入操作 happens-before 于每一个后续对同一域的读操作”。</li>
<li><strong>线程启动法则</strong>:在一个线程里，对 Thread. start 的调用会 happens -before 于每一个启动线程中的动作。</li>
<li><strong>线程终结法则</strong>:线程中的任何动作都 happens before 于其他线程检测到这个线程已经终结、或者从 Thread.join 调用中成功返回，或者 Thread. isAlive 返回 false.</li>
<li><strong>中断法则</strong>:一个线程调用另一个线程的 interrupt happens-before 于被中断的线程发现中断(通过抛出 InterruptedException, 或者调用 isInterrupted 和 interrupted)。</li>
<li><strong>终结法则</strong>:一个对象的构造函数的结東 happens-before 于这个对象 finalizer 的开始。</li>
<li><strong>传递性</strong>:如果 A happens-before 于 B,且 B happens-before 于 C，则 Ahappens-before 于 C.</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2630542/1624078907630-1748f7e2-c92b-43ac-98bb-1ffa41cd3008.png#averageHue=%23f1f1f1&clientId=u581f1ab9-5f03-4&errorMessage=unknown%20error&from=paste&height=561&id=ubdacaef0&name=image.png&originHeight=561&originWidth=716&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=85779&status=error&style=none&taskId=u75324057-2dc2-4301-b36b-d330bc789e0&title=&width=716" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="16-2-发布"><a href="#16-2-发布" class="headerlink" title="16.2 发布"></a>16.2 发布</h2><p>在缺少 happens-before 关系的情况下，存在重排序的可能性。这就解释了为什么如果在没有充分同步的情况下就发布-个对象，会导致另外的线程看到一个部分创建对象。新对象的初始化涉及到写入变量一新对 象的域。类似地，引用的发布涉及到写入另一个变量一新对 象的引用。如果你不能保证布共享引用 happens-before 于另外的线程加载这个共享引用，那么写入新对象的引用与写入对象域(从消费该对象的线程的角度看)可以被重排序。在这种情况下，另一个线程可以看到对象引用的最新值，不过也看到一些或全部对象状态的过期值一个部分创建对象。</p>
<h3 id="双重锁检查-double-checked-locking"><a href="#双重锁检查-double-checked-locking" class="headerlink" title="双重锁检查(double checked locking)"></a>双重锁检查(double checked locking)</h3><p>DCL 声称是“鱼与熊掌可兼得”的最佳典范一-惰性 初始化在通常的代码路径下，不需要在同步上花费时间。它运作的方式是，首先检查在没有同步的情况下检查是否需要初始化，如果;resource 不等于 null,就用它。否则，就进行同步，并再次检查 Resource 是否需要同步，以保证只有唯一的线程真正地初始化了共享的 Resource。 通常的代码路径一获取一个已经构建的 Resource 的引用并没有用到同步。</p>
<h2 id="16-3-初始化安全性"><a href="#16-3-初始化安全性" class="headerlink" title="16.3 初始化安全性"></a>16.3 初始化安全性</h2><p>初始化安全可以保证，对于正确创建的对象，无论它是如何发布的，所有线程都将看到构造函数设置的 final 域的值。更进一步，一个正确创建的对象中，任何可以通过其 final 堿触及到的变量(比如一一个 final 数组中的元素,或者一个 final 域引用的 HashMap 里面的内容)，也可以保证对其他线程都是可见的“。</p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" class="category-chain-item">编程语言</a>
  
  
    <span>></span>
    
  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/" class="category-chain-item">Java</a>
  
  
    <span>></span>
    
  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/%E5%B9%B6%E5%8F%91%E7%9B%B8%E5%85%B3/" class="category-chain-item">并发相关</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%B9%B6%E5%8F%91/">#并发</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>读书笔记篇-Java并发编程实战</div>
      <div>https://mikeygithub.github.io/2021/05/19/yuque/读书笔记篇-Java并发编程实战/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Mikey</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2021年5月19日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/05/22/yuque/%E4%BA%91%E5%8E%9F%E7%94%9F%E7%AF%87-Kubernetes%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/" title="云原生篇-Kubernetes权威指南">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">云原生篇-Kubernetes权威指南</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/05/18/yuque/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E4%BA%8C/" title="读书笔记篇-Java核心技术卷二">
                        <span class="hidden-mobile">读书笔记篇-Java核心技术卷二</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'mikeygithub/commit-utterance');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  





  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.13.10/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});
  });
</script>




  <!-- Custom -->
  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" lazyload class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       Copyright © 麦奇 Powered by <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> and <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> core on github page 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      桂ICP备2020009931号-1
    </a>
  </span>
  
    
      <span>
        <a
          href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=2020009931"
          rel="nofollow noopener"
          class="beian-police"
          target="_blank"
        >
          
            <span style="visibility: hidden; width: 0">|</span>
            <img src="/img/police_beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
          
          <span>桂公网安备2020009931号</span>
        </a>
      </span>
    
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?74301a15e5497361e93588eeee69f4b2";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  

  

  

  

  

  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        MathJax = {
          tex    : {
            inlineMath: { '[+]': [['$', '$']] }
          },
          loader : {
            load: ['ui/lazy']
          },
          options: {
            renderActions: {
              findScript    : [10, doc => {
                document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                  const display = !!node.type.match(/; *mode=display/);
                  const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                  const text = document.createTextNode('');
                  node.parentNode.replaceChild(text, node);
                  math.start = { node: text, delim: '', n: 0 };
                  math.end = { node: text, delim: '', n: 0 };
                  doc.math.push(math);
                });
              }, '', false],
              insertedScript: [200, () => {
                document.querySelectorAll('mjx-container').forEach(node => {
                  let target = node.parentNode;
                  if (target.nodeName.toLowerCase() === 'li') {
                    target.parentNode.classList.add('has-jax');
                  }
                });
              }, '', false]
            }
          }
        };
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.0/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
