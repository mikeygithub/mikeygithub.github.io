---
title: 云原生篇-Spring Native
index_img: 'https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/spring-native.png'
hide: false
date: 2021-03-28 12:29:35
category: 云原生篇
tags: Spring Native
---

# 什么是云原生

>想要知道云原生(Cloud Native)那你得先知道什么是云，云一般指 的是一个提供资源的平台，云计算的本质是按需分配资源和弹性计算。目前云原生并没有确切的定义。我个人的理解为云原生是构建一套技术方法理论，适合云平台部署和运行而设计的应用。

[巨硬的定义](https://docs.microsoft.com/en-us/dotnet/architecture/cloud-native/definition)

>Cloud-native technologies empower organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds. Containers, service meshes, microservices, immutable infrastructure, and declarative APIs exemplify this approach.
 
>These techniques enable loosely coupled systems that are resilient, manageable, and observable. Combined with robust automation, they allow engineers to make high-impact changes frequently and predictably with minimal toil.

![云原生](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img//cloud-native-foundational-pillars.png)

# 云原生与十二要素

The following table highlights the Twelve-Factor methodology:

|      | Factor              | Explanation                                                  |
| :--- | :------------------ | :----------------------------------------------------------- |
| 1    | Code Base           | A single code base for each microservice, stored in its own repository. Tracked with version control, it can deploy to multiple environments (QA, Staging, Production). |
| 2    | Dependencies        | Each microservice isolates and packages its own dependencies, embracing changes without impacting the entire system. |
| 3    | Configurations      | Configuration information is moved out of the microservice and externalized through a configuration management tool outside of the code. The same deployment can propagate across environments with the correct configuration applied. |
| 4    | Backing Services    | Ancillary resources (data stores, caches, message brokers) should be exposed via an addressable URL. Doing so decouples the resource from the application, enabling it to be interchangeable. |
| 5    | Build, Release, Run | Each release must enforce a strict separation across the build, release, and run stages. Each should be tagged with a unique ID and support the ability to roll back. Modern CI/CD systems help fulfill this principle. |
| 6    | Processes           | Each microservice should execute in its own process, isolated from other running services. Externalize required state to a backing service such as a distributed cache or data store. |
| 7    | Port Binding        | Each microservice should be self-contained with its interfaces and functionality exposed on its own port. Doing so provides isolation from other microservices. |
| 8    | Concurrency         | Services scale out across a large number of small identical processes (copies) as opposed to scaling-up a single large instance on the most powerful machine available. |
| 9    | Disposability       | Service instances should be disposable, favoring fast startups to increase scalability opportunities and graceful shutdowns to leave the system in a correct state. Docker containers along with an orchestrator inherently satisfy this requirement. |
| 10   | Dev/Prod Parity     | Keep environments across the application lifecycle as similar as possible, avoiding costly shortcuts. Here, the adoption of containers can greatly contribute by promoting the same execution environment. |
| 11   | Logging             | Treat logs generated by microservices as event streams. Process them with an event aggregator and propagate the data to data-mining/log management tools like Azure Monitor or Splunk and eventually long-term archival. |
| 12   | Admin Processes     | Run administrative/management tasks as one-off processes. Tasks can include data cleanup and pulling analytics for a report. Tools executing these tasks should be invoked from the production environment, but separately from the application. |


In the book, [Beyond the Twelve-Factor App](https://content.pivotal.io/blog/beyond-the-twelve-factor-app), author Kevin Hoffman details each of the original 12 factors (written in 2011). Additionally, he discusses three additional factors that reflect today's modern cloud application design.
  
  |      | New Factor                    | Explanation                                                  |
  | :--- | :---------------------------- | :----------------------------------------------------------- |
  | 13   | API First                     | Make everything a service. Assume your code will be consumed by a front-end client, gateway, or another service. |
  | 14   | Telemetry                     | On a workstation, you have deep visibility into your application and its behavior. In the cloud, you don't. Make sure your design includes the collection of monitoring, domain-specific, and health/system data. |
  | 15   | Authentication/ Authorization | Implement identity from the start. Consider [RBAC (role-based access control)](https://docs.microsoft.com/en-us/azure/role-based-access-control/overview) features available in public clouds. |
  
  We'll refer to many of the 12+ factors in this chapter and throughout the book.

# Spring Native




# 参考资料

[Defining cloud native](https://docs.microsoft.com/en-us/dotnet/architecture/cloud-native/definition)

[Announcing Spring Native Beta!](https://spring.io/blog/2021/03/11/announcing-spring-native-beta)  

[译版](https://jishuin.proginn.com/p/763bfbd4d072)

[什么是云原生？这回终于有人讲明白了](https://zhuanlan.zhihu.com/p/150190166)

[架构新纪元（二）：什么是云原生？](https://www.infoq.cn/article/xpFP8uclTKJQhhFqDyjZ)


 