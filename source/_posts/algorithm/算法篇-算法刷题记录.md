---
title: 算法篇-刷题记录 
date: 2020-11-19 10:00:22 
index_img: https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/stjl.png
category: 算法学习
tags: 刷题记录
---

# 刷题前言

> 先复习一波[算法基础](https://mikeygithub.github.io/2020/11/14/algorithm/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/)、建议根据题目类型来刷、这样有利于熟悉其规律和提高速度

# 链表结构

>链表一般采用双指针

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof">反转链表(简单)</a></span></summary>
  <br>

解题思路
> 迭代: 双指针，pre,cur 完善

> 递归: 递归到尾节点，将其返回，设置下一个节点为

```java
class Solution {
    //迭代
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;//指向前一个节点
        ListNode curr = head;//当前节点
        while (curr != null) {
            ListNode nextTemp = curr.next;
            curr.next = prev;
            prev = curr;
            curr = nextTemp;
        }
        return prev;
    }

    //递归
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {//递归结束条件返回初始链表最后一个结点
            return head;
        }
        ListNode p = reverseList(head.next);//
        head.next.next = head;//
        head.next = null;//下一个结点
        return p;//始终返回初始链表最后一个结点
    }
}

```

</details>


<details>
    <summary><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/"><span>反转链表II(中等)</span></a>
    </summary>
    <br>

解题思路

> 第一步: 将所指区域进行翻转
> 第二步: 将翻转和未翻转的链表连接

代码实现

```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        // 设置 dummyNode 是这一类问题的一般做法
        ListNode dummyNode = new ListNode(-1);
        dummyNode.next = head;
        ListNode pre = dummyNode;
        //移动到指定位置
        for (int i = 0; i < left - 1; i++) {
            pre = pre.next;
        }
        ListNode cur = pre.next;
        ListNode next;
        //翻转
        for (int i = 0; i < right - left; i++) {
            //翻转
            next = cur.next;
            cur.next = next.next;
            //链接
            next.next = pre.next;
            pre.next = next;
        }
        return dummyNode.next;
    }
}
```

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/linked-list-cycle/">环形链表(简单)</a></span></summary>
  <br>

题目
> 给定一个链表，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 如果链表中存在环，则返回 true 。 否则，返回 false 。




解题思路
> 采用哈希表或者快慢指针两中方法


代码实现

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }
        ListNode slow = head;
        ListNode fast = head.next;
        while (slow != fast) {
            if (fast == null || fast.next == null) {
                return false;
            }
            slow = slow.next;
            fast = fast.next.next;
        }
        return true;
    }
}
```

</details>

<details>
    <summary><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/"><span>环形链表 II(中等)</span></a>
    </summary>
    <br>



解题思路


> 先判断是否存在环，再确定其入环节点，采用双指针迭代，步长分别为1和2，当有环时两者会重逢，确定入环节点`头节点到环入口的距离=环的长度`　　(注意这里的快指针开始结点和慢指针应用，和第一题不同)

[官方解题](https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/)

代码实现

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null) return null;//空值返回
        ListNode slow = head, fast = head;//俩个指针,slow步长1,fast步长2
        while (fast != null) {
            //移动
            slow = slow.next;
            if (fast.next != null) fast = fast.next.next;
            else return null;
            //指针重逢
            if (fast == slow) {//
                ListNode ptr = head;//
                while (ptr != slow) {//当fast和slow重逢时，头节点到环入口的距离=环的长度
                    ptr = ptr.next;
                    slow = slow.next;
                }
                return ptr;
            }
        }
        return null;
    }
}
```

</details>

<details>
    <summary><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/"><span>相交链表(简单)</span></a>
    </summary>
    <br>



解题思路


> 两条链表分别同时遍历，当到达链尾时`指向对方表头`再次重逢就是该节点

```text
A:1-2-3-4-5
B:7-8-9-3-4-5

  1-2
	 \
	  3-4-5
	 /
7-9-8

遍历
1-2-3-4-5-7-8-9-`3`
7-8-9-3-4-5-1-2-`3`
```

代码实现

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        /**
         * 定义两个指针, 第一轮让两个到达末尾的节点指向另一个链表的头部, 最后如果相遇则为交点(在第一轮移动中恰好抹除了长度差)
         * 两个指针等于移动了相同的距离, 有交点就返回, 无交点就是各走了两条指针的长度
         **/
        if (headA == null || headB == null) return null;
        ListNode pA = headA, pB = headB;
        // 在这里第一轮体现在pA和pB第一次到达尾部会移向另一链表的表头, 而第二轮体现在如果pA或pB相交就返回交点, 不相交最后就是null==null
        while (pA != pB) {
            pA = pA == null ? headB : pA.next;
            pB = pB == null ? headA : pB.next;
        }
        return pA;
    }
}
```

</details>


<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">K个一组翻转链表(困难)</a></span>
    </summary>


解题思路

![图示](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/k-reverse-link.png)

代码实现

````java
public ListNode reverseKGroup(ListNode head, int k) {
    //辅助指针,表头前一个指针
    ListNode dummy = new ListNode(0);
    //下一个结点指向链表表头
    dummy.next = head;
    //每一组的开头
    ListNode pre = dummy;
    //每一组的结尾
    ListNode end = dummy;

    while (end.next != null) {
        //移动尾部指针
        for (int i = 0; i < k && end != null; i++) end = end.next;
        //尾指针为空直接结束当前循环
        if (end == null) break;
        //开始翻转的指针
        ListNode start = pre.next;
        //下一组的表头
        ListNode next = end.next;
        //将本组末尾元素下一个指针置空
        end.next = null;
        //翻转并返回其表头
        pre.next = reverse(start);
        //链接下一组链表表头
        start.next = next;
        //指向下一组链表表头前一个(这组翻转后的末尾结点)
        pre = start;
        //重置end指针
        end = pre;
    }
    //返回表头
    return dummy.next;
}
//将链表进行翻转
private ListNode reverse(ListNode head) {
    ListNode pre = null;
    ListNode curr = head;
    while (curr != null) {
        ListNode next = curr.next;
        curr.next = pre;
        pre = curr;
        curr = next;
    }
    return pre;
}
````

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists">合并两个有序链表(简单)</a></span></summary>
  <br>

解题思路
> 递归或者迭代双指针

代码实现

```java
class Solution {
    /**
     * 递归
     * @param l1
     * @param l2
     * @return
     */
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) {
            return l2;
        } else if (l2 == null) {
            return l1;
        } else if (l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }

    }

    /**
     * 迭代
     * @param l1
     * @param l2
     * @return
     */
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {

        ListNode prehead = new ListNode(-1);//定义一个头指针
        ListNode prev = prehead;//前一个指针

        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                prev.next = l1;
                l1 = l1.next;
            } else {
                prev.next = l2;
                l2 = l2.next;
            }
            prev = prev.next;
        }

        // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
        prev.next = l1 == null ? l2 : l1;

        return prehead.next;
    }
}

```

</details>

<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/palindrome-linked-list">回文链表(简单)</a></span>
    </summary>



解题思路

> 1.数组双指针判断
>
>2.递归双指针判断

代码实现

````java
class Solution {
    ListNode prev = null;

    //递归
    public boolean isPalindrome(ListNode head) {
        prev = head;
        return helper(head);
    }

    public boolean helper(ListNode head) {
        if (head == null) return true;
        boolean res = helper(head.next);
        if (head.val != prev.val) return false;
        prev = prev.next;
        if (prev == head) return true;
        return res;
    }

    //双指针
    public boolean isPalindrome1(ListNode head) {
        if (head == null) return true;
        List<ListNode> arr = new ArrayList<>();
        while (head != null) {
            arr.add(head);
            head = head.next;
        }
        int i = 0, j = arr.size() - 1;
        while (i < j) {
            if (arr.get(i).val != arr.get(j).val) return false;
            i++;
            j--;
        }
        return true;
    }
}
````

</details>

<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof">链表中倒数第k个节点(简单)</a></span>
    </summary>



解题思路

> 1.两轮循环先获取链表长度，然后循环 长度-k次
>
>2.双指针判断，前指针走k步后，双指针同时向后移动，直到前指针指向链尾部

代码实现

````java
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        ListNode former = head, latter = head;
        for (int i = 0; i < k; i++)
            former = former.next;
        while (former != null) {
            former = former.next;
            latter = latter.next;
        }
        return latter;
    }
}
````

</details>

<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">合并K个升序链表(困难)</a></span>
    </summary>



解题思路

>分别两组两组合并

代码实现

````java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        ListNode ans = null;
        for (int i = 0; i < lists.length; ++i) {
            ans = mergeTwoLists(ans, lists[i]);
        }
        return ans;
    }

    public ListNode mergeTwoLists(ListNode a, ListNode b) {
        if (a == null || b == null) {
            return a != null ? a : b;
        }
        ListNode head = new ListNode(0);
        ListNode tail = head, aPtr = a, bPtr = b;
        while (aPtr != null && bPtr != null) {
            if (aPtr.val < bPtr.val) {
                tail.next = aPtr;
                aPtr = aPtr.next;
            } else {
                tail.next = bPtr;
                bPtr = bPtr.next;
            }
            tail = tail.next;
        }
        tail.next = (aPtr != null ? aPtr : bPtr);
        return head.next;
    }
}
````

</details>

<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/lru-cache/">LRU 缓存机制(中等)</a></span>
    </summary>

解题思路

> LRU 缓存机制可以通过`哈希表`辅以`双向链表`实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。

双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。

哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。

这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(1) 的时间内完成 get 或者 put 操作。具体的方法如下：

> 对于 get 操作，首先判断 key 是否存在：如果 key 不存在，则返回 −1；如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。

> 对于 put 操作，首先判断 key 是否存在：如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。

上述各项操作中，访问哈希表的时间复杂度为 O(1)，在双向链表的头部添加节点、在双向链表的尾部删除节点的复杂度也为 O(1)。而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在 O(1)
时间内完成。

小贴士

在双向链表的实现中，使用一个伪头部（dummy head）和伪尾部（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。

代码实现

```java
public class LRUCache {
    class DLinkedNode {
        int key;
        int value;
        DLinkedNode prev;
        DLinkedNode next;

        public DLinkedNode() {
        }

        public DLinkedNode(int _key, int _value) {
            key = _key;
            value = _value;
        }
    }

    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();
    private int size;
    private int capacity;
    private DLinkedNode head, tail;

    public LRUCache(int capacity) {
        this.size = 0;
        this.capacity = capacity;
        // 使用伪头部和伪尾部节点
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            return -1;
        }
        // 如果 key 存在，先通过哈希表定位，再移到头部
        moveToHead(node);
        return node.value;
    }

    public void put(int key, int value) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            // 如果 key 不存在，创建一个新的节点
            DLinkedNode newNode = new DLinkedNode(key, value);
            // 添加进哈希表
            cache.put(key, newNode);
            // 添加至双向链表的头部
            addToHead(newNode);
            ++size;
            if (size > capacity) {
                // 如果超出容量，删除双向链表的尾部节点
                DLinkedNode tail = removeTail();
                // 删除哈希表中对应的项
                cache.remove(tail.key);
                --size;
            }
        } else {
            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
            node.value = value;
            moveToHead(node);
        }
    }
    //添加到头部
    private void addToHead(DLinkedNode node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }
    //移除结点
    private void removeNode(DLinkedNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
    //移动到头结点
    private void moveToHead(DLinkedNode node) {
        removeNode(node);
        addToHead(node);
    }
    //删除尾部结点
    private DLinkedNode removeTail() {
        DLinkedNode res = tail.prev;
        removeNode(res);
        return res;
    }
}
```

复杂度分析

时间复杂度：对于 put 和 get 都是 O(1)。

空间复杂度：O(capacity)，因为哈希表和双向链表最多存储 capacity+1 个元素。

</details>

# 树型结构

> 在树的题目当中主要围绕着,前序、中序、后续、广度、深度遍历来进行解题，所以掌握其十分重要，直接上迭代版本，递归太简单就不上了

<details>
  <summary><span>前序遍历-通过栈实现(先压入右结点)</span></summary>
  <br>

  ```java
  class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        if (root == null) {
            return new ArrayList<>();
        } else {
            List<Integer> list = new ArrayList<>();
            Stack<TreeNode> stack = new Stack<>();
            stack.push(root);
            while (!stack.isEmpty()) {
                TreeNode tmp = stack.pop();
                list.add(tmp.val);
                if (tmp.right != null)
                    stack.push(tmp.right);
                if (tmp.left != null)
                    stack.push(tmp.left);
            }
            return list;
        }
    }
}
```

</details>

<details>
  <summary><span>中序遍历-通过栈实现(一路向左把沿途结点压入栈)</span></summary>
  <br>

  ```java
  class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        if (root == null) {
            return new ArrayList<>();
        } else {
            Stack<TreeNode> stack = new Stack<>();
            List<Integer> list = new ArrayList<>();
            while (root != null || !stack.isEmpty()) {
                while (root != null) {// 一路向左把沿途结点压入栈
                    stack.push(root);
                    root = root.left;
                }
                if (!stack.isEmpty()) {
                    root = stack.pop();// 弹出栈
                    list.add(root.val);
                    root = root.right;// 转向右节点
                }
            }
            return list;
        }
    }
}
```

</details>

<details>
  <summary><span>后序遍历-通过栈实现(前序先push-left再reverse)</span></summary>
  <br>

  ```java
  class Solution {
    public List<Integer> postorderTreversal(TreeNode root) {
        if (root == null) {
            return new ArrayList<>();
        } else {
            List<Integer> list = new ArrayList<>();
            Stack<TreeNode> stack = new Stack<>();
            stack.push(root);
            while (!stack.isEmpty()) {
                TreeNode tmp = stack.pop();
                list.add(tmp.val);
                if (tmp.left != null) {
                    stack.push(tmp.left);
                }
                if (tmp.right != null) {
                    stack.push(tmp.right);
                }
            }
            Collections.reverse(list);
            return list;
        }
    }
}
```

</details>

<details>
  <summary><span>广度优先-通过队列实现</span></summary>
  <br>

> 借助队列

```java
class Solution {
    public void BFS(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        if (!Objects.isNull(root)) queue.add(root);
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();//出队
            if (node.left != null) queue.add(node.left);
            if (node.right != null) queue.add(node.right);
        }
    }
}
```

</details>

<details>
  <summary><span>深度优先-通过栈实现</span></summary>
  <br>

> 借助栈

```java
class Solution {
    public List<Integer> DFS(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode tmp = stack.pop();
            list.add(tmp.val);
            if (tmp.left != null) stack.push(tmp.left);
            if (tmp.right != null) stack.push(tmp.right);
        }
        return list;
    }
}
```

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof">平衡二叉树(简单)</a></span></summary>
  <br>

判断是否是平衡二叉树

> 判断树是否为平衡二叉树

测试用例

![avatar](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/balance_binary_tree.jpg)

输入：root = [3,9,20,null,null,15,7]
输出：true

解题思路

> 平衡二叉树：左右子树高度差不超过一，根据这一特点，递归判断各个节点的子树是否符合条件，不满足则直接返回false,直到递归完成。

代码实现

```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {
    }

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    /**
     * 判断是否为平衡二叉树
     * @param root
     * @return
     */
    public boolean isBalanced(TreeNode root) {
        if (root == null) {
            return true;
        } else {
            return Math.abs(height(root.left) - height(root.right)) <= 1 && isBalanced(root.left) && isBalanced(root.right);
        }
    }

    /**
     * 获取当前节点树高度
     * @param root
     * @return
     */
    public int height(TreeNode root) {
        if (root == null) {
            return 0;
        } else {
            return Math.max(height(root.left), height(root.right)) + 1;
        }
    }
}
```

</details>



<details>
  <summary><span><a href="https://leetcode-cn.com/problems/list-of-depth-lcci" >特定深度节点链表(中等)</a> </span></summary>
  <br>

特定深度节点链表

题目描述

> 给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 D，则会创建出 D 个链表）。返回一个包含所有深度的链表的数组。


示例

输入：[1,2,3,4,5,null,7,8]

        1
       /  \ 
      2    3
     / \    \ 
    4   5    7
/ 8

输出：[[1],[2,3],[4,5,7],[8]]

实现思路

> 通过广度优先遍历对树进行逐层遍历构造链表，通过每一次获取当前队列长度读取当前层的元素个数(关键)

代码实现

```java
class Solution {

    public static ListNode[] listOfDepth(TreeNode tree) {

        List<ListNode> listNodes = new ArrayList<>();
        //广度优先遍历
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(tree);
        while (!queue.isEmpty()) {
            int size = queue.size();//队列大小（核心）
            ListNode head, tmp;
            head = tmp = new ListNode(0);//链表临时头节点
            for (int i = 0; i < size; i++) {//循环当前层元素
                TreeNode treeNode = queue.poll();//从对头取当前元素
                //构建链表
                tmp.next = new ListNode(treeNode.val);
                tmp = tmp.next;
                //将下一层元素压入队列
                if (treeNode.left != null) queue.add(treeNode.left);
                if (treeNode.right != null) queue.add(treeNode.right);
            }
            //将每一条链表添加到list中
            listNodes.add(head.next);
        }

        return listNodes.toArray(new ListNode[]{});
    }
}
```        

</details>



<details>
  <summary><span> <a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal" >N叉树的前序遍历(简单)</a> </span></summary>
  <br>

N叉树的前序遍历

题目描述

给定一个 N 叉树，返回其节点值的前序遍历。

例如，给定一个 3叉树 :

![avatar](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/n-tree.png)

返回其前序遍历: [1,3,5,6,2,4]。

代码实现

 ```java
public class Tree {
    List<Integer> list = new ArrayList<>();

    public List<Integer> preorder(Node root) {
        list.add(root.val);
        //遍历子节点
        root.children.forEach(v -> {
            preorder(v);
        });
        return list;
    }

    public List<Integer> preorder(Node root) {
        //容器
        List<Integer> list = new ArrayList<>();
        Stack<Node> stack = new Stack<>();
        if (root == null) {
            return list;
        }
        //首个节点
        stack.push(root);
        //迭代
        while (!stack.empty()) {
            Node tmp = stack.pop();//出栈
            list.add(tmp.val);//插入值
            Collections.reverse(tmp.children);//将子节点进行反转
            tmp.children.forEach(v -> stack.push(v));//压栈
        }
        //返回结果
        return list;
    }
}
```

递归版
```java
class Solution {
    List<Integer> ans = new ArrayList<>();
    public List<Integer> preorder(Node root) {
        if(root==null)return new ArrayList<>();
        ans.add(root.val);
        for(int i=0;i<root.children.size();i++){
            preorder(root.children.get(i));
        }
        return ans;
    }
}
```

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/maximum-binary-tree">最大二叉树(中等)</a> </span></summary>
  <br>

最大二叉树

给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：

二叉树的根是数组中的最大元素。 左子树是通过数组中最大值左边部分构造出的最大二叉树。 右子树是通过数组中最大值右边部分构造出的最大二叉树。 通过给定的数组构建最大二叉树，并且输出这个树的根节点。

 

示例 ：

````
输入：[3,2,1,6,0,5]
输出：返回下面这棵树的根节点：

      6
    /   \
   3     5
    \    / 
     2  0   
       \
        1
 
````

提示：给定的数组的大小在 [1, 1000] 之间。

```java
class Solution {

    public TreeNode constructMaximumBinaryTree(int[] nums) {
        if (nums.length == 0) return null;
        //获得最大值
        int maxIndex = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[maxIndex] < nums[i]) maxIndex = i;
        }
        //构造当前节点
        TreeNode node = new TreeNode(nums[maxIndex]);
        //构造左子树
        if (maxIndex >= 0)//左边数组还有值
            node.left = constructMaximumBinaryTree(Arrays.copyOfRange(nums, 0, maxIndex));
        //构造右子树
        if (maxIndex < nums.length - 1)//右边数组还有值
            node.right = constructMaximumBinaryTree(Arrays.copyOfRange(nums, maxIndex + 1, nums.length));
        //返回当前节点
        return node;
    }
}
```

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/maximum-binary-tree-ii" >最大二叉树 II(中等)</a>  </span></summary>
  <br>

最大树定义：一个树，其中每个节点的值都大于其子树中的任何其他值。

给出最大树的根节点 root。

就像之前的问题那样，给定的树是从表 A（root = Construct(A)）递归地使用下述 Construct(A) 例程构造的：

如果 A 为空，返回 null 否则，令 A[i] 作为 A 的最大元素。创建一个值为 A[i] 的根节点 root root 的左子树将被构建为 Construct([A[0], A[1], ..., A[i-1]])
root 的右子树将被构建为 Construct([A[i+1], A[i+2], ..., A[A.length - 1]])
返回 root 请注意，我们没有直接给定 A，只有一个根节点 root = Construct(A).

假设 B 是 A 的副本，并附加值 val。保证 B 中的值是不同的。

返回 Construct(B)。

 

示例 1：

输入：root = [4,1,3,null,null,2], val = 5 输出：[5,4,null,1,3,null,null,2]
解释：A = [1,4,2,3], B = [1,4,2,3,5]
示例 2：

输入：root = [5,2,4,null,1], val = 3 输出：[5,2,4,null,1,null,3]
解释：A = [2,1,5,4], B = [2,1,5,4,3]
示例 3：

输入：root = [5,2,3,null,1], val = 4 输出：[5,2,4,null,1,3]
解释：A = [2,1,5,3], B = [2,1,5,3,4]

提示：

1 <= B.length <= 100

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof">二叉搜索树的第k大节点(简单)</a> </span></summary>
  <br>

给定一棵二叉搜索树，请找出其中第k大的节点。

 

````
示例 1:

输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 4
示例 2:

输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 4
````

限制： 1 ≤ k ≤ 二叉搜索树元素个数

解题思路
> 二叉搜索树、通过中许遍历得到递增序列、那么优先改变一下，从右子树先遍历即可得到递减序列

```java
class Solution {
    private int ans = 0, count = 0;

    public int kthLargest(TreeNode root, int k) {
        // clarification:  root == null?   k <= 1?
        helper(root, k);
        return ans;
    }

    private void helper(TreeNode root, int k) {
        if (root.right != null) helper(root.right, k);

        if (++count == k) {
            ans = root.val;
            return;
        }

        if (root.left != null) helper(root.left, k);
    }
}
```      

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/number-of-good-leaf-nodes-pairs/">好叶子节点对的数量(中等)</a></span></summary>
  <br>

给你二叉树的根节点 root 和一个整数 distance 。

如果二叉树中两个 叶 节点之间的 最短路径长度 小于或者等于 distance ，那它们就可以构成一组 好叶子节点对 。

返回树中 好叶子节点对的数量 。

示例

```text
输入: root = [1,2,3,null,4], distance = 3
       1
      / \
     2   3
      \
       4
输出: 1
解释：树的叶节点是 3 和 4 ，它们之间的最短路径的长度是 3 。这是唯一的好叶子节点对。
```

解题思路

> 父节点和子节点的距离是 1

> 对树后序遍历 ，需要返回这个节点到其下方所有叶子节点的距离

> 这样就可以将这个节点的左子树所有叶子节点和右子树所有叶子节点都凑个对

> 然后将所有叶子节点不超过距离的弄到一起返回

代码实现

```java
class Solution {
    //计数
    private int ans = 0;

    public int countPairs(TreeNode root, int distance) {
        dfs(root, distance);
        return ans;
    }

    //后续遍历
    private List<Integer> dfs(TreeNode root, int distance) {
        //当前节点为空返回空
        if (root == null)
            return new ArrayList();
        //叶子节点
        if (root.left == null && root.right == null) {
            List<Integer> list = new ArrayList();
            list.add(0);
            return list;
        }
        //
        List<Integer> list = new ArrayList();
        //左叶子节点的距离
        List<Integer> left = dfs(root.left, distance);
        //判断是否超过distance
        for (int it : left) {
            if (++it > distance)
                continue;
            list.add(it);
        }
        //右叶子节点的距离
        List<Integer> right = dfs(root.right, distance);
        for (int it : right) {
            if (++it > distance)
                continue;
            list.add(it);
        }
        //
        for (int l : left) {
            for (int r : right) {
                if (l + r + 2 <= distance)
                    ans++;
            }
        }
        return list;
    }
}
```

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes">具有所有最深节点的最小子树(中等)</a></span></summary>
  <br>

题目描述
> 给定一个根为 root 的二叉树，每个节点的深度是 该节点到根的最短距离 。 如果一个节点在 整个树 的任意节点之间具有最大的深度，则该节点是 最深的 。 一个节点的 子树 是该节点加上它的所有后代的集合。 返回能满足 以该节点为根的子树中包含所有最深的节点 这一条件的具有最大深度的节点。

`说的云里雾里，人话：最深叶子节点的最近公共祖先`

![avatar](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/sketch1.png)


> 输入：root = [3,5,1,6,2,0,8,null,null,7,4]
输出：[2,7,4]
解释： 我们返回值为 2 的节点，在图中用黄色标记。 在图中用蓝色标记的是树的最深的节点。 注意，节点 5、3 和 2 包含树中最深的节点，但节点 2 的子树最小，因此我们返回它。


解题思路
> 对于一个节点，如果左子树高度==右子树高度，这个节点就是答案，如果左子树高度<右子树高度，查找右子树，否则查找左子树


代码实现

```java
class Solution {
    public TreeNode subtreeWithAllDeepest(TreeNode root) {
        if (root == null) return null;//为空返回
        else {
            int ldep = maxDepth(root.left), rdep = maxDepth(root.right);//获取左右最大深度
            if (ldep == rdep) return root;//相等返回
            else if (ldep > rdep) return subtreeWithAllDeepest(root.left);//左边深度大、查找左边
            else return subtreeWithAllDeepest(root.right);//右边深度大、查找右边
        }
    }

    int maxDepth(TreeNode root) {//获取当前节点的最大深度
        if (root == null) return 0;
        else return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
```

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/paths-with-sum-lcci/">求和路径(中等)</a></span></summary>
  <br>

题目描述

给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。

示例:
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1

返回:3 解释：和为 22 的路径有：[5,4,11,2], [5,8,4,5], [4,11,7]
提示：节点总数 <= 10000

解题思路
> 求出当前节点为根路径是否满足，递归判断每个节点

代码实现

```java
class Solution {
    int count = 0;

    public int pathSum(TreeNode root, int sum) {
        if (root == null) return 0;
        helper(root, sum);
        if (root.left != null) pathSum(root.left, sum);
        if (root.right != null) pathSum(root.right, sum);
        return count;
    }


    public void helper(TreeNode node, int sum) {
        if (sum == node.val) count++;
        if (node.left != null) helper(node.left, sum - node.val);
        if (node.right != null) helper(node.right, sum - node.val);
    }
}
```

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal">二叉树的层序遍历(中等)</a></span></summary>
  <br>

给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

  

示例： 二叉树：[3,9,20,null,null,15,7],

     3
    / \

9 20 /  \
15 7 返回其层次遍历结果：

[
[3],
[9,20],
[15,7]
]

解题思路
> 广度优先遍历，采用队列获取其每层的长度

代码实现

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        List<Integer> list;
        if (!Objects.isNull(root)) queue.add(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            list = new ArrayList<>();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                list.add(node.val);
                if (node.left != null) queue.add(node.left);
                if (node.right != null) queue.add(node.right);
            }
            result.add(list);
        }
        return result;
    }
}
```

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree">二叉树的最近公共祖先(中等)</a></span></summary>

题目描述
> 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]

解题思路
> 对树DFS判断其目标节点是否存在，如果存在返回true寻找另一个节点，当两个节点都找到，递归返回获得其第一个公共节点

代码实现

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || p == root || q == root)return root;//递归结束条件
        TreeNode left = lowestCommonAncestor(root.left,p,q);//深度优先遍历左子树
        TreeNode right = lowestCommonAncestor(root.right,p,q);//深度优先遍历右子树
        if(left!=null && right != null)return root;//找到节点将其返回
        return left == null ? right : left;//否则返回已查询到的节点
    }
}
```

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree">二叉树的直径(容易)</a></span></summary>
  <br>

题目描述
> 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

示例 :
给定二叉树

           1
          / \
         2   3
        / \     
       4   5    

返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

注意：两结点之间的路径长度是以它们之间边的数目表示。

解题思路
> 深度优先搜索，分别递归计算每个节点的左右子树的路径之和，默认值为1超过则更新，递归向上执行

代码实现

```java
class Solution {
    int ans;//记录最大路径

    public int diameterOfBinaryTree(TreeNode root) {//方法入口
        ans = 1;
        depth(root);
        return ans - 1;
    }

    //深度优先遍历
    public int depth(TreeNode node) {
        if (node == null) return 0; // 访问到空节点了，返回0
        int L = depth(node.left); // 左儿子为根的子树的深度
        int R = depth(node.right); // 右儿子为根的子树的深度
        ans = Math.max(ans, L + R + 1); // 计算d_node即L+R+1 并更新ans
        return Math.max(L, R) + 1; // 返回该节点为根的子树的深度
    }
}

``` 

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal">二叉树的锯齿形层次遍历(中等)</a></span></summary>
  <br>

题目描述
> 给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

例如： 给定二叉树 [3,9,20,null,null,15,7],

     3
    / \
    9 20 
     /  \
     15 7 

返回锯齿形层次遍历如下：

[
[3],
[20,9],
[15,7]
]

解题思路
> 广度优先遍历，每次将当前层元素出队，使用一个全局变量判断方向，调用addLast或者addFirst。

代码实现

```java
class Solution {
    public void DFS(TreeNode node, int level, List<List<Integer>> results) {
        if (level >= results.size()) {
            LinkedList<Integer> newLevel = new LinkedList<Integer>();
            newLevel.add(node.val);
            results.add(newLevel);
        } else {
            if (level % 2 == 0)
                results.get(level).add(node.val);
            else
                results.get(level).add(0, node.val);
        }

        if (node.left != null) DFS(node.left, level + 1, results);
        if (node.right != null) DFS(node.right, level + 1, results);
    }

    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        if (root == null) {
            return new ArrayList<List<Integer>>();
        }
        List<List<Integer>> results = new ArrayList<List<Integer>>();
        DFS(root, 0, results);
        return results;
    }
    //
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> ant = new LinkedList<>();
        if(root==null)return ant;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        boolean flag = false;
        while(!queue.isEmpty()){
            int size = queue.size();
            List<Integer> list = new LinkedList<>();
            for(int i=0;i<size;i++){
                TreeNode node = queue.poll();
                list.add(node.val);
                if(node.left!=null)queue.offer(node.left);
                if(node.right!=null)queue.offer(node.right);
            }
            if(flag)
            Collections.reverse(list);
            ant.add(list);
            flag=!flag;
        }
        return ant;
    }
}
```

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree">二叉树的最大深度(简单)</a></span></summary>
  <br>

解题思路
> 递归每次递归返回+1,返回左右节点较大的值。

代码实现

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if (Objects.isNull(root)) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
```

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/balanced-binary-tree" taget="_blank">验证二叉搜索树(中等)</a></span></summary>
  <br>

题目描述
> 给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

- 节点的左子树只包含小于当前节点的数。
- 节点的右子树只包含大于当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

示例 1:

```` 
输入:
     2
    / \
   1   3
输出: true
示例 2:
 
输入:
     5
    / \
   1   4
      / \
     3   6
输出: false
````

解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。

解题思路
> 获取左右子书的边界值，递归判断每一个节点是否满足条件

代码实现

```java
public class Solution {
    //函数入口
    public boolean isValidBST(TreeNode root) {
        return helper(root, null, null);
    }

    //DFS
    public boolean helper(TreeNode node, Integer lower, Integer upper) {
        //空节点返回
        if (node == null) return true;
        //如果存在左子树则左子书最大值要小于当前节点值
        if (lower != null && node.val <= lower) return false;
        //如果存在左子树则左子书最大值要小于当前节点值
        if (upper != null && node.val >= upper) return false;
        //递归判断左子树
        if (!helper(node.left, lower, val)) return false;//关键
        //递归判断右子树
        if (!helper(node.right, val, upper)) return false;//关键
        //
        return true;
    }
}
```

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum" taget="_blank">二叉树中的最大路径和(困难)</a></span></summary>
  <br>

题目描述
> 给定一个非空二叉树，返回其最大路径和。

本题中，路径被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。

  

示例 1：

````
 输入：[1,2,3]
 
        1
       / \
      2   3
 
 输出：6
 示例 2：
 
 输入：[-10,9,20,null,null,15,7]
 
    -10
    / \
   9  20
     /  \
    15   7
 
 输出：42
````

解题思路
> 后序递归遍历，判断其左右子树最大值，依此递归

代码实现

```java
class Solution {
    int ans = Integer.MIN_VALUE;//记录结果

    public int maxPathSum(TreeNode root) {
        max(root);
        return ans;
    }

    //后序遍历
    public int max(TreeNode root) {
        if (Objects.isNull(root)) return 0;//递归结束
        int left = Math.max(max(root.left), 0);//左子树最大值
        int right = Math.max(max(root.right), 0);//右子树最大值
        ans = Math.max(ans, left + right + root.val);//是否大于当前的最大值
        return Math.max(left, right) + root.val;//返回最大值
    }
}
```

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从前序与中序遍历序列构造二叉树(中等)</a></span></summary>
  <br>

>根据一棵树的前序遍历与中序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

前序遍历 preorder =[3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]

<p class="note note-primary">
    采用递归
</p>

```text
preorder = [3,9,20,15,7]
inorder = [9,3,15,20,7]
首先根据 preorder 找到根节点是 3
    
然后根据根节点将 inorder 分成左子树和右子树
左子树
inorder [9]

右子树
inorder [15,20,7]

把相应的前序遍历的数组也加进来
左子树
preorder[9] 
inorder [9]

右子树
preorder[20 15 7] 
inorder [15,20,7]

现在我们只需要构造左子树和右子树即可，成功把大问题化成了小问题
然后重复上边的步骤继续划分，直到 preorder 和 inorder 都为空，返回 null 即可
```

```java
    class Solution {
        public TreeNode buildTree(int[] preorder, int[] inorder) {
            HashMap<Integer, Integer> map = new HashMap<>();//存储值对应的下标
            for (int i = 0; i < inorder.length; i++)map.put(inorder[i], i);//存入map
            return buildTree(preorder,0,preorder.length-1,inorder,0,inorder.length-1,map);//递归调用
        }
        //构建
        TreeNode buildTree(int[] preorder, int preStart, int preEnd,int[] inorder, int inStart, int inEnd, Map<Integer, Integer> inMap) {
            if(preStart > preEnd || inStart > inEnd) return null;//下标超过则停止(递归结束条件)
            TreeNode root = new TreeNode(preorder[preStart]);//构建结点
            int inRoot = inMap.get(root.val);//根结点下标
            int numsLeft = inRoot - inStart;//重新定义左边
            root.left = buildTree(preorder, preStart + 1, preStart + numsLeft,inorder, inStart, inRoot - 1, inMap);//递归调用
            root.right = buildTree(preorder, preStart + numsLeft + 1, preEnd,inorder, inRoot + 1, inEnd, inMap);//递归调用
            return root;//返回根节点
        }
    }
```

</details>


<details>
  <summary><span><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">不同的二叉搜索树 II(中等)</a></span></summary>
  <br>

解题思路

>回溯 

```java
class Solution {
    public List<TreeNode> generateTrees(int n) {
        if (n == 0) {
            return new LinkedList<TreeNode>();
        }
        return generateTrees(1, n);
    }

    public List<TreeNode> generateTrees(int start, int end) {
        List<TreeNode> allTrees = new LinkedList<TreeNode>();
        if (start > end) {
            allTrees.add(null);
            return allTrees;
        }

        // 枚举可行根节点
        for (int i = start; i <= end; i++) {
            // 获得所有可行的左子树集合
            List<TreeNode> leftTrees = generateTrees(start, i - 1);
            // 获得所有可行的右子树集合
            List<TreeNode> rightTrees = generateTrees(i + 1, end);
            // 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上
            for (TreeNode left : leftTrees) {
                for (TreeNode right : rightTrees) {
                    TreeNode currTree = new TreeNode(i);
                    currTree.left = left;
                    currTree.right = right;
                    allTrees.add(currTree);
                }
            }
        }
        return allTrees;
    }
}
```


</details>

# 回溯算法

> 回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/combinations/">组合(中等)</a></span></summary>
  <br>

>给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

示例:
````text
输入:n = 4, k = 2
输出:
[
    [2,4],
    [3,4],
    [2,3],
    [1,2],
    [1,3],
    [1,4],
]
````

```java

public class Solution {
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> res = new ArrayList<>();
        if (k <= 0 || n < k) {
            return res;
        }
        // 为了防止底层动态数组扩容，初始化的时候传入最大长度
        Deque<Integer> path = new ArrayDeque<>(k);
        dfs(1, n, k, path, res);
        return res;
    }

    private void dfs(int begin, int n, int k, Deque<Integer> path, List<List<Integer>> res) {
        if (k == 0) {
            res.add(new ArrayList<>(path));
            return;
        }
        // 基础版本的递归终止条件：if (begin == n + 1) {
        if (begin > n - k + 1) {
            return;
        }
        // 不选当前考虑的数 begin，直接递归到下一层
        dfs(begin + 1, n, k, path, res);
        // 不选当前考虑的数 begin，递归到下一层的时候 k - 1，这里 k 表示还需要选多少个数
        path.addLast(begin);
        dfs(begin + 1, n, k - 1, path, res);
        // 深度优先遍历有回头的过程，因此需要撤销选择
        path.removeLast();
    }
}
```
</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/permutations/">全排列(中等)</a></span></summary>
  <br>

>给定一个 没有重复 数字的序列，返回其所有可能的全排列。

示例:

输入: [1,2,3]
输出:
[
    [1,2,3],
    [1,3,2],
    [2,1,3],
    [2,3,1],
    [3,1,2],
    [3,2,1]
]

```java
class Solution{
    //存储结果
    List<List<Integer>> res = new LinkedList<>();
    //函数入口
    List<List<Integer>> permute(int[] nums){
        //记录走过的路径
        LinkedList<Integer> integers = new LinkedList<>();
        //入口
        backtrack(nums,integers);
        return res;
    }
    //回溯函数
    public void backtrack(int[] nums, LinkedList<Integer> track){
        //如果走过的路径包含所有的选择则完成一轮
        if (nums.length==track.size()) {
            res.add(new LinkedList(track));
            return;
        }
        for (int i = 0; i <nums.length; i++) {
            //排除不合法的选择
            if (track.contains(nums[i]))continue;
            //做选择
            track.add(nums[i]);
            //进入下一层决策树
            backtrack(nums,track);
            //撤销选择
            track.removeLast();
        }
    }
}
```


</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/permutations-ii/">全排列II(中等)</a></span></summary>
  <br>

题目描述

>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列

示例 1：

输入：nums = [1,1,2]
输出：
[[1,1,2],
[1,2,1],
[2,1,1]]
示例 2：

输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

```java
class Solution {
    public List<List<Integer>> permuteUnique(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        //从小到大排序，跳过重复项
        Arrays.sort(nums);
        boolean[] visited = new boolean[nums.length];
        backtrack(res, new ArrayList<>(), nums, visited, 0);
        return res;
    }

    public void backtrack(List<List<Integer>> res, List<Integer> list, int[] nums, boolean[] visited, int n) {
        //终止条件, 说明找到一组组合
        if(n == nums.length) {
            res.add(new ArrayList<>(list));
            return;
        }
        for(int i = 0; i < nums.length; i++) {
            if(visited[i] == true) continue;
            if(i > 0 && nums[i] == nums[i - 1] && visited[i - 1] == false) continue;
            //选择当前值
            visited[i] = true;
            list.add(nums[i]);
            //递归
            backtrack(res, list, nums, visited, n + 1);
            //撤销选择
            list.remove(list.size() - 1);
            visited[i] = false;
        }
    }
}
```

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/powx-n/">Pow(x, n)(中等)</a></span></summary>
  <br>

>递归和迭代拆分进行计算

```java
class Solution {
    public double quickMul(double x, long N) {
        if (N == 0) return 1.0;//0次幂
        double y = quickMul(x, N / 2);//折半计算
        return N % 2 == 0 ? y * y : y * y * x;//减少计算
    }
    public double myPow(double x, int n) {
        long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);//处理负次方幂
    }
}
```

```java
class Solution {
    double quickMul(double x, long N) {
        double ans = 1.0;
        // 贡献的初始值为 x
        double x_contribute = x;
        // 在对 N 进行二进制拆分的同时计算答案
        while (N > 0) {
            if (N % 2 == 1) {
                // 如果 N 二进制表示的最低位为 1，那么需要计入贡献
                ans *= x_contribute;
            }
            // 将贡献不断地平方
            x_contribute *= x_contribute;
            // 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可
            N /= 2;
        }
        return ans;
    }
    public double myPow(double x, int n) {
        long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }
}
```


</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/majority-element/">多数元素(简单)</a></span></summary>
  <br>

给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素

<p class="note note-primary">
    哈希表,排序,摩尔投票
</p>

>Boyer-Moore 投票算法

思路

如果我们把众数记为 +1，把其他数记为 −1，将它们全部加起来，显然和大于 0，从结果本身我们可以看出众数比其他数多。

算法

Boyer-Moore 算法的本质和方法四中的分治十分类似。我们首先给出 Boyer-Moore 算法的详细步骤：

```text
我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；
我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：
如果 x 与 candidate 相等，那么计数器 count 的值增加 1；
如果 x 与 candidate 不等，那么计数器 count 的值减少 1。
在遍历完成后，candidate 即为整个数组的众数。
```



我们举一个具体的例子，例如下面的这个数组：

[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]

在遍历到数组中的第一个元素以及每个在 | 之后的元素时，candidate 都会因为 count 的值变为 0 而发生改变。最后一次 candidate 的值从 5 变为 7，也就是这个数组中的众数。

Boyer-Moore 算法的正确性较难证明，这里给出一种较为详细的用例子辅助证明的思路，供读者参考：

首先我们根据算法步骤中对 count 的定义，可以发现：在对整个数组进行遍历的过程中，count 的值一定非负。这是因为如果 count 的值为 0，那么在这一轮遍历的开始时刻，我们会将 x 的值赋予 candidate 并在接下来的一步中将 count 的值增加 1。因此 count 的值在遍历的过程中一直保持非负。

那么 count 本身除了计数器之外，还有什么更深层次的意义呢？我们还是以数组

[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]

作为例子，首先写下它在每一步遍历时 candidate 和 count 的值：

nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
candidate:  7  7  7  7  7  7   5  5   5  5  5  5   7  7  7  7
count:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4

我们再定义一个变量 value，它和真正的众数 maj 绑定。在每一步遍历时，如果当前的数 x 和 maj 相等，那么 value 的值加 1，否则减 1。value 的实际意义即为：到当前的这一步遍历为止，众数出现的次数比非众数多出了多少次。我们将 value 的值也写在下方：

nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
value:      1  2  1  2  1  0  -1  0  -1 -2 -1  0   1  2  3  4

有没有发现什么？我们将 count 和 value 放在一起：

nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
count:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4
value:      1  2  1  2  1  0  -1  0  -1 -2 -1  0   1  2  3  4

发现在每一步遍历中，count 和 value 要么相等，要么互为相反数！并且在候选众数 candidate 就是 maj 时，它们相等，candidate 是其它的数时，它们互为相反数！

为什么会有这么奇妙的性质呢？这并不难证明：我们将候选众数 candidate 保持不变的连续的遍历称为「一段」。在同一段中，count 的值是根据 candidate == x 的判断进行加减的。那么如果 candidate 恰好为 maj，那么在这一段中，count 和 value 的变化是同步的；如果 candidate 不为 maj，那么在这一段中 count 和 value 的变化是相反的。因此就有了这样一个奇妙的性质。

这样以来，由于：

我们证明了 count 的值一直为非负，在最后一步遍历结束后也是如此；

由于 value 的值与真正的众数 maj 绑定，并且它表示「众数出现的次数比非众数多出了多少次」，那么在最后一步遍历结束后，value 的值为正数；

在最后一步遍历结束后，count 非负，value 为正数，所以它们不可能互为相反数，只可能相等，即 count == value。因此在最后「一段」中，count 的 value 的变化是同步的，也就是说，candidate 中存储的候选众数就是真正的众数 maj。

```java
class Solution {
    public int majorityElement(int[] nums) {
        int count = 0;
        Integer candidate = null;

        for (int num : nums) {
            if (count == 0) {
                candidate = num;
            }
            count += (num == candidate) ? 1 : -1;
        }
        return candidate;
    }
}
```


</details>

<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">电话号码的字母组合(中等)</a></span>
    </summary>

>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

```java
class Solution {
    /**
     * 方法入口
     * @param digits
     * @return
     */
    public List<String> letterCombinations(String digits) {
        List<String> combinations = new ArrayList<String>();
        if (digits.length() == 0) {
            return combinations;
        }
        Map<Character, String> phoneMap = new HashMap<Character, String>() {{
            put('2', "abc");
            put('3', "def");
            put('4', "ghi");
            put('5', "jkl");
            put('6', "mno");
            put('7', "pqrs");
            put('8', "tuv");
            put('9', "wxyz");
        }};
        backtrack(combinations, phoneMap, digits, 0, new StringBuffer());
        return combinations;
    }
    /**
     * 回溯
     * @param combinations
     * @param phoneMap
     * @param digits
     * @param index
     * @param combination
     */
    public void backtrack(List<String> combinations, Map<Character, String> phoneMap, String digits, int index, StringBuffer combination) {
        if (index == digits.length()) {//结束条件
            combinations.add(combination.toString());
        } else {
            char digit = digits.charAt(index);//获取当前数字
            String letters = phoneMap.get(digit);//获取当前数字对应的字符串
            int lettersCount = letters.length();//字符串长度
            for (int i = 0; i < lettersCount; i++) {//遍历字符串
                combination.append(letters.charAt(i));//追加字符到字符串末尾
                backtrack(combinations, phoneMap, digits, index + 1, combination);
                combination.deleteCharAt(index);//移除追加的字符串
            }
        }
    }
}
```

</details>



<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/n-queens/">N皇后(困难)</a></span>
    </summary>

>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。
 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。
 
`后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。`

>结题思路、回溯

```java
class Solution{
        //存放结果
        List<List<String>> res = new ArrayList<>();
        public  List<List<String>> solveNQueens(int n) {

            //用二维char数组初始化棋盘
            char[][] board = new char[n][n];
            for(int i = 0; i < n; i++){
                Arrays.fill(board[i],'.');
            }
            backtrack(0,board);
            return res;
        }
        public  void backtrack(int row,char[][] board){
            if(board.length == row){
                res.add(charArraysToList(board));
                return;
            }
            int n = board[row].length - 1;
            for(int col = 0; col <= n; col++){
             //排除不合法的选项
             if (!isValid(board,row,col))
                 continue;
             //做选择
                board[row][col]='Q';
             //进入下一行决策
                backtrack(row+1,board);
             //撤销选择
                board[row][col]='.';
            }

        }
        public static boolean isValid(char[][] board,int row , int col){
            int n = board.length;
            //注意由于我们是从上往下的来一个一个排列 所以不用检查下方的棋盘
            //检查正上方有没有冲突(列冲突)
            for (int r = 0; r< n;r++){
               if ( board[r][col] =='Q')
                   return false;
            }
            //检查左上方
            for (int i = row-1,j=col-1; i>=0&&j>=0;i--,j--){
                if (board[i][j]=='Q')return false;
            }
            //检查右上方
            for (int i = row-1,j=col+1; i>=0&&j<board[i].length;i--,j++){
                if (board[i][j]=='Q')return false;
            }
            return true;
        }
        public static List<String> charArraysToList(char[][] board){
            //将char数组变成list<String>
            List<String> list = new ArrayList<>();
            for (char[] c : board){
                String str = new String(c);
                list.add(str);
            }
            return list;
        }
}
```

</details>

<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/minimum-genetic-mutation/">最小基因变化(中等)</a></span>
    </summary>
    
>回溯思想、广度优先遍历

```java
class Solution {
    public int minMutation(String start, String end, String[] bank) {
        HashSet<String> set = new HashSet<>(Arrays.asList(bank));
        //不包含结果直接返回-1
        if (!set.contains(end)) {
            return -1;
        }
        //
        char[] four = {'A', 'C', 'G', 'T'};
        Queue<String> queue = new LinkedList<>();
        queue.offer(start);//
        set.remove(start);//集合中移除
        int step = 0;
        while (queue.size() > 0) {
            step++;
            for (int count = queue.size(); count > 0; --count) {
                char[] temStringChars = queue.poll().toCharArray();
                for (int i = 0, len = temStringChars.length; i < len; ++i) {
                    char oldChar = temStringChars[i];
                    for (int j = 0; j < 4; ++j) {
                        temStringChars[i] = four[j];
                        String newGenetic = new String(temStringChars);
                        if (end.equals(newGenetic)) {
                            return step;
                        } else if (set.contains(newGenetic)) {
                            set.remove(newGenetic);
                            queue.offer(newGenetic);
                        }
                    }
                    temStringChars[i] = oldChar;
                }
            }
        }
        return -1;
    }
}
```

>回溯思想、深度优先遍历

```java
class Solution {
    int minStepCount = Integer.MAX_VALUE;//设置默认值
    //函数入口
    public int minMutation(String start, String end, String[] bank) {
        dfs(new HashSet<String>(), 0, start, end, bank);
        return (minStepCount == Integer.MAX_VALUE) ? -1 : minStepCount;
    }
    //深度优先遍历
    private void dfs (HashSet<String> step, int stepCount,String current, String end, String[] bank) {
        //满足条件进行比较赋值
        if (current.equals(end))  minStepCount = Math.min(stepCount, minStepCount);
        //遍历基因库
        for (String str: bank) {
            //遍历
            int diff = 0;
            for (int i = 0; i < str.length(); i++) 
                if (current.charAt(i) != str.charAt(i)) if (++diff > 1) break;//记录基因不同的位置
            //当前有基因不同 && 基因库中不包含当前基因序列(已使用过处理)
            if (diff == 1 && !step.contains(str)) {
                step.add(str);//添加当前序列
                dfs(step, stepCount + 1, str, end, bank);//进入下一层遍历,步数+1,并且使用当前序列作为current
                step.remove(str);//移除当前序列
            }
        }
    }
}

```

</details>


<details>
    <summary>
        <span><a href="">在每个树行中找最大值(中等)</a></span>
    </summary>

>广度优先

```java
class Solution {
    public List<Integer> largestValues(TreeNode root) {
        List<Integer> ans = new ArrayList<Integer>();
        LinkedList<TreeNode> queue = new LinkedList<>();
        if(!Objects.isNull(root))queue.add(root);

        while(!queue.isEmpty()){
            int size = queue.size();
            int max = queue.getFirst().val;
            for(int i=0;i<size;i++){
                TreeNode node = queue.poll();
                if(node.val>max)max=node.val;
                if(node.left!=null)queue.add(node.left);
                if(node.right!=null)queue.add(node.right);
            }
            ans.add(max);
        }
        return ans;
    }
}
```

</details>

# 贪心类型

> 贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解 [1]  。 贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择。也就是说，不从整体最优上加以考虑，做出的只是在某种意义上的局部最优解 [1]  。



<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/lemonade-change/">柠檬水找零(简单)</a></span>
    </summary>


```java
class Solution {
    public boolean lemonadeChange(int[] bills) {
        int five = 0, ten = 0;
        for (int bill : bills) {
            if (bill == 5) {
                five++;
            } else if (bill == 10) {
                if (five == 0) {
                    return false;
                }
                five--;
                ten++;
            } else {
                if (five > 0 && ten > 0) {
                    five--;
                    ten--;
                } else if (five >= 3) {
                    five -= 3;
                } else {
                    return false;
                }
            }
        }
        return true;
    }
}
```

</details>

<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/number-of-islands/solution/">岛屿数量(中等)</a></span>
    </summary>

>广度优先遍历

```java
class Solution {
    int[][] visit ;//记录已经走过的坐标
    char[][] arr;
    public int numIslands(char[][] grid) {
        int ans = 0;
        arr = grid;
        visit = new int[grid.length][grid[0].length];//记录已经走过的坐标
        //深度优先搜索
        for(int i=0;i<grid.length;i++){
            for (int j = 0; j < grid[i].length; j++) {
                if (grid[i][j]=='1'&&visit[i][j]==0){
                    bfs(i,j);
                    ans+=1;
                }
            }
        }
        return ans;
    }
    //
    public void bfs(int x,int y){
        visit[x][y]=1;
        //上
        if(x-1>=0&&visit[x-1][y]==0&&arr[x-1][y]=='1')bfs(x-1,y);
        //下
        if(x+1<arr.length&&visit[x+1][y]==0&&arr[x+1][y]=='1')bfs(x+1,y);
        //左
        if(y-1>=0&&visit[x][y-1]==0&&arr[x][y-1]=='1')bfs(x,y-1);
        //右
        if(y+1<arr[x].length&&visit[x][y+1]==0&&arr[x][y+1]=='1')bfs(x,y+1);
    }
}
```

</details>


<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II(简单)</a></span>
    </summary>

>贪心算法

```java
class Solution {
    //动态规划(dp[i][j] 表示到下标为 i 的这一天，持股状态为 j 时，我们手上拥有的最大现金数。)    
    public int maxProfit(int[] prices) {
        int len = prices.length;
        if (len < 2)return 0;
        // cash：持有现金
        // hold：持有股票
        // 状态数组
        // 状态转移：cash → hold → cash → hold → cash → hold → cash
        int[] cash = new int[len];
        int[] hold = new int[len];
    
        cash[0] = 0;
        hold[0] = -prices[0];
    
        for (int i = 1; i < len; i++) {
            // 这两行调换顺序也是可以的
            cash[i] = Math.max(cash[i - 1], hold[i - 1] + prices[i]);//卖出
            hold[i] = Math.max(hold[i - 1], cash[i - 1] - prices[i]);//买入
        }
        return cash[len - 1];
    }
    //空间优化
    public int maxProfit(int[] prices) {
        int len = prices.length;
        if (len < 2)return 0;
        // cash：持有现金
        // hold：持有股票
        // 状态转移：cash → hold → cash → hold → cash → hold → cash
        int cash = 0;
        int hold = -prices[0];
    
        int preCash = cash;
        int preHold = hold;
        for (int i = 1; i < len; i++) {
            cash = Math.max(preCash, preHold + prices[i]);
            hold = Math.max(preHold, preCash - prices[i]);
            preCash = cash;
            preHold = hold;
        }
        return cash;
    }
    //贪婪算法
    public int maxProfit(int[] prices) {
        int ans = 0;
        int n = prices.length;
        for (int i = 1; i < n; ++i) {
            ans += Math.max(0, prices[i] - prices[i - 1]);
        }
        return ans;
    }
}
```
</details>

<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/jump-game/">跳跃游戏(中等)</a></span>
    </summary>

<p class="note note-primary">
给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。
</p>

```text
输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
```

>

```java
public class Solution {
    //循环方式
    public boolean canJump(int[] nums) {
        int n = nums.length;//数字长度
        int rightmost = 0;//可以到达最远位置
        //迭代
        for (int i = 0; i < n; ++i) {
            //当前下标小于可达最远下标则更新
            if (i <= rightmost) {
                rightmost = Math.max(rightmost, i + nums[i]);//更新可达最远位置
                if (rightmost >= n - 1) {//如果最远可达大于等于末尾下标返回true
                    return true;
                }
            }
        }
        return false;
    }
    //dfs方式
    public boolean canJump0(int[] nums) {
       return bfs(0,nums);
    }
    public boolean bfs(int index,int[] nums){
        if (index==nums.length-1)return true;//满足条件
            for (int j = 1; j < nums[index]; j++) {
                boolean bfs = bfs(index + j, nums);
                if (bfs)return true;
            }
        return false;
    }  
}
```


</details>



<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/jump-game-ii/">跳跃游戏 II(困难)</a></span>
    </summary>

<p class="note note-primary">
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。
</p>

```text
输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

> 


```java
class Solution {
    //反向
    /**
    * 我们的目标是到达数组的最后一个位置，因此我们可以考虑最后一步跳跃前所在的位置，该位置通过跳跃能够到达最后一个位置。
    * 如果有多个位置通过跳跃都能够到达最后一个位置，那么我们应该如何进行选择呢？直观上来看，我们可以「贪心」地选择距离最后一个位置最远的那个位置，也就是对应下标最小的那个位置。因此，我们可以从左到右遍历数组，选择第一个满足要求的位置。
    * 找到最后一步跳跃前所在的位置之后，我们继续贪心地寻找倒数第二步跳跃前所在的位置，以此类推，直到找到数组的开始位置。
    * @param nums
    * @return 
    */
    public int jump(int[] nums) {
        int position = nums.length - 1;//终点
        int steps = 0;//步数
        while (position > 0) {
            //每次寻找距离终点最远的那个下标，更新终点和step
            for (int i = 0; i < position; i++) {
                if (i + nums[i] >= position) {//如果当前
                    position = i;
                    steps++;
                    break;
                }
            }
        }
        return steps;
    }
    //正向
    //思想就一句话：每次在上次能跳到的范围（end）内选择一个能跳的最远的位置（也就是能跳到maxPosition位置的点）作为下次的起跳点
    public int jump(int[] nums) {
        int end = 0;//上次跳跃可达范围右边界（下次的最右起跳点）
        int maxPosition = 0; // 目前能跳到的最远位置
        int steps = 0;// 跳跃次数
        for (int i = 0; i < nums.length - 1; i++) {
            maxPosition = Math.max(maxPosition, i + nums[i]); 
            // 到达上次跳跃能到达的右边界了
            if (i == end) {
                end = maxPosition;// 目前能跳到的最远位置变成了下次起跳位置的右边界
                steps++;// 跳跃次数++
            }
        }
        return steps;
    }
    //动态规划
    public int jump(int[] nums) {
        int length = nums.length;
		int dp[] = new int[length];
		dp[0] = 0;
		if(length==1)return 0;//排除为1的状况，否则后面动态规划时会让第一个点的步数变为1，从而答案错
		int maxn =0; //当前能到达的最大下标
		for(int i=0;i<=maxn;i++) {
			maxn = Math.max(maxn, i+nums[i]);//更新最大下标
			if(maxn>=length-1) {
				dp[length-1]=dp[length-1]==0?dp[i]+1:Math.min(dp[length-1], dp[i]+1);
					return dp[length-1];
			}//当某一时刻能够达到最大下标时，直接进入最大下标，避免不必要的循环
			for(int j=i+1;j<=i+nums[i]&&j<length;j++) {
				dp[j]=dp[j]==0?dp[i]+1:Math.min(dp[j], dp[i]+1);
			}//每次从当前结点出发，遍历每一个能达到的结点，并更新他们的dp值
		}
		return dp[nums.length-1];
    }
}
```


</details>


<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/">环形子数组的最大和(中等)</a></span>
    </summary>

```java
class Solution {
/**
 *    环形子数组的最大和具有两种可能，一种是不使用环的情况，另一种是使用环的情况
 *      不使用环的情况时，直接通过53题的思路，逐步求出整个数组中的最大子序和即可
 *      使用到了环，则必定包含 A[n-1]和 A[0]两个元素且说明从A[1]到A[n-2]这个子数组中必定包含负数【否则只通过一趟最大子序和就可以的出结果】
 *    因此只需要把A[1]-A[n-2]间这些负数的最小和求出来用整个数组的和 sum减掉这个负数最小和即可实现原环型数组的最大和
 *                
 *                max
 *    无环: |----|////|----|
 *           
 *    有环: |////|----|////|
 *    　　    |---max---|
 *    
 **/
    public int maxSubarraySumCircular(int[] A) {
        int[] dp = new int[A.length];   //dp[i]用来记录以nums[i]结尾的最大子序列和
        dp[0] = A[0];                   //初始化dp
        int max = dp[0];                //最大子序列和
        int sum = dp[0];                //整个数组的和
        //求最大子序列和，见53题
        for (int i = 1; i < dp.length; i++) {
            sum += A[i];
            dp[i] = A[i] + Math.max(dp[i - 1], 0);
            max = Math.max(dp[i], max);
        }
        //使用环情况
        int min = 0;    //开始求A[1]~A[n-1]上的最小子序列和
        for (int i = 1; i < dp.length - 1; i++) {
            dp[i] = A[i] + Math.min(0, dp[i - 1]);
            min = Math.min(dp[i], min);
        }
        return Math.max(sum - min, max);
    }
}
```

</details>


<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">乘积最大子数组(中等)</a></span>
    </summary>

```java
class Solution {
    //动态规划
    public int maxProduct0(int[] nums) {
        //dp[i] = Math.max(dp[i],dp[i]*nums[i]);
        //如果只是维护上面这一个dp的话，会存在当nums[i]为负数时，取的还是dp[i],但num[i]之和在出现负数时(负负得正)可能是出现最大值的
        //所以需要维护两个dp
        int maxF = nums[0], minF = nums[0], ans = nums[0];
        int length = nums.length;
        for (int i = 1; i < length; ++i) {
            int mx = maxF, mn = minF;
            maxF = Math.max(mx * nums[i], Math.max(nums[i], mn * nums[i]));
            minF = Math.min(mn * nums[i], Math.min(nums[i], mx * nums[i]));
            ans = Math.max(maxF, ans);
        }
        return ans;
    }
    //窗口滑动
    public int maxProduct(int[] nums) {
        /*思想：双指针，遇到0左指针开始收敛*/
        int n = nums.length;
        if(n == 1) return nums[0];
        int max = Integer.MIN_VALUE;
        int muti = 1;
        int l = 0, r = 0;
        while(r <= n && l < n){
            if(r == n){//如果右指针到达最后一个位置，左指针开始滑动
                muti /= nums[l++];
            }else{
                if(nums[r] != 0){//如果右指针所指元素不为0，右滑，更新muti
                    muti *= nums[r++];
                }else if(l < r){//右指针为0，开始左滑，更新muti
                    muti /= nums[l++];
                }else{//左右指针都滑到了0的位置，更新max，左右指针指向下一位置重新滑动
                    max = Math.max(max, 0);
                    ++l;
                    ++r;
                }
            }
            //只要左右指针没有指向同一位置，更新max（指向同一位置说明左滑到顶了，记录的muti一定为1，但并不是乘积值）
            if(l != r) max = Math.max(max, muti);
        }
        return max;
    }
}
```


</details>


<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product/">乘积为正数的最长子数组长度(中等)</a></span>
    </summary>

>给你一个整数数组 nums ，请你求出乘积为正数的最长子数组的长度。
 一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。
 请你返回乘积为正数的最长子数组长度。
 

```java
class Solution {
    public int getMaxLen(int[] nums) {
        int length = nums.length;
        int[] positive = new int[length];//正数dp
        int[] negative = new int[length];//负数dp
        if (nums[0] > 0) {
            positive[0] = 1;
        } else if (nums[0] < 0) {
            negative[0] = 1;
        }
        int maxLength = positive[0];
        for (int i = 1; i < length; i++) {
            //num[i]分为三种情况 大于、小于、等于零
            if (nums[i] > 0) {
                positive[i] = positive[i - 1] + 1;//正数直接+1
                negative[i] = negative[i - 1] > 0 ? negative[i - 1] + 1 : 0;//负数直接置为0
            } else if (nums[i] < 0) {
                positive[i] = negative[i - 1] > 0 ? negative[i - 1] + 1 : 0;
                negative[i] = positive[i - 1] + 1;
            } else {
                positive[i] = 0;
                negative[i] = 0;
            }
            maxLength = Math.max(maxLength, positive[i]);
        }
        return maxLength;
    }
}
```

</details>

# 窗口滑动

>

<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串(中等)</a></span>
    </summary>


解题思路

> 窗口滑动，

代码实现

````java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        //双指针窗口滑动
        int left = 0, right = 0, length = 0;
        while (right < s.length()) {
            String str = s.substring(left, right + 1);
            length = length > str.length() ? length : str.length();//记录长度
            right++;//增大窗口
            while (right < s.length() && str.indexOf(s.charAt(right)) != -1) {
                left++;//缩小窗口
                str = s.substring(left, right);
            }
        }
        return length;
    }
}

/**
 * 优化速度
 */
class Solution {
    public int lengthOfLongestSubstring(String s) {
        // 记录字符上一次出现的位置
        int[] last = new int[128];
        for(int i = 0; i < 128; i++) {
            last[i] = -1;
        }
        int n = s.length();

        int res = 0;
        int start = 0; // 窗口开始位置
        for(int i = 0; i < n; i++) {
            int index = s.charAt(i);
            start = Math.max(start, last[index] + 1);
            res   = Math.max(res, i - start + 1);
            last[index] = i;
        }

        return res;
    }
}
````

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">不同的二叉搜索树 II(中等)</a></span></summary>
  <br>



</details>

# 排序算法

[先复习一波](/2020/11/09/algorithm/排序算法/)

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/smallest-k-lcci/solution/">TopK问题(中等)</a></span></summary>
  <br>

> top-k问题 主要解法：排序、堆、随机快速选择、BFPRT 排序方法：时间复杂度O(NlogN)， 因为本题数据特殊性 可以使用计数排序 时间复杂度O(N)
堆：维护一个大小为k的堆， 不太建议使用priority_queue, 额外空间和数据拷贝，可以原地操作数组，使用make_heap + pop_heap、push_heap 或 覆盖堆顶，自实现堆顶下沉 时间复杂度O(Nlogk)
随机快速选择：平均时间复杂度 O(N)
BFPRT：最坏时间复杂度 O(N)


```java
class Solution {
    /**
     * 小顶堆（min-heap）有个重要的性质——每个结点的值均不大于其左右孩子结点的值，则堆顶元素即为整个堆的最小值。JDK中PriorityQueue实现了数据结构堆，通过指定comparator字段来表示小顶堆或大顶堆，默认为null，表示自然序（natural ordering）。
     * 小顶堆解决Top K问题的思路：小顶堆维护当前扫描到的最大100个数，其后每一次的扫描到的元素，若大于堆顶，则入堆，然后删除堆顶；依此往复，直至扫描完所有元素。Java实现第K大整数代码如下：
     * @param nums
     * @param k
     * @return
     */
    public int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> minQueue = new PriorityQueue<>(k);
        for (int num : nums) {
            if (minQueue.size() < k || num > minQueue.peek())
                minQueue.offer(num);
            if (minQueue.size() > k)
                minQueue.poll();
        }
        return minQueue.peek();
    }
}
```


快排解题思路
> 我们知道，经过快速排序算法中的一次划分后，基点左边的所有数小于基点，右边的所有数大于基点，基点位置pivot有三种情况：

- pivot == k 说明基点就是第k+1个小的元素，其左边的子数组就是最小的k个数。此时的子数组[0, k) 就是答案 
- pivot > k 说明基点"偏大"了，对其左子数组继续进行划分 
- pivot < k 说明基点"偏小"了，对其右子数组继续进行划分

快排代码实现

```java
/**
 * 快速排序
 */
class Solution {
    Random random = new Random();
    //函数入口
    public int findKthLargest(int[] nums, int k) {
        // 要找到的元素所在索引:  前K大，即倒数索引第K个
        int index = nums.length - k;
        int right = nums.length - 1;
        int left = 0;
        return quickSelect(nums, left, right, index);
    }
    //快排选择
    public int quickSelect(int[] nums, int left, int right, int index) {
        // 得到分区值索引q
        int q = randomPartition(nums, left, right);

        if (q == index) {
            // 如果刚好索引q就是想要的索引，则直接返回
            return nums[q];

        } else {
            // 如果不是，比较q 与 index ,确定下次要检索的区间, 要么是[q+1, right], 要么就是[left, q-1]
            return q < index ? quickSelect(nums, q + 1, right, index) : quickSelect(nums, left, q - 1, index);
        }
    }
    //随机分区
    public int randomPartition(int[] nums, int l, int r) {
        // 1. 随机数范围: [0, r-l+1) 同时加l, 则是 [l, r+1) = [l, r] 也就是在这个[l,r] 中随机选一个索引出来
        int i = random.nextInt(r - l + 1) + l;
        // 2. 交换nums[i]， nums[r], 也就是将随机数先放在[l,r]最右边nums[r]上
        swap(nums, i, r);
        return partition(nums, l, r);
    }
    //
    public int partition(int[] nums, int l, int r) {
        // 3. 在调用当前方法的randomPartition方法中，已经确定了了随机数是nums[r]
        int x = nums[r], i = l - 1;

        // 首先比较区间在[l， r]之间， 所以nums[j]中的    l<= j <= r
        for (int j = l; j < r; ++j) {
            // 4. nums[j] 跟随机数 x 比较, 小于x的数都跟[l,r]左边区间交换，i=l-1,所以++i=l,初始索引就是l,
            if (nums[j] <= x) {
                swap(nums, ++i, j);//两两交换
            }
        }// 这个for循环操作就是将小于 x 的数都往[i, j]的左边区间设置，从而实现存在[l, i]区间,使得对应数值都 小于 x

        //5. 既然已经将<x的值都放在一边了，现在将x也就是nums[r] 跟nums[i+1]交换，从而分成两个区间[l.i+1]左, [i+2, r]右，左边区间的值都小于x
        swap(nums, i + 1, r);

        // 然后返回这个分区值
        return i + 1;
    }
    //交换位置
    public void swap(int[] a, int i, int j) {
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
```



BFPRT算法思路(O(n))
> BFPRT算法又称中位数的中位数算法，可以用于在O(n)的时间复杂度内找到第k小的数。对于本题，我们可以用BFPRT算法找到第k小的数O(n)，然后遍历一遍原数组O(n)，将小于第k小的数的元素加入到答案数组，即得正确解(时间复杂度也是O(n))。

BFPRT算法的主要步骤如下：

- 将 [公式] 个元素划为 [公式] 组，每组5个，至多只有一组由 [公式] 个元素组成。
- 寻找这 [公式] 个组中每一个组的中位数，这个过程可以用插入排序。
- 对步骤2中的 [公式] 个中位数，重复步骤1和步骤2，递归下去，直到剩下一个数字。
- 最终剩下的数字即为pivot，把大于它的数全放左边，小于等于它的数全放右边。
- 判断pivot的位置与k的大小，有选择的对左边或右边递归。

![avatar](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/bfprt.png)

[中位数的中位数算法](https://segmentfault.com/a/1190000008322873)

代码实现

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

int InsertSort(int array[], int left, int right);
int GetPivotIndex(int array[], int left, int right);
int Partition(int array[], int left, int right, int pivot_index);
int BFPRT(int array[], int left, int right, int k);

int main()
{
    int k = 8; // 1 <= k <= array.size
    int array[20] = { 11,9,10,1,13,8,15,0,16,2,17,5,14,3,6,18,12,7,19,4 };

    cout << "原数组：";
    for (int i = 0; i < 20; i++)
        cout << array[i] << " ";
    cout << endl;

    // 因为是以 k 为划分，所以还可以求出第 k 小值
    cout << "第 " << k << " 小值为：" << array[BFPRT(array, 0, 19, k)] << endl;

    cout << "变换后的数组：";
    for (int i = 0; i < 20; i++)
        cout << array[i] << " ";
    cout << endl;

    return 0;
}

/**
 * 对数组 array[left, right] 进行插入排序，并返回 [left, right]
 * 的中位数。
 */
int InsertSort(int array[], int left, int right)
{
    int temp;
    int j;

    for (int i = left + 1; i <= right; i++)
    {
        temp = array[i];
        j = i - 1;

        while (j >= left && array[j] > temp)
        {
            array[j + 1] = array[j];
            j--;
        }

        array[j + 1] = temp;
    }

    return ((right - left) >> 1) + left;
}

/**
 * 数组 array[left, right] 每五个元素作为一组，并计算每组的中位数，
 * 最后返回这些中位数的中位数下标（即主元下标）。
 *
 * @attention 末尾返回语句最后一个参数多加一个 1 的作用其实就是向上取整的意思，
 * 这样可以始终保持 k 大于 0。
 */
int GetPivotIndex(int array[], int left, int right)
{
    if (right - left < 5)
        return InsertSort(array, left, right);

    int sub_right = left - 1;

    // 每五个作为一组，求出中位数，并把这些中位数全部依次移动到数组左边
    for (int i = left; i + 4 <= right; i += 5)
    {
        int index = InsertSort(array, i, i + 4);
        swap(array[++sub_right], array[index]);
    }

    // 利用 BFPRT 得到这些中位数的中位数下标（即主元下标）
    return BFPRT(array, left, sub_right, ((sub_right - left + 1) >> 1) + 1);
}

/**
 * 利用主元下标 pivot_index 进行对数组 array[left, right] 划分，并返回
 * 划分后的分界线下标。
 */
int Partition(int array[], int left, int right, int pivot_index)
{
    swap(array[pivot_index], array[right]); // 把主元放置于末尾

    int partition_index = left; // 跟踪划分的分界线
    for (int i = left; i < right; i++)
    {
        if (array[i] < array[right])
        {
            swap(array[partition_index++], array[i]); // 比主元小的都放在左侧
        }
    }

    swap(array[partition_index], array[right]); // 最后把主元换回来

    return partition_index;
}

/**
 * 返回数组 array[left, right] 的第 k 小数的下标
 */
int BFPRT(int array[], int left, int right, int k)
{
    int pivot_index = GetPivotIndex(array, left, right); // 得到中位数的中位数下标（即主元下标）
    int partition_index = Partition(array, left, right, pivot_index); // 进行划分，返回划分边界
    int num = partition_index - left + 1;

    if (num == k)
        return partition_index;
    else if (num > k)
        return BFPRT(array, left, partition_index - 1, k);
    else
        return BFPRT(array, partition_index + 1, right, k - num);
}
```

[Top K问题的两种解决思路](https://www.cnblogs.com/en-heng/p/6336625.html)


</details>

<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">数组中的逆序对(困难)</a></span>
    </summary>




解题思路

> ![image.png](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/array-nxd-1.png)
>
>------
>
>![image.png](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/array-nxd-2.png)

代码实现

````java
class Solution {
    //先来一段归并排序的代码
    void merge(int[] arr, int start, int end) {
        if (start == end) return;
        int mid = (start + end) / 2;
        merge(arr, start, mid);
        merge(arr, mid + 1, end);

        int[] temp = new int[end - start + 1];
        int i = start, j = mid + 1, k = 0;
        while (i <= mid && j <= end)
            temp[k++] = arr[i] < arr[j] ? arr[i++] : arr[j++];
        while (i <= mid)
            temp[k++] = arr[i++];
        while (j <= end)
            temp[k++] = arr[j++];
        System.arraycopy(temp, 0, arr, start, end);
    }

    //再看一下这道题的题解
    public int reversePairs(int[] nums) {
        return merge(nums, 0, nums.length - 1);
    }

    int merge(int[] arr, int start, int end) {
        if (start == end) return 0;
        int mid = (start + end) / 2;
        int count = merge(arr, start, mid) + merge(arr, mid + 1, end);//计算两个区间的逆序个数

        int[] temp = new int[end - start + 1];
        int i = start, j = mid + 1, k = 0;
        while (i <= mid && j <= end) {
            count += arr[i] <= arr[j] ? j - (mid + 1) : 0;//关键
            temp[k++] = arr[i] <= arr[j] ? arr[i++] : arr[j++];
        }
        while (i <= mid) {
            count += j - (mid + 1);//关键
            temp[k++] = arr[i++];
        }
        while (j <= end) temp[k++] = arr[j++];
        System.arraycopy(temp, 0, arr, start, end - start + 1);
        return count;
    }
}
````

</details>


<details>
  <summary><span><a href="https://leetcode-cn.com/problems/subsets/">子集(中等)</a></span></summary>
  <br>

>给你一个整数数组 nums ，返回该数组所有可能的子集（幂集）。解集不能包含重复的子集。

```text
示例 1：
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

示例 2：
输入：nums = [0]
输出：[[],[0]]
```

>字典排序(二进制排序)

nums=\[5,2,9]

|0/1 序列 | 子集	0/1 | 0/1 序列对应的二进制数 |
|----|----|----|
000	|{}|	0|
001	|{9}|	1|
010	|{2}|	2|
011	|{2,9}|	3|
100	|{5}|	4|
101	|{5,9}|	5|
110	|{5,2}|	6|
111	|{5,2,9}|	7|

```java
class Solution {
    List<Integer> t = new ArrayList<Integer>();
    List<List<Integer>> ans = new ArrayList<List<Integer>>();
    public List<List<Integer>> subsets(int[] nums) {
        int n = nums.length;
        for (int mask = 0; mask < (1 << n); ++mask) {//左移乘2
            t.clear();
            for (int i = 0; i < n; ++i) {
                //i为数组长度
                //mask为二进制对应的数 0-2^n
                //1<<i左移位数　并且按位与(&) 当为1时证明当前数=mask
                if ((mask & (1 << i)) != 0) {//判断是否已经存在子集当中
                    t.add(nums[i]);
                }
            }
            ans.add(new ArrayList<Integer>(t));
        }
        return ans;
    }
}
```
>递归回溯，深度优先遍历

```java
class Solution {
    //存储
    List<Integer> t = new ArrayList<Integer>();
    List<List<Integer>> ans = new ArrayList<List<Integer>>();
    //方法入口
    public List<List<Integer>> subsets(int[] nums) {
        dfs(0, nums);
        return ans;
    }
    //深度遍历
    public void dfs(int cur, int[] nums) {
        if (cur == nums.length) {//递归结束条件
            ans.add(new ArrayList<Integer>(t));
            return;
        }
        t.add(nums[cur]);//添加到当前记录结果
        dfs(cur + 1, nums);//递归调用
        t.remove(t.size() - 1);//移除当前末尾元素
        dfs(cur + 1, nums);//递归调用
    }
}
```


</details>

# 动态规划

> 动态规划

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/coin-change/">零钱兑换(中等)</a></span></summary>
  <br>

>动态规划、状态转移方程　F(S)=F(S-C)+1

![](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/coin-change.jpeg)


例子2：假设


coins = [1, 2, 3], amount = 6

![](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/coin-change-1.jpeg)

在上图中，可以看到：

```text
F(3)=min(F(3−c1),F(3−c2),F(3−c3))+1
    =min(F(3−1),F(3−2),F(3−3))+1  
    =min(F(2),F(1),F(0))+1  
    =min(1,1,0)+1  
    =1
```

代码实现

```java
public class Solution {
    public int coinChange(int[] coins, int amount) {
        int max = amount + 1;
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, max);//填充
        dp[0] = 0;//basecase
        for (int i = 1; i <= amount; i++) {
            for (int j = 0; j < coins.length; j++) {
                if (coins[j] <= i) {
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
}
```


</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">斐波那契数列(简单)</a></span></summary>
  <br>

```java
class Solution {
    public int fib(int n) {
        if (n == 0) return 0;
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
            dp[i] %= 1000000007;
        }
        return dp[n];
    }
}
```

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof">礼物的最大价值(中等)</a></span></summary>
  <br>

礼物的最大价值

题目描述

> 在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？

       

示例

输入:
> \[   &emsp;\[1,3,1],  
  &emsp;\[1,5,1],  
  &emsp;\[4,2,1]  
]

输出: 12 解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物

解题思路

动态规划+dp数组，自底向上，状态转移方程 `f(i, j) = max{f(i - 1, j), f(i, j - 1)} + grid[i][j]`

```java
class Solution {
    public int maxValue(int[][] grid) {
        int m = grid.length, n = grid[0].length;//获取数组长度
        int[] dp = new int[n + 1];//dp数组 最长长度为n+1 用于存放
        for (int i = 1; i <= m; i++) {//两层循环
            for (int j = 1; j <= n; j++) {
                dp[j] = Math.max(dp[j], dp[j - 1]) + grid[i - 1][j - 1];//结合状态转移方程
            }
        }
        return dp[n];
    }
}

```

</details>

<details>
  <summary><a href="https://leetcode-cn.com/problems/chou-shu-lcof"><span>丑数(中等)</span></a></summary>
  <br>

丑数
> 我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

示例
> 输入: n = 10 输出: 12 解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。

说明
> 1是丑数。 n 不超过1690。

解题思路

```text
状态定义： 设动态规划列表 dp ，dp[i] 代表第 i + 1 个丑数。
转移方程：
当索引 a, b, c 满足以下条件时， dp[i] 为三种情况的最小值；
每轮计算 dp[i] 后，需要更新索引 a, b, c 的值，使其始终满足方程条件。
实现方法：分别独立判断 dp[i] 和 dp[a]×2 , dp[b]×3 , dp[c]×5 的大小关系，若相等则将对应索引 a , b , c 加 1 。

dp[a]×2>dp[i−1]≥dp[a−1]×2  
dp[b]×3>dp[i−1]≥dp[b−1]×3  
dp[c]×5>dp[i−1]≥dp[c−1]×5  

得出公式=dp[i] = min(dp[a]×2,dp[b]×3,dp[c]×5)

初始状态： dp[0] = 1 ，即第一个丑数为 1.  
返回值： dp[n-1] ，即返回第 n 个丑数.
```

代码实现

```java
class Solution {
    public int nthUglyNumber(int n) {
        int a = 0, b = 0, c = 0;
        int[] dp = new int[n];//dp数组
        dp[0] = 1;
        for (int i = 1; i < n; i++) {
            int n2 = dp[a] * 2, n3 = dp[b] * 3, n5 = dp[c] * 5;//状态转移方程
            dp[i] = Math.min(n2, n3, n5);
            if (dp[i] == n2) a++;
            if (dp[i] == n3) b++;
            if (dp[i] == n5) c++;
        }
        return dp[n - 1];
    }
}
```

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof" >数组中的逆序对(困难)</a></span></summary>
  <br>

题目描述

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

 

示例

输入: [7,5,6,4]
输出: 5

解题思路

> 通过对数组进行排序

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">最长公共子序列(中等)</a></span></summary>
  <br>

给定两个字符串text1 和text2，返回这两个字符串的最长公共子序列的长度。

一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。

若这两个字符串没有公共子序列，则返回 0。

示例 1:
``````
输入：text1 = "abcde", text2 = "ace"
输出：3  
解释：最长公共子序列是 "ace"，它的长度为 3。
示例 2:

输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc"，它的长度为 3。
示例 3:

输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0。
``````

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length(), n = text2.length();
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j]);
                dp[i][j] = Math.max(dp[i][j - 1], dp[i][j]);
            }
        }
        return dp[m][n];
    }
}
```

</details>

<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II(简单)</a></span>
    </summary>

>动态规划　dp[i][1]=max{dp[i−1][1],dp[i−1][0]−prices[i]}

![](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/best-time-to-buy-and-sell-stock-ii.png)

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[][] dp = new int[n][2];
        //dp[i][j] 表示到下标为 i 的这一天，持股状态为 j 时，我们手上拥有的最大现金数。
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        for (int i = 1; i < n; ++i) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        }
        return dp[n - 1][0];
    }
    //优化
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int dp0 = 0, dp1 = -prices[0];
        for (int i = 1; i < n; ++i) {
            int newDp0 = Math.max(dp0, dp1 + prices[i]);
            int newDp1 = Math.max(dp1, dp0 - prices[i]);
            dp0 = newDp0;
            dp1 = newDp1;
        }
        return dp0;
    }
}
```

>贪心解法

```java
class Solution {
    public int maxProfit(int[] prices) {
        int ans = 0;
        int n = prices.length;
        for (int i = 1; i < n; ++i) {
            ans += Math.max(0, prices[i] - prices[i - 1]);
        }
        return ans;
    }
}
```


</details>


<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/unique-paths/">不同路径(中等)</a></span>
    </summary>

>dp方程 dp[i][j]=dp[i+1][j]+dp[i][j+1]

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];

        for (int i = 0; i < m; i++) dp[i][n-1]=1;
        for (int i = 0; i < n; i++) dp[m-1][i]=1;

        for (int i = m-2; i >=  0; i--) {
            for (int j = n-2; j >= 0; j--) {
                dp[i][j]=dp[i+1][j]+dp[i][j+1];
            }
        }
        return dp[0][0];
    }
}
```

</details>


<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/unique-paths-ii/">不同路径 II(中等)</a></span>
    </summary>

>一维数组压缩状态

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int n = obstacleGrid.length, m = obstacleGrid[0].length;
        int[] f = new int[m];
        f[0] = obstacleGrid[0][0] == 0 ? 1 : 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (obstacleGrid[i][j] == 1) {
                    f[j] = 0;
                    continue;
                }
                if (j - 1 >= 0 && obstacleGrid[i][j - 1] == 0) {//且没有障碍的时候在推导
                    f[j] += f[j - 1];
                }
            }
        }
        return f[m - 1];
    }
}
```

复杂度分析

- 时间复杂度：O(nm)O(nm)，其中 nn 为网格的行数，mm 为网格的列数。我们只需要遍历所有网格一次即可。
- 空间复杂度：O(m)O(m)。利用滚动数组优化，我们可以只用 O(m)O(m) 大小的空间来记录当前行的 ff 值。

</details>


<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">最长公共子序列(中等)</a></span>
    </summary>

>

$$状态转移方程=\begin{cases} dp[i][j]=dp[i-1][j-1]+1 & (str1[i]==str2[j])\\\\ dp[i][j]=max(dp[i-1][j],dp[i][j-1]) & (str1[i]!=str2[j])\\\\ \end{cases}$$ 

```java
class Solution {
    public int  longestCommonSubsequence(String text1, String text2) {
        char[] t1 = text1.toCharArray();
        char[] t2 = text2.toCharArray();
        int length1 = t1.length;
        int length2 = t2.length;
        int[][] dp = new int[length1+1][length2+1];
        //求dp
        for (int i = 1; i < length1 +1; i++) {
            for (int j = 1; j < length2 +1; j++) {
                if (t1[i-1] == t2[j-1]){
                    // 这边找到一个 lcs 的元素，继续往前找
                    dp[i][j] = 1+ dp[i-1][j-1];
                }else {
                    //谁能让 lcs 最长，就听谁的
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[length1][length2];
    }
}
```

</details>


<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/triangle/">三角形最小路径和(中等)</a></span>
    </summary>

>由于每一步只能移动到下一行「相邻的节点」上，因此要想走到位置 (i, j)(i,j)，上一步就只能在位置 (i - 1, j - 1)(i−1,j−1) 或者位置 (i - 1, j)(i−1,j)

>状态转移方程=f[i][j]=min(f[i−1][j−1],f[i−1][j])+c[i][j]      其中c[i][j] 表示位置 (i, j)(i,j) 对应的元素值

```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int n = triangle.size();
        int[][] f = new int[n][n];
        f[0][0] = triangle.get(0).get(0);
        for (int i = 1; i < n; ++i) {
            f[i][0] = f[i - 1][0] + triangle.get(i).get(0);
            for (int j = 1; j < i; ++j) {
                f[i][j] = Math.min(f[i - 1][j - 1], f[i - 1][j]) + triangle.get(i).get(j);
            }
            f[i][i] = f[i - 1][i - 1] + triangle.get(i).get(i);
        }
        int minTotal = f[n - 1][0];
        for (int i = 1; i < n; ++i) {
            minTotal = Math.min(minTotal, f[n - 1][i]);
        }
        return minTotal;
    }
}
```

</details>


<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/maximum-subarray/">最大子序和(简单)</a></span>
    </summary>

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

>状态转移方程 f(i)=max{f(i−1)+nums[i],nums[i]}

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int pre = 0, maxAns = nums[0];
        for (int x : nums) {
            pre = Math.max(pre + x, x);
            maxAns = Math.max(maxAns, pre);
        }
        return maxAns;
    }
}
```

</details>


<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/maximum-product-subarray/description/">乘积最大子数组(中等)</a></span>
    </summary>

![](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/maximum-product-subarray.png)

```java
class Solution {
    public int maxProduct(int[] nums) {
        int length = nums.length;
        int[] maxF = new int[length];
        int[] minF = new int[length];
        System.arraycopy(nums, 0, maxF, 0, length);
        System.arraycopy(nums, 0, minF, 0, length);
        for (int i = 1; i < length; ++i) {
            maxF[i] = Math.max(maxF[i - 1] * nums[i], Math.max(nums[i], minF[i - 1] * nums[i]));
            minF[i] = Math.min(minF[i - 1] * nums[i], Math.min(nums[i], maxF[i - 1] * nums[i]));
        }
        int ans = maxF[0];
        for (int i = 1; i < length; ++i) {
            ans = Math.max(ans, maxF[i]);
        }
        return ans;
    }
    //优化
    public int maxProduct(int[] nums) {
        int maxF = nums[0], minF = nums[0], ans = nums[0];
        int length = nums.length;
        for (int i = 1; i < length; ++i) {
            int mx = maxF, mn = minF;
            maxF = Math.max(mx * nums[i], Math.max(nums[i], mn * nums[i]));
            minF = Math.min(mn * nums[i], Math.min(nums[i], mx * nums[i]));
            ans = Math.max(maxF, ans);
        }
        return ans;
    }
}
```

</details>


<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/house-robber/">打家劫舍(中等)</a></span>
    </summary>

```java
class Solution {
    public int rob(int[] nums) {
        //dp[i]=max(nums[i]+dp[i-2],dp[i-1])
        if(nums==null||nums.length==0)return 0;
        if(nums.length==1)return nums[0];
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0],nums[1]);
        for(int i=2;i<nums.length;i++){
            dp[i]=Math.max(nums[i]+dp[i-2],dp[i-1]);
        }
        return dp[nums.length-1];
    }
}
```

</details>



<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/house-robber-ii/">打家劫舍 II(中等)</a></span>
    </summary>

```java
class Solution {
    public int rob(int[] nums) {
        if(nums.length==1)return nums[0];
        if(nums.length==2)return Math.max(nums[0],nums[1]);
        //分为两组
        return Math.max(robRange(nums,0,nums.length-2),robRange(nums,1,nums.length-1));
    }
    public int robRange(int[] nums,int start,int end){
        int first = nums[start],second = Math.max(nums[start],nums[start+1]);
        for(int i=start+2;i<=end;i++){
            int tmp = second;
            second = Math.max(nums[i]+first,second);
            first = tmp;
        }
        return second;
    }
}
```

</details>


<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/delete-and-earn/">删除并获得点数(中等)</a></span>
    </summary>

```java
class Solution {
    public int deleteAndEarn(int[] nums) {
        int maxVal = 0;
        //找出最大值
        for (int val : nums) {
            maxVal = Math.max(maxVal, val);
        }
        //构建数组(每个数有的个数)
        int[] sum = new int[maxVal + 1];
        for (int val : nums) {
            sum[val] += val;
        }
        return rob(sum);
    }

    public int rob(int[] nums) {
        int size = nums.length;
        int first = nums[0], second = Math.max(nums[0], nums[1]);
        for (int i = 2; i < size; i++) {
            int temp = second;
            second = Math.max(first + nums[i], second);
            first = temp;
        }
        return second;
    }
}
```

</details>


<details>
    <summary>
        <span><a href="">回文串(中等)</a></span>
    </summary>

>思路1:中间向两边扩散，遍历字符数组，时间复杂度O(n^2)

>思路2:对于一个子串而言，如果它是回文串，并且长度大于 2，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串 “ababa”，如果我们已经知道 “bab” 是回文串，那么 “ababa” 一定是回文串，这是因为它的首尾两个字母都是 “a”。
得出状态转移方程 `P(i,j)=P(i+1,j−1)∧(Si==Sj)`也就是说，只有 s[i+1:j-1]s[i+1:j−1] 是回文串，并且 ss 的第 i 和 j 个字母相同时，s[i:j]s[i:j] 才会是回文串。时间复杂度O(n^2)

```java
public class Solution {

    //dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]
    public String longestPalindrome(String s) {
        int len = s.length();
        //特殊情况
        if (len < 2) {
            return s;
        }

        int maxLen = 1;
        int begin = 0;
        // dp[i][j] 表示 s[i..j] 是否是回文串
        boolean[][] dp = new boolean[len][len];
        // 初始化：所有长度为 1 的子串都是回文串
        for (int i = 0; i < len; i++) {
            dp[i][i] = true;
        }

        char[] charArray = s.toCharArray();
        // 递推开始
        // 先枚举子串长度（先一列一列的填，在一行一行填）
        for (int L = 2; L <= len; L++) {
            // 枚举左边界，左边界的上限设置可以宽松一些
            for (int i = 0; i < len; i++) {
                // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得
                int j = L + i - 1;
                // 如果右边界越界，就可以退出当前循环
                if (j >= len) {
                    break;
                }
                //如果字符不相等
                if (charArray[i] != charArray[j]) {
                    dp[i][j] = false;
                } else {
                    //
                    if (j - i < 3) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }

                // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置
                if (dp[i][j] && j - i + 1 > maxLen) {
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substring(begin, begin + maxLen);
    }
}
```

> 马拉车算法

```java

```

</details>


<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/">最长定差子序列(中等)</a></span>
    </summary>

>我们从头遍历数组，遇到一个数 x，判断 x-d 在不在数组里面即可知道，能不能形成以 x 为结尾的等差数组，同时，我们记录下来以 x 结尾的等差数组的长度，这样，在后续的遍历过程中，我们就可以使用得上这个长度了。
 
 我们来举个例子，假设给定数组为 [1,5,3,6,5,7]，等差 d=2，辅助数组为 dp，求解的过程如下：
 
 遍历到 1，发现 1-2=-1 不在 dp 数组，记录 dp[1] = 1，表示以 1 结尾的等差数列只有 1 个数；
 遍历到 5，发现 5-2=3 不在 dp 数组，记录 dp[5]=1；
 遍历到 3，发现 3-2=1 在 dp 数组且以 1 结尾的等差数列长度为 1，所以，记录 dp[3]=dp[3-2]+1=2，表示以 3 结尾的等差数列长度为 2；
 遍历到 6，发现 6-2=4 不在 dp 数组，记录 dp[6]=1；
 遍历到 5，发现 5-2=3 在 dp 数组，记录 dp[5]=dp[5-2]+1=3；
 遍历到 7，发现 7-2=5 在 dp 数组，记录 dp[7]=dp[7-2]+1=4；
 取 dp 数组中的最大值，即 4，所以，最长等差子序列的长度为 4。
 这其实就是动态规划的递推过程，所以，我们可以定义动态规划如下：
 
 状态定义：dp[x] 表示以 x 结尾的最长等差子序列的长度；
 状态转移：dp[x]=dp[x-d]+1；
 初始值：无；


```java
class Solution {
    public int longestSubsequence(int[] arr, int difference) {
        int ans = 0;
        Map<Integer, Integer> dp = new HashMap<Integer, Integer>();
        for (int v : arr) {
            dp.put(v, dp.getOrDefault(v - difference, 0) + 1);
            ans = Math.max(ans, dp.get(v));
        }
        return ans;
    }
}
```

</details>

<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">分割等和子集(中等)</a></span>
    </summary>
给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

思路:
>转化为求当前数组元素和==所有元素和/2，进一步转化为背包问题，将数组元素装入total_sum/2的背包中，通过动态规划求解
> 
> 

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int n = nums.length;
        if (n < 2) {
            return false;
        }
        int sum = 0, maxNum = 0;
        for (int num : nums) {
            sum += num;
            maxNum = Math.max(maxNum, num);
        }
        if (sum % 2 != 0) {
            return false;
        }
        int target = sum / 2;
        if (maxNum > target) {
            return false;
        }
        boolean[] dp = new boolean[target + 1];
        dp[0] = true;
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            for (int j = target; j >= num; --j) {
                dp[j] |= dp[j - num];
            }
        }
        return dp[target];
    }
}
```

</details>

# 数组类型

> 数组类型题目一般可以考虑排序来帮助

<details>
  <summary><span><a href="">大整数相加(简单)</a></span></summary>
  <br>

<p class="note note-primary">
解题思路： 使用数组存储
</p>

我们以 426 709 752 31 8 + 95481 253 129 为例,来看看大整数相加的详细步骤。

第1步, 创建两个整型数组,数组长度是较大整数的位数+1。把每一个整数倒序存储到数组中,整数的个位存于数组下标为0的位置,最高位存于数组的尾部。之所以倒序存储,是因为这样更符合从左到右访问数组的习惯。

![大整数相加](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/big-integer-1.png)

第2步, 创建结果数组,结果数组的长度同样是较大整数的位数+1,+1的目的很明显,是给最高位进位预留的。

![大整数相加](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/big-integer-2.png)

第3步, 遍历两个数组,从左到右按照对应下标把元素两两相加,就像小学生计算竖式一样。

在本示例中,最先相加的是数组A的第1个元素8和数组B的第1个元素9,结果是7,进位1。把7填充到result数组的对应下标位置,进位的1填充到下一个位置。

![大整数相加](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/big-integer-3.png)

第2组相加的是数组A的第2个元素1和数组B的第2个元素2,结果是3, 再加上刚才的进位1,把4填充到result数组的对应下标位置。

![大整数相加](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/big-integer-4.png)

第3组相加的是数组A的第3个元素3和数组B的第3个元素1,结果是4,把4填充到result数组的对应下标位置。

![大整数相加](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/big-integer-5.png)

第4组相加的是数组A的第4个元素2和数组B的第4个元素3,结果是5,把5填充到result数组的对应下标位置。

![大整数相加](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/big-integer-6.png)

以此类推......一直把数组的所有元素都相加完毕。

![大整数相加](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/big-integer-7.png)

第4步, 把result数组的全部元素再次逆序,去掉首位的0,就是最终结果。

![大整数相加](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/big-integer-8.png)

需要说明的是,为两个大整数建立临时数组,是一种直观的解决方案。若想节省内存空间,也可以不创建这两个临时数组。

<p class="note note-danger">
代码实现
</p>

```java
class Solution {
    public static String bigNumberSum(String bigNumberA, String bigNumberB) {
        //1.把两个大整数用数组逆序存储，数组长度等于较大整数位数+1
        int maxLength = bigNumberA.length() > bigNumberB.length() ? bigNumberA.length() : bigNumberB.length();
        int[] arrayA = new int[maxLength + 1];//+1是为了考虑到进位的问题
        //逆序存储
        for (int i = 0; i < bigNumberA.length(); i++) {
            arrayA[i] = bigNumberA.charAt(bigNumberA.length() - 1 - i) - '0';
        }
        int[] arrayB = new int[maxLength + 1];//+1是为了考虑到进位的问题
        for (int i = 0; i < bigNumberB.length(); i++) {
            arrayB[i] = bigNumberA.charAt(bigNumberB.length() - 1 - i) - '0';
        }
        //2.构建result数组，数组长度等于较大整数位置+1
        int[] result = new int[maxLength + 1];
        //3.遍历数组按位相加
        for (int i = 0; i < result.length; i++) {
            int temp = result[i];
            temp += arrayA[i];
            temp += arrayB[i];
            //判断是否进位
            if (temp > 10) {
                temp = temp - 10;
                result[i + 1] = 1;
            }
            result[i] = temp;
        }
        //4.把数组再次逆序并转为字符串
        StringBuilder sb = new StringBuilder();
        //是否找到大整数的最高有效位
        boolean findFirst = false;
        for (int i = result.length - 1; i >= 0; i--) {
            if (!findFirst) {
                if (result[i] == 0) continue;
                findFirst = true;
            }
            sb.append(result[i]);
        }
        return sb.toString();
    }
}
```

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/move-zeroes/">移动零(简单)</a></span></summary>
  <br>

题目
> 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例:
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
说明:
必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。


解题思路
> 使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。 右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。 注意到以下性质：

1. 左指针左边均为非零数；
2. 右指针左边直到左指针处均为零。 因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int n = nums.length, left = 0, right = 0;
        while (right < n) {
            if (nums[right] != 0) {
                swap(nums, left, right);
                left++;
            }
            right++;
        }
    }

    public void swap(int[] nums, int left, int right) {
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
}
```

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/container-with-most-water/">盛最多水的容器(简单)</a></span></summary>
  <br>

解题思路
> 1.采用两层循环，时间复杂度O(n^2)
> 2.双指针首尾比较,如果比当前的高度小直接跳过比较(过滤),否则进行运算比较

```java
public class Solution {
    public int maxArea(int[] height) {
        int l = 0, r = height.length - 1;
        int ans = 0;
        while (l < r) {
            int area = Math.min(height[l], height[r]) * (r - l);
            ans = Math.max(ans, area);
            if (height[l] <= height[r]) {
                ++l;
            } else {
                --r;
            }
        }
        return ans;
    }
}
```

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/3sum/">三数之和(中等)</a></span></summary>
  <br>

解题思路
> 排序+指针移动

![图解](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/2124b524439bcf0eb159ba43be4420c76f60ff2b3b51f87de269c001a323ea1a-Video_2019-06-19_192352.gif)

代码实现

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        int n = nums.length;
        Arrays.sort(nums);
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        // 枚举 a
        for (int first = 0; first < n; ++first) {
            // 需要和上一次枚举的数不相同
            if (first > 0 && nums[first] == nums[first - 1]) {
                continue;
            }
            // c 对应的指针初始指向数组的最右端
            int third = n - 1;
            int target = -nums[first];
            // 枚举 b
            for (int second = first + 1; second < n; ++second) {
                // 需要和上一次枚举的数不相同
                if (second > first + 1 && nums[second] == nums[second - 1]) {
                    continue;
                }
                // 需要保证 b 的指针在 c 的指针的左侧
                while (second < third && nums[second] + nums[third] > target) {
                    --third;
                }
                // 如果指针重合，随着 b 后续的增加
                // 就不会有满足 a+b+c=0 并且 b<c 的 c 了，可以退出循环
                if (second == third) {
                    break;
                }
                if (nums[second] + nums[third] == target) {
                    List<Integer> list = new ArrayList<Integer>();
                    list.add(nums[first]);
                    list.add(nums[second]);
                    list.add(nums[third]);
                    ans.add(list);
                }
            }
        }
        return ans;
    }
}
```

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/rotate-array/">旋转数组(中等)</a></span></summary>
  <br>
解题思路
>

代码实现

```java
class Solution {
    //暴力破解
    public void rotate(int[] nums, int k) {
        for (int i = k; i > 0; i--) {
            int last = nums[nums.length - 1];
            for (int j = nums.length - 1; j > 0; j--) {
                nums[j] = nums[j - 1];
            }
            nums[0] = last;
        }
    }

    //使用额外的数组
    public void rotate(int[] nums, int k) {
        int[] arr = new int[nums.length];
        for (int i = 0; i < nums.length; i++) {
            arr[(i + k) % nums.length] = nums[i];
        }
        for (int i = 0; i < nums.length; i++) nums[i] = arr[i];
    }

    //反转
    public void rotate(int[] nums, int k) {
        k %= nums.length;
        reverse(nums, 0, nums.length - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.length - 1);
    }

    //反转
    public void reverse(int[] nums, int start, int end) {
        while (start < end) {
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start++;
            end--;
        }
    }
    //TODO:使用环状替换
}
```

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/plus-one/">加一(简单)</a></span></summary>
  <br>

```java
class Solution {
    public int[] plusOne(int[] digits) {
        for (int i = digits.length - 1; i >= 0; i--) {
            digits[i]++;
            digits[i] = digits[i] % 10;
            if (digits[i] != 0) return digits;
        }
        digits = new int[digits.length + 1];
        digits[0] = 1;
        return digits;
    }
}
```

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">删除排序数组中的重复项(简单)</a></span></summary>
  <br>

> > 方法：双指针法

数组完成排序后，我们可以放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。只要 nums[i] = nums[j]，我们就增加 j 以跳过重复项。

当我们遇到 nums[j]!=nums[i] 时，跳过重复项的运行已经结束，因此我们必须把它（nums[j]）的值复制到 nums[i+1]。然后递增 i，接着我们将再次重复相同的过程，直到 j 到达数组的末尾为止。

Java

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        if (nums.length == 0) return 0;
        int i = 0;
        for (int j = 1; j < nums.length; j++) {
            if (nums[j] != nums[i]) {
                i++;
                nums[i] = nums[j];
            }
        }
        return i + 1;
    }
}
```

复杂度分析

时间复杂度：O(n)O(n)，假设数组的长度是 nn，那么 ii 和 jj 分别最多遍历 nn 步。

空间复杂度：O(1)O(1)。

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">柱状图中最大的矩形(困难)</a></span></summary>
  <br>

题目描述
> 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。

解题思路
>

代码实现

```java

```

</details>

# 栈结构型

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/valid-parentheses/">有效的括号(简单)</a></span></summary>
  <br>
解题思路
>通过使用栈结构，当为左括号压栈，右括号出栈判断

实现代码

```java
class Solution {
    public boolean isValid(String s) {
        if (s.length() % 2 != 0) return false;
        Stack<Character> stack = new Stack<>();
        for (char c : s.toCharArray()) {
            if (c == '(' || c == '[' || c == '{') stack.push(c);
            else if (!stack.isEmpty()) {
                Character pop = stack.pop();
                if (check(pop, c)) continue;
                else {
                    stack.push(pop);
                    stack.push(c);
                }
            } else return false;
        }
        return stack.isEmpty();
    }

    //检查
    public boolean check(char a, char b) {
        if ((a == '{' && b == '}') || (a == '[' && b == ']') || (a == '(' && b == ')')) return true;
        return false;
    }
}
```


</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">柱状图中最大的矩形(困难)</a></span></summary>
  <br>

> 使用单调栈进行实现

单调栈 单调栈分为单调递增栈和单调递减栈

    1. 单调递增栈即栈内元素保持单调递增的栈
    2. 同理单调递减栈即栈内元素保持单调递减的栈

操作规则（下面都以单调递增栈为例）

    1. 如果新的元素比栈顶元素大，就入栈
    2. 如果新的元素较小，那就一直把栈内元素弹出来，直到栈顶比新元素小

加入这样一个规则之后，会有什么效果

    1. 栈内的元素是递增的
    2. 当元素出栈时，说明这个新元素是出栈元素向后找第一个比其小的元素

> 举个例子，配合下图，现在索引在 6 ，栈里是 1 5 6 。 接下来新元素是 2 ，那么 6 需要出栈。 当 6 出栈时，右边 2 代表是 6 右边第一个比 6 小的元素。

当元素出栈后，说明新栈顶元素是出栈元素向前找第一个比其小的元素
> 当 6 出栈时，5 成为新的栈顶，那么 5 就是 6 左边第一个比 6 小的元素。

代码模板

```c++
stack<int> st;
for(int i = 0; i < nums.size(); i++)
{
	while(!st.empty() && st.top() > nums[i])
	{
		st.pop();
	}
	st.push(nums[i]);
}
```

画图理解

![](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/cfx.png)

思路
> 对于一个高度，如果能得到向左和向右的边界 那么就能对每个高度求一次面积 遍历所有高度，即可得出最大面积
`使用单调栈，在出栈操作时得到前后边界并计算面积`

答题

```c++
int largestRectangleArea(vector<int>& heights)
{
    int ans = 0;
    vector<int> st;
    heights.insert(heights.begin(), 0);
    heights.push_back(0);
    for (int i = 0; i < heights.size(); i++)
    {
        while (!st.empty() && heights[st.back()] > heights[i])
        {
            int cur = st.back();
            st.pop_back();
            int left = st.back() + 1;
            int right = i - 1;
            ans = max(ans, (right - left + 1) * heights[cur]);
        }
        st.push_back(i);
    }
    return ans;
}
```

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        int n = heights.length;
        int[] left = new int[n];
        int[] right = new int[n];
        Arrays.fill(right, n);

        Stack<Integer> mono_stack = new Stack<Integer>();
        for (int i = 0; i < n; ++i) {
            while (!mono_stack.isEmpty() && heights[mono_stack.peek()] >= heights[i]) {
                right[mono_stack.peek()] = i;
                mono_stack.pop();
            }
            left[i] = (mono_stack.isEmpty() ? -1 : mono_stack.peek());
            mono_stack.push(i);
        }

        int ans = 0;
        for (int i = 0; i < n; ++i) {
            ans = Math.max(ans, (right[i] - left[i] - 1) * heights[i]);
        }
        return ans;
    }
}
```

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/trapping-rain-water/">接雨水(困难)</a></span></summary>
  <br>

> 暴力解法、优化、双指针、[单调栈](https://leetcode-cn.com/problems/trapping-rain-water/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-8/)

![单调栈](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jys.png)

```java
class Solution {
    public int trap6(int[] height) {
        int sum = 0;
        Stack<Integer> stack = new Stack<>();
        int current = 0;
        while (current < height.length) {
            //如果栈不空并且当前指向的高度大于栈顶高度就一直循环
            while (!stack.empty() && height[current] > height[stack.peek()]) {
                int h = height[stack.peek()]; //取出要出栈的元素
                stack.pop(); //出栈
                if (stack.empty()) { // 栈空就出去
                    break;
                }
                int distance = current - stack.peek() - 1; //两堵墙之前的距离。
                int min = Math.min(height[stack.peek()], height[current]);
                sum = sum + distance * (min - h);
            }
            stack.push(current); //当前指向的墙入栈
            current++; //指针后移
        }
        return sum;
    }
}
```

</details>


<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/trapping-rain-water-ii">接雨水 II(困难)</a></span>
    </summary>

- 该方块不为最外层的方块；
- 该方块自身的高度比其上下左右四个相邻的方块接水后的高度都要低；

>我们假设初始时矩阵的每个格子都接满了水，其高度均为maxHeight,其中maxHeight为矩阵中高度最高的格子。我们知道方块接水后的高度为water[i][j],他的求解公式，方块(i,j)的接水的高度为:
`water[i][j]=max(heightMap[i],min(water[i−1][j],water[i+1][j],water[i][j−1],water[i][j+1]))`
我们知道方块 (i,j)(i,j) 实际接水的容量计算公式为 water[i][j] - heightMap[i][j]
我们首先假设每个方块 (i,j) 的接水后的高度均为 water[i][j] = maxHeight，首先我们知道最外层的方块的肯定不能接水，所有的多余的水都会从最外层的方块溢出，我们每次发现当前方块 (i,j) 的接水高度 water[i][j] 小于与它相邻的 4 个模块的接水高度时，则我们将进行调整接水高度，我们将其相邻的四个方块的接水高度调整与 (i,j) 的高度保持一致，我们不断重复的进行调整，直到所有的方块的接水高度不再有调整时即为满足要求。


```java
class Solution {
    public int trapRainWater(int[][] heightMap) {
        int m = heightMap.length;
        int n = heightMap[0].length;
        //方向数组　把dx和dy压缩成一维来做
        int[] dirs = {-1, 0, 1, 0, -1};
        int maxHeight = 0;
        //找出最大值
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                maxHeight = Math.max(maxHeight, heightMap[i][j]);
            }
        }
        //全部设置为最大值
        int[][] water = new int[m][n];
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j){
                water[i][j] = maxHeight;      
            }
        }  
        //构建队列
        Queue<int[]> qu = new LinkedList<>();
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (i == 0 || i == m - 1 || j == 0 || j == n - 1) {//最外一圈
                    if (water[i][j] > heightMap[i][j]) {
                        water[i][j] = heightMap[i][j];
                        qu.offer(new int[]{i, j});
                    }
                }
            }
        } 
        //广度优先遍历
        while (!qu.isEmpty()) {
            int[] curr = qu.poll();
            int x = curr[0];
            int y = curr[1];
            //搜索四个方向
            for (int i = 0; i < 4; ++i) {
                //四周坐标
                int nx = x + dirs[i], ny = y + dirs[i + 1];
                //坐标越界
                if (nx < 0 || nx >= m || ny < 0 || ny >= n) {
                    continue;
                }
                //如果当前坐标水位 < 某一个方向水位　&& 某一个水位 > 矩阵中高度
                if (water[x][y] < water[nx][ny] && water[nx][ny] > heightMap[nx][ny]) {
                    //当前水位还可以进行装
                    water[nx][ny] = Math.max(water[x][y], heightMap[nx][ny]);
                    qu.offer(new int[]{nx, ny});
                }
            }
        }

        int res = 0;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                res += water[i][j] - heightMap[i][j];
            }
        }
        return res;
    }
}
```

</details>

<details>
    <summary>
        <span><a href="">每日温度(中等)</a></span>
    </summary>

>暴力解法 + 单调栈

</details>


<details>
    <summary>
        <span><a href="">下一个更大元素(简单)</a></span>
    </summary>

>暴力解法、单调栈

</details>


<details>
    <summary>
        <span><a href="">去除重复字母(困难)</a></span>
    </summary>

>栈 + 哨兵技巧（Java、C++、Python）

</details>


<details>
    <summary>
        <span><a href="">股票价格跨度(中等)</a></span>
    </summary>

>单调栈

</details>


<details>
    <summary>
        <span><a href="">移掉K位数字()</a></span>
    </summary>

>

</details>


<details>
    <summary>
        <span><a href="">最短无序连续子数组()</a></span>
    </summary>



</details>

# 队列类型

<details>
  <summary><span><a href="http://leetcode-cn.com/problems/min-stack">最小栈(简单)</a></span></summary>
  <br>

解题思路
> 使用辅助队列或者栈进行实现，入栈时判断当前是否小于最小栈或队列的值，小于则置于栈顶，否则插入相同栈顶元素，出栈队时两个都出

代码实现１

```java
class MinStack {
    Stack<Integer> stackA;
    Stack<Integer> stackB;

    /** initialize your data structure here. */
    public MinStack() {
        this.stackA = new Stack<>();
        this.stackB = new Stack<>();
        stackB.push(Integer.MAX_VALUE);
    }

    public void push(int x) {
        stackA.push(x);
        Integer peek = stackB.peek();
        if (x < peek) stackB.push(x);
        else stackB.push(peek);
    }

    public void pop() {
        stackA.pop();
        stackB.pop();
    }

    public int top() {
        return stackA.peek();
    }

    public int getMin() {
        return stackB.peek();
    }
}
```

实现代码2

```java
class MinStack {
    Deque<Integer> xStack;
    Deque<Integer> minStack;

    public MinStack() {
        xStack = new LinkedList<Integer>();
        minStack = new LinkedList<Integer>();
        minStack.push(Integer.MAX_VALUE);
    }

    public void push(int x) {
        xStack.push(x);
        minStack.push(Math.min(minStack.peek(), x));
    }

    public void pop() {
        xStack.pop();
        minStack.pop();
    }

    public int top() {
        return xStack.peek();
    }

    public int getMin() {
        return minStack.peek();
    }
}
```

</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">滑动窗口最大值(困难)</a></span></summary>
  <br>

> 暴力破解(时间超时),双向队列,动态规划

```text
处理前 k 个元素，初始化双向队列。队列存储的是数组元素下标
遍历整个数组。在每一步 :
清理双向队列 :
  - 只保留当前滑动窗口中有的元素的索引。
  - 移除比当前元素小的所有元素，它们不可能是最大的。
将当前元素添加到双向队列中。
将 deque[0] 添加到输出中。
返回输出数组。
```

```java
class Solution {
    ArrayDeque<Integer> deq = new ArrayDeque<Integer>();
    int[] nums;

    public void clean_deque(int i, int k) {
        // remove indexes of elements not from sliding window
        if (!deq.isEmpty() && deq.getFirst() == i - k) deq.removeFirst();//如果是队头直接移除
        // remove from deq indexes of all elements 
        // which are smaller than current element nums[i]
        while (!deq.isEmpty() && nums[i] > nums[deq.getLast()]) deq.removeLast();//将小于num[i]的元素全部从尾部出队
    }

    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        if (n * k == 0) return new int[0];
        if (k == 1) return nums;
        // init deque and output
        this.nums = nums;
        int max_idx = 0;
        for (int i = 0; i < k; i++) {//先构建一个k长度的双端队列
            clean_deque(i, k);
            deq.addLast(i);
            // compute max in nums[:k]
            if (nums[i] > nums[max_idx]) max_idx = i;
        }
        int[] output = new int[n - k + 1];
        output[0] = nums[max_idx];//初始化第一个最大值
        // build output
        for (int i = k; i < n; i++) {
            clean_deque(i, k);
            deq.addLast(i);
            output[i - k + 1] = nums[deq.getFirst()];//每次从对头获取最大值
        }
        return output;
    }
}
```

</details>

<details>
  <summary><span><a href="">设计循环双端队列(中等)</a></span></summary>
  <br>

```java
public class MyCircularDeque {

    // 1、不用设计成动态数组，使用静态数组即可
    // 2、设计 head 和 tail 指针变量
    // 3、head == tail 成立的时候表示队列为空
    // 4、tail + 1 == head

    private int capacity;
    private int[] arr;
    private int front;
    private int rear;

    /**
     * Initialize your data structure here. Set the size of the deque to be k.
     */
    public MyCircularDeque(int k) {
        capacity = k + 1;
        arr = new int[capacity];

        // 头部指向第 1 个存放元素的位置
        // 插入时，先减，再赋值
        // 删除时，索引 +1（注意取模）
        front = 0;
        // 尾部指向下一个插入元素的位置
        // 插入时，先赋值，再加
        // 删除时，索引 -1（注意取模）
        rear = 0;
    }

    /**
     * Adds an item at the front of Deque. Return true if the operation is successful.
     */
    public boolean insertFront(int value) {
        if (isFull()) {
            return false;
        }
        front = (front - 1 + capacity) % capacity;
        arr[front] = value;
        return true;
    }

    /**
     * Adds an item at the rear of Deque. Return true if the operation is successful.
     */
    public boolean insertLast(int value) {
        if (isFull()) {
            return false;
        }
        arr[rear] = value;
        rear = (rear + 1) % capacity;
        return true;
    }

    /**
     * Deletes an item from the front of Deque. Return true if the operation is successful.
     */
    public boolean deleteFront() {
        if (isEmpty()) {
            return false;
        }
        // front 被设计在数组的开头，所以是 +1
        front = (front + 1) % capacity;
        return true;
    }

    /**
     * Deletes an item from the rear of Deque. Return true if the operation is successful.
     */
    public boolean deleteLast() {
        if (isEmpty()) {
            return false;
        }
        // rear 被设计在数组的末尾，所以是 -1
        rear = (rear - 1 + capacity) % capacity;
        return true;
    }

    /**
     * Get the front item from the deque.
     */
    public int getFront() {
        if (isEmpty()) {
            return -1;
        }
        return arr[front];
    }

    /**
     * Get the last item from the deque.
     */
    public int getRear() {
        if (isEmpty()) {
            return -1;
        }
        // 当 rear 为 0 时防止数组越界
        return arr[(rear - 1 + capacity) % capacity];
    }

    /**
     * Checks whether the circular deque is empty or not.
     */
    public boolean isEmpty() {
        return front == rear;
    }

    /**
     * Checks whether the circular deque is full or not.
     */
    public boolean isFull() {
        // 注意：这个设计是非常经典的做法
        return (rear + 1) % capacity == front;
    }
}
```

</details>

# 递归类型

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/generate-parentheses/">括号生成(中等)</a></span></summary>
  <br>

```text
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

 

示例：

输入：n = 3
输出：[
       "((()))",
       "(()())",
       "(())()",
       "()(())",
       "()()()"
     ]
```

>递归

![](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/khsc.png)

```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<String>();//存储结果
        generate(res, "", 0, 0, n);//函数入口
        return res;//返回结果
    }
    //count1统计“(”的个数，count2统计“)”的个数
    public void generate(List<String> res , String ans, int count1, int count2, int n){
        if(count1 > n || count2 > n) return;//递归结束条件
        if(count1 == n && count2 == n)  res.add(ans);//相等返回
        if(count1 >= count2){//左括号数量大于等于右括号
            String ans1 = new String(ans);
            generate(res, ans+"(", count1+1, count2, n);//增加左边个数
            generate(res, ans1+")", count1, count2+1, n);//增加右括号个数
        }
    }
}
```

>回溯思想、

```java
class Solution {
    
    public List<String> generateParenthesis(int n) {
        List<String> ans = new ArrayList<String>();
        backtrack(ans, new StringBuilder(), 0, 0, n);
        return ans;
    }
    //回溯函数
    public void backtrack(List<String> ans, StringBuilder cur, int open, int close, int max) {
        //递归结束条件
        if (cur.length() == max * 2) {
            ans.add(cur.toString());//添加入结果
            return;
        }
        //
        if (open < max) {
            cur.append('(');
            backtrack(ans, cur, open + 1, close, max);
            cur.deleteCharAt(cur.length() - 1);
        }
        //
        if (close < open) {
            cur.append(')');
            backtrack(ans, cur, open, close + 1, max);
            cur.deleteCharAt(cur.length() - 1);
        }
    }
}
```


</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/invert-binary-tree/">翻转二叉树(简单)</a></span></summary>
  <br>

```java
//利用前序遍历
class Solution {
        // 先序遍历--从顶向下交换
        public TreeNode invertTree(TreeNode root) {
            if (root == null) return null;
            // 保存右子树
            TreeNode rightTree = root.right;
            // 交换左右子树的位置
            root.right = invertTree(root.left);
            root.left = invertTree(rightTree);
            return root;
        }
    }

//利用中序遍历
class Solution {
    public TreeNode invertTree(TreeNode root) {
            if (root == null) return null;
            invertTree(root.left); // 递归找到左节点
            TreeNode rightNode= root.right; // 保存右节点
            root.right = root.left;
            root.left = rightNode;
            // 递归找到右节点 继续交换 : 因为此时左右节点已经交换了,所以此时的右节点为root.left
            invertTree(root.left); 
    }
}

//利用后序遍历
 class Solution {
        public TreeNode invertTree(TreeNode root) {
            // 后序遍历-- 从下向上交换
            if (root == null) return null;
            TreeNode leftNode = invertTree(root.left);
            TreeNode rightNode = invertTree(root.right);
            root.right = leftNode;
            root.left = rightNode;
            return root;
        }
    }

//利用层次遍历
   class Solution {
        public TreeNode invertTree(TreeNode root) {
            // 层次遍历--直接左右交换即可
            if (root == null) return null;
            Queue<TreeNode> queue = new LinkedList<>();
            queue.offer(root);
            while (!queue.isEmpty()){
                TreeNode node = queue.poll();
                TreeNode rightTree = node.right;
                node.right = node.left;
                node.left = rightTree;
                if (node.left != null){
                    queue.offer(node.left);
                }
                if (node.right != null){
                    queue.offer(node.right);
                }
            }
            return root;
        }
    }
```
</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">验证二叉搜索树(中等)</a></span></summary>
  <br>


```java
class Solution {
    long pre = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if (root == null) {
            return true;
        }
        // 访问左子树
        if (!isValidBST(root.left)) {
            return false;
        }
        // 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回 false；否则继续遍历。
        if (root.val <= pre) {
            return false;
        }
        pre = root.val;
        // 访问右子树
        return isValidBST(root.right);
    }
}
```
</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">二叉树的最大深度(简单)</a></span></summary>
  <br>

```java
class Solution {
    public int maxDepth(TreeNode root) {
        return root == null ? 0 : Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
```
</details>

<details>
  <summary><span><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">二叉树的最小深度(简单)</a></span></summary>
  <br>

```java
class Solution {
    public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    // null节点不参与比较
    if (root.left == null && root.right != null) {
        return 1 + minDepth(root.right);
    }
    // null节点不参与比较
    if (root.right == null && root.left != null) {
        return 1 + minDepth(root.left);
    }
    return 1 + Math.min(minDepth(root.left), minDepth(root.right));
    }
}
```
</details>

<details>
  <summary><span><a href="https://support.leetcode-cn.com/hc/kb/category/1018267/">二叉树的序列化与反序列化(困难)</a></span></summary>
  <br>

```java
public class Codec {
    public String rserialize(TreeNode root, String str) {
        if (root == null) {
            str += "None,";
        } else {
            str += str.valueOf(root.val) + ",";
            str = rserialize(root.left, str);
            str = rserialize(root.right, str);
        }
        return str;
    }
    //序列化
    public String serialize(TreeNode root) {
        return rserialize(root, "");
    }
    //
    public TreeNode rdeserialize(List<String> l) {
        if (l.get(0).equals("None")) {
            l.remove(0);
            return null;
        }
        TreeNode root = new TreeNode(Integer.valueOf(l.get(0)));
        l.remove(0);
        root.left = rdeserialize(l);
        root.right = rdeserialize(l);
        return root;
    }
    //反序列化
    public TreeNode deserialize(String data) {
        String[] data_array = data.split(",");
        List<String> data_list = new LinkedList<String>(Arrays.asList(data_array));
        return rdeserialize(data_list);
    }
}
```
</details>


<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/minesweeper/">扫雷游戏(中等)</a></span>
    </summary>

- 当前点击的是「未挖出的地雷」，我们将其值改为 \text{X}X 即可。
- 当前点击的是「未挖出的空方块」，我们需要统计它周围相邻的方块里地雷的数量 \textit{cnt}cnt（即 \text{M}M 的数量）。如果 \textit{cnt}cnt 为零，即执行规则 22，此时需要将其改为 \text{B}B，且递归地处理周围的八个未挖出的方块，递归终止条件即为规则 44，没有更多方块可被揭露的时候。否则执行规则 33，将其修改为数字即可。

```java
class Solution {
    int[] dirX = {0, 1, 0, -1, 1, 1, -1, -1};
    int[] dirY = {1, 0, -1, 0, 1, -1, 1, -1};

    public char[][] updateBoard(char[][] board, int[] click) {
        int x = click[0], y = click[1];
        if (board[x][y] == 'M') {
            // 规则 1
            board[x][y] = 'X';
        } else{
            dfs(board, x, y);
        }
        return board;
    }

    public void dfs(char[][] board, int x, int y) {
        int cnt = 0;
        for (int i = 0; i < 8; ++i) {
            int tx = x + dirX[i];
            int ty = y + dirY[i];
            if (tx < 0 || tx >= board.length || ty < 0 || ty >= board[0].length) {
                continue;
            }
            // 不用判断 M，因为如果有 M 的话游戏已经结束了
            if (board[tx][ty] == 'M') {
                ++cnt;
            }
        }
        if (cnt > 0) {
            // 规则 3
            board[x][y] = (char) (cnt + '0');
        } else {
            // 规则 2
            board[x][y] = 'B';
            for (int i = 0; i < 8; ++i) {
                int tx = x + dirX[i];
                int ty = y + dirY[i];
                // 这里不需要在存在 B 的时候继续扩展，因为 B 之前被点击的时候已经被扩展过了
                if (tx < 0 || tx >= board.length || ty < 0 || ty >= board[0].length || board[tx][ty] != 'E') {
                    continue;
                }
                dfs(board, tx, ty);
            }
        }
    }
}
```

</details>


<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/word-ladder/">单词接龙(困难)</a></span>
    </summary>
    
![](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/word-jielong.png)

>图的广度优先遍历

```java
class Solution {
    Map<String, Integer> wordId = new HashMap<String, Integer>();
    List<List<Integer>> edge = new ArrayList<List<Integer>>();
    int nodeNum = 0;

    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        for (String word : wordList) {
            addEdge(word);
        }
        addEdge(beginWord);
        if (!wordId.containsKey(endWord)) {
            return 0;
        }
        int[] dis = new int[nodeNum];
        Arrays.fill(dis, Integer.MAX_VALUE);
        int beginId = wordId.get(beginWord), endId = wordId.get(endWord);
        dis[beginId] = 0;

        Queue<Integer> que = new LinkedList<Integer>();
        que.offer(beginId);
        while (!que.isEmpty()) {
            int x = que.poll();
            if (x == endId) {
                return dis[endId] / 2 + 1;
            }
            for (int it : edge.get(x)) {
                if (dis[it] == Integer.MAX_VALUE) {
                    dis[it] = dis[x] + 1;
                    que.offer(it);
                }
            }
        }
        return 0;
    }

    public void addEdge(String word) {
        addWord(word);
        int id1 = wordId.get(word);
        char[] array = word.toCharArray();
        int length = array.length;
        for (int i = 0; i < length; ++i) {
            char tmp = array[i];
            array[i] = '*';
            String newWord = new String(array);
            addWord(newWord);
            int id2 = wordId.get(newWord);
            edge.get(id1).add(id2);
            edge.get(id2).add(id1);
            array[i] = tmp;
        }
    }

    public void addWord(String word) {
        if (!wordId.containsKey(word)) {
            wordId.put(word, nodeNum++);
            edge.add(new ArrayList<Integer>());
        }
    }
}
```

</details>

# 字典树型


<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">实现 Trie (前缀树)(中等)</a></span>
    </summary>

```java
class Trie {

    // 构造Trie树节点
    class TrieNode {

        // 标识该节点是否是字符串的结束节点
        boolean isEnd = false;
        // 当前节点的孩子节点
        TrieNode[] next = new TrieNode[26];

        // 设置当前节点为一个字符串的结束节点
        public void setIsEnd (boolean isEnd) {
            this.isEnd = isEnd;
        }

    }

    // root为根节点
    TrieNode root;

    /** Initialize your data structure here. */
    public Trie()  {
        root = new TrieNode();
    }
    
    /** Inserts a word into the trie. */
    public void insert(String word) {
        
        char[] chs = word.toCharArray();
        // 表示从根节点开始向下构建
        TrieNode node = root;
        for (int i = 0; i < chs.length; i++) {
            
            int u = chs[i] - 'a';
            // 判断node的子节点集合中是否已经存在了chs[i], 不存在则创建
            if (node.next[u] == null) 
                node.next[u] = new TrieNode();
            // 继续向下构建
            node = node.next[u];
        
        }

        // 当前TrieNode节点是一个字符串的结尾
        node.setIsEnd(true);

    }
    
    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        
        char[] chs = word.toCharArray();
        // 表示从根节点开始向下构建
        TrieNode node = root;
        for (int i = 0; i < chs.length; i++) {
            
            int u = chs[i] - 'a';
            // 判断node的子节点集合中是否已经存在了chs[i], 不存在则创建
            if (node.next[u] == null) 
                return false;
            // 继续向下构建
            node = node.next[u];
        
        }

        // 当前TrieNode节点是否一个字符串的结尾
        return node.isEnd;

    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {

        char[] chs = prefix.toCharArray();
        // 表示从根节点开始向下构建
        TrieNode node = root;
        for (int i = 0; i < chs.length; i++) {
            
            int u = chs[i] - 'a';
            // 判断node的子节点集合中是否已经存在了chs[i], 不存在则创建
            if (node.next[u] == null) 
                return false;
            // 继续向下构建
            node = node.next[u];
        
        }

        // 前缀查找成功
        return true;

    }
}
```

</details>

# 查并集类

>


<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/number-of-islands/">岛屿数量(中等)</a></span>
    </summary>

>

```java
class Solution {

    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }

        int nr = grid.length;
        int nc = grid[0].length;
        int num_islands = 0;
        UnionFind uf = new UnionFind(grid);
        for (int r = 0; r < nr; ++r) {
            for (int c = 0; c < nc; ++c) {
                if (grid[r][c] == '1') {
                    grid[r][c] = '0';
                    if (r - 1 >= 0 && grid[r-1][c] == '1') {
                        uf.union(r * nc + c, (r-1) * nc + c);
                    }
                    if (r + 1 < nr && grid[r+1][c] == '1') {
                        uf.union(r * nc + c, (r+1) * nc + c);
                    }
                    if (c - 1 >= 0 && grid[r][c-1] == '1') {
                        uf.union(r * nc + c, r * nc + c - 1);
                    }
                    if (c + 1 < nc && grid[r][c+1] == '1') {
                        uf.union(r * nc + c, r * nc + c + 1);
                    }
                }
            }
        }
        return uf.getCount();
    }
    //并查集
    class UnionFind {
        int count;
        int[] parent;
        int[] rank;

        public UnionFind(char[][] grid) {
            count = 0;
            int m = grid.length;
            int n = grid[0].length;
            parent = new int[m * n];
            rank = new int[m * n];
            for (int i = 0; i < m; ++i) {
                for (int j = 0; j < n; ++j) {
                    if (grid[i][j] == '1') {
                        parent[i * n + j] = i * n + j;
                        ++count;
                    }
                    rank[i * n + j] = 0;
                }
            }
        }

        public int find(int i) {
            if (parent[i] != i) parent[i] = find(parent[i]);
            return parent[i];
        }

        public void union(int x, int y) {
            int rootx = find(x);
            int rooty = find(y);
            if (rootx != rooty) {
                if (rank[rootx] > rank[rooty]) {
                    parent[rooty] = rootx;
                } else if (rank[rootx] < rank[rooty]) {
                    parent[rootx] = rooty;
                } else {
                    parent[rooty] = rootx;
                    rank[rootx] += 1;
                }
                --count;
            }
        }

        public int getCount() {
            return count;
        }
    }
}
```

</details>

# 二分查找


<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/sqrtx/">x 的平方根(简单)</a></span>
    </summary>

>二分查找

```java
class Solution {
    public int mySqrt(int x) {
        int l = 0, r = x, ans = -1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if ((long) mid * mid <= x) {
                ans = mid;
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return ans;
    }
}
```

>牛顿迭代法

```java
class Solution {
    public int mySqrt(int x) {
        if (x == 0) {
            return 0;
        }

        double C = x, x0 = x;
        while (true) {
            double xi = 0.5 * (x0 + C / x0);
            if (Math.abs(x0 - xi) < 1e-7) {
                break;
            }
            x0 = xi;
        }
        return (int) x0;
    }
}
```

</details>


<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/valid-perfect-square/">有效的完全平方数(简单)</a></span>
    </summary>

>二分查找

```java
class Solution {
    public boolean isPerfectSquare(int num) {
    int l = 0, r = num, ans = -1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if ((long) mid * mid == num) {
                return true;
            }else if ((long) mid * mid <= num) {
                ans = mid;
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return false;
    }
}
```

</details>


<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">搜索旋转排序数组(中等)</a></span>
    </summary>

>

```java
class Solution {
  public int findMin(int[] nums) {
    // If the list has just one element then return that element.
    if (nums.length == 1) {
      return nums[0];
    }
    // initializing left and right pointers.
    int left = 0, right = nums.length - 1;
    // if the last element is greater than the first element then there is no rotation.
    // e.g. 1 < 2 < 3 < 4 < 5 < 7. Already sorted array.
    // Hence the smallest element is first element. A[0]
    if (nums[right] > nums[0]) {
      return nums[0];
    }
    // Binary search way
    while (right >= left) {
      // Find the mid element
      int mid = left + (right - left) / 2;
      // if the mid element is greater than its next element then mid+1 element is the smallest
      // This point would be the point of change. From higher to lower value.
      // [4,5,6,7,0,1,2] mid=7的情况
      if (nums[mid] > nums[mid + 1]) {
        return nums[mid + 1];
      }
      // if the mid element is lesser than its previous element then mid element is the smallest
      // [4,5,6,7,0,1,2] mid=0的情况
      if (nums[mid - 1] > nums[mid]) {
        return nums[mid];
      }
      // if the mid elements value is greater than the 0th element this means
      // the least value is still somewhere to the right as we are still dealing with elements
      // greater than nums[0]
      if (nums[mid] > nums[0]) {
        left = mid + 1;
      } else {
        // if nums[0] is greater than the mid value then this means the smallest value is somewhere to
        // the left
        right = mid - 1;
      }
    }
    return -1;
  }
}
```

</details>



<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/">搜索二维矩阵(中等)</a></span>
    </summary>

>二分查找，将其看做一个有序一维数组,`row = idx / n ， col = idx % n`

![](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/search-matrix.png)

```java
class Solution {
  public boolean searchMatrix(int[][] matrix, int target) {
    int m = matrix.length;
    if (m == 0) return false;
    int n = matrix[0].length;

    // 二分查找
    int left = 0, right = m * n - 1;
    int pivotIdx, pivotElement;
    while (left <= right) {
      pivotIdx = (left + right) / 2;
      pivotElement = matrix[pivotIdx / n][pivotIdx % n];
      if (target == pivotElement) return true;
      else {
        if (target < pivotElement) right = pivotIdx - 1;
        else left = pivotIdx + 1;
      }
    }
    return false;
  }
}
```

</details>



<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">搜索二维矩阵(中等)</a></span>
    </summary>

```java
class Solution {
    /**
     *左下角的元素是这一行中最小的元素，同时又是这一列中最大的元素。比较左下角元素和目标：
若左下角元素等于目标，则找到
若左下角元素大于目标，则目标不可能存在于当前矩阵的最后一行，问题规模可以减小为在去掉最后一行的子矩阵中寻找目标
若左下角元素小于目标，则目标不可能存在于当前矩阵的第一列，问题规模可以减小为在去掉第一列的子矩阵中寻找目标
若最后矩阵减小为空，则说明不存在 
     */
    public boolean searchMatrix(int[][] matrix, int target) { 
        int x=matrix.length-1,y=0;
        while(x>=0&&y<matrix[0].length){
            if(matrix[x][y]==target){
                return true;
            }
            if(matrix[x][y]>target){
                x--;
            }else{
                y++;
            }
        }
        return false;
    }
}
```

</details>

<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">寻找旋转排序数组中的最小值(中等)</a></span>
    </summary>

>

```java
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length;
        if (n == 0) {
            return -1;
        }
        if (n == 1) {
            return nums[0] == target ? 0 : -1;
        }
        //二分查找
        int l = 0, r = n - 1;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] == target) {//是目标值直接返回
                return mid;
            }
            if (nums[0] <= nums[mid]) {//当前是单调递增区间
                if (nums[0] <= target && target < nums[mid]) {//0-mid区间
                    r = mid - 1;
                } else {//mid-r区间
                    l = mid + 1;
                }
            } else {//当前不是单调递增区间
                if (nums[mid] < target && target <= nums[n - 1]) {//(mid)-(n-1)区间
                    l = mid + 1;
                } else {//l-mid区间
                    r = mid - 1;
                }
            }
        }
        return -1;
    }
}
```


</details>

# 位移运算


<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/number-of-1-bits/">位1的个数(简单)</a></span>
    </summary>

>位移

```java
class Solution{
    public int hammingWeight(int n) {
        int bits = 0;
        int mask = 1;
        for (int i = 0; i < 32; i++) {
            if ((n & mask) != 0) bits++;
            mask <<= 1;
        }
        return bits;
    }
    //优化
    //不断把数字最后一个 11 反转，并把答案加一
    //在二进制表示中，数字 n 中最低位的 11 总是对应 n - 1 中的 0。因此，将 n 和 n - 1 与运算总是能把 n 中最低位的 1 变成 0 ，并保持其他位不变。
    public int hammingWeight(int n) {
        int sum = 0;
        while (n != 0) {
            sum++;
            n &= (n - 1);
        }
        return sum;
    }
}


```

</details>



<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/power-of-two/">2的幂(简单)</a></span>
    </summary>
    
>(x & (-x)) == x
>(x & (x - 1)) == 0


```java
class Solution {
  //位运算：获取二进制中最右边的 1
  //若 x 为 2 的幂，则它的二进制表示中只包含一个 1，则有 x & (-x) = x
  public boolean isPowerOfTwo(int n) {
    if (n == 0) return false;
    long x = (long) n;
    return (x & (-x)) == x;
  }
  //位运算：去除二进制中最右边的 1
  //(x - 1) 代表了将 x 最右边的 1 设置为 0，并且将较低位设置为 1。
  //2 的幂二进制表示只含有一个 1。
  // x & (x - 1) 操作会将 2 的幂设置为 0，因此判断是否为 2 的幂是：判断 x & (x - 1) == 0
  public boolean isPowerOfTwo(int n) {
    if (n == 0) return false;
    long x = (long) n;
    return (x & (x - 1)) == 0;
  }
}
```

</details>


<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/reverse-bits/">颠倒二进制位(简单)</a></span>
    </summary>

>1011 & 0001 = 0001 获取末尾二进制值

>

```java
public class Solution {
    public int reverseBits(int n) {
        int result = 0;
        for (int i = 0; i < 32; i++) {
            result <<= 1;
            result += 1 & n;
            n >>= 1;
        }
        return result;
    }
    //优化
    //由于1 & n的值为 0 或者 1，所以返回结果 result 直接加上（1 & n）以更新最后一位数值。
    //这里也可以使用或运算。参与或运算的两个元素，只要有一个为1，那么结果就为1，否则为0。
    public int reverseBits(int n) {
        int result = 0;
        for (int i = 0; i < 32; i++) {
            result <<= 1;//左移一位进行进位
            result |= n & 1;//
            n >>= 1;//n右移一位
        }
        return result;
    }
}
```

</details>


<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/counting-bits/description/">比特位计数(中等)</a></span>
    </summary>

给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。

>x>>1右移1位(除以2)，x&1取末位

P(x)=P(x&(x−1))+1;

```java
public class Solution {
  public int[] countBits(int num) {
      int[] ans = new int[num + 1];
      for (int i = 1; i <= num; ++i)
        ans[i] = ans[i >> 1] + (i & 1); // x / 2 is x >> 1 and x % 2 is x & 1
      return ans;
  }
}
```

</details>



<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/single-number/">只出现一次的数字(简单)</a></span>
    </summary>

解题思路

>数组列表进行异或即可得出只出现一次的数字

| a    | b    | a⊕b  |
| ---- | ---- | ---- |
| 0    | 0    | 0    |
| 0    | 1    | 1    |
| 1    | 0    | 1    |
| 1    | 1    | 0    |


```java
class Solution {
    public int singleNumber(int[] nums) {
        int ans = 0;
        for(int i=0;i<nums.length;i++){
            ans = ans^nums[i];
            System.out.println(ans);
        }
        return ans;
    }
}
```


</details>


<details>
    <summary>
        <span><a href="https://leetcode-cn.com/problems/single-number-ii/">只出现一次的数字 II(中等)</a></span>
    </summary>
给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。

解题思路
>将我们的数的二进制位每一位相加，然后对其每一位的和取余 

![img](https://cdn.nlark.com/yuque/0/2021/png/2630542/1635597301462-761b5127-de43-4493-ace7-ecfbb6a4b5ae.png)


>如果输入是：nums = [2,2,3,2]，那么它的各个元素对应的32位二进制数就是
```
[
    0000 0000 0000 0000 0000 0000 0000 0010, 
    0000 0000 0000 0000 0000 0000 0000 0010, 
    0000 0000 0000 0000 0000 0000 0000 0011, 
    0000 0000 0000 0000 0000 0000 0000 0010
]
```
接着，对这些二进制数的对应位进行求和，得到： [00000000000000000000000000000041]；
对这个求和结果的每一位进行3的取模运算，得到：[00000000000000000000000000000011]；
把上面的结果从二进制转换为十进制，就是：3。这就是我们的答案。

```java
class Solution {
    public int singleNumber(int[] nums) {
      int res = 0;
      //当前数组为整数32位
      for(int i = 0; i < 32; i++){
          int count = 0;
          for (int j = 0; j < nums.length; j++) {
              //先将数右移，并求出最后一位为 1 的个数
              // 提取从右往左数第i位的数值，将所有nums[i]二进制下的第i位数值进行求和
              if ((nums[j] >> i & 1) == 1) {
                  count++;
              }             
          }
          //找到某一位取余为 1 的数，并左移，为了将这一位循环结束后移至原位
          if (count % 3 != 0) {// 如果没办法被3整除，那么说明落单的那个数的第i位是1不是0
              res = res | 1 << i;
          }
      }
      return res;       
    }
}
```

</details>

<details>
    <summary>
        <span><a href="">只出现一次的数字 III(中等)</a></span>
    </summary>

解题思路
>有两个数只出现了一次记为 num1、num2 初始化为 0, 其余的数出现了两次,我们可以对所有的数进行一次异或操作, 易知这个结果就等于 num1 和 num2 的异或结果(相同的数异或结果都为 0, 0和任意数异或结果都为那个数). 
         
>那么我可以考虑异或结果的某个非 0 位如最后一个非 0 位, 因为我们知道只有当 num1、num2 在该位不一样的时候才会出现异或结果为 1. 所以我们以该
位是否为 1 对数组进行划分, 只要该位为 1 就和 num1 异或, 只要该位为 0就和 num2 异或, 这样最终得到就是只出现过一次的两个数(其他在该位为 1 或 0 的数必然出现 0/2 次对异或结果无影响)

>例： **a,b,a,b,c,d,e,f,e,f ** 分组后
 A组：a, a , b, b, c 异或得到 c
 B组：e, e, f, f, d 异或得到 d
 
 那么我们应该怎么借助分组位进行分组呢？
 
 我们处理 c , d 的异或值，可以仅保留异或值的分组位，其余位变为 0 ，例如 101 变成 001或 100
 为什么要这么做呢？在第二题提到，我们可以根据 a & 1 来判断 a 的最后一位为 0 还是为 1，所以我们将 101 变成 001 之后，然后数组内的元素 x & 001 即可对 x 进行分组 。同样也可以 x & 100 进行分组.
 那么我们如何才能仅保留分组位，其余位变为 0 呢？例 101 变为 001
 我们可以利用 x & (-x) 来保留最右边的 1
 

```java
class Solution {
    public int[] singleNumber(int[] nums) {
        int xorsum = 0;
        //结果就只剩下x1和x2的异或
        for (int num : nums) {
            xorsum ^= num;
        }
        //xorsum & (-xorsum)得出x1,x2最低位非0的数字(最右边为一的位置)
        //防止溢出
        int lsb = (xorsum == Integer.MIN_VALUE ? xorsum : xorsum & (-xorsum));
        int type1 = 0, type2 = 0;
        //将两个不同的数分别放在两个组，这样子各自组进行异或即可得出这两个数
        for (int num : nums) {
            //分为两组
            if ((num & lsb) != 0) {//如果最右边位
                type1 ^= num;
            } else {
                type2 ^= num;
            }
        }
        return new int[]{type1, type2};
    }
}
```

</details>

# 参考资料

[力扣前200高频题目](https://leetcode-cn.top/#/home)  
[牛客网模块训练](https://ac.nowcoder.com/acm/skill/noip-pj)  
[拉布拉多算法小抄](https://labuladong.gitbook.io/algo/)  
[动画讲编程](https://www.toutiao.com/c/user/token/MS4wLjABAAAAUbAv6lV7flBtQQ985gWufzkO45WqoJdVL6KGJi--Mtg/)  
[LeetCode Cookbook](https://books.halfrost.com/leetcode/)
