---
title: Linux篇-Linux操作系统教程
index_img: https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/linux.jpeg
hide: false
date: 2021-02-10 10:03:44
category: Linux学习
tags: Linux
---
# 第1章 Linux概述

![操作系统简介](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226185336241.png)

- 操作系统（Operation System，简称OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基石。
- 操作系统本质上是运行在计算机上的软件程序 ；
- 为用户提供一个与系统交互的操作界面 ；
- 操作系统分内核与外壳 ：

## Windows

目前最流行的个人桌面操作系统 。

![image-20210226185613561](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226185613561.png)

## Unix

最早的多用户、多任务操作系统

![image-20210226185620701](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226185620701.png)

## Linux

- 类Unix系统：Linux是一种自由、开放源码的类似Unix的操作系统 
- Linux内核：严格来说，Linux这个词本身只表示Linux内核

![image-20210226185743281](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226185743281.png)

- 1991年，芬兰的业余计算机爱好者Linus Torvalds
- 编写了一款类似Minix的系统（基于微内核架构的类Unix操作系统） 
- 被ftp管理员命名为Linux 
- 加入到自由软件基金的GNU计划中 
- Linux以一只可爱的企鹅作为标志，象征着敢作敢为、热爱生活。

`内核版本`

Linux内核版本由3个数字组成：a.b.c ：

a：当前发布的内核主版本；
b：偶数表示稳定版，奇数表示开发中的版本；
c：错误修补的次数。

Linux内核在内核官方网站www.kerenl.org上发布 

| **内核版本** | **日期**  | **说明**                                                     |
| ------------ | --------- | ------------------------------------------------------------ |
| 0.00         | 1991.2.4  | 两个进程，分别显示AAA和BBB                                   |
| 0.01         | 1991.9    | 第一个向外公布的Linux内核版本                                |
| 0.02         | 1991.10.5 | Linux第一个稳定的工作版本                                    |
| 0.11         | 1991.12.8 | 基本可以正常运行的内核版本                                   |
| 0.12         | 1992.1.15 | 主要加入数学协处理器的软件模拟程序                           |
| 0.95(0.13)   | 1992.3.8  | 开始加入虚拟文件系统思想的内核版本                           |
| 2.0          | 1996.2.9  | 支持多处理器                                                 |
| 2.2          | 1999.1.26 | 支持许多新的文件系统类型，使用全新的文件缓存机制             |
| 2.4          | 2001.1.4  | 使用一种适应性很强的资源管理系统                             |
| 2.6          | 2003.12.7 | 性能、安全性和驱动程序进行改进                               |
| 2.6.30       | 2009.6    | 改善文件系统、加入完整性检验补丁、线程中断处理支持等         |
| 2.6.32       | 2009.12   | 改进Btrfs文件系统、内存控制器支持、运行时电源管理            |
| 2.6.34       | 2010.5    | 支持flash设备文件系统、新的Vhost net、新的perf功能等         |
| 2.6.38       | 2011.3.15 | 合并自动进程分组、优化进程调度，改善VFS虚拟文件系统可扩展性，透明化内存Huge Pages使用过程，实现按需自动调用等 |

## Linux发行版

### Ubuntu

![image-20210226190142767](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226190142767.png)

Ubuntu Linux系统具有如下特色：

- `系统安全性高`，采用“sudo”工具，所有系统相关的任务均需要使用此指令，并输入密码，比起传统系统以管理员账号进行管理工作具有更大的安全性。
- `统易用性强`，传统的Linux系统软件安装和删除经常需要用户自己解决软件的依赖性问题，Ubuntu采用APT系统可轻松进行软件安装和删除。
- `供多种安装方式`，可以直接裸机安装或在虚拟机上进行安装，也可以通过安装程序提供的wubi.exe程序在Windows上进行安装，这为初学者学习和研究Linux带来了便利
- `界面友好`，Ubuntu提供的桌面操作方式特别适合熟悉Windows的用户，初学者易于上手

---

Ubuntu 每六个月发布一个新版本，用户可以免费升级到最新版本 。
Ubuntu版本的命名遵从“Y.MM (开发代号)”格式，Y代表年份，MM代表月份 。
由于受到来自官方的和非官方的社区支持，Ubuntu还有不少衍生版本 。

---

流行的官方衍生版 ：

- Kubuntu：基于KDE桌面环境。与Ubuntu的唯一区别在于桌面环境。
- Edubuntu：用于教育的衍生版，内置的软件全部免费
- Xubuntu：基于XFce桌面环境。
- Ubuntu Studio：更适合于多媒体设计人员的衍生版。

### Redhat

![image-20210226190256321](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226190256321.png)

美国的“红帽子”公司，1995年发布了桌面版的Red Hat Linux2.0 ；
2003年，Red Hat Linux9.0发布 ；
2004年，Red Hat公司正式决定停止对Red Hat Linux9.0的支持；
原本的桌面版Red Hat Linux发行包则与来自民间的Fedora计划合并，成为Fedora Core发行版 

### Fedora

![image-20210226190326510](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226190326510.png)

由Fedora Project社区开发、Red Hat公司赞助一个开放的、创新的Linux操作系统，它允许任何人自由地使用、修改和重发布 。

### OpenSuse

![image-20210226190441643](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226190441643.png)

最早是由德国的四个Linux爱好者推出的项目，2003年被Novell公司收购。
OpenSUSE向用户提供了漂亮的桌面环境，并提供了优秀的系统管理工具YaST。

### Debian

![image-20210226190506322](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226190506322.png)

创始人是伊恩默多克（Ian Murdock）。
发行版提供众多的软件包-deb包。
Ubuntu就是基于Debian发行版，两者使用APT作为软件管理系统。

### Mandriva

![image-20210226190536314](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226190536314.png)

法国的Mandriva公司开发 。
众多国际级Linux发行版中唯一一个默认即支持中文环境的Linux。

## Linux和Windows的相似之处

- 都是多用户操作系统，都可以由许多不同的用户来使用，都可以以组成员的方式来控制资源的访问权限；
- 都支持多文件系统，文件资源可以通过FTP或者其他协议与其他客户机共享；
- 都支持多种网络协议，比如TCP/IP、NetBIOS等；
- 都可以提供网络服务能力，如DHCP和DNS等。

## Linux和Windows的不同之处

| **比较项**   | **Linux**                                                    | **Windows**                                                 |
| ------------ | ------------------------------------------------------------ | ----------------------------------------------------------- |
| 定位         | Linux的设计定位是网络，设计灵感来自于网络操作系统Unix，因此它的命令的设计比较简单、简洁。由于纯文本可以非常好地跨网络工作，所以Linux配置文件和数据都以文本为基础 | Windows最初的目标是家庭和办公应用，例如打印、图形化服务     |
| 图形用户界面 | 图形环境并没有集成到Linux内核中，而是运行于系统之上的单独一层，这意味着可以在需要时再运行GUI | Windows是把GUI直接集成到操作系统内的                        |
| 文件扩展名   | Linux不使用文件扩展名来识别文件的类型，而是根据文件头的内容来识别其类型 | 使用文件扩展名来识别文件的类型                              |
| 文件执行     | Linux通过文件访问权限来判断是否为可执行文件。程序和脚本（其实是文本文件）的创建者或管理员可以将需要执行的文件赋予可执行权限，这样做有利于安全。保存到系统上的可执行文件不能自动执行，因此可以防止许多脚本病毒 | 对于Windows来说用户双击.exe为扩展名的文件系统都尝试加载执行 |
| 系统重启问题 | Linux的设计思想之一是，遵循“牛顿运动定律”，一旦开始运行，它将保持运行状态，直到受到外界因素的干扰，比如硬件故障。除了内核之外，其他软件的安装、卸载都不需要重新引导系统 | Windows在安装软件，特比是安装驱动程序后，经常需要重启系统   |
| 远程管理     | 可以远程地完成Linux中的很多工作。只要系统的基本网路服务在运行，就可以远程登录并管理系统。如果系统中一个特定的服务出现了问题，可以在进行故障诊断的同时让其他服务继续运行：当在一个系统上同时运行多个服务的时候（例如同时运行FTP、DNS、WWW服务），这种管理方式非常重要 | Windows的远程管理功能较弱                                   |

# 第2章 基本操作

## 软件包

Internet上有专门为Ubuntu建立的软件包仓库，其中包含大量的软件包，它们按照是否遵守GPL协议分成四种类型：

| **类型**             | **特点**                 | **描述**                                                     |
| -------------------- | ------------------------ | ------------------------------------------------------------ |
| main（主要）         | 开源软件，可以被自由发布 | Ubuntu开发团队提供完全技术支持的软件                         |
| restricted（受限）   | 专供特殊用途的软件       | 被Ubuntu开发团队支持，但因为不能直接修改程序，因而Ubuntu可能不能提供完全的技术支持。一般主要是硬件驱动程序 |
| universe（公共）     | 自由发布                 | 可以和“main”软件相安无事地共同运行，但没有安全升级的保障     |
| multiverse（多元化） | 不开源、不允许自由发布   | 不被Ubuntu开发团队支持，用户自己承担任何版权和技术风险       |

![image-20210226191433268](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226191433268.png)

## Linux桌面

X Window：是Unix/Linux中的底层图形界面系统 ；

## Shell

Shell命令可以分为内部命令和外部命令：

- 内部命令，也称作内置命令，是Shell程序的一部分，其中包含的是一些比较简单的Linux系统命令，这些命令在Shell程序内部完成运行。
- 外部命令，是Linux系统中的实用应用程序，命令的可执行实体不在Shell内部，但是其执行过程由Shell控制。

`可以通过“which”命令来判断某个命令是否是外部命令`

![image-20210226191706371](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226191706371.png)

- man命令，用于查看外部命令的帮助手册。
- help命令，用于查看内部命令的帮助手册 

![image-20210226220920398](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226220920398.png)

## 安装软件

安装

```shell
sudo apt install xxxx
```

卸载

```shell
sudo apt remove xxxx
```

## Vim

| **类型**   | **命令**                               | **说明**         |
| ---------- | -------------------------------------- | ---------------- |
| 进入vim    | vim                                    | 启动vim          |
| vim 文件名 | 启动vim并打开或新建文件                |                  |
| 光标移动   | h                                      | 向左移动一个字符 |
| j          | 向下移动一行                           |                  |
| k          | 向上移动一行                           |                  |
| l          | 向右移动以行                           |                  |
| 0          | 移动到行开始（注意是数字0，不是字母o） |                  |
| $          | 移动到行尾                             |                  |
| 屏幕翻滚   | Ctrl+u                                 | 向文件首翻半屏   |
| Ctrl+d     | 向文件尾翻半屏                         |                  |
| Ctrl+f     | 向文件尾翻一屏                         |                  |
| Ctrl+b     | 向文件首翻一屏                         |                  |
| 文本插入/追加 | a                         | 在光标后追加文本 |
| A             | 在当前行尾追加            |                  |
| i             | 在光标前插入              |                  |
| I             | 在当前行首插入            |                  |
| o             | 在当前行下面新开一行      |                  |
| O             | 在当前行上面新开一行      |                  |
| 文本删除      | dd                        | 删除当前行       |
| dw            | 删除一个单词              |                  |
| nx            | 删除光标后n个字符，例如3x |                  |
| nX            | 删除光标前n个字符，例如3X |                  |
| 撤销/重做       | u                              | 恢复上一个命令以前的状态，可以多次按下u命令 |
| .               | 重复一条命令                   |                                             |
| 搜索            | /字符串                        | 向下搜索字符串                              |
| ?字符串         | 向上搜索字符串                 |                                             |
| n               | 继续搜索                       |                                             |
| N               | 继续向相反防线搜索             |                                             |
| 替换            | :s/p1/p2/g                     | 将当前行中所有p1均用p2替换                  |
| :n1,n2s/p1/p2/g | 将底n1至n2行中所有p1均用p2替换 |                                             |
| :g/p1/s//p2/g   | 将文件中所有p1均用p2替换       |                                             |
| 复制/粘贴 | nyy                          | 将当前n行放入缓冲区 |
| p         | 将缓冲区的内容放到当前行下面 |                     |
| 保存文件  | w                            | 存盘                |
| w 文件名  | 存盘至文件                   |                     |
| 退出vim   | q                            | 退出                |
| wq        | 保存退出                     |                     |
| q!        | 强制退出                     |                     |

# 第3章 文件系统

![image-20210226223834451](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226223834451.png)

命令行打开文件管理系统GUI

> nautilus

- 当用户登录Linux时或在Ubuntu上打开一个终端后，首先进入一个特殊目录，称为“用户主目录” ；
- Linux规定可以用符号“~”表示当前登录用户的“用户主目录”。 
- 当前所在的目录称为“当前工作目录”。当前工作目录可以用“.”表示，当前工作目录的父目录可以用“..”表示。

对每个执行的命令，Linux系统都会自动打开3个文件，并且都有一个小的整数与之对应 ：

- stdin，标准输入文件，一般指键盘输入，用0表示；
- stdout，标准输出文件，一般指显示器，用1表示；
- stderr，标准错误输出文件，一般指显示器，用2表示。

## 比较文件

diff命令用来比较两个文件的内容，通过把其中一个文件转换成另一个文件的命令的形式来显示这两个文件之间的区别
示例 ：使用Gedit或vim在当前用户主目录下创建两个文件t1.txt和t2.txt，然后使用命令比较两个文件的内容 

```shell
diff t1.txt t2.txt
```

## 删除重复行

![image-20210226224321037](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226224321037.png)

## 访问权限

1、访问权限的分类：

- 可读（r）
- 可写（w）
- 可执行（x）三种 

2、访问权限的用户类别，有三种不同的类型的用户可对文件或目录进行访问：

- 文件所有者
- 同组用户
- 其他用户 

3、访问权限的表示：
共有10个字符组成，第一个字符指定了文件类型。剩下的是文件或目录的访问权限，分为三组，每组用三位表示，分别为：

- 文件所有者的读、写和执行权限 
- 与文件所有者同组的用户的读、写和执行权限 
- 系统中其他用户的读、写和执行权限 

![image-20210226224517215](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226224517215.png)

在Linux中，可以使用命令chmod来改变文件或目录的访问权限。
语法格式如下：

```shell
chmod [选项] [mode] <文件或目录>
```

常用选项有 ：

- -c  若该档案权限确实已经更改，才显示其更改动作 ； 
- -f  若该档案权限无法被更改也不要显示错误信息； 
- -v  显示权限变更的详细资料；
- -R  对目前目录下的所有档案与子目录进行相同的权限变更（即以递归的方式逐个变更）；



- mode是权限标记，可以有两种格式：符号标记和八进制数；
- 文件或目录，是要设置的文件名或目录名，必须输入。



使用符号标记法修改权限时，chmod命令中的mode是由`[who] [operator] [permission]`三部分组成。其中：
操作对象[who]可以是下述字母中任何一个或者它们的组合：

- u，表示“用户（user）”，即文件或目录的所有者；
- g，表示“同组（group）用户”，即与文件所有者同组的所有者；
- o，表示“其他（other）用户”； 
- a，表示“所有（all）用户”，它是系统默认值。

其中：操作符`[operator]`可以是：

- +，添加某个权限；
- -，取消某个权限；
- =，赋予给定权限并取消其他权限,即设定唯一的权限；

其中需要[permission]所表示的权限可用下述字母的任何一个或任意的组合：

- r，可读 ；
- w，可写 ；
- x，可执行 ； 



八进制数法修改权限
使用八进制数法修改权限时，chmod命令中的mode用三个八进制数abc表示，其中：

- a表示用户（user）的权限；
- b表示同组（group）用户的权限；
- c表示其他（other）的权限



而八进制数是4（可读）、2（可写）、1（可执行）的组合。因此：

- 若要读、写、执行权限（rwx），则4+2+1=7； 
- 若要读、写权限（rw-），则4+2=6； 
- 若要读、执行权限（r-x），则4+1=5 

## 正则表达式

正则表达式：描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串、将匹配的子串做替换或者从某个串中取出符合某个条件的子串等；
支持正则表达式的常用工具有grep、egrep、vim等，尤其是egrep能较好地支持正则表达式，而grep对正则表达式支持的较少 

| **符号** | **含义**                                                     |
| -------- | ------------------------------------------------------------ |
| \        | 将下一字符标记为特殊字符、文本、八进制转义符。例如，“n”匹配字符“n”，“\n”匹配换行符 |
| ^        | 匹配输入字符串开始的位置。例如，“^st”匹配以st开始的行        |
| $        | 匹配输入字符串结尾的位置。例如，“st$”匹配以st结尾的行        |
| *        | 零次或多次匹配前面的字符或表达式，例如，“zo*”匹配“z”和“zoo”  |
| +        | 一次或多次匹配前面的字符或表达式，例如“zo+”与“zo”和“zoo”匹配，但与“z”不匹配 |
| ？       | 零次或一次匹配与前面的字符或表达式，例如“do?”匹配“do”或“does”中的“do” |
| {n}      | n是非负整数，正好匹配n次，例如，“o｛2｝”与“Bob”中的“o”不匹配，但与“food”中的两“o”匹配 |
| ｛n，m｝ | m和n是非负整数，其中n<=m。匹配至少n次，至多m次，例如“o｛1，3｝”匹配“foooood”中的前三个“o” |
| x\|y     | 匹配x或y。例如“z\|food”匹配“z”或“food”，“(z\|f)ood”匹配“zood”或“food” |
| [a-z]    | 字符范围，匹配指定范围内的任何字符，例如，“[a-z]”匹配“a”到“z”范围内的任何小写字母 |
| [^a-z]   | 反向字符范围。匹配不在指定范围内的任何字符，例如“[^a-z]”匹配任何不在“a”到“z”范围内的任何字符 |
| \b       | 匹配一个字边界，例如，“er\b”匹配“never”中的“er”，但不匹配“verb”中的“er” |
| \B       | 非字边界匹配，例如，“er\B”匹配“verb”中的“er”，但不匹配“never”中的“er” |
| \f       | 换页符匹配                                                   |
| \f       | 换页符匹配                                                   |
| \d       | 数字字符匹配，等效于[0-9]                                    |
| \D       | 非数字字符匹配，等效于[^0-9]                                 |
| \n       | 换行符匹配                                                   |
| \r       | 匹配一个回车符                                               |
| \s       | 匹配任何空白字符，包括空格，制表符，换页符等。               |
| \t       | 制表符匹配                                                   |
| \w       | 匹配任何字类字符                                             |
| \W       | 匹配任何非字类字符                                           |

## 文件内容查找

搜索文件内容的命令有grep、egrep和fgrep，三个命令中：

- fgrep命令是执行速度最快的，不过有较多的限制；
- egrep是最慢的，但却是最灵活的，完全支持正则表达式；

- grep具有合理的速度和部分正则表达式支持 

![image-20210226230830381](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226230830381.png)

其中：
常用选项：
-c：显示匹配的行数；
-n：显示匹配内容所在的文档的行号；
-i：匹配时忽略大小写；
-v：输出不匹配内容； 
-x：只选择能匹配完整一行的匹配。



其中：
模式，可以使用正则表达式描述字符串匹配的模式。
  常用的正则表达式操作符有：
‘^’：匹配的字符串在行首，如：‘^xyz’匹配所有以xyz开头的行
‘$’：匹配的字符串在行尾，如：‘xyz$’匹配所有以xyz结尾的行 
‘\<’：指匹配表达式的开始，如：‘\<man’匹配‘manic’ 等
 。。。



其中：
文件列表，是要查找的文件名列表。
  如果没有文件列表，则从标准输入中读入数据
当使用“grep –E”等同于使用egrep；
  当使用“grep -F”等同于使用fgrep。



2、关于引号的使用
一般情况下当grep命令格式中的“模式”是一个不包含空格的简单字符串时，既可以使用单引号也可以使用双引号，或者甚至不适用引号
例如查找在abn文件中查找包含字符串hello的行，以下三个命令是等价的： 

```shell
grep  hello  abn
grep 'hello' abn
grep "hello" abn
```

```shell
grep ‘$hello’ abn  #查找abn文件中包含字符串$hello的行
grep “$hello” abn  #查找abn文件中包含变量hello所代表的内容的行
grep  $hello  abn  #同上，与命令“grep  "$hello"  abn”意义相同
```

## 文件排序

Linux中文件排序使用sort命令，该命令可以对文件内容进行排序输出，但不改变文件原有内容。其语法格式如下 

`sort [选项] <文件或目录>`

其中：
常用选项有：
-r，以反向的顺序来排序
-u，排序输出时，去掉重复行
文件或目录，是需要排序的文件名或目录名。

## 文件压缩与解压缩

文件压缩的命令有：`gzip`、`gzexe`、`zcat`。
本小结介绍gzip命令的应用。其语法格式如下 

`gzip [选项] <文件列表>`

其中：
常用选项有：
-c 将输出写到标准输出上，并保留原有文档 
-d 将压缩文件解压 
-r 递归式地查找指定目录并压缩其中的所有文件或是解压缩 

## 文件备份和还原

`tar [选项] <文件或目录>`

其中“选项”是命令执行时可使用的参数，tar命令选项分为：主选项和辅助选项。

- 常用主选项有 ：
  -c 创建新的档案文件；
  -r 把要存档的文件追加到档案的末尾；
  -t 列出档案文件的内容，查看已经备份了哪些文件 
  -u 更新文件；
  -x 从档案文件中释放文件。

- 常用辅助选项有 ：
  -f 指定是要使用的文件名，这个选项通常是必选项，选项后面要有文件名；
  -v 详细报告tar处理的文件信息；
  -z 用gzip来压缩/解压缩文件，加上该选项后可以将档案文件进行压缩，但还原时也一定要使用该选项进行解压缩。

# 第4章 高级操作

![image-20210226231642366](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226231642366.png)

- Linux是多任务操作系统，每个运行着的程序实例就是一个进程。
  在单CPU情况下，每个进程每次只执行很短的时间，执行过后CPU被Linux分配给另外一个进程，这种进程间的快速切换给用户的感觉就是可以同时运行多个程序。
- Linux进程都需要从某个进程创建出来，此时创建者进程称为“父进程”，被创建的进程称为“子进程”。
  进程可以具有多种状态中的一种，可以从一种状态切换到另一种状态，直到执行结束或非正常终止 

| **状态** | **说明**                                                     |
| -------- | ------------------------------------------------------------ |
| 就绪     | 进程准备执行，但没有得到CPU                                  |
| 执行     | 进程正在执行（使用CPU）                                      |
| 等待     | 进程等待事件发生。可能的事件包括I/O（例如磁盘读写操作）完成，父进程等待一个或多个子进程退出 |
| 交换     | 进程准备运行，但是它暂时被放置到磁盘上；或者该进程需要很多内存但是系统现在没有足够的内存空间可用 |
| 僵死     | 进程执行退出操作之前其父进程已经终止，该进程就变成僵死进程   |

Linux操作系统包括三种不同类型的进程：

- 交互进程：由用户启动（通过桌面点击操作或在终端中运行命令），可以工作在前台或后台；
- 批处理进程：和终端没有联系，是一个进程序列（提交给Linux进程等待队列的进程）；
- 守护进程；也称监控进程，由Shell或Linux系统自动启动，工作在后台，用于监视特定任务；

启动进程的方式有两种：

- 手工启动：
  前台启动：直接在终端中输入程序名（外部命令名），例如：vim ；
  后台启动：输入程序名时加“&”，例如：vim&。
- 调度启动 ：
  指定系统在特定时间运行程序，可用at，batch和cron调度

## 作业机制

事先进行调度安排，指定时间运行任务。
Linux中常用at、batch和crontab命令进行作业控制，他们之间的区别如下：

- `at命令`：在指定的精确时间执行；

语法格式：`at [选项]  <时间>`

其中，若省略选项，表示是设定作业，常用“选项”如下：
-d，删除指定的调度作业；
-f 文件名，从指定文件中读取执行的命令 

| **类型**         | **时间表示法**  | **说明**                 | **举例**          |
| ---------------- | --------------- | ------------------------ | ----------------- |
| 绝对表示法       | midnight        | 当天午夜                 | at midnight       |
| moon             | 当天中午        | at moon                  |                   |
| hh:mm [mm/dd/yy] | 时:分 月/日/年  | at 12:23at 23:01 5/21/09 |                   |
| 相对表示法       | now+n minutes   | 现在起向后n分钟          | at now+30 minutes |
| now+n hours      | 现在起向后n小时 | at now +2 hours          |                   |
| now+n days       | 现在起向后n天   | at now+5 days            |                   |
| now+n weeks      | 现在起向后n周   | at now+1 weeks           |                   |

与at命令相关的还有atq命令（显示队列中的作业信息）和atrm命令（删除队列作业）。下图所示为atq和arm命令的使用方法 

- `batch命令`：在系统负载较低的时候执；

2、batcht命令：设定完作业后，会等到系统载荷小于0.8的时候执行作业。
在使用batch时，不需要参数，batch执行时依然是在at输入符下输入要执行的命令，最后输入Ctrl+d结束batch命令，如图所示。 

![image-20210226232157429](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226232157429.png)

上述命令执行完毕后，立刻使用“ls”命令就可以看到“bt.txt”文件。如图所示 。这是因为此时系统负载较小，所以作业立即执行了 。

![image-20210226232216555](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226232216555.png)

- `crontab命令`：用于创建周期运行的任务作业。

crontab命令：可以设定周期运行的任务作业 。
使用命令“crontab -e”，即可创建作业，该命令打开一个编辑窗口，用户需要将设定的任务写入文件中。
首次使用该命令时，系统要求选择默认的编辑器，如图所示。本例中选择“3”，使用vim作为默认编辑器。

![image-20210226232247830](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226232247830.png)

3、crontab命令：可以设定周期运行的任务作业 。
在打开的编辑器内，需要按照如下固定格式输入要执行的任务：

`分钟  小时  日期  月份  星期  命令`

可以使用通配符“*”表示任何时间，例如要设定在每日10点20分执行一次“touch test.txt”，可以输入以下内容：

`20 10 * * * touch test.txt`

入完crontab作业后，按下ESC键，输入“:wq”，保存退出，crontab即可生效。若要编辑crontab作业，可以再次运行“crontab -e”命令；若要查询crontab作业，可以使用命令“crontab -l”，如图所示

![image-20210226232419159](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226232419159.png)

## 进程管理

Linux的进程管理是通过进程管理工具实现的，主要有以下工具命令：

- ps，查询列举进程；
- pgrep，按名字查询进程；
- pstree，显示进程树；
- kill，杀死进程。

### ps命令：查询进程 
ps用于查询进程，其语法格式如下：

`ps  [选项]  <程序名>`

| **选项参数** | **说明**                                 |
| ------------ | ---------------------------------------- |
| a            | 显示终端上的所有进程，包括其他用户的进程 |
| u            | 按用户名和启动时间的顺序来显示进程       |
| x            | 显示无控制终端的进程                     |
| l            | 长格式显示                               |
| -e           | 显示所有进程                             |
| -f           | 全格式输出，即可以看到进程的命令行       |
| -u           | 有效使用者相关的进程                     |

ps命令常用的选项组合是“aux”、“-ef”等。

![image-20210226232634201](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226232634201.png)

ps命令相关显示信息如下：
USER，运行进程的用户；
PID，进程的ID号；
%CPU，进程使用的CPU资源百分比；
%MEM，进程使用的内存资源百分比；
VSZ，进程使用的虚拟内存（Kbytes）；
RSS，进程所使用物理内存的大小；
TTY，进程关联的终端，如果没有终端显示“？”； 
STAT，进程目前的状态，主要状态如表4- 4所示； 
TIME，当前为止进程已经运行的时间，或休眠和停止之前运行的时间；
COMMAND，进程的程序名。



其中进程状态（stat），如下表所示。

| **进程状态** | **说明**                            |
| ------------ | ----------------------------------- |
| R            | 正在运行，或等待被系统调度来使用CPU |
| S            | 休眠                                |
| T            | 停止或正在被系统侦测                |
| Z            | 僵死进程                            |

### pgrep命令

1、通过程序的名字来查询进程，一般用来判断程序是否正在运行，这在服务器的配置和管理中可以用到 
语法格式如下：`pgrep  [选项]  <程序名>`

其中，常用选项如下 ：
-l，列出程序名和进程ID；
-o，程序名匹配最早生成的进程；
-n，程序名匹配最新生成的进程。

2、pgrep命令：通过程序的名字来查询进程，一般用来判断程序是否正在运行，这在服务器的配置和管理中可以用到 
例如，“/sbin/init”程序是一个系统进程，可以使用pgrep命令查看其进程ID，如图所示 ：

![image-20210226233323912](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226233323912.png)

### pstree命令

使用树形结构显示进程间的关系。pstree有很多参数，一般情况下直接使用pstree命令获取进程间的关系情况。如图示 ：

![image-20210226233435108](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226233435108.png)

### kill命令

当某个进程由于某种原因（如死锁）需要用户干预以提前终止。一般结合ps或pgrep命令，找到进程的ID，然后用kill终止它。
kill命令语法格式如下：

`kill [信号代码]  进程ID`

其中，信号代码可以省略，常用的信号代码是-9，表示`强制终止`。

## 多用户和多任务

有两个概念需要理解：

- 单用户多任务：单个用户可以同时执行多个进程（程序），例如单个用户可以同时运行vim、gedit等多个进程；

- 多用户多任务：多个用户同时登录并使用系统，例如有本地用户、远程的网络用户同时登录系统。

  `Linux支持多用户同时使用系统，也支持单个用户运行多个任务 `

### 用户和组管理

| **命令** | **说明**     |
| -------- | ------------ |
| useradd  | 创建新用户   |
| userdel  | 删除用户     |
| usermod  | 修改用户账号 |
| passwd   | 修改用户口令 |
| groupadd | 创建组       |
| groupdel | 删除组       |

## 相关系统文件

- /etc/passwd 

  > “/etc/passwd”是用户账号文件，该文件每行存放1个账户的一些信息，信息被“：”隔开成7个域，内容格式如下：

`用户名:口令:用户ID:组ID:用户全名或描述:登录目录:登录Shell`

上述信息中的“口令”，其实只是个特殊字符，如“x”或“*”，真正的口令在/etc/shadow文件中 

![image-20210226234325106](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226234325106.png)

2、/etc/shadow 
“/etc/shadow”是用户口令文件，其中存放已经加密的用户口令，每行一个用户信息，用“：”分割成9个域，包括：
用户名 
加密后的口令 
从1970年1月1日至今密码最近一次被修改的天数 
从1970年1月1日起多少天内口令不能修改 
从1970年1月1日多少天内口令必须修改 
提前多少天警告用户口令将过期 
在口令过期之后多少天禁用此用户 
从1970年1月1日起多少天后口令失效 
保留

![image-20210226234419850](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226234419850.png)

3、/etc/group 
“/etc/group”是组账号文件，每行存放一个组账号信息，用“：”分割成4个域：

`组名:组口令:组ID:组成员列表`

其中“组口令”一般的Linux系统都不使用，通常这个位置是一个特殊字符，例如“x” 

![image-20210226234527544](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226234527544.png)

## 重定向

### 输出重定向

输出重定向用大于号“>”，如果这条命令要往标准输出写入或者发送信息，那么都将写入输出文件中，而不是与命令所关联的显示器。
其语法格式有两条：

`命令 > 文件`
`命令 >> 文件`

上述第一条命令，将命令的执行结果送至指定的文件中，若文件已存在，则`覆盖`；
第二条命令，将命令的执行结果`追加`到指定文件中。 

### 输入重定向

输入重定向用小于号“<”来表示，如果命令从标准输入中读取输入，这个输入就是来自输入文件，而不是和命令相关的键盘。
其语法格式如下：

<命令>  <  <文件>

其中：

- 命令，可以是任何一条Shell命令；
- 文件，是要作为输入命令的文件 

### 错误输出重定向

可以通过描述符（0、1、2）与操作符“<”和“>”相关联，来对标准输入、标准输出、错误输出重定向。
示例：通过使用“2> ”对一条命令标准出错进行重定向 

$ cat a.c
$ cat a.c 2> error.txt

![image-20210226234827588](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226234827588.png)

## 管道

### 管道的概念

Linux系统允许通过管道操作将一条命令的输出作为另一条命令的标准输入。管道的操作符是一个竖杠“|”。下图说明了管道操作的含义 

![image-20210226235005809](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226235005809.png)

简单的说就是利用管道符“|”将两个命令分开，管道符左边命令的输出就会作为管道符右边命令的输入；
连续使用管道意味着第一个命令的输出会作为第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推。 



- 使用ls和more命令，利用管道操作分屏显示目录“/usr/include”里的内容。具体操作步骤如下：

1、用ls命令查看目录“/usr/include”里的内容`ls /usr/include`

2、ls命令通过管道将内容输出到more命令，从而可以进行分屏控`ls /usr/include | more`

- 使用ls、grep和more命令，利用管道操作查找“/usr/include”目录内以字符串“lib”开头的“.h”文件，并分屏显示 

`ls /usr/include | grep '^lib' | more`

# 第5章 Shell编程

- 在Linux系统中，虽然有各种各样的图形化操作工具，但是Shell仍然是一个非常灵活的工具：
  Shell不仅能够执行命令，而且是一门非常优秀的编程语言。

- 通过使用Shell编程可以使大量的任务自动化。

- Shell程序特别擅长系统管理任务，尤其适合那些易用性、可维护性和便携性比效率更重要的任务。

## Shell特点

Linux系统中的Shell脚本通常具备以下特点：

- Shell脚本程序是由Shell环境解释执行的；
- Shell脚本不需要编译、连接及生成可执行文件，直接由相应的解释器解释执行即可；
- 执行Shell程序时，Shell脚本文件需要具有可执行的权限；
- Shell脚本可以使用变量、控制语句等比较复杂的结构；
- Shell脚本是从上而下，顺序执行的。

## 环境变量

| **环境变量** | **说明**                                                     |
| ------------ | ------------------------------------------------------------ |
| $PATH        | 以冒号分割的，统常用来搜索命令的目录列表                     |
| $HOME        | 当前用户的主目录                                             |
| $0           | shell脚本程序的名字                                          |
| $#           | 传递给脚本的参数个数，如果脚本程序在调用时没有传递任何参数，则$#的值是0 |
| $IFS         | 输入域分隔符。当Shell读取输入时，它给出用来分隔单词的一组字符，通常是空格、制表符和换行符等 |
| $1,$2,…      | 脚本程序调用时传递过来的参数                                 |
| $*           | 在一个变量中列出所有的参数，各个参数之间用$IFS中的第一个字符分隔 |

[参考资料]()

# 第6章 网络操作

TCP/IP协议应用层协议是直接为用户服务的网络协议，常见应用层协议如表所示：

| **协议** | **说明**                                  |
| -------- | ----------------------------------------- |
| HTTP     | 超文本传输协议，用于实现互联网中的www服务 |
| FTP      | 文件传输协议，实现上传下载                |
| DNS      | 域名解析服务，提供域名到IP地址之间的转换  |
| Telnet   | 用户远程登录服务                          |

## IP地址

TCP/IP协议中的网络层也称为IP层，按照该层协议的要求，为连接在Internet上的每个主机分配一个32bit长的地址，称之为IP地址。

 IP地址用二进制表示，32bit的IP地址可换算成4个字节。

为了方便使用，IP地址经常被写成十进制的形式，中间用“.”分开不同的字节，如“202.102.134.68”。 

## 子网掩码

按照TCP/IP协议的要求，可以将IP地址划分成“网络地址”和“主机地址”两部分。 

为了方便计算，使用“子网掩码”来指明一个IP地址哪些位标示的是“主机”所在子网，哪些位标示的是主机的位掩码。

与IP地址相同，子网掩码也用二进制来表示，长度也是32位，且有以下规律：
子网掩码的二进制位1和0分别连续；
左边是网络位，用二进制数“1”表示，“1”的数目等于网络位的长度；
右边是主机位，用二进制数“0”表示，“0”的数目等于主机位的长度。

以上规则的设计目的是：`让子网掩码与IP地址做“与”运算时用“0”遮住原主机数，而不改变原网络段数字，且方便通过“0”的位数确定子网的主机数。` 

## 网络命令

| **命令** | **功能**                                     | **备注**                                        |
| -------- | -------------------------------------------- | ----------------------------------------------- |
| ifconfig | 查看和配置网络接口的参数                     |                                                 |
| ping     | 用于查看网络上的主机是否在工作               |                                                 |
| ftp      | 登录到FTP服务器，以利用ftp协议上传和下载文件 | 需要安装FTP客户端软件，Ubuntu11.04已默认安装    |
| telnet   | 利用telnet协议访问主机                       | 需要安装telnet客户端软件，Ubuntu11.04已默认安装 |
| ssh      | 利用ssh协议登录对方主机                      | 需要ssh客户端软件，Ubuntu11.04已默认安装        |
| iptables | 网络数据包过滤设置                           |                                                 |

### ifconfig

1、查看网络配置情况
使用ifconfig查看当前系统网络配置情况的语法格式如下： 

`  ifconfig  [网络接口]`

其中，“网络接口”是一个后跟单元号的驱动设备名，例如第一个以太网接口eth0、第二个以太网接口eth1等 ；
使用以上命令时，若省略“网路接口”，则查询本机所有网络接口的配置情况。 

![image-20210227000231844](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210227000231844.png)

2、配置指定接口参数
使用ifconfig命令配置指定接口（如eth0、eth1）的参数（如IP地址、网络掩码、广播地址等），语法格式如下：

`  ifocnifg <网络接口> [选项] <IP地址>`

其中，常用“选项”如下：
down，关闭指定的网络设备
up，启动指定的网络设备
netmask<子网掩码>  


示例：设置本机eth0的IP地址为“192.168.1.6”子网掩码为“255.255.255.0”。 

`sudo ifconfig eth0 192.168.1.6 netmask 255.255.255.0`

### ping

使用ping命令可以检查网络是否能够连通。
常用语法格式如下：

 `ping  <IP地址>`

其中，“IP地址”是要测试能够通过网络到达的主机的IP地址。

![image-20210227000534701](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210227000534701.png)

### FTP

使用ftp命令可登录到FTP服务器，ftp命令运行成功后，用户需要输入相应的用户名和密码，验证通过后，用户可以使用相关的FTP客户端命令进行远程文件操作。 
FTP登录命令常用语法格式如下：

` ftp  <IP地址> `

其中，“IP地址”是提供FTP服务的主机IP地址。

![image-20210227000626239](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210227000626239.png)

| **命令** | **功能**           |
| -------- | ------------------ |
| ls       | 列举服务器上的文件 |
| get      | 下载文件           |
| put      | 上传文件           |
| mkdir    | 建立目录           |
| rmdir    | 删除目录           |
| cd       | 改变工作目录       |
| help     | 查看帮助           |
| bye      | 退出FTP            |

# 第7章 编程工具

## 编译链接

在Linux中，C程序的编译用gcc程序，链接用ld程序，gcc编译完后可自动调用ld程序完成链接过程。因此这里重点介绍gcc程序。
调用gcc编译程序的的语法格式如下：

`gcc [选项] <文件名>`

其中，最常使用的选项有：
-c：只编译，不链接成为可执行文件
-o output_filename：确定输出文件,默认是a.out
-g：产生符号调试工具（GNU的gdb）所必要的符号信息
l-pg：产生代码剖析工具gprof使用的信息
-w：忽略警告信息
文件名：需要编译程序的文件名

## 调试

Linux上调试C语言程序，可使用gdb程序。
使用gdb调试程序前，需要先使用gcc的“-g”选项编译程序，而后通过gdb命令加载编译好的程序， gdb会不断从键盘接收用户命令并完成相应的任务，直到输入q命令（quit的简写）让它退出为止。

`<gdb> <可执行程序>`

![image-20210227000951646](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210227000951646.png)

| **命令** | **命令简写** | **说明**                                                     |
| -------- | ------------ | ------------------------------------------------------------ |
| list     | l            | 列出程序的源代码                                             |
| break    | b            | b <代码行号>，在某代码行设置断点                             |
| run      | r            | 从头开始，全速运行程序至断点处                               |
| step     | s            | 单步执行                                                     |
| continue | c            | 继续运行到下一个断点                                         |
| delete   | d            | 直接运行d命令，表示要删除所有断点；d <代码行号>，表示删除指定的断点 |
| print    | p            | p <变量名>，显示某个变量的值                                 |
| kill     | k            | 停止被调试程序的运行                                         |

## make工具

make工程管理器简称make工具，可以同时管理一个项目中多个文件的编译链接和生成。
make工具其实是个“自动编译管理器”， “自动”是指它能够根据文件时间去自动发现更新过的文件而减少编译的工作量。
make工具通过“Makefile”文件的内容自动执行大量的编译工作，而用户只需要编写一些简单的编辑语句，这极大地提高了实际项目的工作效率，几乎所有Linux下的项目均会使用它。

使用make工具时的语法格式如下：`make [选项] [目标]`

其中，如果省略“选项”和“目标”，则make工具会寻找当前目录下的Makefile文件，解释执行其中的规则：
常用的“选项”如下
-f 文件，告诉make工具使用指定的文件作为Makefile文件
-d，显示调试信息
-n，测试模式，并不真正执行任何命令
-s，安静模式，不输出任何信息
“目标”：直接执行Makefile中的指定目标



Makefile文件由注释和一系列的“make规则”组成。“make规则”由以下格式组成

`<目标文件列表>:[依赖文件列表][<Tab>命令列表]`

其中：
目标文件列表：一系列文件名，文件之间要用空格隔开，是make最终需要创建的文件
依赖文件列表：一系列文件名，文件之间要用空格隔开，是生成目标文件所依赖的一个或多个其他文件
命令列表：必须有个前导TAB键操作。生成目标文件所需要执行的shell命令。一个make规则可以有多个命令行，每一条命令占一行。且每一个命令的第一个字符必须是制表符[Tab]。



> 无论上述那个Makefile文件（本例假设使用上述第一个Makefile文件），都可以直接执行make命令，make工具自动寻找当前目录下的Makefile，并解释执行其中的规则：

## gprof工具

gprof常用语法格式如下

`gprof [选项] [可执行程序] [数据文件]`

其中，“选项”是命令执行时可使用的参数，常用“选项”有中：
-b：不再输出统计图表中每个字段的详细描述
-p：输出函数的调用图
-q：输出函数时间消耗列表
-z：显示从未使用过的函数
可执行程序，指gcc用“-pg”选项编译的程序，可以省略，默认是是当前目录下的a.out文件
目标文件，可以省略，默认是当前目录下的gmon.out文件



使用gprof工具对程序进行静态分析。具体操作步骤如下
1、使用gcc的“-pg”选项编译程序

`gcc –pg –o hello.exe hello.c`

2、运行编译好的程序

![image-20210227001247211](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210227001247211.png)

3、用gprof命令查看gmon.out保存的信息

![image-20210227001258170](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210227001258170.png)

## time工具

time工具用于分析一个程序或任何Shell命令的运行效率。
Linux下time命令可以获取一个程序的执行时间，包括程序的实际运行时间（real time），以及程序运行在用户态的时间（user time）和内核态的时间（sys time）。它们的意义如下：

- 实际运行时间，是指程序从开始运行到结束所花费的时间
- 用户态时间，是真正的代码执行时间
- 内核态时间，是指程序执行时系统活动所花费的时间

time工具的常用语法格式如下：

`<time> [选项] [用户程序]`

其中，“选项”是命令执行时可使用的参数，常用“选项”有：
-o：将time的输出写入所指定的文件中，如果文件已经存在，系统将覆盖其内容
-a：配合-o使用，将结果写到文件末端，而不会覆盖掉原来的内容
-p：把显示格式设定为百分比的形式
用户程序，要动态分析的程序名，需要包含路径



`time ./hello.exe`

![image-20210227001357047](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210227001357047.png)





# 参考资料

[计算机组成与系统结构](http://www.xduph.com/)   


 