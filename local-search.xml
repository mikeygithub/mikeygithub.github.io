<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>源码篇-Spring源码分析</title>
    <link href="/2021/02/28/java/%E6%BA%90%E7%A0%81%E7%AF%87-Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2021/02/28/java/%E6%BA%90%E7%A0%81%E7%AF%87-Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href=""></a></p>]]></content>
    
    
    <categories>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>源码篇-MyBatis源码分析</title>
    <link href="/2021/02/27/java/%E6%BA%90%E7%A0%81%E7%AF%87-MyBatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2021/02/27/java/%E6%BA%90%E7%A0%81%E7%AF%87-MyBatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href=""></a></p>]]></content>
    
    
    <categories>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>源码篇-SpringMVC源码分析</title>
    <link href="/2021/02/27/java/%E6%BA%90%E7%A0%81%E7%AF%87-SpringMVC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2021/02/27/java/%E6%BA%90%E7%A0%81%E7%AF%87-SpringMVC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    <categories>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringMVC源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>源码篇-SpringBoot源码分析</title>
    <link href="/2021/02/27/java/%E6%BA%90%E7%A0%81%E7%AF%87-SpringBoot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2021/02/27/java/%E6%BA%90%E7%A0%81%E7%AF%87-SpringBoot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h1><p>通过加载</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/QQ%E5%9B%BE%E7%89%8720210227235542.png" alt="QQ图片20210227235542"></p><h1 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href=""></a></p>]]></content>
    
    
    <categories>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python篇-Python快速入门</title>
    <link href="/2021/02/27/python/Python%E7%AF%87-Python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2021/02/27/python/Python%E7%AF%87-Python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。</p><p>Python 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。</p><p>Python 是一种解释型语言： 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言。</p><p>Python 是交互式语言： 这意味着，您可以在一个 Python 提示符 &gt;&gt;&gt; 后直接执行代码。</p><p>Python 是面向对象语言: 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。</p><p>Python 是初学者的语言：Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>1.易于学习：Python有相对较少的关键字，结构简单，和一个明确定义的语法，学习起来更加简单。</p><p>2.易于阅读：Python代码定义的更清晰。</p><p>3.易于维护：Python的成功在于它的源代码是相当容易维护的。</p><p>4.一个广泛的标准库：Python的最大的优势之一是丰富的库，跨平台的，在UNIX，Windows和Macintosh兼容很好。</p><p>5.互动模式：互动模式的支持，您可以从终端输入执行代码并获得结果的语言，互动的测试和调试代码片断。</p><p>6.可移植：基于其开放源代码的特性，Python已经被移植（也就是使其工作）到许多平台。</p><p>7.可扩展：如果你需要一段运行很快的关键代码，或者是想要编写一些不愿开放的算法，你可以使用C或C++完成那部分程序，然后从你的Python程序中调用。</p><p>8.数据库：Python提供所有主要的商业数据库的接口。</p><p>9.GUI编程：Python支持GUI可以创建和移植到许多系统调用。</p><p>10.可嵌入: 你可以将Python嵌入到C/C++程序，让你的程序的用户获得”脚本化”的能力。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install python<br></code></pre></td></tr></table></figure><p>或者去<a href="https://www.python.org/downloads/">官网</a>下载</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.python.org/">官网</a></p><p><a href="https://www.runoob.com/python/python-tutorial.html">菜鸟教程</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS篇-Bochs在Ubuntu下的安装教程</title>
    <link href="/2021/02/26/os/OS%E7%AF%87-Bochs%E5%9C%A8Ubuntu%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <url>/2021/02/26/os/OS%E7%AF%87-Bochs%E5%9C%A8Ubuntu%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>最近在看《操作系统真相还原》这本书，打算跟着做一个微型操作系统，就有了这篇教程</p></blockquote><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p><a href="https://mikeygithub.github.io/2021/02/26/os/OS%E7%AF%87-Bochs%E5%9C%A8Ubuntu%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B">OS篇-Bochs在Ubuntu下的安装教程</a></p><h1 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h1><ul><li><p>下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://udomain.dl.sourceforge.net/project/bochs/bochs/2.6.2/bochs-2.6.2.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>解压</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">tar -zxvf bochs-2.6.2.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>配置</p></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">./configure \<br>--prefix=/your_path/bochs \<br>--enable-debugger\<br>--enable-disasm \<br>--enable-iodebug \<br>--enable-x86-debugger \<br>--with-x \<br>--with-x11<br></code></pre></td></tr></table></figure><p>解释</p><blockquote><p>–prefix=/your_path/bochs 是用来指定 bochs 的安装目录,根据个人实际情况将 your_path 替换为自己待安装的路径。<br> –enable-debugger 打开 bochs 自己的调试器。<br> –enable-disasm 使 bochs 支持反汇编。<br> –enable-iodebug 启用 io 接口调试器。<br> –enable-x86-debugger 支持 x86 调试器。<br> –with-x 使用 x windows。<br> –with-x11 使用 x11 图形用户接口。  </p></blockquote><ul><li>make install</li></ul><p>make install报错</p><p><code>x.cc:37:10: fatal error: X11/Xlib.h: No such file or directory  #include &lt;X11/Xlib.h&gt;           ^~~~~~~~~~~~</code><br>还报错<br><code>x.cc:42:10: fatal error: X11/extensions/Xrandr.h: No such file or directory  #include &lt;X11/extensions/Xrandr.h&gt;           ^~~~~~~~~~~~~~~~~~~~~~~~~</code></p><p>解决方法</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo apt-get install libx11-dev ................. for X11/Xlib.h<br>sudo apt-get install mesa-common-dev........ for GL/glx.h<br>sudo apt-get install libglu1-mesa-dev ..... for GL/glu.h<br>sudo apt-get install libxrandr-dev ........... for X11/extensions/Xrandr.h<br>sudo apt-get install libxi-dev ................... for X11/extensions/XInput.h<br></code></pre></td></tr></table></figure><h1 id="配置软件"><a href="#配置软件" class="headerlink" title="配置软件"></a>配置软件</h1><p>将安装目录下的配置文件<code>bochs/share/doc/bochs/bochsrc-sample.txt</code>复制到当前目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv /home/mikey/bochs/share/doc/bochs/bochsrc-sample.txt ./bochsrc<br></code></pre></td></tr></table></figure><p>查看配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell">[work@localhost bochs]$ cat bochsrc<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">##############################################</span></span><br><span class="hljs-meta">#</span><span class="bash"> Configuration file <span class="hljs-keyword">for</span> Bochs</span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">##############################################</span></span><br><span class="hljs-meta">#</span><span class="bash"> 第一步,首先设置 Bochs 在运行过程中能够使用的内存,本例为 32MB。</span><br><span class="hljs-meta">#</span><span class="bash"> 关键字为:megs</span><br>megs: 32<br><span class="hljs-meta">#</span><span class="bash"> 第二步,设置对应真实机器的 BIOS 和 VGA BIOS。</span><br><span class="hljs-meta">#</span><span class="bash"> 对应两个关键字为:romimage 和 vgaromimage</span><br>romimage: file=/实际路径/bochs/share/bochs/BIOS-bochs-latest<br>vgaromimage: file=/实际路径/bochs/share/bochs/VGABIOS-lgpl-latest<br><span class="hljs-meta">#</span><span class="bash"> 第三步,设置 Bochs 所使用的磁盘,软盘的关键字为 floppy。</span><br><span class="hljs-meta">#</span><span class="bash"> 若只有一个软盘,则使用 floppya 即可,若有多个,则为 floppya,floppyb...</span><br><span class="hljs-meta">#</span><span class="bash">floppya: 1_44=a.img, status=inserted</span><br><span class="hljs-meta">#</span><span class="bash"> 第四步,选择启动盘符。</span><br><span class="hljs-meta">#</span><span class="bash">boot: floppy</span><br><span class="hljs-meta">#</span><span class="bash">默认从软盘启动,将其注释</span><br>boot: disk<br><span class="hljs-meta">#</span><span class="bash">改为从硬盘启动。我们的任何代码都将直接写在硬盘上,所以不会再有读写软盘的操作。</span><br><span class="hljs-meta">#</span><span class="bash"> 第五步,设置日志文件的输出。</span><br>log: bochs.out<br><span class="hljs-meta">#</span><span class="bash"> 第六步,开启或关闭某些功能。</span><br><span class="hljs-meta">#</span><span class="bash"> 下面是关闭鼠标,并打开键盘。</span><br>mouse: enabled=0<br>keyboard_mapping: enabled=1,<br>map=/实际路径/bochs/share/bochs/keymaps/x11-pc-us.map<br><span class="hljs-meta">#</span><span class="bash"> 硬盘设置</span><br>ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14<br><span class="hljs-meta">#</span><span class="bash"> 下面的是增加的 bochs 对 gdb 的支持,这样 gdb 便可以远程连接到此机器的 1234 端口调试了</span><br>gdbstub: enabled=1, port=1234, text_base=0, data_base=0, bss_base=0<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">##################配置文件结束#####################</span></span><br></code></pre></td></tr></table></figure><h1 id="测试开机"><a href="#测试开机" class="headerlink" title="测试开机"></a>测试开机</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs shell">mikey@mikey:~/bochs/bin$ ./bochs<br>========================================================================<br>                       Bochs x86 Emulator 2.6.2<br>                Built from SVN snapshot on May 26, 2013<br>                  Compiled on Feb 26 2021 at 11:34:31<br>========================================================================<br>00000000000i[     ] reading configuration from bochsrc<br>------------------------------<br>Bochs Configuration: Main Menu<br>------------------------------<br><br>This is the Bochs Configuration Interface, where you can describe the<br>machine that you want to simulate.  Bochs has already searched for a<br>configuration file (typically called bochsrc.txt) and loaded it if it<br>could be found.  When you are satisfied with the configuration, go<br>ahead and start the simulation.<br><br>You can also start bochs with the -q option to skip these menus.<br><br>1. Restore factory default configuration<br>2. Read options from...<br>3. Edit options<br>4. Save options to...<br>5. Restore the Bochs state from...<br>6. Begin simulation<br>7. Quit now<br><br>Please choose one: [6] 2<br><br>What is the configuration file name?<br>To cancel, type &#x27;none&#x27;. [bochsrc] <br>00000000000i[     ] reading configuration from bochsrc<br>------------------------------<br>Bochs Configuration: Main Menu<br>------------------------------<br><br>This is the Bochs Configuration Interface, where you can describe the<br>machine that you want to simulate.  Bochs has already searched for a<br>configuration file (typically called bochsrc.txt) and loaded it if it<br>could be found.  When you are satisfied with the configuration, go<br>ahead and start the simulation.<br><br>You can also start bochs with the -q option to skip these menus.<br><br>1. Restore factory default configuration<br>2. Read options from...<br>3. Edit options<br>4. Save options to...<br>5. Restore the Bochs state from...<br>6. Begin simulation<br>7. Quit now<br><br>Please choose one: [6] 6<br>00000000000i[     ] installing x module as the Bochs GUI<br>00000000000i[     ] Bochs x86 Emulator 2.6.2<br>00000000000i[     ]   Built from SVN snapshot on May 26, 2013<br>00000000000i[     ] Compiled on Feb 26 2021 at 11:34:31<br>00000000000i[     ] System configuration<br>00000000000i[     ]   processors: 1 (cores=1, HT threads=1)<br>00000000000i[     ]   A20 line support: yes<br>00000000000i[     ] IPS is set to 4000000<br>00000000000i[     ] CPU configuration<br>00000000000i[     ]   SMP support: no<br>00000000000i[     ]   level: 6<br>00000000000i[     ]   APIC support: xapic<br>00000000000i[     ]   FPU support: yes<br>00000000000i[     ]   MMX support: yes<br>00000000000i[     ]   3dnow! support: no<br>00000000000i[     ]   SEP support: yes<br>00000000000i[     ]   SSE support: sse2<br>00000000000i[     ]   XSAVE support: no <br>00000000000i[     ]   AES support: no<br>00000000000i[     ]   MOVBE support: no<br>00000000000i[     ]   ADX support: no<br>00000000000i[     ]   x86-64 support: no<br>00000000000i[     ]   MWAIT support: yes<br>00000000000i[     ] Optimization configuration<br>00000000000i[     ]   RepeatSpeedups support: no<br>00000000000i[     ]   Fast function calls: no<br>00000000000i[     ]   Handlers Chaining speedups: no<br>00000000000i[     ] Devices configuration<br>00000000000i[     ]   NE2000 support: no<br>00000000000i[     ]   PCI support: yes, enabled=yes<br>00000000000i[     ]   SB16 support: no<br>00000000000i[     ]   USB support: no<br>00000000000i[     ]   VGA extension support: vbe<br>00000000000i[MEM0 ] allocated memory at 0x7f7ad1cea010. after alignment, vector=0x7f7ad1ceb000<br>00000000000i[MEM0 ] 32.00MB<br>00000000000i[MEM0 ] mem block size = 0x00100000, blocks=32<br>00000000000i[MEM0 ] rom at 0xfffe0000/131072 (&#x27;/home/mikey/bochs/share/bochs/BIOS-bochs-latest&#x27;)<br>00000000000i[     ] init_dev of &#x27;pci&#x27; plugin device by virtual method<br>00000000000i[DEV  ] i440FX PMC present at device 0, function 0<br>00000000000i[     ] init_dev of &#x27;pci2isa&#x27; plugin device by virtual method<br>00000000000i[DEV  ] PIIX3 PCI-to-ISA bridge present at device 1, function 0<br>00000000000i[     ] init_dev of &#x27;cmos&#x27; plugin device by virtual method<br>00000000000i[CMOS ] Using local time for initial clock<br>00000000000i[CMOS ] Setting initial clock to: Fri Feb 26 11:58:08 2021 (time0=1614311888)<br>00000000000i[     ] init_dev of &#x27;dma&#x27; plugin device by virtual method<br>00000000000i[DMA  ] channel 4 used by cascade<br>00000000000i[     ] init_dev of &#x27;pic&#x27; plugin device by virtual method<br>00000000000i[     ] init_dev of &#x27;pit&#x27; plugin device by virtual method<br>00000000000i[     ] init_dev of &#x27;floppy&#x27; plugin device by virtual method<br>00000000000i[DMA  ] channel 2 used by Floppy Drive<br>00000000000i[     ] init_dev of &#x27;vga&#x27; plugin device by virtual method<br>00000000000i[MEM0 ] Register memory access handlers: 0x0000000a0000 - 0x0000000bffff<br>00000000000i[VGA  ] interval=200000<br>00000000000i[MEM0 ] Register memory access handlers: 0x0000e0000000 - 0x0000e0ffffff<br>00000000000i[BXVGA] VBE Bochs Display Extension Enabled<br>00000000000i[XGUI ] test_alloc_colors: 16 colors available out of 16 colors tried<br>00000000000i[XGUI ] font 8 wide x 16 high, display depth = 24<br>00000000000i[MEM0 ] rom at 0xc0000/41472 (&#x27;/home/mikey/bochs/share/bochs/VGABIOS-lgpl-latest&#x27;)<br>00000000000i[     ] init_dev of &#x27;acpi&#x27; plugin device by virtual method<br>00000000000i[DEV  ] ACPI Controller present at device 1, function 3<br>00000000000i[     ] init_dev of &#x27;ioapic&#x27; plugin device by virtual method<br>00000000000i[IOAP ] initializing I/O APIC<br>00000000000i[MEM0 ] Register memory access handlers: 0x0000fec00000 - 0x0000fec00fff<br>00000000000i[IOAP ] IOAPIC enabled (base address = 0xfec00000)<br>00000000000i[     ] init_dev of &#x27;keyboard&#x27; plugin device by virtual method<br>00000000000i[KBD  ] will paste characters every 400 keyboard ticks<br>00000000000i[     ] init_dev of &#x27;harddrv&#x27; plugin device by virtual method<br>00000000000i[HD   ] HD on ata0-0: &#x27;disk.img&#x27;, &#x27;flat&#x27; mode<br>00000000000p[HD   ] &gt;&gt;PANIC&lt;&lt; ata0-0: could not open hard drive image file &#x27;disk.img&#x27;<br>========================================================================<br>Bochs is exiting with the following message:<br>[HD   ] ata0-0: could not open hard drive image file &#x27;disk.img&#x27;<br>========================================================================<br>00000000000i[CTRL ] quit_sim called with exit code 1<br></code></pre></td></tr></table></figure><p>因为还没有设置启动盘所以报错，但是可以看到GUI界面还是挺激动的是吧哈哈哈哈</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226120003077.png" alt="测试开机"></p><h1 id="创建启动盘"><a href="#创建启动盘" class="headerlink" title="创建启动盘"></a>创建启动盘</h1><p>使用<code>bin/bximage</code>进行创建</p><blockquote><p>-fd 创建软盘。<br>-hd 创建硬盘。<br>-mode 创建硬盘的类型,有 flat、sparse、growing 三种。<br>-size 指创建多大的硬盘,以 MB 为单位。<br>-q 以静默模式创建,创建过程中不会和用户交互</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bin/bximage -hd -mode=&quot;flat&quot; -size=60 -q hd60M.img<br></code></pre></td></tr></table></figure><p>这个命令串中最后一个 hd60M.img 是咱们创建的虚拟硬盘的名称。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226121421416.png" alt="image-20210226121421416"></p><p>修改配置文件</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226122039438.png"></p><p>重新启动<code>./bochs -f bochsrc</code>查看效果</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226122004018.png" alt="image-20210226122004018"></p><h1 id="编写MBR"><a href="#编写MBR" class="headerlink" title="编写MBR"></a>编写MBR</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim mbr.S<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs bash">;主引导程序<br>;------------------------------------------------------------<br>SECTION MBR vstart=0x7c00<br>mov ax,cs<br>mov ds,ax<br>mov es,ax<br>mov ss,ax<br>mov fs,ax<br>mov sp,0x7c00<br>; 清屏利用 0x06 号功能,上卷全部行, 则可清屏 。<br>; -----------------------------------------------------------<br>;INT 0x10<br>;功能号:0x06<br>;功能描述:上卷窗口<br>;------------------------------------------------------<br>;输入:<br>;AH 功能号= 0x06<br>;AL = 上卷的行数(如果为 0,表示全部)<br>;BH = 上卷行属性<br>;(CL,CH) = 窗口左上角的(X,Y)位置<br>;(DL,DH) = 窗口右下角的(X,Y)位置<br>;无返回值:<br>mov ax, 0x600<br>mov bx, 0x700<br>mov cx, 0<br>; 左上角: (0, 0)<br>mov dx, 0x184f<br>; 右下角: (80,25),<br>; VGA 文本模式中,一行只能容纳 80 个字符,共 25 行 。<br>; 下标从 0 开始,所以 0x18=24,0x4f=79<br>int 0x10<br>; int 0x10<br>;;;;;;;;;<br>;下面这三行代码获取光标位置<br>;;;;;;;;;<br>;.get_cursor 获取当前光标位置,在光 标位置处打印字符 。<br>mov ah, 3<br>; 输入: 3 号子功能是获取光标位置,需要存入 ah 寄存器<br>mov bh, 0<br>; bh 寄存器存储的是待获取光标的页号<br>; 输出: ch=光标开始行,cl=光标结束行<br>; dh=光标所在行号,dl=光标所在列号<br>int 0x10<br>;;;;;;;;;<br>;获取光标位置结束<br>;;;;;;;;;;;;;;;;<br>;;;;;;;;;<br>;打印字符串<br>;;;;;;;;;;;<br>;还是用 10h 中断,不过这次调用 13 号子功能打印字符串<br>mov ax, message<br>mov bp, ax<br>; es:bp 为串首地址,es 此时同 cs 一致,<br>; 开头时已经为 sreg 初始化<br>; 光标位置要用到 dx 寄存器中内容,cx 中的光标位置可忽略<br>mov cx, 5<br>; cx 为串长度,不包括结束符 0 的字符个数<br>mov ax, 0x1301<br>;子功能号 13 显示字符及属性,要存入 ah 寄存器,<br>; al 设置写字符方式 ah=01: 显示字符串,光标跟随移动<br>mov bx, 0x2<br>; bh 存储要显示的页号,此处是第 0 页,<br>; bl 中是字符属性,属性黑底绿字(bl = 02h)<br>int 0x10<br>; 执行 BIOS 0x10 号中断<br>;;;;;;;;;<br>;打字字符串结束<br>;;;;;;;;;;;;;;;<br>; 使程序悬停在此<br>jmp $<br>message db <span class="hljs-string">&quot;1 MBR&quot;</span><br><span class="hljs-built_in">times</span> 510-($-$$) db 0<br>db 0x55,0xaa<br></code></pre></td></tr></table></figure><p>编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nasm -o mbr.bin mbr.S<br></code></pre></td></tr></table></figure><p>查看其大小为512k</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -lb mbr.bin<br></code></pre></td></tr></table></figure><p>配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dd if=/home/mikey/bochs/bin/mbr.bin of=/home/mikey/bochs/bin/hd60M.img bs=512 count=1 conv=notrunc<br></code></pre></td></tr></table></figure><p>查看</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./bochs</span> -f bochsrc<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226142846512.png" alt="启动成功截图"></p><p>即可完成一个简单MBR的编写</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="">《操作系统真相还原》</a></p><p><a href="https://www.cnblogs.com/lfri/p/11489223.html">Ubuntu 16.04LTS 安装和配置Bochs</a></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bochs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java篇-JVM详解</title>
    <link href="/2021/02/24/java/Java%E7%AF%87-JVM%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/02/24/java/Java%E7%AF%87-JVM%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="01-JVM内存与垃圾回收篇概述"><a href="#01-JVM内存与垃圾回收篇概述" class="headerlink" title="01-JVM内存与垃圾回收篇概述"></a>01-JVM内存与垃圾回收篇概述</h1><p>Java Virtual Machine(JVM):</p><blockquote><p><strong>Java virtual machine</strong> (<strong>JVM</strong>) is a <a href="https://en.wikipedia.org/wiki/Virtual_machine">virtual machine</a> that enables a computer to run <a href="https://en.wikipedia.org/wiki/Java_(software_platform)">Java</a> programs as well as programs written in <a href="https://en.wikipedia.org/wiki/List_of_JVM_languages">other languages</a> that are also compiled to <a href="https://en.wikipedia.org/wiki/Java_bytecode">Java bytecode</a>. The JVM is detailed by a <a href="https://en.wikipedia.org/wiki/Specification_(technical_standard)">specification</a> that formally describes what is required in a JVM implementation. Having a specification ensures interoperability of Java programs across different implementations so that program authors using the <a href="https://en.wikipedia.org/wiki/Java_Development_Kit">Java Development Kit</a> (JDK) need not worry about idiosyncrasies of the underlying hardware platform.</p></blockquote><p>Java Memary Model(JMM):</p><blockquote><p>The <strong>Java memory model</strong> describes how <a href="https://en.wikipedia.org/wiki/Thread_(computer_science)">threads</a> in the <a href="https://en.wikipedia.org/wiki/Java_(programming_language)">Java programming language</a> interact through memory. Together with the description of single-threaded execution of code, the memory model provides the <a href="https://en.wikipedia.org/wiki/Formal_semantics_of_programming_languages">semantics</a> of the Java programming language.</p></blockquote><p>Garbage Collection(GC):</p><blockquote><p>Java garbage collection is the process by which Java programs perform automatic memory management. Java programs compile to bytecode that can be run on a Java Virtual Machine, or JVM for short. When Java programs run on the JVM, objects are created on the heap, which is a portion of memory dedicated to the program. Eventually, some objects will no longer be needed. The garbage collector finds these unused objects and deletes them to free up memory.</p></blockquote><h1 id="02-如何看待Java上层技术与JVM"><a href="#02-如何看待Java上层技术与JVM" class="headerlink" title="02-如何看待Java上层技术与JVM"></a>02-如何看待Java上层技术与JVM</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TB;<br>A1(我们写的应用程序)--&gt;B1(Spring)<br>A1--&gt;B2(Struts)<br>A1--&gt;B3(MyBatis)<br>A1--&gt;B4(SpringMVC)<br><br>B1--&gt;C1(Java API)<br>B2--&gt;C1<br>B3--&gt;C1<br>B4--&gt;C1<br><br>C1--&gt;D1(JVM)<br><br>A(汇编语言)--&gt;B(机器指令)<br>C(高级语言)--&gt;D(汇编语言)<br>D--&gt;E(机器指令)<br>B--&gt;F(CPU)<br>E--&gt;F(CPU)<br></code></pre></td></tr></table></figure><h1 id="05-官方规范下载与参考书目"><a href="#05-官方规范下载与参考书目" class="headerlink" title="05-官方规范下载与参考书目"></a>05-官方规范下载与参考书目</h1><ul><li><p><a href="https://docs.oracle.com/javase/specs/jvms/se7/html/">The Java® Virtual Machine Specification</a></p></li><li><p>《深入了解Java虚拟机》</p></li></ul><h1 id="06-跨平台的语言Java和跨语言的平台JVM"><a href="#06-跨平台的语言Java和跨语言的平台JVM" class="headerlink" title="06-跨平台的语言Java和跨语言的平台JVM"></a>06-跨平台的语言Java和跨语言的平台JVM</h1><p><a href="https://www.tiobe.com/tiobe-index/">TIOBE语言热度排行榜</a></p><blockquote><p>Java是目前应用最为广泛的软件开发平台之一</p></blockquote><ul><li>作为平台。Java虚拟机有着举足轻重的作用，Groovy、Scala、JRuby、Kotlin等都是Java平台的一部分。</li><li>作为一种文化。Java几乎成为开源的代名词，第三方开源框架、JDK和JVM也有开源实现，如OpenJDK。</li><li>作为一个社区。Java拥有全世界最多的技术拥护者和开源社区支持，生态丰富。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TB;<br><br>A-1(Java应用程序)--&gt;A1<br>A1(字节码文件)--&gt;B1(Spring)<br>A1--&gt;B2(WindowsJVM)<br>A1--&gt;B3(LinuxJVM)<br>A1--&gt;B4(MacJVM)<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TB;<br>C1(Kotlin)--&gt;D1(编译器)<br>C2(Clojure)--&gt;D2(编译器)<br>C3(Groovy)--&gt;D3(编译器)<br>C4(Scala)--&gt;D4(编译器)<br>C5(Jython)--&gt;D5(编译器)<br>C6(JRuby)--&gt;D6(编译器)<br>C7(JavaScript)--&gt;D7(编译器)<br><br>D1--&gt;E<br>D2--&gt;E<br>D3--&gt;E<br>D4--&gt;E<br>D5--&gt;E<br>D6--&gt;E<br>D7--&gt;E<br><br>E(字节码文件)--&gt;F(Java虚拟机)<br></code></pre></td></tr></table></figure><h1 id="07-字节码与多语言混合编程"><a href="#07-字节码与多语言混合编程" class="headerlink" title="07-字节码与多语言混合编程"></a>07-字节码与多语言混合编程</h1><ol><li>Java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。</li><li>试想一下，在一个项目之中，并行处理用Clojure语言编写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在一个虚拟机之上。</li><li>对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进（如DaVinci Machine项目、Nashorn引擎、InvokeDynamic指令、java.lang.invoke包等），推动Java虚拟机从“Java语言的虚拟机”向 “多语言虚拟机”的方向发展。</li></ol><h1 id="08-Java及JVM历史上的重大事件"><a href="#08-Java及JVM历史上的重大事件" class="headerlink" title="08-Java及JVM历史上的重大事件"></a>08-Java及JVM历史上的重大事件</h1><ul><li>1990年，在Sun计算机公司中，由Patrick Naughton、MikeSheridan及James Gosling领导的小组Green Team，开发出的新的程序语言，命名为Oak，后期命名为Java</li><li>1995年，Sun正式发布Java和HotJava产品，Java首次公开亮相。</li><li>1996年1月23日Sun Microsystems发布了JDK 1.0。</li><li>1998年，JDK1.2版本发布。同时，Sun发布了JSP/Servlet、EJB规范，以及将Java分成了J2EE、J2SE和J2ME。这表明了Java开始向企业、桌面应用和移动设备应用3大领域挺进。</li><li>2000年，JDK1.3发布，Java HotSpot Virtual Machine正式发布，成为Java的默认虚拟机。</li><li>2002年，JDK1.4发布，古老的Classic虚拟机退出历史舞台。</li><li>2003年年底，Java平台的scala正式发布，同年Groovy也加入了Java阵营。</li><li>2004年，JDK1.5发布。同时JDK1.5改名为JavaSE5.0。</li><li>2006年，JDK6发布。同年，Java开源并建立了OpenJDK。顺理成章，Hotspot虚拟机也成为了OpenJDK中的默认虚拟机。</li><li>2007年，Java平台迎来了新伙伴Clojure。</li><li>2008年，oracle收购了BEA，得到了JRockit虚拟机。</li><li>2009年，Twitter宣布把后台大部分程序从Ruby迁移到Scala，这是Java平台的又一次大规模应用。</li><li>2010年，Oracle收购了Sun，获得Java商标和最真价值的HotSpot虚拟机。此时，Oracle拥有市场占用率最高的两款虚拟机HotSpot和JRockit，并计划在未来对它们进行整合：HotRockit。JCP组织管理Java语言</li><li>2011年，JDK7发布。在JDK1.7u4中，正式启用了新的垃圾回收器G1。</li><li><strong>2017年，JDK9发布。将G1设置为默认GC，替代CMS</strong></li><li>同年，IBM的J9开源，形成了现在的Open J9社区</li><li>2018年，Android的Java侵权案判决，Google赔偿Oracle计88亿美元</li><li>同年，Oracle宣告JavagE成为历史名词JDBC、JMS、Servlet赠予Eclipse基金会</li><li><strong>同年，JDK11发布，LTS版本的JDK，发布革命性的ZGC，调整JDK授权许可</strong></li><li>2019年，JDK12发布，加入RedHat领导开发的Shenandoah GC</li></ul><h1 id="09-虚拟机与Java虚拟机介绍"><a href="#09-虚拟机与Java虚拟机介绍" class="headerlink" title="09-虚拟机与Java虚拟机介绍"></a>09-虚拟机与Java虚拟机介绍</h1><h3 id="虚拟机概念"><a href="#虚拟机概念" class="headerlink" title="虚拟机概念"></a>虚拟机概念</h3><ul><li><p>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。</p><ul><li><p>大名鼎鼎的Virtual Box，VMware就属于系统虚拟机，它们完全是对物理计算机硬件的仿真(模拟)，提供了一个可运行完整操作系统的软件平台。</p></li><li><p>程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。</p></li></ul></li><li><p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p></li></ul><h3 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h3><ol><li>Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。</li><li>JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</li><li><strong>Java技术的核心就是Java虚拟机</strong>（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。</li></ol><p><strong>作用：</strong></p><p>Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p><p><strong>特点：</strong></p><ol><li>一次编译，到处运行</li><li>自动内存管理</li><li>自动垃圾回收功能</li></ol><h1 id="10-JVM的位置"><a href="#10-JVM的位置" class="headerlink" title="10-JVM的位置"></a>10-JVM的位置</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/tva1.sinaimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200704183048061.png" alt="image-20200704183048061"></p><h1 id="11-JVM的整体结构"><a href="#11-JVM的整体结构" class="headerlink" title="11-JVM的整体结构"></a>11-JVM的整体结构</h1><ul><li>HotSpot VM是目前市面上高性能虚拟机的代表作之一。</li><li>它采用解释器与即时编译器并存的架构。</li><li>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一较高下的地步。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200704183436495.png" alt="image-20200704183436495"></p><p>执行引擎包含三部分：<code>解释器</code>，<code>及时编译器</code>，<code>垃圾回收器</code></p><h1 id="12-Java代码执行流程"><a href="#12-Java代码执行流程" class="headerlink" title="12-Java代码执行流程"></a>12-Java代码执行流程</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200704210429535.png" alt="image-20200704210429535"></p><p>只是能生成被Java虚拟机所能解释的字节码文件，那么理论上就可以自己设计一套代码了</p><h1 id="13-区分栈的指令集架构和寄存器的指令集架构"><a href="#13-区分栈的指令集架构和寄存器的指令集架构" class="headerlink" title="13-区分栈的指令集架构和寄存器的指令集架构"></a>13-区分栈的指令集架构和寄存器的指令集架构</h1><p>Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。具体来说：这两种架构之间的区别：</p><p>基于<code>栈式架构</code>的特点</p><ul><li>设计和实现更简单，适用于资源受限的系统；</li><li>避开了寄存器的分配难题：使用零地址指令方式分配。</li><li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。</li><li>不需要硬件支持，可移植性更好，更好实现跨平台</li></ul><p>基于寄存器架构的特点</p><ul><li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。</li><li>指令集架构则完全依赖硬件，可移植性差</li><li>性能优秀和执行更高效</li><li>花费更少的指令去完成一项操作。</li><li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主方水洋</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>同样执行2+3这种逻辑操作，其指令分别如下：</p><p>基于栈的计算流程（以Java虚拟机为例）：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">iconst_2 <span class="hljs-regexp">//</span>常量<span class="hljs-number">2</span>入栈<br>istore_1<br>iconst_3 <span class="hljs-regexp">//</span> 常量<span class="hljs-number">3</span>入栈<br>istore_2<br>iload_1<br>iload_2<br>iadd <span class="hljs-regexp">//</span>常量<span class="hljs-number">2</span>/<span class="hljs-number">3</span>出栈，执行相加<br>istore_0 <span class="hljs-regexp">//</span> 结果<span class="hljs-number">5</span>入栈<br></code></pre></td></tr></table></figure><p>而基于寄存器的计算流程</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-number">2</span> //将<span class="hljs-built_in">eax</span>寄存器的值设为<span class="hljs-number">1</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">eax</span>,<span class="hljs-number">3</span> //使<span class="hljs-built_in">eax</span>寄存器的值加<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="字节码反编译"><a href="#字节码反编译" class="headerlink" title="字节码反编译"></a>字节码反编译</h3><p>我们编写一个简单的代码，然后查看一下字节码的反编译后的结果</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackStruTest</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span> + <span class="hljs-number">3</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们找到编译后的 class文件，使用下列命令进行反编译</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">javap -v <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StackStruTest</span>.</span></span><span class="hljs-keyword">class</span><br></code></pre></td></tr></table></figure><p>得到的文件为:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">public</span> static void main(java.lang.String[]);<br>  <span class="hljs-attribute">descriptor</span>: ([Ljava/lang/String;)V<br>  <span class="hljs-attribute">flags</span>: ACC_PUBLIC, ACC_STATIC<br>  <span class="hljs-attribute">Code</span>:<br>    <span class="hljs-attribute">stack</span>=<span class="hljs-number">2</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">1</span><br>       <span class="hljs-attribute">0</span>: iconst_<span class="hljs-number">2</span><br>       <span class="hljs-attribute">1</span>: istore_<span class="hljs-number">1</span><br>       <span class="hljs-attribute">2</span>: iconst_<span class="hljs-number">3</span><br>       <span class="hljs-attribute">3</span>: istore_<span class="hljs-number">2</span><br>       <span class="hljs-attribute">4</span>: iload_<span class="hljs-number">1</span><br>       <span class="hljs-attribute">5</span>: iload_<span class="hljs-number">2</span><br>       <span class="hljs-attribute">6</span>: iadd<br>       <span class="hljs-attribute">7</span>: istore_<span class="hljs-number">3</span><br>       <span class="hljs-attribute">8</span>: return<br>    <span class="hljs-attribute">LineNumberTable</span>:<br>      <span class="hljs-attribute">line</span> <span class="hljs-number">9</span>: <span class="hljs-number">0</span><br>      <span class="hljs-attribute">line</span> <span class="hljs-number">10</span>: <span class="hljs-number">2</span><br>      <span class="hljs-attribute">line</span> <span class="hljs-number">11</span>: <span class="hljs-number">4</span><br>      <span class="hljs-attribute">line</span> <span class="hljs-number">12</span>: <span class="hljs-number">8</span><br>    <span class="hljs-attribute">LocalVariableTable</span>:<br>      <span class="hljs-attribute">Start</span>  Length  Slot  Name   Signature<br>          <span class="hljs-attribute">0</span>       <span class="hljs-number">9</span>     <span class="hljs-number">0</span>  args  <span class="hljs-meta"> [Ljava/lang/String;</span><br><span class="hljs-meta">          2       7     1     i   I</span><br><span class="hljs-meta">          4       5     2     j   I</span><br><span class="hljs-meta">          8       1     3     k   I</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p><p>时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpotVM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul><li>跨平台性</li><li>指令集小</li><li>指令多</li><li>执行性能比寄存器差</li></ul><h1 id="14-JVM的生命周期"><a href="#14-JVM的生命周期" class="headerlink" title="14-JVM的生命周期"></a>14-JVM的生命周期</h1><h3 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a>虚拟机的启动</h3><p>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p><h3 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h3><ul><li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。</li><li>程序开始执行时他才运行，程序结束时他就停止。</li><li>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。</li></ul><h3 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a>虚拟机的退出</h3><p>有如下的几种情况：</p><ul><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统用现错误而导致Java虚拟机进程终止</li><li>某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。</li><li>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。</li></ul><h1 id="15-SUN-Classic-VM的介绍"><a href="#15-SUN-Classic-VM的介绍" class="headerlink" title="15-SUN Classic VM的介绍"></a>15-SUN Classic VM的介绍</h1><ul><li>早在1996年Java1.0版本的时候，Sun公司发布了一款名为sun classic VM的Java虚拟机，它同时也是世界上第一款商用Java虚拟机，JDK1.4时完全被淘汰。</li><li>这款虚拟机内部只提供解释器。现在还有及时编译器，因此效率比较低，而及时编译器会把热点代码缓存起来，那么以后使用热点代码的时候，效率就比较高。</li><li>如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。</li><li>现在hotspot内置了此虚拟机。</li></ul><h1 id="16-Exact-VM的介绍"><a href="#16-Exact-VM的介绍" class="headerlink" title="16-Exact VM的介绍"></a>16-Exact VM的介绍</h1><p>为了解决上一个虚拟机问题，jdk1.2时，sun提供了此虚拟机。 Exact Memory Management：准确式内存管理</p><ul><li>也可以叫Non-Conservative/Accurate Memory Management</li><li>虚拟机可以知道内存中某个位置的数据具体是什么类型。|</li></ul><p>具备现代高性能虚拟机的维形</p><ul><li>热点探测（寻找出热点代码进行缓存）</li><li>编译器与解释器混合工作模式</li></ul><p>只在solaris平台短暂使用，其他平台上还是classic vm，英雄气短，终被Hotspot虚拟机替换</p><h1 id="17-HotSpot-VM的介绍"><a href="#17-HotSpot-VM的介绍" class="headerlink" title="17-HotSpot VM的介绍"></a>17-HotSpot VM的介绍</h1><p>HotSpot历史</p><ul><li>最初由一家名为“Longview Technologies”的小公司设计</li><li>1997年，此公司被sun收购；2009年，Sun公司被甲骨文收购。</li><li>JDK1.3时，HotSpot VM成为默认虚拟机</li></ul><p>目前Hotspot占有绝对的市场地位，称霸武林。</p><ul><li>不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot</li><li>Sun/oracle JDK和openJDK的默认虚拟机</li><li>其他两个商用虚机都没有方法区的概念</li></ul><p>从服务器、桌面到移动端、嵌入式都有应用。</p><p>名称中的HotSpot指的就是它的热点代码探测技术。</p><ul><li>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</li><li>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</li></ul><h1 id="18-JRockit-VM的介绍"><a href="#18-JRockit-VM的介绍" class="headerlink" title="18-JRockit VM的介绍"></a>18-JRockit VM的介绍</h1><p>专注于服务器端应用</p><ul><li>它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行。</li></ul><p>大量的行业基准测试显示，JRockit JVM是世界上最快的JVM。</p><ul><li>使用JRockit产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成本的减少（达50%）。</li></ul><p>优势：全面的Java运行时解决方案组合</p><ul><li>JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要</li><li>MissionControl服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</li></ul><p>2008年，JRockit被oracle收购。</p><p>oracle表达了整合两大优秀虚拟机的工作，大致在JDK8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。</p><p>高斯林：目前就职于谷歌，研究人工智能和水下机器人</p><h1 id="19-IBM-J9-VM的介绍"><a href="#19-IBM-J9-VM的介绍" class="headerlink" title="19-IBM J9 VM的介绍"></a>19-IBM J9 VM的介绍</h1><p>全称：IBM Technology for Java Virtual Machine，简称IT4J，内部代号：J9</p><p>市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多用途VM广泛用于IBM的各种Java产品。</p><p>目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的Java虚拟机。</p><p>2017年左右，IBM发布了开源J9VM，命名为openJ9，交给EClipse基金会管理，也称为Eclipse OpenJ9</p><p>OpenJDK -&gt; 是JDK开源了，包括了虚拟机</p><h1 id="20-KVM、CDC、CLDC的介绍"><a href="#20-KVM、CDC、CLDC的介绍" class="headerlink" title="20-KVM、CDC、CLDC的介绍"></a>20-KVM、CDC、CLDC的介绍</h1><p>racle在Java ME产品线上的两款虚拟机为：CDC/CLDC HotSpot Implementation VM KVM（Kilobyte）是CLDC-HI早期产品目前移动领域地位尴尬，智能机被Angroid和ioS二分天下。</p><p>KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场</p><ul><li>智能控制器、传感器</li><li>老人手机、经济欠发达地区的功能手机</li></ul><p>所有的虚拟机的原则：一次编译，到处运行。</p><h1 id="21-Azul-VM和BEA-Liquid-VM的介绍"><a href="#21-Azul-VM和BEA-Liquid-VM的介绍" class="headerlink" title="21-Azul VM和BEA Liquid VM的介绍"></a>21-Azul VM和BEA Liquid VM的介绍</h1><h3 id="Azul-VM"><a href="#Azul-VM" class="headerlink" title="Azul VM"></a>Azul VM</h3><p>前面三大“高性能Java虚拟机”使用在通用硬件平台上这里Azu1VW和BEALiquid VM是与特定硬件平台绑定、软硬件配合的专有虚拟机I</p><ul><li>高性能Java虚拟机中的战斗机。</li></ul><p>Azul VM是Azu1Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的专有硬件Vega系统上的ava虚拟机。</p><p>每个Azu1VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。</p><p>2010年，AzulSystems公司开始从硬件转向软件，发布了自己的zing JVM，可以在通用x86平台上提供接近于Vega系统的特性。</p><h3 id="Liquid-VM"><a href="#Liquid-VM" class="headerlink" title="Liquid VM"></a>Liquid VM</h3><p>高性能Java虚拟机中的战斗机。</p><p>BEA公司开发的，直接运行在自家Hypervisor系统上Liquid VM即是现在的JRockit VE（Virtual Edition），</p><p>Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。</p><p>随着JRockit虚拟机终止开发，Liquid vM项目也停止了。</p><h1 id="22-Apache-Harmony的介绍"><a href="#22-Apache-Harmony的介绍" class="headerlink" title="22-Apache Harmony的介绍"></a>22-Apache Harmony的介绍</h1><p>Apache也曾经推出过与JDK1.5和JDK1.6兼容的Java运行平台Apache Harmony。</p><p>它是IElf和Inte1联合开发的开源JVM，受到同样开源的openJDK的压制，Sun坚决不让Harmony获得JCP认证，最终于2011年退役，IBM转而参与OpenJDK</p><p>虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK。</p><h1 id="23-Microsoft-JVM和TaobaoJVM"><a href="#23-Microsoft-JVM和TaobaoJVM" class="headerlink" title="23-Microsoft JVM和TaobaoJVM"></a>23-Microsoft JVM和TaobaoJVM</h1><h3 id="Micorsoft-JVM"><a href="#Micorsoft-JVM" class="headerlink" title="Micorsoft JVM"></a>Micorsoft JVM</h3><p>微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM。</p><p>只能在window平台下运行。但确是当时Windows下性能最好的Java VM。</p><p>1997年，sun以侵犯商标、不正当竞争罪名指控微软成功，赔了sun很多钱。微软windowsXPSP3中抹掉了其VM。现在windows上安装的jdk都是HotSpot。</p><h3 id="Taobao-JVM"><a href="#Taobao-JVM" class="headerlink" title="Taobao JVM"></a>Taobao JVM</h3><p>由AliJVM团队发布。阿里，国内使用Java最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。</p><p>基于openJDK开发了自己的定制版本AlibabaJDK，简称AJDK。是整个阿里Java体系的基石。</p><p>基于openJDK Hotspot VM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机。</p><ul><li>创新的GCIH（GCinvisible heap）技术实现了off-heap，即将生命周期较长的Java对象从heap中移到heap之外，并且Gc不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升Gc的回收效率的目的。</li><li>GCIH中的对象还能够在多个Java虚拟机进程中实现共享</li><li>使用crc32指令实现JvM intrinsic降低JNI的调用开销</li><li>PMU hardware的Java profiling tool和诊断协助功能</li><li>针对大数据场景的ZenGc</li></ul><p>taobao vm应用在阿里产品上性能高，硬件严重依赖inte1的cpu，损失了兼容性，但提高了性能</p><p>目前已经在淘宝、天猫上线，把oracle官方JvM版本全部替换了。</p><h1 id="24-Dalvik-VM及其他虚拟机的介绍"><a href="#24-Dalvik-VM及其他虚拟机的介绍" class="headerlink" title="24-Dalvik VM及其他虚拟机的介绍"></a>24-Dalvik VM及其他虚拟机的介绍</h1><p>谷歌开发的，应用于Android系统，并在Android2.2中提供了JIT，发展迅猛。</p><p>Dalvik y只能称作虚拟机，而不能称作“Java虚拟机”，它没有遵循 Java虚拟机规范</p><p>不能直接执行Java的Class文件</p><p>基于寄存器架构，不是jvm的栈架构。</p><p>执行的是编译以后的dex（Dalvik Executable）文件。执行效率比较高。</p><ul><li>它执行的dex（Dalvik Executable）文件可以通过class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。</li></ul><p>Android 5.0使用支持提前编译（Ahead of Time Compilation，AoT）的ART VM替换Dalvik VM。</p><h1 id="25-Graal-VM的介绍"><a href="#25-Graal-VM的介绍" class="headerlink" title="25-Graal VM的介绍"></a>25-Graal VM的介绍</h1><p>2018年4月，oracle Labs公开了GraalvM，号称 “Run Programs Faster Anywhere”，勃勃野心。与1995年java的”write once，run anywhere”遥相呼应。</p><p>GraalVM在HotSpot VM基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言” 的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R等</p><p>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件</p><p>工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</p><p>如果说HotSpot有一天真的被取代，Graalvm希望最大。但是Java的软件生态没有丝毫变化。</p><h1 id="26-内存结构概述"><a href="#26-内存结构概述" class="headerlink" title="26-内存结构概述"></a>26-内存结构概述</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210224232545014.png" alt="image-20210224232545014"></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200705080911284.png" alt="image-20200705080911284"></p><p>如果自己想手写一个Java虚拟机的话，主要考虑哪些结构呢？</p><ul><li>类加载器</li><li>执行引擎</li></ul><h1 id="27-概述类的加载器及类加载过程"><a href="#27-概述类的加载器及类加载过程" class="headerlink" title="27-概述类的加载器及类加载过程"></a>27-概述类的加载器及类加载过程</h1><p>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</p><p>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</p><p>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200705081813409.png" alt="image-20200705081813409"></p><ul><li>class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</li><li>class file加载到JVM中，被称为DNA元数据模板，放在方法区。</li><li>在.class文件-&gt;JVM-&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200705081913538.png" alt="image-20200705081913538"></p><p>例如下面的一段简单的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloLoader</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我已经被加载啦&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>它的加载过程是怎么样的呢?</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200705082255746.png" alt="image-20200705082255746"></p><p>完整的流程图如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200705082601441.png" alt="image-20200705082601441"></p><h1 id="28-类的加载过程一：Loading"><a href="#28-类的加载过程一：Loading" class="headerlink" title="28-类的加载过程一：Loading"></a>28-类的加载过程一：Loading</h1><p>通过一个类的全限定名获取定义此类的二进制字节流</p><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p><p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p><h3 id="加载class文件的方式"><a href="#加载class文件的方式" class="headerlink" title="加载class文件的方式"></a>加载class文件的方式</h3><ul><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从zip压缩包中读取，成为日后jar、war格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ul><h1 id="29-类的加载过程二：Linking"><a href="#29-类的加载过程二：Linking" class="headerlink" title="29-类的加载过程二：Linking"></a>29-类的加载过程二：Linking</h1><h4 id="验证-Verify"><a href="#验证-Verify" class="headerlink" title="验证 Verify"></a>验证 Verify</h4><p>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</p><p>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210224234633992.png" alt="image-20210224234633992"></p><p>如果出现不合法的字节码文件，那么将会验证不通过</p><p>同时我们可以通过安装IDEA的插件，来查看我们的Class文件</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210224234734657.png" alt="image-20210224234734657"></p><p>点击view选择Show bytecode with jclasslib</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210224235108632.png" alt="image-20210224235108632"></p><h3 id="准备-Prepare"><a href="#准备-Prepare" class="headerlink" title="准备 Prepare"></a>准备 Prepare</h3><p>为类变量分配内存并且设置该类变量的默认初始值，即零值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloApp</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 准备阶段为0，在下个阶段，也就是初始化的时候才是1</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的变量a在准备阶段会赋初始值，但不是1，而是0。</p><p>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化；</p><p>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</p><h3 id="解析-Resolve"><a href="#解析-Resolve" class="headerlink" title="解析 Resolve"></a>解析 Resolve</h3><p>将常量池内的符号引用转换为直接引用的过程。</p><p>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。</p><p>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</p><h1 id="30-类的加载过程三：Initialization"><a href="#30-类的加载过程三：Initialization" class="headerlink" title="30-类的加载过程三：Initialization"></a>30-类的加载过程三：Initialization</h1><p>初始化阶段就是执行类构造器法（）的过程。</p><p>此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</p><ul><li>也就是说，当我们代码中包含static变量的时候，就会有clinit方法</li></ul><p>构造器方法中指令按语句在源文件中出现的顺序执行。</p><p>（）不同于类的构造器。（关联：构造器是虚拟机视角下的（））若该类具有父类，JVM会保证子类的（）执行前，父类的（）已经执行完毕。</p><ul><li>任何一个类在声明后，都有生成一个构造器，默认是空参构造器</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassInitTest</span> &#123;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">static</span> &#123;<br>        num = <span class="hljs-number">2</span>;<br>        number = <span class="hljs-number">20</span>;<br>        System.out.<span class="hljs-built_in">println</span>(num);<br>        System.out.<span class="hljs-built_in">println</span>(number);  <span class="hljs-comment">//报错，非法的前向引用</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(ClassInitTest.num); <span class="hljs-comment">// 2</span><br>        System.out.<span class="hljs-built_in">println</span>(ClassInitTest.number); <span class="hljs-comment">// 10</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于涉及到父类时候的变量赋值过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClinitTest1</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> A = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">static</span> &#123;<br>            A = <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> b = A;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(Son.b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们输出结果为 2，也就是说首先加载ClinitTest1的时候，会找到main方法，然后执行Son的初始化，但是Son继承了Father，因此还需要执行Father的初始化，同时将A赋值为2。我们通过反编译得到Father的加载过程，首先我们看到原来的值被赋值成1，然后又被复制成2，最后返回</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">iconst_1<br>putstatic #<span class="hljs-number">2</span> &lt;com<span class="hljs-regexp">/atguigu/</span>java<span class="hljs-regexp">/chapter02/</span>ClinitTest1$Father.A&gt;<br>iconst_2<br>putstatic #<span class="hljs-number">2</span> &lt;com<span class="hljs-regexp">/atguigu/</span>java<span class="hljs-regexp">/chapter02/</span>ClinitTest1$Father.A&gt;<br><span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>虚拟机必须保证一个类的（）方法在多线程下被同步加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadThreadTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 线程t1开始&quot;</span>);<br>            <span class="hljs-keyword">new</span> DeadThread();<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 线程t2开始&quot;</span>);<br>            <span class="hljs-keyword">new</span> DeadThread();<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadThread</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">true</span>) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 初始化当前类&quot;</span>);<br>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码，输出结果为</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">线程<span class="hljs-built_in">t1</span>开始<br>线程<span class="hljs-built_in">t2</span>开始<br>线程<span class="hljs-built_in">t2</span> 初始化当前类<br></code></pre></td></tr></table></figure><p>从上面可以看出初始化后，只能够执行一次初始化，这也就是同步加锁的过程</p><h1 id="31-几种类加载器的使用体会"><a href="#31-几种类加载器的使用体会" class="headerlink" title="31-几种类加载器的使用体会"></a>31-几种类加载器的使用体会</h1><p>JVM支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</p><p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。</p><p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200705094149223.png" alt="image-20200705094149223"></p><p>这里的四者之间是<code>包含关系</code>，不是上层和下层，也不是子系统的继承关系。</p><p>我们通过一个类，获取它不同的加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassLoaderTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 获取系统类加载器</span><br>        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();<br>        System.out.println(<span class="hljs-string">&quot;获取系统类加载器:&quot;</span>+systemClassLoader);<br><br>        <span class="hljs-comment">// 获取其上层的：扩展类加载器</span><br>        ClassLoader extClassLoader = systemClassLoader.getParent();<br>        System.out.println(<span class="hljs-string">&quot;扩展类加载器:&quot;</span>+extClassLoader);<br><br>        <span class="hljs-comment">// 试图获取根加载器</span><br>        ClassLoader bootstrapClassLoader = extClassLoader.getParent();<br>        System.out.println(<span class="hljs-string">&quot;试图获取根加载器:&quot;</span>+bootstrapClassLoader);<br><br>        <span class="hljs-comment">// 获取自定义加载器</span><br>        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();<br>        System.out.println(<span class="hljs-string">&quot;获取自定义加载器:&quot;</span>+classLoader);<br><br>        <span class="hljs-comment">// 获取String类型的加载器</span><br>        ClassLoader classLoader1 = String.class.getClassLoader();<br>        System.out.println(<span class="hljs-string">&quot;获取String类型的加载器:&quot;</span>+classLoader1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elixir">获取系统类加载器<span class="hljs-symbol">:sun</span>.misc.Launcher<span class="hljs-variable">$AppClassLoader</span><span class="hljs-variable">@18b4aac2</span><br>扩展类加载器<span class="hljs-symbol">:sun</span>.misc.Launcher<span class="hljs-variable">$ExtClassLoader</span><span class="hljs-variable">@74a14482</span><br>试图获取根加载器<span class="hljs-symbol">:null</span><br>获取自定义加载器<span class="hljs-symbol">:sun</span>.misc.Launcher<span class="hljs-variable">$AppClassLoader</span><span class="hljs-variable">@18b4aac2</span><br>获取String类型的加载器<span class="hljs-symbol">:null</span><br></code></pre></td></tr></table></figure><h1 id="32-引导类、扩展类、系统类加载器的使用及演示"><a href="#32-引导类、扩展类、系统类加载器的使用及演示" class="headerlink" title="32-引导类、扩展类、系统类加载器的使用及演示"></a>32-引导类、扩展类、系统类加载器的使用及演示</h1><h3 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h3><h4 id="启动类加载器（引导类加载器，Bootstrap-ClassLoader）"><a href="#启动类加载器（引导类加载器，Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（引导类加载器，Bootstrap ClassLoader）"></a>启动类加载器（引导类加载器，Bootstrap ClassLoader）</h4><ul><li>这个类加载使用C/C++语言实现的，嵌套在JVM内部。</li><li>它用来加载Java的核心库（JAVAHOME/jre/1ib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li><li>并不继承自ava.lang.ClassLoader，没有父加载器。</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ul><h3 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h3><ul><li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/1ib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li></ul><h3 id="应用程序类加载器（系统类加载器，AppClassLoader）"><a href="#应用程序类加载器（系统类加载器，AppClassLoader）" class="headerlink" title="应用程序类加载器（系统类加载器，AppClassLoader）"></a>应用程序类加载器（系统类加载器，AppClassLoader）</h3><ul><li>javI语言编写，由sun.misc.LaunchersAppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过classLoader#getSystemclassLoader（）方法可以获取到该类加载器</li></ul><h1 id="33-为什么需要用户自定义类加载器及具体实现"><a href="#33-为什么需要用户自定义类加载器及具体实现" class="headerlink" title="33-为什么需要用户自定义类加载器及具体实现"></a>33-为什么需要用户自定义类加载器及具体实现</h1><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。 为什么要自定义类加载器？</p><ul><li>隔离加载类</li><li>修改类加载的方式</li><li>扩展加载源</li><li>防止源码泄漏</li></ul><p>用户自定义类加载器实现步骤：</p><ul><li>开发人员可以通过继承抽象类ava.1ang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写1oadClass（）方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖1oadclass（）方法，而是建议把自定义的类加载逻辑写在findclass（）方法中</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ul><h3 id="查看根加载器所能加载的目录"><a href="#查看根加载器所能加载的目录" class="headerlink" title="查看根加载器所能加载的目录"></a>查看根加载器所能加载的目录</h3><p>刚刚我们通过概念了解到了，根加载器只能够加载 java /lib目录下的class，我们通过下面代码验证一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassLoaderTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;*********启动类加载器************&quot;</span>);<br>        <span class="hljs-comment">// 获取BootstrapClassLoader 能够加载的API的路径</span><br>        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();<br>        <span class="hljs-keyword">for</span> (URL url : urls) &#123;<br>            System.out.println(url.toExternalForm());<br>        &#125;<br>        <span class="hljs-comment">// 从上面路径中，随意选择一个类，来看看他的类加载器是什么：得到的是null，说明是  根加载器</span><br>        ClassLoader classLoader = Provider.class.getClassLoader();<br>        <br>        <span class="hljs-comment">//*********启动类加载器************</span><br>        <span class="hljs-comment">//file:/home/mikey/DevTools/jdk1.8.0_221/jre/lib/resources.jar</span><br>        <span class="hljs-comment">//file:/home/mikey/DevTools/jdk1.8.0_221/jre/lib/rt.jar</span><br>        <span class="hljs-comment">//file:/home/mikey/DevTools/jdk1.8.0_221/jre/lib/sunrsasign.jar</span><br>        <span class="hljs-comment">//file:/home/mikey/DevTools/jdk1.8.0_221/jre/lib/jsse.jar</span><br>        <span class="hljs-comment">//file:/home/mikey/DevTools/jdk1.8.0_221/jre/lib/jce.jar</span><br>        <span class="hljs-comment">//file:/home/mikey/DevTools/jdk1.8.0_221/jre/lib/charsets.jar</span><br>        <span class="hljs-comment">//file:/home/mikey/DevTools/jdk1.8.0_221/jre/lib/jfr.jar</span><br>        <span class="hljs-comment">//file:/home/mikey/DevTools/jdk1.8.0_221/jre/classes</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">//Process finished with exit code 0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="34-ClassLoader的常用方法及获取方法"><a href="#34-ClassLoader的常用方法及获取方法" class="headerlink" title="34-ClassLoader的常用方法及获取方法"></a>34-ClassLoader的常用方法及获取方法</h1><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200705103516138.png" alt="image-20200705103516138"></p><p>sun.misc.Launcher 它是一个java虚拟机的入口应用</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200705103636003.png" alt="image-20200705103636003"></p><p>获取ClassLoader的途径</p><ul><li>获取当前ClassLoader：clazz.getClassLoader()</li><li>获取当前线程上下文的ClassLoader：Thread.currentThread().getContextClassLoader()</li><li>获取系统的ClassLoader：ClassLoader.getSystemClassLoader()</li><li>获取调用者的ClassLoader：DriverManager.getCallerClassLoader()</li></ul><h1 id="35-双亲委派机制的工作原理及演示"><a href="#35-双亲委派机制的工作原理及演示" class="headerlink" title="35-双亲委派机制的工作原理及演示"></a>35-双亲委派机制的工作原理及演示</h1><p>Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200705105151258.png" alt="image-20200705105151258"></p><h3 id="双亲委派机制举例"><a href="#双亲委派机制举例" class="headerlink" title="双亲委派机制举例"></a>双亲委派机制举例</h3><p>当我们加载jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI核心类，然后在加载SPI接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar的加载。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200705105810107.png" alt="image-20200705105810107"></p><h3 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h3><p>自定义string类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p><h1 id="36-双亲委派机制的优势"><a href="#36-双亲委派机制的优势" class="headerlink" title="36-双亲委派机制的优势"></a>36-双亲委派机制的优势</h1><p>通过上面的例子，我们可以知道，双亲机制可以</p><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心API被随意篡改<ul><li>自定义类：java.lang.String</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li></ul></li></ul><h3 id="如何判断两个class对象是否相同"><a href="#如何判断两个class对象是否相同" class="headerlink" title="如何判断两个class对象是否相同"></a>如何判断两个class对象是否相同</h3><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ul><li>类的完整类名必须一致，包括包名。</li><li>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。</li></ul><p>换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。</p><p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p><h1 id="37-沙箱安全机制"><a href="#37-沙箱安全机制" class="headerlink" title="37-沙箱安全机制"></a>37-沙箱安全机制</h1><p>自定义string类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p><h1 id="38-类的主动使用与被动使用等"><a href="#38-类的主动使用与被动使用等" class="headerlink" title="38-类的主动使用与被动使用等"></a>38-类的主动使用与被动使用等</h1><p>Java程序对类的使用方式分为：王动使用和被动使用。 主动使用，又分为七种情况：</p><ul><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法I</li><li>反射（比如：Class.forName（”com.atguigu.Test”））</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被标明为启动类的类</li><li>JDK7开始提供的动态语言支持：</li><li>java.lang.invoke.MethodHandle实例的解析结果REF getStatic、REF putStatic、REF invokeStatic句柄对应的类没有初始化，则初始化</li></ul><p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化。</p><h1 id="39-运行时数据区内部结构"><a href="#39-运行时数据区内部结构" class="headerlink" title="39-运行时数据区内部结构"></a>39-运行时数据区内部结构</h1><p>本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200705111640511.png" alt="image-20200705111640511"></p><p>当我们通过前面的：类的加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200705111843003.png" alt="image-20200705111843003"></p><p>也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200705112036630.png" alt="image-20200705112036630"></p><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p><blockquote><p>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</p></blockquote><p>运行时数据区的完整图</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200705112416101.png" alt="image-20200705112416101"></p><p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p><p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p><ul><li>每个线程：独立包括程序计数器、栈、本地栈。</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200705112601211.png" alt="image-20200705112601211"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。 在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。</p><ul><li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</li></ul><p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run（）方法。</p><h1 id="40-JVM中的线程说明"><a href="#40-JVM中的线程说明" class="headerlink" title="40-JVM中的线程说明"></a>40-JVM中的线程说明</h1><p>如果你使用console或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main（String[]）的main线程以及所有这个main线程自己创建的线程。| 这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p><ul><li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li><li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li><li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li><li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li><li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li></ul><h1 id="41-PC寄存器概述"><a href="#41-PC寄存器概述" class="headerlink" title="41-PC寄存器概述"></a>41-PC寄存器概述</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210225150048654.png" alt="image-20210225150048654"></p><p>JVM中的程序计数寄存器(Program Counter Register) 中，Register 的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有 把数据装载到寄存器才能够运行。「这里，并非是广义上所指的物理寄存器，或许将其翻译为Pc计数器(或指令计数器)会更加贴切(也称为程序钩子)，并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210225150239195.png" alt="image-20210225150239195"></p><ul><li>它是一块很小的内存空间，几乎可以忽略不证。也是运行速度最快的存储区域。|</li><li>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</li><li>任何时间一一个线程都只有一一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址:或者，如果是在执行native方法，则是未指定值(undefned)。</li><li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li><li>它是唯一一 个 在Java虚拟机规范中没有规定任何OutOtMemoryError情况的区域。</li></ul><h1 id="42-PC寄存器的使用举例"><a href="#42-PC寄存器的使用举例" class="headerlink" title="42-PC寄存器的使用举例"></a>42-PC寄存器的使用举例</h1><p>我们首先写一个简单的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCRegisterTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">20</span>;<br>        <span class="hljs-keyword">int</span> k = i + j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后将代码进行编译成字节码文件，我们再次查看 ，发现在字节码的左边有一个行号标识，它其实就是指令地址，用于指向当前执行到哪里。</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><span class="hljs-attribute">0</span>: bipush        10<br><span class="hljs-attribute">2</span>: istore_1<br><span class="hljs-attribute">3</span>: bipush        20<br><span class="hljs-attribute">5</span>: istore_2<br><span class="hljs-attribute">6</span>: iload_1<br><span class="hljs-attribute">7</span>: iload_2<br><span class="hljs-attribute">8</span>: iadd<br><span class="hljs-attribute">9</span>: istore_3<br><span class="hljs-attribute">10</span>: return<br></code></pre></td></tr></table></figure><p>通过PC寄存器，我们就可以知道当前程序执行到哪一步了 <img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200705161007423.png" alt="image-20200705161007423"></p><h1 id="43-解决PC寄存器两个面试问题"><a href="#43-解决PC寄存器两个面试问题" class="headerlink" title="43-解决PC寄存器两个面试问题"></a>43-解决PC寄存器两个面试问题</h1><h2 id="使用PC寄存器存储字节码指令地址有什么用呢？"><a href="#使用PC寄存器存储字节码指令地址有什么用呢？" class="headerlink" title="使用PC寄存器存储字节码指令地址有什么用呢？"></a>使用PC寄存器存储字节码指令地址有什么用呢？</h2><p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p><p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200705161409533.png" alt="image-20200705161409533"></p><h2 id="PC寄存器为什么被设定为私有的？"><a href="#PC寄存器为什么被设定为私有的？" class="headerlink" title="PC寄存器为什么被设定为私有的？"></a>PC寄存器为什么被设定为私有的？</h2><p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p><p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p><p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200705161812542.png" alt="image-20200705161812542"></p><h2 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h2><p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p><p>在宏观上：俄们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p><p>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200705161849557.png" alt="image-20200705161849557"></p><h1 id="44-虚拟机栈的主要特点"><a href="#44-虚拟机栈的主要特点" class="headerlink" title="44-虚拟机栈的主要特点"></a>44-虚拟机栈的主要特点</h1><h2 id="虚拟机栈概述"><a href="#虚拟机栈概述" class="headerlink" title="虚拟机栈概述"></a>虚拟机栈概述</h2><p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。 优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p><p>有不少Java开发人员一提到Java内存结构，就会非常粗粒度地将JVM中的内存区理解为仅有Java堆（heap）和Java战（stack）？为什么？</p><p>首先栈是运行时的单位，而堆是存储的单位</p><ul><li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</li><li>堆解决的是数据存储的问题，即数据怎么放，放哪里</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200705163928652.png" alt="image-20200705163928652"></p><h3 id="Java虚拟机栈是什么"><a href="#Java虚拟机栈是什么" class="headerlink" title="Java虚拟机栈是什么"></a>Java虚拟机栈是什么</h3><p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。</p><blockquote><p>是线程私有的</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200705164722033.png" alt="image-20200705164722033"></p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了</p><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p><blockquote><p>局部变量，它是相比于成员变量来说的（或属性）</p><p>基本数据类型变量 VS 引用类型变量（类、数组、接口）</p></blockquote><h3 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h3><p>栈是一种快速有效的分配存储方式，访问速度仅次于罹序计数器。JVM直接对Java栈的操作只有两个：</p><ul><li>每个方法执行，伴随着进栈（入栈、压栈）</li><li>执行结束后的出栈工作</li></ul><p>对于栈来说不存在垃圾回收问题（栈存在溢出的情况）</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200705165025382.png" alt="image-20200705165025382"></p><h1 id="45-虚拟机栈的常见异常与如何设置栈大小"><a href="#45-虚拟机栈的常见异常与如何设置栈大小" class="headerlink" title="45-虚拟机栈的常见异常与如何设置栈大小"></a>45-虚拟机栈的常见异常与如何设置栈大小</h1><p>栈中可能出现的异常</p><p>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。</p><p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackoverflowError 异常。</p><p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 OutOfMemoryError 异常。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackErrorTest</span> &#123;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(count++);<br>        main(args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当栈深度达到9803的时候，就出现栈内存空间不足</p><h3 id="设置栈内存大小"><a href="#设置栈内存大小" class="headerlink" title="设置栈内存大小"></a>设置栈内存大小</h3><p>我们可以使用参数 -Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-Xss1m</span><br><span class="hljs-deletion">-Xss1k</span><br></code></pre></td></tr></table></figure><h2 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h2><p>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。</p><p>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</p><p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p><h3 id="栈中存储什么？"><a href="#栈中存储什么？" class="headerlink" title="栈中存储什么？"></a>栈中存储什么？</h3><p>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。在这个线程上正在执行的每个方法都各自对应一个栈颜（Stack Frame）。栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p><blockquote><p>OOP的基本概念：类和对象</p><p>类中基本结构：field（属性、字段、域）、method</p></blockquote><p>JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”/“后进先出”原则。</p><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）。</p><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200705203142545.png" alt="image-20200705203142545"></p><p>下面写一个简单的代码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackFrameTest</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        method01();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method01</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;方法1的开始&quot;</span>);<br>        <span class="hljs-keyword">int</span> i = method02();<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;方法1的结束&quot;</span>);<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method02</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;方法2的开始&quot;</span>);<br>        <span class="hljs-keyword">int</span> i = method03();;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;方法2的结束&quot;</span>);<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method03</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;方法3的开始&quot;</span>);<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">30</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;方法3的结束&quot;</span>);<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">方法1的开始<br>方法2的开始<br>方法3的开始<br>方法3的结束<br>方法2的结束<br>方法1的结束<br></code></pre></td></tr></table></figure><p>满足栈先进后出的概念，通过Idea的 DEBUG，能够看到栈信息</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200705203916023.png" alt="image-20200705203916023"></p><h1 id="46-栈的存储结构和运行原理"><a href="#46-栈的存储结构和运行原理" class="headerlink" title="46-栈的存储结构和运行原理"></a>46-栈的存储结构和运行原理</h1><p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p><p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p><p>Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</p><h1 id="47-栈桢的内部结构"><a href="#47-栈桢的内部结构" class="headerlink" title="47-栈桢的内部结构"></a>47-栈桢的内部结构</h1><p>每个栈帧中存储着：</p><ul><li>局部变量表（Local Variables）</li><li>操作数栈（operand Stack）（或表达式栈）</li><li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200705204836977.png" alt="image-20200705204836977"></p><p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200705205443993.png" alt="image-20200705205443993"></p><h1 id="48-局部变量表结构的认识"><a href="#48-局部变量表结构的认识" class="headerlink" title="48-局部变量表结构的认识"></a>48-局部变量表结构的认识</h1><p>局部变量表：Local Variables，被称之为局部变量数组或本地变量表</p><p>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。</p><p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题</p><p>局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</p><p>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</p><p>局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</p><h1 id="49-字节码中方法内部结构的剖析"><a href="#49-字节码中方法内部结构的剖析" class="headerlink" title="49-字节码中方法内部结构的剖析"></a>49-字节码中方法内部结构的剖析</h1><h1 id="50-变量槽slot的理解与演示"><a href="#50-变量槽slot的理解与演示" class="headerlink" title="50-变量槽slot的理解与演示"></a>50-变量槽slot的理解与演示</h1><h3 id="关于Slot的理解"><a href="#关于Slot的理解" class="headerlink" title="关于Slot的理解"></a>关于Slot的理解</h3><p>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。</p><p>局部变量表，最基本的存储单元是Slot（变量槽）局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</p><p>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（1ong和double）占用两个slot。</p><blockquote><p>byte、short、char 在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。 1ong和double则占据两个slot。</p></blockquote><p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上</p><p>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问1ong或doub1e类型变量）</p><p>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的s1ot处，其余的参数按照参数表顺序继续排列。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200705212454445.png" alt="image-20200705212454445"></p><h3 id="Slot的重复利用"><a href="#Slot的重复利用" class="headerlink" title="Slot的重复利用"></a>Slot的重复利用</h3><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200705213106749.png" alt="image-20200705213106749"></p><h1 id="51-静态变量与局部变量的对比及小结"><a href="#51-静态变量与局部变量的对比及小结" class="headerlink" title="51-静态变量与局部变量的对比及小结"></a>51-静态变量与局部变量的对比及小结</h1><p>变量的分类：</p><ul><li>按数据类型分：基本数据类型、引用数据类型</li><li>按类中声明的位置分：成员变量（类变量，实例变量）、局部变量<ul><li>类变量：linking的paper阶段，给类变量默认赋值，init阶段给类变量显示赋值即静态代码块</li><li>实例变量：随着对象创建，会在堆空间中分配实例变量空间，并进行默认赋值</li><li>局部变量：在使用前必须进行显式赋值，不然编译不通过。</li></ul></li></ul><p>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</p><p>我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</p><p>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</p><p>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p><p>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p><h1 id="52-操作数栈的特点"><a href="#52-操作数栈的特点" class="headerlink" title="52-操作数栈的特点"></a>52-操作数栈的特点</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>操作数栈：Operand Stack</p><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 <strong>操作数栈</strong>，也可以称之为 <strong>表达式栈</strong>（Expression Stack）</p><p>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）</p><ul><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈</li><li>比如：执行复制、交换、求和等操作</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200706090618332.png" alt="image-20200706090618332"></p><p>代码举例</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200706090833697.png" alt="image-20200706090833697"></p><p>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</p><p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。.</p><blockquote><p>这个时候数组是有长度的，因为数组一旦创建，那么就是不可变的</p></blockquote><p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为maxstack的值。</p><p>栈中的任何一个元素都是可以任意的Java数据类型</p><ul><li>32bit的类型占用一个栈单位深度</li><li>64bit的类型占用两个栈单位深度</li></ul><p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</p><p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</p><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。|</p><p>另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</p><h1 id="53-涉及操作数栈的字节码指令执行分析"><a href="#53-涉及操作数栈的字节码指令执行分析" class="headerlink" title="53-涉及操作数栈的字节码指令执行分析"></a>53-涉及操作数栈的字节码指令执行分析</h1><h3 id="代码追踪"><a href="#代码追踪" class="headerlink" title="代码追踪"></a>代码追踪</h3><p>我们给定代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAddOperation</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">byte</span> i = <span class="hljs-number">15</span>;<br>    <span class="hljs-built_in">int</span> j = <span class="hljs-number">8</span>;<br>    <span class="hljs-built_in">int</span> k = i + j;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用javap 命令反编译class文件： javap -v 类名.class</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200706092610730.png" alt="image-20200706092610730"></p><blockquote><p>byte、short、char、boolean 内部都是使用int型来进行保存的</p><p>从上面的代码我们可以知道，我们都是通过bipush对操作数 15 和 8进行入栈操作</p><p>同时使用的是 iadd方法进行相加操作，i -&gt; 代表的就是 int，也就是int类型的加法操作</p></blockquote><p>执行流程如下所示：</p><p>首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入栈。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200706093131621.png" alt="image-20200706093131621"></p><p>执行完后，让PC + 1，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置，我们可以看到局部变量表的已经增加了一个元素</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200706093251302.png" alt="image-20200706093251302"></p><blockquote><p>为什么局部变量表不是从0开始的呢？</p><p>其实局部变量表也是从0开始的，但是因为0号位置存储的是this指针，所以说就直接省略了~</p></blockquote><p>然后PC+1，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200706093646406.png" alt="image-20200706093646406"></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200706093751711.png" alt="image-20200706093751711"></p><p>然后从局部变量表中，依次将数据放在操作数栈中</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200706093859191.png" alt="image-20200706093859191"></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200706093921573.png" alt="image-20200706093921573"></p><p>然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200706094046782.png" alt="image-20200706094046782"></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200706094109629.png" alt="image-20200706094109629"></p><p>最后PC寄存器的位置指向10，也就是return方法，则直接退出方法</p><p>i++和++i的区别</p><h1 id="54-栈顶缓存技术"><a href="#54-栈顶缓存技术" class="headerlink" title="54-栈顶缓存技术"></a>54-栈顶缓存技术</h1><p>栈顶缓存技术：Top Of Stack Cashing</p><p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。</p><p>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</p><blockquote><p>寄存器：指令更少，执行速度快</p></blockquote><h1 id="55-动态链接的理解与常量池的作用"><a href="#55-动态链接的理解与常量池的作用" class="headerlink" title="55-动态链接的理解与常量池的作用"></a>55-动态链接的理解与常量池的作用</h1><p>动态链接：Dynamic Linking</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200706100311886.png" alt="image-20200706100311886"></p><blockquote><p>动态链接、方法返回地址、附加信息 ： 有些地方被称为帧数据区</p></blockquote><p>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中该栈帧所属方法的引用包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic指令</p><p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Reference）保存在class文件的常量池里。</p><p>比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200706101251847.png" alt="image-20200706101251847"></p><blockquote><p>为什么需要运行时常量池？</p><p>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，节省了空间</p><p>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</p></blockquote><h2 id="方法调用：解析与分配"><a href="#方法调用：解析与分配" class="headerlink" title="方法调用：解析与分配"></a>方法调用：解析与分配</h2><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期克制，且运行期保持不变时，这种情况下降调用方法的符号引用转换为直接引用的过程称之为静态链接</p><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p><h1 id="56-方法的绑定机制：静态绑定与动态绑定"><a href="#56-方法的绑定机制：静态绑定与动态绑定" class="headerlink" title="56-方法的绑定机制：静态绑定与动态绑定"></a>56-方法的绑定机制：静态绑定与动态绑定</h1><h3 id="绑定机制"><a href="#绑定机制" class="headerlink" title="绑定机制"></a>绑定机制</h3><p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p><h4 id="早期绑定"><a href="#早期绑定" class="headerlink" title="早期绑定"></a>早期绑定</h4><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p><h4 id="晚期绑定"><a href="#晚期绑定" class="headerlink" title="晚期绑定"></a>晚期绑定</h4><p>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</p><h3 id="早晚期绑定的发展历史"><a href="#早晚期绑定的发展历史" class="headerlink" title="早晚期绑定的发展历史"></a>早晚期绑定的发展历史</h3><p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特悄，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p><p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p><h1 id="57-4种方法调用指令区分非虚方法与虚方法"><a href="#57-4种方法调用指令区分非虚方法与虚方法" class="headerlink" title="57-4种方法调用指令区分非虚方法与虚方法"></a>57-4种方法调用指令区分非虚方法与虚方法</h1><h3 id="虚方法和非虚方法"><a href="#虚方法和非虚方法" class="headerlink" title="虚方法和非虚方法"></a>虚方法和非虚方法</h3><ul><li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li><li>静态方法、私有方法、fina1方法、实例构造器、父类方法都是非虚方法。</li><li>其他方法称为虚方法。</li></ul><blockquote><p>子类对象的多态的使用前提</p><ul><li>类的继承关系</li><li>方法的重写</li></ul></blockquote><p>虚拟机中提供了以下几条方法调用指令：</p><h4 id="普通调用指令："><a href="#普通调用指令：" class="headerlink" title="普通调用指令："></a>普通调用指令：</h4><ul><li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li><li>invokespecial：调用方法、私有及父类方法，解析阶段确定唯一方法版本</li><li>invokevirtual：调用所有虚方法</li><li>invokeinterface：调用接口方法</li></ul><h4 id="动态调用指令："><a href="#动态调用指令：" class="headerlink" title="动态调用指令："></a>动态调用指令：</h4><ul><li>invokedynamic：动态解析出需要调用的方法，然后执行</li></ul><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（fina1修饰的除外）称为虚方法。</p><h1 id="58-invokedynamic指令的使用"><a href="#58-invokedynamic指令的使用" class="headerlink" title="58-invokedynamic指令的使用"></a>58-invokedynamic指令的使用</h1><p>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现动态类型语言】支持而做的一种改进。</p><p>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</p><p>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</p><h3 id="动态类型语言和静态类型语言"><a href="#动态类型语言和静态类型语言" class="headerlink" title="动态类型语言和静态类型语言"></a>动态类型语言和静态类型语言</h3><p>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。</p><p>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</p><blockquote><p>Java：String info = “mogu blog”; (Java是静态类型语言的，会先编译就进行类型检查)</p><p>JS：var name = “shkstart”; var name = 10; （运行时才进行检查）</p></blockquote><h1 id="59-方法重写的本质与虚方法表的使用"><a href="#59-方法重写的本质与虚方法表的使用" class="headerlink" title="59-方法重写的本质与虚方法表的使用"></a>59-方法重写的本质与虚方法表的使用</h1><h4 id="Java-语言中方法重写的本质："><a href="#Java-语言中方法重写的本质：" class="headerlink" title="Java 语言中方法重写的本质："></a>Java 语言中方法重写的本质：</h4><ul><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.1ang.I1legalAccessError 异常。</li><li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.1ang.AbstractMethodsrror异常。</li></ul><h4 id="IllegalAccessError介绍"><a href="#IllegalAccessError介绍" class="headerlink" title="IllegalAccessError介绍"></a>IllegalAccessError介绍</h4><p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p><h3 id="方法的调用：虚方法表"><a href="#方法的调用：虚方法表" class="headerlink" title="方法的调用：虚方法表"></a>方法的调用：虚方法表</h3><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表 （virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</p><p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p><p>虚方法表是什么时候被创建的呢？</p><p>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200706144954070.png" alt="image-20200706144954070"></p><p>如上图所示：如果类中重写了方法，那么调用的时候，就会直接在虚方法表中查找，否则将会直接连接到Object的方法中。</p><h1 id="60-方法返回地址的说明"><a href="#60-方法返回地址的说明" class="headerlink" title="60-方法返回地址的说明"></a>60-方法返回地址的说明</h1><p>存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：</p><ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p><p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p><p>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口；</p><ul><li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li><li>在字节码指令中，返回指令包含ireturn（当返回值是boolean，byte，char，short和int类型时使用），lreturn（Long类型），freturn（Float类型），dreturn（Double类型），areturn。另外还有一个return指令声明为void的方法，实例初始化方法，类和接口的初始化方法使用。</li></ul><p>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。</p><p>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200706154554604.png" alt="image-20200706154554604"></p><p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p><p>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p><h1 id="61-栈桢中的一些附加信息"><a href="#61-栈桢中的一些附加信息" class="headerlink" title="61-栈桢中的一些附加信息"></a>61-栈桢中的一些附加信息</h1><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p><h1 id="62-虚拟机栈的5道面试题"><a href="#62-虚拟机栈的5道面试题" class="headerlink" title="62-虚拟机栈的5道面试题"></a>62-虚拟机栈的5道面试题</h1><h2 id="栈的相关面试题"><a href="#栈的相关面试题" class="headerlink" title="栈的相关面试题"></a>栈的相关面试题</h2><ul><li>举例栈溢出的情况？（StackOverflowError）<ul><li>通过 -Xss设置栈的大小</li></ul></li><li>调整栈大小，就能保证不出现溢出么？<ul><li>不能保证不溢出</li></ul></li><li>分配的栈内存越大越好么？<ul><li>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个空间是有限的。</li></ul></li><li>垃圾回收是否涉及到虚拟机栈？<ul><li>不会</li></ul></li><li>方法中定义的局部变量是否线程安全？<ul><li>具体问题具体分析</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringBuilderTest</span> </span>&#123;<br>    <span class="hljs-comment">// s1的声明方式是线程安全的</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">method01</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-comment">// 线程内部创建的，属于局部变量</span><br>        StringBuilder s1 = <span class="hljs-keyword">new</span> StringBuilder();<br>        s1.append(<span class="hljs-string">&quot;a&quot;</span>);<br>        s1.append(<span class="hljs-string">&quot;b&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 这个也是线程不安全的，因为有返回值，有可能被其它的程序所调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringBuilder <span class="hljs-function"><span class="hljs-title">method04</span>(<span class="hljs-params"></span>)</span> &#123;<br>        StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>        stringBuilder.append(<span class="hljs-string">&quot;a&quot;</span>);<br>        stringBuilder.append(<span class="hljs-string">&quot;b&quot;</span>);<br>        <span class="hljs-keyword">return</span> stringBuilder;<br>    &#125;<br>    <span class="hljs-comment">// stringBuilder 是线程不安全的，操作的是共享数据</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">method02</span>(<span class="hljs-params">StringBuilder stringBuilder</span>)</span> &#123;<br>        stringBuilder.append(<span class="hljs-string">&quot;a&quot;</span>);<br>        stringBuilder.append(<span class="hljs-string">&quot;b&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 同时并发的执行，会出现线程不安全的问题</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">method03</span>(<span class="hljs-params"></span>)</span> &#123;<br>        StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            stringBuilder.append(<span class="hljs-string">&quot;a&quot;</span>);<br>            stringBuilder.append(<span class="hljs-string">&quot;b&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>        method02(stringBuilder);<br>    &#125;<br>    <span class="hljs-comment">// StringBuilder是线程安全的，但是String也可能线程不安全的</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">method05</span>(<span class="hljs-params"></span>)</span> &#123;<br>        StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>        stringBuilder.append(<span class="hljs-string">&quot;a&quot;</span>);<br>        stringBuilder.append(<span class="hljs-string">&quot;b&quot;</span>);<br>        <span class="hljs-keyword">return</span> stringBuilder.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结一句话就是：如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</p><p>运行时数据区，是否存在Error和GC？</p><table><thead><tr><th>运行时数据区</th><th>是否存在Error</th><th>是否存在GC</th></tr></thead><tbody><tr><td>程序计数器</td><td>否</td><td>否</td></tr><tr><td>虚拟机栈</td><td>是</td><td>否</td></tr><tr><td>本地方法栈</td><td>是</td><td>否</td></tr><tr><td>方法区</td><td>是（OOM）</td><td>是</td></tr><tr><td>堆</td><td>是</td><td>是</td></tr></tbody></table><h1 id="63-本地方法接口的理解"><a href="#63-本地方法接口的理解" class="headerlink" title="63-本地方法接口的理解"></a>63-本地方法接口的理解</h1><h2 id="什么是本地方法"><a href="#什么是本地方法" class="headerlink" title="什么是本地方法"></a>什么是本地方法</h2><p>简单地讲，一个Native Methodt是一个Java调用非Java代码的接囗。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “c” 告知c++编译器去调用一个c的函数。</p><p>“A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）</p><p>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</p><p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200706164139252.png" alt="image-20200706164139252"></p><p>代码举例说明Native方法是如何编写的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IhaveNatives</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Native1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">native</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">Native2</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">native</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> <span class="hljs-title">Native3</span><span class="hljs-params">(Object o)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Natives</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] ary)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>需要注意的是：标识符native可以与其它java标识符连用，但是abstract除外</p></blockquote><h2 id="为什么使用Native-Method？"><a href="#为什么使用Native-Method？" class="headerlink" title="为什么使用Native Method？"></a>为什么使用Native Method？</h2><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p><h3 id="与Java环境的交互"><a href="#与Java环境的交互" class="headerlink" title="与Java环境的交互"></a>与Java环境的交互</h3><p>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p><h3 id="与操作系统的交互"><a href="#与操作系统的交互" class="headerlink" title="与操作系统的交互"></a>与操作系统的交互</h3><p>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用c写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</p><h3 id="Sun’s-Java"><a href="#Sun’s-Java" class="headerlink" title="Sun’s Java"></a>Sun’s Java</h3><p>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setpriority（）方法是用Java实现的，但是它实现调用的是该类里的本地方法setpriorityo（）。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority（）ApI。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVw调用。</p><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p><h1 id="64-本地方法栈的理解"><a href="#64-本地方法栈的理解" class="headerlink" title="64-本地方法栈的理解"></a>64-本地方法栈的理解</h1><p>Java虚拟机栈于管理Java方法的调用，而<strong>本地方法栈用于管理本地方法的调用</strong>。</p><p>本地方法栈，也是线程私有的。</p><p>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</p><ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</li></ul><p>本地方法是使用C语言实现的。</p><p>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200706174708418.png" alt="image-20200706174708418"></p><p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</p><ul><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。</li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存。</li></ul><p>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</p><p>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</p><h1 id="66-堆空间的概述-进程中堆的唯一性"><a href="#66-堆空间的概述-进程中堆的唯一性" class="headerlink" title="66-堆空间的概述_进程中堆的唯一性"></a>66-堆空间的概述_进程中堆的唯一性</h1><h2 id="堆的核心概念"><a href="#堆的核心概念" class="headerlink" title="堆的核心概念"></a>堆的核心概念</h2><p>堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，但是进程包含多个线程，他们是共享同一堆空间的。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200706195127740.png" alt="image-20200706195127740"></p><h1 id="67-堆空间关于对象创建和和GC的概述"><a href="#67-堆空间关于对象创建和和GC的概述" class="headerlink" title="67-堆空间关于对象创建和和GC的概述"></a>67-堆空间关于对象创建和和GC的概述</h1><p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p><p>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。</p><ul><li>堆内存的大小是可以调节的。</li></ul><p>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p><p>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</p><blockquote><p>-Xms10m：最小堆内存</p><p>-Xmx10m：最大堆内存</p></blockquote><p>下图就是使用：Java VisualVM查看堆空间的内容，通过 jdk bin提供的插件</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200706200739392.png" alt="image-20200706200739392"></p><p>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）</p><p>我要说的是：“几乎”所有的对象实例都在这里分配内存。—从实际使用角度看的。</p><ul><li>因为还有一些对象是在栈上分配的</li></ul><p>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p><p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p><ul><li>也就是触发了GC的时候，才会进行回收</li><li>如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word</li></ul><p>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200706201904057.png" alt="image-20200706201904057"></p><h1 id="68-堆的细分内存结构"><a href="#68-堆的细分内存结构" class="headerlink" title="68-堆的细分内存结构"></a>68-堆的细分内存结构</h1><p>Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区</p><ul><li>Young Generation Space 新生区  Young/New   又被划分为Eden区和Survivor区</li><li>Tenure generation space 养老区 Old/Tenure</li><li>Permanent Space永久区   Perm</li></ul><p>Java 8及之后堆内存逻辑上分为三部分：新生区养老区+元空间</p><ul><li>Young Generation Space新生区  Young/New  又被划分为Eden区和Survivor区</li><li>Tenure generation space 养老区  Old/Tenure</li><li>Meta Space  元空间   Meta</li></ul><p>约定：新生区 -&gt; 新生代 -&gt; 年轻代   、  养老区 -&gt; 老年区 -&gt; 老年代、 永久区 -&gt; 永久代</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200706203419496.png" alt="image-20200706203419496"></p><p>堆空间内部结构，JDK1.8之前从永久代  替换成 元空间</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200706203835403.png" alt="image-20200706203835403"></p><h1 id="69-堆空间大小的设置和查看"><a href="#69-堆空间大小的设置和查看" class="headerlink" title="69-堆空间大小的设置和查看"></a>69-堆空间大小的设置和查看</h1><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。</p><ul><li>“-Xms”用于表示堆区的起始内存，等价于-xx:InitialHeapSize</li><li>“-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</li></ul><p>一旦堆区中的内存大小超过“-xmx”所指定的最大内存时，将会抛出outofMemoryError异常。</p><p>通常会将-Xms和-Xmx两个参数配置相同的值，其目的是<strong>为了能够在ava垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能</strong>。</p><p>默认情况下</p><ul><li><p>初始内存大小：物理电脑内存大小/64</p></li><li><p>最大内存大小：物理电脑内存大小/4</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小</span><br><span class="hljs-comment"> *  -X：是jvm运行参数</span><br><span class="hljs-comment"> *  ms：memory start</span><br><span class="hljs-comment"> * -Xmx：用来设置堆空间（年轻代+老年代）的最大内存大小</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapSpaceInitial</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 返回Java虚拟机中的堆内存总量</span><br>        <span class="hljs-keyword">long</span> initialMemory = Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;<br>        <span class="hljs-comment">// 返回Java虚拟机试图使用的最大堆内存</span><br>        <span class="hljs-keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;<br>        System.out.println(<span class="hljs-string">&quot;-Xms:&quot;</span> + initialMemory + <span class="hljs-string">&quot;M&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;-Xmx:&quot;</span> + maxMemory + <span class="hljs-string">&quot;M&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">-Xms</span><span class="hljs-selector-pseudo">:245M</span><br><span class="hljs-selector-tag">-Xmx</span><span class="hljs-selector-pseudo">:3614M</span><br></code></pre></td></tr></table></figure><p>如何查看堆内存的内存分配情况</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">jps </span> -&gt;  <span class="hljs-keyword">jstat </span>-gc 进程id<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200706205756045.png" alt="image-20200706205756045"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">-XX</span><span class="hljs-selector-pseudo">:+PrintGCDetails</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200706205821919.png" alt="image-20200706205821919"></p><h1 id="70-OOM的说明与举例"><a href="#70-OOM的说明与举例" class="headerlink" title="70-OOM的说明与举例"></a>70-OOM的说明与举例</h1><h3 id="OutOfMemory举例"><a href="#OutOfMemory举例" class="headerlink" title="OutOfMemory举例"></a>OutOfMemory举例</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200706205947535.png" alt="image-20200706205947535"></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200706210000461.png" alt="image-20200706210000461"></p><p>我们简单的写一个OOM例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * OOM测试</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OOMTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>            list.add(<span class="hljs-number">999999999</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后设置启动参数</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">-Xms10m</span> <span class="hljs-selector-tag">-Xmx</span><span class="hljs-selector-pseudo">:10m</span><br></code></pre></td></tr></table></figure><p>运行后，就出现OOM了，那么我们可以通过 VisualVM这个工具查看具体是什么参数造成的OOM</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200706211652779.png" alt="image-20200706211652779"></p><h1 id="71-新生代与老年代中相关参数的设置"><a href="#71-新生代与老年代中相关参数的设置" class="headerlink" title="71-新生代与老年代中相关参数的设置"></a>71-新生代与老年代中相关参数的设置</h1><p>存储在JVM中的Java对象可以被划分为两类：</p><ul><li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速<ul><li>生命周期短的，及时回收即可</li></ul></li><li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</li></ul><p>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p><p>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200707075847954.png" alt="image-20200707075847954"></p><p>下面这参数开发中一般不会调：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200707080154039.png" alt="image-20200707080154039"></p><ul><li>Eden：From：to -&gt;  8:1:1</li><li>新生代：老年代  - &gt;  1 : 2</li></ul><p>配置新生代与老年代在堆结构的占比。</p><ul><li><p>默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</p></li><li><p>可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</p></li></ul><blockquote><p>当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整 老年代的大小，来进行调优</p></blockquote><p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1当然开发人员可以通过选项“-xx:SurvivorRatio”调整这个空间比例。比如-xx:SurvivorRatio=8</p><p>几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。（有些大的对象在Eden区无法存储时候，将直接进入老年代）</p><blockquote><p>IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</p><p>可以使用选项”-Xmn”设置新生代最大内存大小</p><p>这个参数一般使用默认值就可以了。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200707084208115.png" alt="image-20200707084208115"></p><h1 id="72-图解对象分配的一般过程"><a href="#72-图解对象分配的一般过程" class="headerlink" title="72-图解对象分配的一般过程"></a>72-图解对象分配的一般过程</h1><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>为新对象分配内存是一件非常严谨和复杂的任务，JM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p><ul><li>new的对象先放伊甸园区。此区有大小限制。</li><li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li><li>然后将伊甸园中的剩余对象移动到幸存者0区。</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</li><li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li><li>啥时候能去养老区呢？可以设置次数。默认是15次。</li><li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理</li><li>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</li></ul><p>可以设置参数：-Xx:MaxTenuringThreshold= N进行设置</p><h3 id="图解过程"><a href="#图解过程" class="headerlink" title="图解过程"></a>图解过程</h3><p>我们创建的对象，一般都是存放在Eden区的，当我们Eden区满了后，就会触发GC操作，一般被称为 YGC / Minor GC操作</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200707084714886.png" alt="image-20200707084714886"></p><p>当我们进行一次垃圾收集后，红色的将会被回收，而绿色的还会被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，一次回收后就是1。</p><p>同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象 进行一次收集，把存活的对象放到 Survivor To区，同时让年龄 + 1</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200707085232646.png" alt="image-20200707085232646"></p><p>我们继续不断的进行对象生成 和 垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion晋升的操作，也就是将年轻代中的对象  晋升到 老年代中</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200707085737207.png" alt="image-20200707085737207"></p><h3 id="思考：幸存区区满了后？"><a href="#思考：幸存区区满了后？" class="headerlink" title="思考：幸存区区满了后？"></a>思考：幸存区区满了后？</h3><p>特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作</p><p>如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代</p><blockquote><p>举例：以当兵为例，正常人的晋升可能是 ：  新兵 -&gt; 班长 -&gt; 排长 -&gt; 连长</p><p>但是也有可能有些人因为做了非常大的贡献，直接从  新兵 -&gt; 排长</p></blockquote><h1 id="73-对象分配的特殊情况"><a href="#73-对象分配的特殊情况" class="headerlink" title="73-对象分配的特殊情况"></a>73-对象分配的特殊情况</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200707091058346.png" alt="image-20200707091058346"></p><h1 id="74-代码举例与JVisualVM演示对象的分配过程"><a href="#74-代码举例与JVisualVM演示对象的分配过程" class="headerlink" title="74-代码举例与JVisualVM演示对象的分配过程"></a>74-代码举例与JVisualVM演示对象的分配过程</h1><h3 id="代码演示对象分配过程"><a href="#代码演示对象分配过程" class="headerlink" title="代码演示对象分配过程"></a>代码演示对象分配过程</h3><p>我们不断的创建大对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 代码演示对象创建过程</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 陌溪</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-07-07-9:16</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapInstanceTest</span> </span>&#123;<br>    <span class="hljs-keyword">byte</span> [] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1024</span> * <span class="hljs-number">200</span>)];<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ArrayList&lt;HeapInstanceTest&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            list.add(<span class="hljs-keyword">new</span> HeapInstanceTest());<br>            Thread.sleep(<span class="hljs-number">10</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后设置JVM参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-Xms600m -Xmx600m<br></code></pre></td></tr></table></figure><p>然后cmd输入下面命令，打开VisualVM图形化界面</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">jvisualvm</span><br></code></pre></td></tr></table></figure><p>然后通过执行上面代码，通过VisualGC进行动态化查看</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.gif" alt="垃圾回收"></p><p>最终，在老年代和新生代都满了，就出现OOM</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">Exception</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">thread</span> &quot;<span class="hljs-selector-tag">main</span>&quot; <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.OutOfMemoryError</span>: <span class="hljs-selector-tag">Java</span> <span class="hljs-selector-tag">heap</span> <span class="hljs-selector-tag">space</span><br><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.atguigu</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-class">.chapter08</span><span class="hljs-selector-class">.HeapInstanceTest</span>.&lt;<span class="hljs-selector-tag">init</span>&gt;(<span class="hljs-selector-tag">HeapInstanceTest</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:13)</span><br><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.atguigu</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-class">.chapter08</span><span class="hljs-selector-class">.HeapInstanceTest</span><span class="hljs-selector-class">.main</span>(<span class="hljs-selector-tag">HeapInstanceTest</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:17)</span><br></code></pre></td></tr></table></figure><h1 id="75-常用优工具概述与Jprofiler的演示"><a href="#75-常用优工具概述与Jprofiler的演示" class="headerlink" title="75-常用优工具概述与Jprofiler的演示"></a>75-常用优工具概述与Jprofiler的演示</h1><ul><li>JDK命令行</li><li>Eclipse：Memory Analyzer Tool</li><li>Jconsole</li><li>Visual VM（实时监控  推荐~）</li><li>Jprofiler（推荐~）</li><li>Java Flight Recorder（实时监控）</li><li>GCViewer</li><li>GCEasy</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to</li><li>关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不再永久代和元空间进行收集</li><li>新生代采用复制算法的目的：是为了减少内碎片</li></ul><h1 id="76-MinorGC、MajorGC和FullGC的对比"><a href="#76-MinorGC、MajorGC和FullGC的对比" class="headerlink" title="76-MinorGC、MajorGC和FullGC的对比"></a>76-MinorGC、MajorGC和FullGC的对比</h1><ul><li>Minor GC：新生代的GC</li><li>Major GC：老年代的GC</li><li>Full GC：整堆收集，收集整个Java堆和方法区的垃圾收集</li></ul><blockquote><p>我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW的问题</p><p>而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上</p></blockquote><p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p><p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p><ul><li>新生代收集（MinorGC/YoungGC）：只是新生代的垃圾收集</li><li>老年代收集（MajorGC/o1dGC）：只是老年代的圾收集。<ul><li>目前，只有CMSGC会有单独收集老年代的行为。</li><li>注意，很多时候Major GC会和Fu11GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li></ul></li><li>混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。<ul><li>目前，只有G1 GC会有这种行为</li></ul></li></ul><p>整堆收集（FullGC）：收集整个java堆和方法区的垃圾收集。</p><h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p>当年轻代空间不足时，就会触发MinorGC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存。）</p><p>因为Java对象大多都具备 <strong>朝生夕灭</strong> 的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p><p>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</p><blockquote><p>STW：stop the word</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200707095606813.png" alt="image-20200707095606813"></p><h3 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h3><p>指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</p><p>出现了MajorGc，经常会伴随至少一次的Minor GC（但非绝对的，在Paralle1 Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）</p><ul><li>也就是在老年代空间不足时，会先尝试触发MinorGc。如果之后空间还不足，则触发Major GC</li></ul><p>Major GC的速度一般会比MinorGc慢1e倍以上，STW的时间更长，如果Major GC后，内存还不足，就报OOM了</p><h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p>触发Fu11GC执行的情况有如下五种：</p><ul><li>调用System.gc（）时，系统建议执行Fu11GC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、survivor spacee（From Space）区向survivor spacel（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ul><p>说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些</p><h1 id="77-GC举例与日志分析"><a href="#77-GC举例与日志分析" class="headerlink" title="77-GC举例与日志分析"></a>77-GC举例与日志分析</h1><p>我们编写一个OOM的异常，因为我们在不断的创建字符串，是存放在元空间的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * GC Test</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GCTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            String a = <span class="hljs-string">&quot;Gc Test&quot;</span>;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>                list.add(a);<br>                a += a;<br>                i++;<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.getStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>设置JVM启动参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-Xms10m -Xmx10m -XX:+PrintGCDetails<br></code></pre></td></tr></table></figure><p>打印出的日志</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">2038</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">500</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">2038</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">797</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.3532002</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.36</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <br><span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">2108</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">480</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">2405</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">1565</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0014069</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <br><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Ergonomics</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">2288</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">6845</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">5281</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">7168</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">9133</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">5281</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3482</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3482</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0058675</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <br><span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">5281</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">5281</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0002857</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <br><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">5281</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">5263</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">7168</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">5281</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">5263</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3482</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3482</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0058564</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <br><span class="hljs-variable">Heap</span><br> <span class="hljs-variable">PSYoungGen</span>      <span class="hljs-variable">total</span> <span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">used</span> <span class="hljs-number">60</span><span class="hljs-built_in">K</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x0000000100000000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x0000000100000000</span><span class="hljs-punctuation">)</span><br>  <span class="hljs-variable">eden</span> <span class="hljs-variable">space</span> <span class="hljs-number">2048</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">2</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd0f138</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff00000</span><span class="hljs-punctuation">)</span><br>  <span class="hljs-variable">from</span> <span class="hljs-variable">space</span> <span class="hljs-number">512</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff80000</span><span class="hljs-punctuation">)</span><br>  <span class="hljs-variable">to</span>   <span class="hljs-variable">space</span> <span class="hljs-number">512</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff80000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff80000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x0000000100000000</span><span class="hljs-punctuation">)</span><br> <span class="hljs-variable">ParOldGen</span>       <span class="hljs-variable">total</span> <span class="hljs-number">7168</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">used</span> <span class="hljs-number">5263</span><span class="hljs-built_in">K</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ff600000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-punctuation">)</span><br>  <span class="hljs-variable">object</span> <span class="hljs-variable">space</span> <span class="hljs-number">7168</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">73</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ff600000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffb23cf0</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-punctuation">)</span><br> <span class="hljs-variable">Metaspace</span>       <span class="hljs-variable">used</span> <span class="hljs-number">3514</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">capacity</span> <span class="hljs-number">4498</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">committed</span> <span class="hljs-number">4864</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">reserved</span> <span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><br>  <span class="hljs-variable">class</span> <span class="hljs-variable">space</span>    <span class="hljs-variable">used</span> <span class="hljs-number">388</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">capacity</span> <span class="hljs-number">390</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">committed</span> <span class="hljs-number">512</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">reserved</span> <span class="hljs-number">1048576</span><span class="hljs-built_in">K</span><br>  <br>  <span class="hljs-variable">Exception</span> <span class="hljs-variable">in</span> <span class="hljs-variable">thread</span> <span class="hljs-string">&quot;main&quot;</span> <span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">lang</span><span class="hljs-operator">.</span><span class="hljs-variable">OutOfMemoryError</span><span class="hljs-operator">:</span> <span class="hljs-variable">Java</span> <span class="hljs-variable">heap</span> <span class="hljs-variable">space</span><br><span class="hljs-variable">at</span> <span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">util</span><span class="hljs-operator">.</span><span class="hljs-built_in">Arrays</span><span class="hljs-operator">.</span><span class="hljs-variable">copyOfRange</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Arrays</span><span class="hljs-operator">.</span><span class="hljs-variable">java</span><span class="hljs-operator">:</span><span class="hljs-number">3664</span><span class="hljs-punctuation">)</span><br><span class="hljs-variable">at</span> <span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">lang</span><span class="hljs-operator">.</span><span class="hljs-built_in">String</span><span class="hljs-operator">.&lt;</span><span class="hljs-variable">init</span><span class="hljs-operator">&gt;</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">String</span><span class="hljs-operator">.</span><span class="hljs-variable">java</span><span class="hljs-operator">:</span><span class="hljs-number">207</span><span class="hljs-punctuation">)</span><br><span class="hljs-variable">at</span> <span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">lang</span><span class="hljs-operator">.</span><span class="hljs-variable">StringBuilder</span><span class="hljs-operator">.</span><span class="hljs-variable">toString</span><span class="hljs-punctuation">(</span><span class="hljs-variable">StringBuilder</span><span class="hljs-operator">.</span><span class="hljs-variable">java</span><span class="hljs-operator">:</span><span class="hljs-number">407</span><span class="hljs-punctuation">)</span><br><span class="hljs-variable">at</span> <span class="hljs-variable">com</span><span class="hljs-operator">.</span><span class="hljs-variable">atguigu</span><span class="hljs-operator">.</span><span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">chapter08</span><span class="hljs-operator">.</span><span class="hljs-variable">GCTest</span><span class="hljs-operator">.</span><span class="hljs-variable">main</span><span class="hljs-punctuation">(</span><span class="hljs-variable">GCTest</span><span class="hljs-operator">.</span><span class="hljs-variable">java</span><span class="hljs-operator">:</span><span class="hljs-number">20</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>触发OOM的时候，一定是进行了一次Full GC，因为只有在老年代空间不足时候，才会爆出OOM异常</p><h1 id="78-体会堆空间分代的思想"><a href="#78-体会堆空间分代的思想" class="headerlink" title="78-体会堆空间分代的思想"></a>78-体会堆空间分代的思想</h1><p> 为什么要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p><blockquote><p>新生代：有Eden、两块大小相同的survivor（又称为from/to，s0/s1）构成，to总为空。<br>老年代：存放新生代中经历多次GC仍然存活的对象。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200707101511025.png" alt="image-20200707101511025"></p><p>其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200707101543871.png" alt="image-20200707101543871"></p><h1 id="79-总结内存分配策略"><a href="#79-总结内存分配策略" class="headerlink" title="79-总结内存分配策略"></a>79-总结内存分配策略</h1><p>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代</p><p>对象晋升老年代的年龄阀值，可以通过选项-xx:MaxTenuringThreshold来设置</p><p>针对不同年龄段的对象分配原则如下所示：</p><ul><li>优先分配到Eden<ul><li>开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象 都是 朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢</li></ul></li><li>大对象直接分配到老年代<ul><li>尽量避免程序中出现过多的大对象</li></ul></li><li>长期存活的对象分配到老年代</li><li>动态对象年龄判断<ul><li>如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold 中要求的年龄。</li></ul></li></ul><p>空间分配担保： -Xx:HandlePromotionFailure</p><ul><li>也就是经过Minor GC后，所有的对象都存活，因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中。</li></ul><h1 id="80-堆空间为每个线程分配的TLAB"><a href="#80-堆空间为每个线程分配的TLAB" class="headerlink" title="80-堆空间为每个线程分配的TLAB"></a>80-堆空间为每个线程分配的TLAB</h1><h3 id="问题：堆空间都是共享的么？"><a href="#问题：堆空间都是共享的么？" class="headerlink" title="问题：堆空间都是共享的么？"></a>问题：堆空间都是共享的么？</h3><p>不一定，因为还有TLAB这个概念，在堆中划分出一块区域，为每个线程所独占</p><h3 id="为什么有TLAB？"><a href="#为什么有TLAB？" class="headerlink" title="为什么有TLAB？"></a>为什么有TLAB？</h3><p>TLAB：Thread Local Allocation Buffer，也就是为每个线程单独分配了一个缓冲区</p><p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</p><p>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</p><p>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p><h3 id="什么是TLAB"><a href="#什么是TLAB" class="headerlink" title="什么是TLAB"></a>什么是TLAB</h3><p>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</p><p>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。</p><p>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200707103547712.png" alt="image-20200707103547712"></p><p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。</p><p>在程序中，开发人员可以通过选项“-Xx:UseTLAB”设置是否开启TLAB空间。</p><p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1，当然我们可以通过选项“-Xx:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。</p><p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</p><h3 id="TLAB分配过程"><a href="#TLAB分配过程" class="headerlink" title="TLAB分配过程"></a>TLAB分配过程</h3><p>对象首先是通过TLAB开辟空间，如果不能放入，那么需要通过Eden来进行分配</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200707104253530.png" alt="image-20200707104253530"></p><h1 id="81-小结堆空间的常用参数设置"><a href="#81-小结堆空间的常用参数设置" class="headerlink" title="81-小结堆空间的常用参数设置"></a>81-小结堆空间的常用参数设置</h1><ul><li><p>-XX：+PrintFlagsInitial：查看所有的参数的默认初始值</p></li><li><p>-XX：+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）</p></li><li><p>-Xms：初始堆空间内存（默认为物理内存的1/64）</p></li><li><p>-Xmx：最大堆空间内存（默认为物理内存的1/4）</p></li><li><p>-Xmn：设置新生代的大小。（初始值及最大值）</p></li><li><p>-XX:NewRatio：配置新生代与老年代在堆结构的占比</p></li><li><p>-XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例</p></li><li><p>-XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄</p></li><li><p>-XX：+PrintGCDetails：输出详细的GC处理日志</p><ul><li>打印gc简要信息：①-Xx：+PrintGC  ② - verbose:gc</li></ul></li><li><p>-XX:HandlePromotionFalilure：是否设置空间分配担保</p></li></ul><p>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。I</p><ul><li>如果大于，则此次Minor GC是安全的</li><li>如果小于，则虚拟机会查看-xx:HandlePromotionFailure设置值是否允担保失败。<ul><li>如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。</li><li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li><li>如果小于，则改为进行一次FullGC。</li><li>如果HandlePromotionFailure=false，则改为进行一次Ful1 Gc。</li></ul></li></ul><p>在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行FullGC。</p><h1 id="82-通过逃逸分析看堆空间的对象分配策略"><a href="#82-通过逃逸分析看堆空间的对象分配策略" class="headerlink" title="82-通过逃逸分析看堆空间的对象分配策略"></a>82-通过逃逸分析看堆空间的对象分配策略</h1><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</p><p>随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p><p>此外，前面提到的基于openJDk深度定制的TaoBaovm，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p><p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p><p>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。逃逸分析的基本行为就是分析对象动态作用域：</p><ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul><h4 id="逃逸分析举例"><a href="#逃逸分析举例" class="headerlink" title="逃逸分析举例"></a>逃逸分析举例</h4><p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧，也就是发生逃逸分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">my_method</span><span class="hljs-params">()</span> </span>&#123;<br>    V v = <span class="hljs-keyword">new</span> V();<br>    <span class="hljs-comment">// use v</span><br>    <span class="hljs-comment">// ....</span><br>    v = <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>针对下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringBuffer <span class="hljs-title">createStringBuffer</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;<br>    StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();<br>    sb.append(s1);<br>    sb.append(s2);<br>    <span class="hljs-keyword">return</span> sb;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想要StringBuffer sb不发生逃逸，可以这样写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">createStringBuffer</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;<br>    StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();<br>    sb.append(s1);<br>    sb.append(s2);<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure><p>完整的逃逸分析代码举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 逃逸分析</span><br><span class="hljs-comment"> * 如何快速的判断是否发生了逃逸分析，大家就看new的对象是否在方法外被调用。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EscapeAnalysis</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> EscapeAnalysis obj;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法返回EscapeAnalysis对象，发生逃逸</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> EscapeAnalysis <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> obj == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> EscapeAnalysis():obj;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 为成员属性赋值，发生逃逸</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setObj</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.obj = <span class="hljs-keyword">new</span> EscapeAnalysis();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 对象的作用于仅在当前方法中有效，没有发生逃逸</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useEscapeAnalysis</span><span class="hljs-params">()</span> </span>&#123;<br>        EscapeAnalysis e = <span class="hljs-keyword">new</span> EscapeAnalysis();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 引用成员变量的值，发生逃逸</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useEscapeAnalysis2</span><span class="hljs-params">()</span> </span>&#123;<br>        EscapeAnalysis e = getInstance();<br>        <span class="hljs-comment">// getInstance().XXX  发生逃逸</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><p>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析</p><p>如果使用的是较早的版本，开发人员则可以通过：</p><ul><li>选项“-xx：+DoEscapeAnalysis”显式开启逃逸分析</li><li>通过选项“-xx：+PrintEscapeAnalysis”查看逃逸分析的筛选结果</li></ul><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>开发中能使用局部变量的，就不要使用在方法外定义。</p><p>使用逃逸分析，编译器可以对代码做如下优化：</p><ul><li>栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li><li>同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li><li>分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li></ul><h1 id="83-代码优化之栈上分配"><a href="#83-代码优化之栈上分配" class="headerlink" title="83-代码优化之栈上分配"></a>83-代码优化之栈上分配</h1><p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p><p>常见的栈上分配的场景</p><blockquote><p>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。</p></blockquote><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p>我们通过举例来说明 开启逃逸分析 和 未开启逃逸分析时候的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 栈上分配</span><br><span class="hljs-comment"> * -Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String age;<br>    <span class="hljs-keyword">private</span> String gender;<br>    <span class="hljs-keyword">private</span> String phone;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackAllocation</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000000</span>; i++) &#123;<br>            alloc();<br>        &#125;<br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;花费的时间为：&quot;</span> + (end - start) + <span class="hljs-string">&quot; ms&quot;</span>);<br><br>        <span class="hljs-comment">// 为了方便查看堆内存中对象个数，线程sleep</span><br>        Thread.sleep(<span class="hljs-number">10000000</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">alloc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 未发生逃逸</span><br>        User user = <span class="hljs-keyword">new</span> User(); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>设置JVM参数，表示未开启逃逸分析</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">-Xmx1G</span> <span class="hljs-selector-tag">-Xms1G</span> <span class="hljs-selector-tag">-XX</span><span class="hljs-selector-pseudo">:-DoEscapeAnalysis</span> <span class="hljs-selector-tag">-XX</span><span class="hljs-selector-pseudo">:+PrintGCDetails</span><br></code></pre></td></tr></table></figure><p>运行结果，同时还触发了GC操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">花费的时间为：664 ms<br></code></pre></td></tr></table></figure><p>然后查看内存的情况，发现有大量的User存储在堆中</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200707203038615.png" alt="image-20200707203038615"></p><p>我们在开启逃逸分析</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">-Xmx1G</span> <span class="hljs-selector-tag">-Xms1G</span> <span class="hljs-selector-tag">-XX</span><span class="hljs-selector-pseudo">:+DoEscapeAnalysis</span> <span class="hljs-selector-tag">-XX</span><span class="hljs-selector-pseudo">:+PrintGCDetails</span><br></code></pre></td></tr></table></figure><p>然后查看运行时间，我们能够发现花费的时间快速减少，同时不会发生GC操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">花费的时间为：5 ms<br></code></pre></td></tr></table></figure><p>在看内存情况，我们发现只有很少的User对象，说明User未发生逃逸，因为它存储在栈中，随着栈的销毁而消失</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200707203441718.png" alt="image-20200707203441718"></p><h1 id="84-代码优化之同步省略"><a href="#84-代码优化之同步省略" class="headerlink" title="84-代码优化之同步省略"></a>84-代码优化之同步省略</h1><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p><p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。</p><p>例如下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>    Object hellis = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">synchronized</span>(hellis) &#123;<br>        System.out.println(hellis);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>    Object hellis = <span class="hljs-keyword">new</span> Object();<br>System.out.println(hellis);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将其转换成字节码</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200707205634266.png" alt="image-20200707205634266"></p><h1 id="85-代码优化之标量替换"><a href="#85-代码优化之标量替换" class="headerlink" title="85-代码优化之标量替换"></a>85-代码优化之标量替换</h1><p>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p><p>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p><p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>    alloc();<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> y;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">alloc</span><span class="hljs-params">()</span> </span>&#123;<br>    Point point = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>    System.out.println(<span class="hljs-string">&quot;point.x&quot;</span> + point.x + <span class="hljs-string">&quot;;point.y&quot;</span> + point.y);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码，经过标量替换后，就会变成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">alloc</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> y = <span class="hljs-number">2</span>;<br>    System.out.println(<span class="hljs-string">&quot;point.x = &quot;</span> + x + <span class="hljs-string">&quot;; point.y=&quot;</span> + y);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。<br>标量替换为栈上分配提供了很好的基础。</p><h3 id="代码优化之标量替换"><a href="#代码优化之标量替换" class="headerlink" title="代码优化之标量替换"></a>代码优化之标量替换</h3><p>上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations<br></code></pre></td></tr></table></figure><p>这里设置参数如下：</p><ul><li>参数-server：启动Server模式，因为在server模式下，才可以启用逃逸分析。</li><li>参数-XX:+DoEscapeAnalysis：启用逃逸分析</li><li>参数-Xmx10m：指定了堆空间最大为10MB</li><li>参数-XX:+PrintGC：将打印Gc日志</li><li>参数一xx：+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li></ul><h3 id="逃逸分析的不足"><a href="#逃逸分析的不足" class="headerlink" title="逃逸分析的不足"></a>逃逸分析的不足</h3><p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟。</p><p>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。<br>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p><p>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JvM设计者的选择。据我所知，oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</p><p>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</p><h1 id="86-代码优化及堆的小结"><a href="#86-代码优化及堆的小结" class="headerlink" title="86-代码优化及堆的小结"></a>86-代码优化及堆的小结</h1><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p><p>老年代放置长生命周期的对象，通常都是从survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。当GC只发生在年轻代中，回收年轻代对象的行为被称为MinorGc。</p><p>当GC发生在老年代时则被称为MajorGc或者FullGC。一般的，MinorGc的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p><h1 id="87-方法区概述-栈堆方法区间的交互关系"><a href="#87-方法区概述-栈堆方法区间的交互关系" class="headerlink" title="87-方法区概述_栈堆方法区间的交互关系"></a>87-方法区概述_栈堆方法区间的交互关系</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次所讲述的是运行时数据区的最后一个部分</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200708093918121.png" alt="image-20200708093918121"></p><p>从线程共享与否的角度来看</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200708094507624.png" alt="image-20200708094507624"></p><p>ThreadLocal：如何保证多个线程在并发环境下的安全性？典型应用就是数据库连接管理，以及会话管理</p><h2 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h2><p>下面就涉及了对象的访问定位</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200708094747667.png" alt="image-20200708094747667"></p><ul><li>Person：存放在元空间，也可以说方法区</li><li>person：存放在Java栈的局部变量表中</li><li>new Person()：存放在Java堆中</li></ul><h1 id="88-方法区的基本理解"><a href="#88-方法区的基本理解" class="headerlink" title="88-方法区的基本理解"></a>88-方法区的基本理解</h1><p>《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</p><p>所以，方法区看作是一块独立于Java堆的内存空间。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200708095853544.png" alt="image-20200708095853544"></p><p>方法区主要存放的是 Class，而堆中主要存放的是 实例化的对象</p><ul><li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。</li><li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：ava.lang.OutofMemoryError：PermGen space 或者java.lang.OutOfMemoryError:Metaspace<ul><li>加载大量的第三方的jar包</li><li>Tomcat部署的工程过多（30~50个）</li><li>大量动态的生成反射类</li></ul></li><li>关闭JVM就会释放这个区域的内存。</li></ul><h1 id="89-Hotspot中方法区的演进"><a href="#89-Hotspot中方法区的演进" class="headerlink" title="89-Hotspot中方法区的演进"></a>89-Hotspot中方法区的演进</h1><p>在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。</p><ul><li>JDK 1.8后，元空间存放在堆外内存中</li></ul><p>本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit / IBM J9 中不存在永久代的概念。</p><blockquote><p>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易oom（超过-XX:MaxPermsize上限）</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200708102919149.png" alt="image-20200708102919149"></p><p>而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200708103055914.png" alt="image-20200708103055914"></p><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存</p><p>永久代、元空间二者并不只是名字变了，内部结构也调整了</p><p>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常</p><h1 id="90-设置方法区大小的参数与OOM"><a href="#90-设置方法区大小的参数与OOM" class="headerlink" title="90-设置方法区大小的参数与OOM"></a>90-设置方法区大小的参数与OOM</h1><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。</p><h3 id="jdk7及以前"><a href="#jdk7及以前" class="headerlink" title="jdk7及以前"></a>jdk7及以前</h3><ul><li>通过-xx:Permsize来设置永久代初始分配空间。默认值是20.75M</li><li>-XX:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</li><li>当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError:PermGen space。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200708111756800.png" alt="image-20200708111756800"></p><h3 id="JDK8以后"><a href="#JDK8以后" class="headerlink" title="JDK8以后"></a>JDK8以后</h3><p>元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize指定</p><p>默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。</p><p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</p><p>-XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-xx:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Ful1GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</p><p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Ful1GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。</p><h3 id="如何解决这些OOM"><a href="#如何解决这些OOM" class="headerlink" title="如何解决这些OOM"></a>如何解决这些OOM</h3><ul><li>要解决ooM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）<ul><li>内存泄漏就是 有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</li></ul></li><li>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GCRoots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</li><li>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li></ul><h1 id="92-方法区的内部结构"><a href="#92-方法区的内部结构" class="headerlink" title="92-方法区的内部结构"></a>92-方法区的内部结构<img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200708161728320.png" alt="image-20200708161728320"></h1><p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200708161856504.png" alt="image-20200708161856504"></p><h3 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h3><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVm必须在方法区中存储以下类型信息：</p><ul><li>这个类型的完整有效名称（全名=包名.类名）</li><li>这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ul><h3 id="域信息"><a href="#域信息" class="headerlink" title="域信息"></a>域信息</h3><p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p><p>域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</p><h3 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h3><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p><ul><li>方法名称</li><li>方法的返回类型（或void）</li><li>方法参数的数量和类型（按顺序）</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li><li>异常表（abstract和native方法除外）</li></ul><blockquote><p>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</p></blockquote><h3 id="non-final的类变量"><a href="#non-final的类变量" class="headerlink" title="non-final的类变量"></a>non-final的类变量</h3><p>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</p><p>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodAreaTest</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br>        Order <span class="hljs-keyword">order</span> = <span class="hljs-keyword">new</span> Order();<br>        <span class="hljs-keyword">order</span>.hello();<br>        System.out.println(<span class="hljs-keyword">order</span>.<span class="hljs-keyword">count</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Order</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> number = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> hello() &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上代码所示，即使我们把order设置为null，也不会出现空指针异常</p><h1 id="95-运行时常量池的理解"><a href="#95-运行时常量池的理解" class="headerlink" title="95-运行时常量池的理解"></a>95-运行时常量池的理解</h1><h3 id="全局常量"><a href="#全局常量" class="headerlink" title="全局常量"></a>全局常量</h3><p>全局常量就是使用 static final 进行修饰</p><p>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</p><h3 id="运行时常量池-VS-常量池"><a href="#运行时常量池-VS-常量池" class="headerlink" title="运行时常量池 VS 常量池"></a>运行时常量池 VS 常量池</h3><p>运行时常量池，就是运行时常量池</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200708171151384.png" alt="image-20200708171151384"></p><ul><li>方法区，内部包含了运行时常量池</li><li>字节码文件，内部包含了常量池</li><li>要弄清楚方法区，需要理解清楚C1assFile，因为加载类的信息都在方法区。</li><li>要弄清楚方法区的运行时常量池，需要理解清楚classFile中的常量池。</li></ul><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200708172357052.png" alt="image-20200708172357052"></p><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用</p><h4 id="为什么需要常量池"><a href="#为什么需要常量池" class="headerlink" title="为什么需要常量池"></a>为什么需要常量池</h4><p>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。r在动态链接的时候会用到运行时常量池，之前有介绍。</p><p>比如：如下的代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleClass</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然上述代码只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。</p><h4 id="常量池中有什么"><a href="#常量池中有什么" class="headerlink" title="常量池中有什么"></a>常量池中有什么</h4><ul><li>数量值</li><li>字符串值</li><li>类引用</li><li>字段引用</li><li>方法引用</li></ul><p>例如下面这段代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodAreaTest2</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> args[]</span>)</span> &#123;<br>        <span class="hljs-built_in">Object</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将会被翻译成如下字节码</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-literal">new</span> #2  <br>dup<br>invokespecial<br></code></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。</p><p>常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</p><p>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</p><p>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</p><p>运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。</p><p>运行时常量池类似于传统编程语言中的符号表（symboltable），但是它所包含的数据却比符号表要更加丰富一些。</p><p>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛outofMemoryError异常。</p><h1 id="96-图示举例方法区的使用"><a href="#96-图示举例方法区的使用" class="headerlink" title="96-图示举例方法区的使用"></a>96-图示举例方法区的使用</h1><p>如下代码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodAreaDemo</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span> args[])</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> x = <span class="hljs-number">500</span>;<br>        <span class="hljs-keyword">int</span> y = <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">int</span> a = x / y;<br>        <span class="hljs-keyword">int</span> b = <span class="hljs-number">50</span>;<br>        System.out.<span class="hljs-built_in">println</span>(a+b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码执行过程展示</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200708204750374.png" alt="image-20200708204750374"></p><p>首先现将操作数500放入到操作数栈中</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200708204953552.png" alt="image-20200708204953552"></p><p>然后存储到局部变量表中</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200708205029376.png" alt="image-20200708205029376"></p><p>然后重复一次，把100放入局部变量表中，最后再将变量表中的500 和 100 取出，进行操作</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200708205221737.png" alt="image-20200708205221737"></p><p>将500 和 100 进行一个除法运算，在把结果入栈</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200708205413721.png" alt="image-20200708205413721"></p><p>在最后就是输出流，需要调用运行时常量池的常量</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200708205708057.png" alt="image-20200708205708057"></p><p>最后调用invokevirtual（虚方法调用），然后返回</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200708205909176.png" alt="image-20200708205909176"></p><p>返回时</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200708210540696.png" alt="image-20200708210540696"></p><p>程序计数器始终计算的都是当前代码运行的位置，目的是为了方便记录 方法调用后能够正常返回，或者是进行了CPU切换后，也能回来到原来的代码进行执行。</p><h1 id="97-方法区在jdk6、jdk7、jdk8中的演进细节"><a href="#97-方法区在jdk6、jdk7、jdk8中的演进细节" class="headerlink" title="97-方法区在jdk6、jdk7、jdk8中的演进细节"></a>97-方法区在jdk6、jdk7、jdk8中的演进细节</h1><p>首先明确：只有Hotspot才有永久代。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一</p><p>Hotspot中方法区的变化：</p><table><thead><tr><th>JDK1.6及以前</th><th>有永久代，静态变量存储在永久代上</th></tr></thead><tbody><tr><td>JDK1.7</td><td>有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中</td></tr><tr><td>JDK1.8</td><td>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td></tr></tbody></table><p>JDK6的时候</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200708211541300.png" alt="image-20200708211541300"></p><p>JDK7的时候</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200708211609911.png" alt="image-20200708211609911"></p><p>JDK8的时候，元空间大小只受物理内存影响</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200708211637952.png" alt="image-20200708211637952"></p><h3 id="为什么永久代要被元空间替代？"><a href="#为什么永久代要被元空间替代？" class="headerlink" title="为什么永久代要被元空间替代？"></a>为什么永久代要被元空间替代？</h3><p>JRockit是和HotSpot融合后的结果，因为JRockit没有永久代，所以他们不需要配置永久代</p><p>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</p><p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间，这项改动是很有必要的，原因有：</p><ul><li>为永久代设置空间大小是很难确定的。</li></ul><p>在某些场景下，如果动态加载类过多，容易产生Perm区的oom。比如某个实际Web工 程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</p><p>“Exception in thread‘dubbo client x.x connector’java.lang.OutOfMemoryError:PermGen space”</p><p>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。</p><ul><li>对永久代进行调优是很困难的。<ul><li>主要是为了降低Full GC</li></ul></li></ul><p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏</p><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不在使用的类型</p><h1 id="98-StringTable为什么要调整位置"><a href="#98-StringTable为什么要调整位置" class="headerlink" title="98-StringTable为什么要调整位置"></a>98-StringTable为什么要调整位置</h1><p>jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而ful1gc是老年代的空间不足、永久代不足时才会触发。</p><p>这就导致stringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p><h1 id="99-如何证明静态变量存在哪"><a href="#99-如何证明静态变量存在哪" class="headerlink" title="99-如何证明静态变量存在哪"></a>99-如何证明静态变量存在哪</h1><h3 id="静态变量存放在那里？"><a href="#静态变量存放在那里？" class="headerlink" title="静态变量存放在那里？"></a>静态变量存放在那里？</h3><p>静态引用对应的对象实体始终都存在堆空间</p><p>可以使用 jhsdb.ext，需要在jdk9的时候才引入的</p><p>staticobj随着Test的类型信息存放在方法区，instanceobj随着Test的对象实例存放在Java堆，localobject则是存放在foo（）方法栈帧的局部变量表中。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200708215025527.png" alt="image-20200708215025527"></p><p>测试发现：三个对象的数据在内存中的地址都落在Eden区范围内，所以结论：只要是对象实例必然会在Java堆中分配。</p><p>接着，找到了一个引用该staticobj对象的地方，是在一个java.1ang.Class的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个java.lang.Class类型的对象实例，里面有一个名为staticobj的实例字段：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200708215218078.png" alt="image-20200708215218078"></p><p>从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射class对象存放在一起，存储于Java堆之中，从我们的实验中也明确验证了这一点</p><h1 id="100-方法区的垃圾回收行为"><a href="#100-方法区的垃圾回收行为" class="headerlink" title="100-方法区的垃圾回收行为"></a>100-方法区的垃圾回收行为</h1><p>有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的zGC收集器就不支持类卸载）。</p><p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p><p>回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）</p><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如osGi、JSP的重加载等，否则通常是很难达成的。</li><li>该类对应的java.lang.C1ass对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。I Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class 以及 -XX：+TraceClass-Loading、-XX：+TraceClassUnLoading查看类加载和卸载信息</li><li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及oSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</li></ul><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200708220303243.png" alt="image-20200708220303243"></p><h1 id="101-运行时数据区的总结与常见大厂面试题说明"><a href="#101-运行时数据区的总结与常见大厂面试题说明" class="headerlink" title="101-运行时数据区的总结与常见大厂面试题说明"></a>101-运行时数据区的总结与常见大厂面试题说明</h1><p>百度 三面：说一下JVM内存模型吧，有哪些区？分别干什么的？</p><p>蚂蚁金服： Java8的内存分代改进 JVM内存分哪几个区，每个区的作用是什么？ 一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？ 二面：Eden和survior的比例分配</p><p>小米： jvm内存分区，为什么要有新生代和老年代</p><p>字节跳动： 二面：Java的内存分区 二面：讲讲vm运行时数据库区 什么时候对象会进入老年代？</p><p>京东： JVM的内存结构，Eden和Survivor比例。 JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。</p><p>天猫： 一面：Jvm内存模型以及分区，需要详细到每个区放什么。 一面：JVM的内存模型，Java8做了什么改</p><p>拼多多： JVM内存分哪几个区，每个区的作用是什么？</p><p>美团： java内存分配 jvm的永久代中会发生垃圾回收吗？ 一面：jvm内存分区，为什么要有新生代和老年代？</p><h1 id="102-对象实例化的几种方式"><a href="#102-对象实例化的几种方式" class="headerlink" title="102-对象实例化的几种方式"></a>102-对象实例化的几种方式</h1><h2 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h2><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><ul><li>对象在JVM中是怎么存储的？</li><li>对象头信息里面有哪些东西？</li><li>Java对象头有什么？</li></ul><p>从对象创建的方式 和 步骤开始说</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200709095356247.png" alt="image-20200709095356247"></p><h3 id="对象创建方式"><a href="#对象创建方式" class="headerlink" title="对象创建方式"></a>对象创建方式</h3><ul><li>new：最常见的方式、单例类中调用getInstance的静态类方法，XXXFactory的静态方法</li><li>Class的newInstance方法：在JDK9里面被标记为过时的方法，因为只能调用空参构造器</li><li>Constructor的newInstance(XXX)：反射的方式，可以调用空参的，或者带参的构造器</li><li>使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone接口</li><li>使用序列化：序列化一般用于Socket的网络传输</li><li>第三方库 Objenesis</li></ul><h1 id="103-字节码角度看对象的创建过程"><a href="#103-字节码角度看对象的创建过程" class="headerlink" title="103-字节码角度看对象的创建过程"></a>103-字节码角度看对象的创建过程</h1><h1 id="104-对象创建的六个步骤"><a href="#104-对象创建的六个步骤" class="headerlink" title="104-对象创建的六个步骤"></a>104-对象创建的六个步骤</h1><h4 id="判断对象对应的类是否加载、链接、初始化"><a href="#判断对象对应的类是否加载、链接、初始化" class="headerlink" title="判断对象对应的类是否加载、链接、初始化"></a>判断对象对应的类是否加载、链接、初始化</h4><p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的 .class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。</p><h4 id="为对象分配内存"><a href="#为对象分配内存" class="headerlink" title="为对象分配内存"></a>为对象分配内存</h4><p>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</p><ul><li>如果内存规整：指针碰撞</li><li>如果内存不规整<ul><li>虚拟表需要维护一个列表</li><li>空闲列表分配</li></ul></li></ul><p>如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。</p><p>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</p><p>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”</p><p>选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p><h4 id="处理并发问题"><a href="#处理并发问题" class="headerlink" title="处理并发问题"></a>处理并发问题</h4><ul><li>采用CAS配上失败重试保证更新的原子性</li><li>每个线程预先分配TLAB - 通过设置 -XX:+UseTLAB参数来设置（区域加锁机制）<ul><li>在Eden区给每个线程分配一块区域</li></ul></li></ul><h4 id="初始化分配到的内存"><a href="#初始化分配到的内存" class="headerlink" title="初始化分配到的内存"></a>初始化分配到的内存</h4><p>给对象属性赋值的操作</p><ul><li>属性的默认初始化</li><li>显示初始化</li><li>代码块中的初始化</li><li>构造器初始化</li><li>所有属性设置默认值，保证对象实例字段在不赋值可以直接使用</li></ul><h3 id="设置对象的对象头"><a href="#设置对象的对象头" class="headerlink" title="设置对象的对象头"></a>设置对象的对象头</h3><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p><h3 id="执行init方法进行初始化"><a href="#执行init方法进行初始化" class="headerlink" title="执行init方法进行初始化"></a>执行init方法进行初始化</h3><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量</p><p>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</p><h3 id="对象实例化的过程"><a href="#对象实例化的过程" class="headerlink" title="对象实例化的过程"></a>对象实例化的过程</h3><ul><li>加载类元信息</li><li>为对象分配内存</li><li>处理并发问题</li><li>属性的默认初始化（零值初始化）</li><li>设置对象头信息</li><li>属性的显示初始化、代码块中初始化、构造器中初始化</li></ul><h1 id="105-对象的内存布局"><a href="#105-对象的内存布局" class="headerlink" title="105-对象的内存布局"></a>105-对象的内存布局</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200709151033237.png" alt="image-20200709151033237"></p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象头包含了两部分，分别是 运行时元数据（Mark Word）和 类型指针</p><blockquote><p>如果是数组，还需要记录数组的长度</p></blockquote><h4 id="运行时元数据"><a href="#运行时元数据" class="headerlink" title="运行时元数据"></a>运行时元数据</h4><ul><li>哈希值（HashCode）</li><li>GC分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程ID</li><li>翩向时间戳</li></ul><h4 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h4><p>指向类元数据InstanceKlass，确定该对象所属的类型。指向的其实是方法区中存放的类元信息</p><h3 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>不是必须的，也没有特别的含义，仅仅起到占位符的作用</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200709152801713.png" alt="image-20200709152801713"></p><h1 id="106-对象访问定位"><a href="#106-对象访问定位" class="headerlink" title="106-对象访问定位"></a>106-对象访问定位</h1><p>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200709164149920.png" alt="image-20200709164149920"></p><h3 id="对象访问的两种方式"><a href="#对象访问的两种方式" class="headerlink" title="对象访问的两种方式"></a>对象访问的两种方式</h3><h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200709164342002.png" alt="image-20200709164342002"></p><p>句柄访问就是说栈的局部变量表中，记录的对象的引用，然后在堆空间中开辟了一块空间，也就是句柄池</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改</p><h4 id="直接指针（HotSpot采用）"><a href="#直接指针（HotSpot采用）" class="headerlink" title="直接指针（HotSpot采用）"></a>直接指针（HotSpot采用）</h4><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200709164350466.png" alt="image-20200709164350466"></p><p>直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</p><h1 id="107-直接内存的简单体验"><a href="#107-直接内存的简单体验" class="headerlink" title="107-直接内存的简单体验"></a>107-直接内存的简单体验</h1><p>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</p><p>直接内存是在Java堆外的、直接向系统申请的内存区间。</p><p>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</p><p>通常，访问直接内存的速度会优于Java堆。即读写性能高。</p><ul><li>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。</li><li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</li></ul><p>使用下列代码，直接分配本地内存空间</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> BUFFER = <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>; <span class="hljs-comment">// 1GB</span><br>ByteBuffer byteBuffer = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBuffer</span>.</span></span>allocate<span class="hljs-constructor">Direct(BUFFER)</span>;<br></code></pre></td></tr></table></figure><h2 id="非直接缓存区和缓存区"><a href="#非直接缓存区和缓存区" class="headerlink" title="非直接缓存区和缓存区"></a>非直接缓存区和缓存区</h2><p>原来采用BIO的架构，我们需要从用户态切换成内核态</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200709170907611.png" alt="image-20200709170907611"></p><p>NIO的方式使用了缓存区的概念</p><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>也可能导致outofMemoryError异常</p><p>由于直接内存在Java堆外，因此它的大小不会直接受限于-xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。 缺点</p><ul><li>分配回收成本较高</li><li>不受JVM内存回收管理</li></ul><p>直接内存大小可以通过MaxDirectMemorySize设置</p><p>如果不指定，默认与堆的最大值-xmx参数值一致</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200709230647277.png" alt="image-20200709230647277"></p><h1 id="108-使用本地内存读写数据的测试"><a href="#108-使用本地内存读写数据的测试" class="headerlink" title="108-使用本地内存读写数据的测试"></a>108-使用本地内存读写数据的测试</h1><h1 id="109-直接内存的00M与内存大小的设置"><a href="#109-直接内存的00M与内存大小的设置" class="headerlink" title="109-直接内存的00M与内存大小的设置"></a>109-直接内存的00M与内存大小的设置</h1><h1 id="110-执行引擎的作用及工作过程概述"><a href="#110-执行引擎的作用及工作过程概述" class="headerlink" title="110-执行引擎的作用及工作过程概述"></a>110-执行引擎的作用及工作过程概述</h1><h2 id="执行引擎概述"><a href="#执行引擎概述" class="headerlink" title="执行引擎概述"></a>执行引擎概述</h2><p>执行引擎属于JVM的下层，里面包括 解释器、及时编译器、垃圾回收器</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200710080707873.png" alt="image-20200710080707873"></p><p>执行引擎是Java虚拟机核心的组成部分之一。“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。</p><p>JVM的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200710081118053.png" alt="image-20200710081118053"></p><p>那么，如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200710081259276.png" alt="image-20200710081259276"></p><h3 id="执行引擎的工作流程"><a href="#执行引擎的工作流程" class="headerlink" title="执行引擎的工作流程"></a>执行引擎的工作流程</h3><ul><li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。</li><li>每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。</li><li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200710081627217.png" alt="image-20200710081627217"></p><p>从外观上来看，所有的Java虚拟机的执行引擎输入，输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行过程。</p><h1 id="111-Java程序的编译和解释运行的理解"><a href="#111-Java程序的编译和解释运行的理解" class="headerlink" title="111-Java程序的编译和解释运行的理解"></a>111-Java程序的编译和解释运行的理解</h1><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤</p><ul><li>前面橙色部分是生成字节码文件的过程，和JVM无关</li><li>后面蓝色和绿色才是JVM需要考虑的过程</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200710082141643.png" alt="image-20200710082141643"></p><p>Java代码编译是由Java源码编译器来完成，流程图如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200710082433146.png" alt="image-20200710082433146"></p><p>Java字节码的执行是由JVM执行引擎来完成，流程图 如下所示</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710083036258.png" alt="image-20200710083036258"></p><p>我们用一个总的图，来说说 解释器和编译器</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200710083656277.png" alt="image-20200710083656277"></p><h3 id="什么是解释器（Interpreter）"><a href="#什么是解释器（Interpreter）" class="headerlink" title="什么是解释器（Interpreter）"></a>什么是解释器（Interpreter）</h3><p>当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p><h3 id="什么是IT编译器"><a href="#什么是IT编译器" class="headerlink" title="什么是IT编译器"></a>什么是IT编译器</h3><p>JIT（Just In Time Compiler）编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。</p><h3 id="为什么Java是半编译半解释型语言"><a href="#为什么Java是半编译半解释型语言" class="headerlink" title="为什么Java是半编译半解释型语言"></a>为什么Java是半编译半解释型语言</h3><p>JDK1.e时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</p><p>翻译成本地代码后，就可以做一个缓存操作，存储在方法区中</p><h1 id="112-机器码-指令-汇编-高级语言理解与执行过程"><a href="#112-机器码-指令-汇编-高级语言理解与执行过程" class="headerlink" title="112-机器码_指令_汇编_高级语言理解与执行过程"></a>112-机器码_指令_汇编_高级语言理解与执行过程</h1><h3 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h3><p>各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。</p><p>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</p><p>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。</p><p>机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>由于机器码是有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。</p><p>指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好</p><p>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。</p><h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><p>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。 如常见的</p><ul><li>x86指令集，对应的是x86架构的平台</li><li>ARM指令集，对应的是ARM架构的平台</li></ul><h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><p>由于指令的可读性还是太差，于是人们又发明了汇编语言。</p><p>在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbo1）或标号（Labe1）代替指令或操作数的地址。在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。</p><blockquote><p>由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行。</p></blockquote><h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><p>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。</p><p>高级语言比机器语言、汇编语言更接近人的语言当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200710085323733.png" alt="image-20200710085323733"></p><p>高级语言也不是直接翻译成 机器指令，而是翻译成汇编语言吗，如下面说的C和C++</p><h3 id="C、C-源程序执行过程"><a href="#C、C-源程序执行过程" class="headerlink" title="C、C++源程序执行过程"></a>C、C++源程序执行过程</h3><p>编译过程又可以分成两个阶段：编译和汇编。</p><p>编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</p><p>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200710085553258.png" alt="image-20200710085553258"></p><h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><p>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</p><p>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。</p><p>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。</p><ul><li>字节码典型的应用为：Java bytecode</li></ul><h1 id="113-解释器的使用"><a href="#113-解释器的使用" class="headerlink" title="113-解释器的使用"></a>113-解释器的使用</h1><p>JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200710090203674.png" alt="image-20200710090203674"></p><p>为什么Java源文件不直接翻译成JMV，而是翻译成字节码文件？可能是因为直接翻译的代码是比较大的</p><p>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p><p>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</p><h3 id="解释器分类"><a href="#解释器分类" class="headerlink" title="解释器分类"></a>解释器分类</h3><p>在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。</p><p>字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。</p><p>而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。</p><h1 id="114-HotspotVM为何解释器与JIT编译器并存"><a href="#114-HotspotVM为何解释器与JIT编译器并存" class="headerlink" title="114-HotspotVM为何解释器与JIT编译器并存"></a>114-HotspotVM为何解释器与JIT编译器并存</h1><p>在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。</p><ul><li>Interpreter模块：实现了解释器的核心功能</li><li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li></ul><h3 id="现状-1"><a href="#现状-1" class="headerlink" title="现状"></a>现状</h3><p>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Per1、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C/C++程序员所调侃。</p><p>为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</p><p>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</p><h1 id="115-热点代码探测确定何时JIT"><a href="#115-热点代码探测确定何时JIT" class="headerlink" title="115-热点代码探测确定何时JIT"></a>115-热点代码探测确定何时JIT</h1><h3 id="Java代码的执行分类"><a href="#Java代码的执行分类" class="headerlink" title="Java代码的执行分类"></a>Java代码的执行分类</h3><p>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</p><p>第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行</p><p>HotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</p><p>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++ 程序一较高下的地步。</p><h3 id="问题来了"><a href="#问题来了" class="headerlink" title="问题来了"></a>问题来了</h3><p>有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</p><ul><li>JRockit虚拟机是砍掉了解释器，也就是只采及时编译器。那是因为呢JRockit只部署在服务器上，一般已经有时间让他进行指令编译的过程了，对于响应来说要求不高，等及时编译器的编译完成后，就会提供更好的性能</li></ul><p>首先明确： 当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。 编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p><p>所以： 尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。</p><p>在此模式下，当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</p><p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。</p><h3 id="HotSpot-JVM执行方式"><a href="#HotSpot-JVM执行方式" class="headerlink" title="HotSpot JVM执行方式"></a>HotSpot JVM执行方式</h3><p>当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>注意解释执行与编译执行在线上环境微妙的辩证关系。机器在热机状态可以承受的负载要大于冷机状态。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</p><p>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1/8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1/2发布成功的服务器马上全部宕机，此故障说明了JIT的存在。—阿里团队</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200710095417462.png" alt="image-20200710095417462"></p><h3 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h3><ul><li>Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程；也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）</li><li>把字节码转变成机器码的过程。</li><li>还可能是指使用静态提前编译器（AOT编译器，Ahead of Time Compiler）直接把.java文件编译成本地机器代码的过程。</li></ul><p>前端编译器：Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）。</p><p>JIT编译器：HotSpot VM的C1、C2编译器。</p><p>AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。</p><h3 id="热点探测技术"><a href="#热点探测技术" class="headerlink" title="热点探测技术"></a>热点探测技术</h3><p>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此被称之为栈上替换，或简称为OSR（On Stack Replacement）编译。</p><p>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。</p><p>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测。</p><p>采用基于计数器的热点探测，HotSpot V将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。</p><ul><li>方法调用计数器用于统计方法的调用次数</li><li>回边计数器则用于统计循环体执行的循环次数</li></ul><h3 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h3><p>这个计数器就用于统计方法被调用的次数，它的默认阀值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。</p><p>这个阀值可以通过虚拟机参数 -XX:CompileThreshold 来人为设定。</p><p>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200710101829934.png" alt="image-20200710101829934"></p><h3 id="热点衰减"><a href="#热点衰减" class="headerlink" title="热点衰减"></a>热点衰减</h3><p>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）</p><ul><li>半衰周期是化学中的概念，比如出土的文物通过查看C60来获得文物的年龄</li></ul><p>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX:-UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</p><p>另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</p><h3 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h3><p>它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200710103103869.png" alt="image-20200710103103869"></p><h3 id="HotSpotVM-可以设置程序执行方法"><a href="#HotSpotVM-可以设置程序执行方法" class="headerlink" title="HotSpotVM 可以设置程序执行方法"></a>HotSpotVM 可以设置程序执行方法</h3><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p><ul><li>-Xint：完全采用解释器模式执行程序；</li><li>-Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li><li>-Xmixed：采用解释器+即时编译器的混合模式共同执行程序。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200710103340273.png" alt="image-20200710103340273"></p><h1 id="116-Hotspot设置模式-C1与C2编译器"><a href="#116-Hotspot设置模式-C1与C2编译器" class="headerlink" title="116-Hotspot设置模式_C1与C2编译器"></a>116-Hotspot设置模式_C1与C2编译器</h1><p>JIT的编译器还分为了两种，分别是C1和C2，在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器 和 C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p><ul><li>-client：指定Java虚拟机运行在Client模式下，并使用C1编译器；<ul><li>C1编译器会对字节码进行简单和可靠的优化，耗时短。以达到更快的编译速度。</li></ul></li><li>-server：指定Java虚拟机运行在server模式下，并使用C2编译器。<ul><li>C2进行耗时较长的优化，以及激进优化。但优化的代码执行效率更高。（使用C++）</li></ul></li></ul><h3 id="C1-和-C2编译器不同的优化策略"><a href="#C1-和-C2编译器不同的优化策略" class="headerlink" title="C1 和 C2编译器不同的优化策略"></a>C1 和 C2编译器不同的优化策略</h3><p>在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化、元余消除。</p><ul><li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li><li>去虚拟化：对唯一的实现樊进行内联</li><li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li></ul><p>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：</p><ul><li>标量替换：用标量值代替聚合对象的属性值</li><li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li><li>同步消除：清除同步操作，通常指synchronized</li></ul><h3 id="分层编译策略"><a href="#分层编译策略" class="headerlink" title="分层编译策略"></a>分层编译策略</h3><p>分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。</p><p>不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul><li>一般来讲，JIT编译出来的机器码性能比解释器搞</li><li>C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器</li></ul><h1 id="117-Graal编译器与AOT编译器"><a href="#117-Graal编译器与AOT编译器" class="headerlink" title="117-Graal编译器与AOT编译器"></a>117-Graal编译器与AOT编译器</h1><p>jdk9引入了AoT编译器（静态提前编译器，Ahead of Time Compiler）</p><p>Java 9引入了实验性AOT编译工具aotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。</p><p>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl">.<span class="hljs-function"><span class="hljs-title">java</span> -&gt;</span> .<span class="hljs-function"><span class="hljs-title">class</span> -&gt;</span> (使用<span class="hljs-function"><span class="hljs-title">jaotc</span>) -&gt;</span> .so<br></code></pre></td></tr></table></figure><p>最大的好处：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验</p><p>缺点：</p><ul><li>破坏了 java “ 一次编译，到处运行”，必须为每个不同的硬件，OS编译对应的发行包</li><li>降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知。</li><li>还需要继续优化中，最初只支持Linux X64 java base</li></ul><h3 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h3><ul><li>自JDK10起，HotSpot又加入了一个全新的及时编译器：Graal编译器</li><li>编译效果短短几年时间就追评了G2编译器，未来可期</li><li>目前，带着实验状态标签，需要使用开关参数去激活才能使用</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">-XX</span><span class="hljs-selector-pseudo">:+UnlockExperimentalvMOptions</span> <span class="hljs-selector-tag">-XX</span><span class="hljs-selector-pseudo">:+UseJVMCICompiler</span><br></code></pre></td></tr></table></figure><h1 id="118-String的不可变性"><a href="#118-String的不可变性" class="headerlink" title="118-String的不可变性"></a>118-String的不可变性</h1><h2 id="String的基本特性"><a href="#String的基本特性" class="headerlink" title="String的基本特性"></a>String的基本特性</h2><ul><li>String：字符串，使用一对 ”” 引起来表示<ul><li>String s1 = “mogublog” ; // 字面量的定义方式</li><li>String s2 = new String(“moxi”);</li></ul></li><li>string声明为final的，不可被继承</li><li>String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示string可以比较大小</li><li>string在jdk8及以前内部定义了final char[] value用于存储字符串数据。JDK9时改为byte[]</li></ul><h3 id="为什么JDK9改变了结构"><a href="#为什么JDK9改变了结构" class="headerlink" title="为什么JDK9改变了结构"></a>为什么JDK9改变了结构</h3><p>String类的当前实现将字符存储在char数组中，每个字符使用两个字节(16位)。从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且，大多数字符串对象只包含拉丁字符。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中有一半的空间将不会使用。</p><p>我们建议改变字符串的内部表示clasš从utf - 16字符数组到字节数组+一个encoding-flag字段。新的String类将根据字符串的内容存储编码为ISO-8859-1/Latin-1(每个字符一个字节)或UTF-16(每个字符两个字节)的字符。编码标志将指示使用哪种编码。</p><p>结论：String再也不用char[] 来存储了，改成了byte [] 加上编码标记，节约了一些空间</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 之前</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];<br><span class="hljs-comment">// 之后</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] value<br></code></pre></td></tr></table></figure><p>同时基于String的数据结构，例如StringBuffer和StringBuilder也同样做了修改</p><h3 id="String的不可变性"><a href="#String的不可变性" class="headerlink" title="String的不可变性"></a>String的不可变性</h3><p>String：代表不可变的字符序列。简称：不可变性。</p><blockquote><p>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 当调用string的replace（）方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</p></blockquote><p>代码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTest1</span> &#123;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 字面量定义的方式，“abc”存储在字符串常量池中</span><br>        <span class="hljs-keyword">String</span> s1 = <span class="hljs-string">&quot;abc&quot;</span>;<br>        <span class="hljs-keyword">String</span> s2 = <span class="hljs-string">&quot;abc&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(s1 == s2);<br>        s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(s1 == s2);<br>        System.out.<span class="hljs-built_in">println</span>(s1);<br>        System.out.<span class="hljs-built_in">println</span>(s2);<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;----------------&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">String</span> s1 = <span class="hljs-string">&quot;abc&quot;</span>;<br>        <span class="hljs-keyword">String</span> s2 = <span class="hljs-string">&quot;abc&quot;</span>;<br>        <span class="hljs-comment">// 只要进行了修改，就会重新创建一个对象，这就是不可变性</span><br>        s2 += <span class="hljs-string">&quot;def&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(s1);<br>        System.out.<span class="hljs-built_in">println</span>(s2);<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;----------------&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">String</span> s1 = <span class="hljs-string">&quot;abc&quot;</span>;<br>        <span class="hljs-keyword">String</span> s2 = s1.replace(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>);<br>        System.out.<span class="hljs-built_in">println</span>(s1);<br>        System.out.<span class="hljs-built_in">println</span>(s2);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        test1();<br>        test2();<br>        test3();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">true<br>false<br>hello<br>abc<br>----------------<br>abc<br>abcdef<br>----------------<br>abc<br>mbc<br></code></pre></td></tr></table></figure><h3 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> class StringExer &#123;<br>    <span class="hljs-keyword">String</span> <span class="hljs-built_in">str</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(<span class="hljs-string">&quot;good&quot;</span>);<br>    <span class="hljs-built_in">char</span> [] ch = &#123;<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> change(<span class="hljs-keyword">String</span> <span class="hljs-built_in">str</span>, <span class="hljs-built_in">char</span> ch []) &#123;<br>        <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;test ok&quot;</span>;<br>        ch[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;b&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        StringExer ex = <span class="hljs-keyword">new</span> StringExer();<br>        ex.change(ex.<span class="hljs-built_in">str</span>, ex.ch);<br>        System.out.<span class="hljs-built_in">println</span>(ex.<span class="hljs-built_in">str</span>);<br>        System.out.<span class="hljs-built_in">println</span>(ex.ch);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">good</span><br><span class="hljs-attribute">best</span><br></code></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><strong>字符串常量池是不会存储相同内容的字符串的</strong></p><p>String的string Pool是一个固定大小的Hashtable，默认值大小长度是1009。如果放进string Pool的string非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用string.intern时性能会大幅下降。</p><p>使用-XX:StringTablesize可设置stringTab1e的长度</p><p>在jdk6中stringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。stringTablesize设置没有要求</p><p>在jdk7中，stringTable的长度默认值是60013，</p><p>在JDK8中，StringTable可以设置的最小值为1009</p><h1 id="120-String内存结构的分配位置"><a href="#120-String内存结构的分配位置" class="headerlink" title="120-String内存结构的分配位置"></a>120-String内存结构的分配位置</h1><p>在Java语言中有8种基本数据类型和一种比较特殊的类型string。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</p><p>常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，string类型的常量池比较特殊。它的主要使用方法有两种。</p><p>直接使用双引号声明出来的String对象会直接存储在常量池中。</p><ul><li>比如：string info=”atguigu.com”；</li></ul><p>如果不是用双引号声明的string对象，可以使用string提供的intern（）方法。</p><p>Java 6及以前，字符串常量池存放在永久代</p><p>Java 7中 oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内</p><blockquote><p>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</p><p>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用string.intern（）。</p></blockquote><p>Java8元空间，字符串常量在堆</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200711093546398.png" alt="image-20200711093546398"></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200711093558709.png" alt="image-20200711093558709"></p><h3 id="为什么StringTable从永久代调整到堆中"><a href="#为什么StringTable从永久代调整到堆中" class="headerlink" title="为什么StringTable从永久代调整到堆中"></a>为什么StringTable从永久代调整到堆中</h3><p>在JDK 7中，interned字符串不再在Java堆的永久生成中分配，而是在Java堆的主要部分(称为年轻代和年老代)中分配，与应用程序创建的其他对象一起分配。此更改将导致驻留在主Java堆中的数据更多，驻留在永久生成中的数据更少，因此可能需要调整堆大小。由于这一变化，大多数应用程序在堆使用方面只会看到相对较小的差异，但加载许多类或大量使用字符串的较大应用程序会出现这种差异。intern()方法会看到更显著的差异。</p><ul><li>永久代的默认比较小</li><li>永久代垃圾回收频率低</li></ul><h1 id="121-两个案例熟悉String的基本操作"><a href="#121-两个案例熟悉String的基本操作" class="headerlink" title="121-两个案例熟悉String的基本操作"></a>121-两个案例熟悉String的基本操作</h1><p>Java语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且必须是指向同一个String类实例。</p><h2 id="字符串拼接操作"><a href="#字符串拼接操作" class="headerlink" title="字符串拼接操作"></a>字符串拼接操作</h2><ul><li>常量与常量的拼接结果在常量池，原理是编译期优化</li><li>常量池中不会存在相同内容的变量</li><li>只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder</li><li>如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">   public static void test1() &#123;<br>       String <span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span> + <span class="hljs-string">&quot;c&quot;</span><span class="hljs-comment">;  // 得到 abc的常量池</span><br>       String <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;abc&quot;</span><span class="hljs-comment">; // abc存放在常量池，直接将常量池的地址返回</span><br>       <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * 最终java编译成.class，再执行.class</span><br><span class="hljs-comment">        */</span><br>       System.out.println(<span class="hljs-built_in">s1</span> == <span class="hljs-built_in">s2</span>)<span class="hljs-comment">; // true，因为存放在字符串常量池</span><br>       System.out.println(<span class="hljs-built_in">s1</span>.equals(<span class="hljs-built_in">s2</span>))<span class="hljs-comment">; // true</span><br>   &#125;<br><br>public static void test2() &#123;<br>       String <span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;javaEE&quot;</span>;<br>       String <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;hadoop&quot;</span>;<br>       String <span class="hljs-built_in">s3</span> = <span class="hljs-string">&quot;javaEEhadoop&quot;</span>;<br>       String <span class="hljs-built_in">s4</span> = <span class="hljs-string">&quot;javaEE&quot;</span> + <span class="hljs-string">&quot;hadoop&quot;</span>;    <br>       String <span class="hljs-built_in">s5</span> = <span class="hljs-built_in">s1</span> + <span class="hljs-string">&quot;hadoop&quot;</span>;<br>       String <span class="hljs-built_in">s6</span> = <span class="hljs-string">&quot;javaEE&quot;</span> + <span class="hljs-built_in">s2</span>;<br>       String <span class="hljs-built_in">s7</span> = <span class="hljs-built_in">s1</span> + <span class="hljs-built_in">s2</span>;<br><br>       System.out.println(<span class="hljs-built_in">s3</span> == <span class="hljs-built_in">s4</span>)<span class="hljs-comment">; // true</span><br>       System.out.println(<span class="hljs-built_in">s3</span> == <span class="hljs-built_in">s5</span>)<span class="hljs-comment">; // false</span><br>       System.out.println(<span class="hljs-built_in">s3</span> == <span class="hljs-built_in">s6</span>)<span class="hljs-comment">; // false</span><br>       System.out.println(<span class="hljs-built_in">s3</span> == <span class="hljs-built_in">s7</span>)<span class="hljs-comment">; // false</span><br>       System.out.println(<span class="hljs-built_in">s5</span> == <span class="hljs-built_in">s6</span>)<span class="hljs-comment">; // false</span><br>       System.out.println(<span class="hljs-built_in">s5</span> == <span class="hljs-built_in">s7</span>)<span class="hljs-comment">; // false</span><br>       System.out.println(<span class="hljs-built_in">s6</span> == <span class="hljs-built_in">s7</span>)<span class="hljs-comment">; // false</span><br><br>       String <span class="hljs-built_in">s8</span> = <span class="hljs-built_in">s6</span>.intern();<br>       System.out.println(<span class="hljs-built_in">s3</span> == <span class="hljs-built_in">s8</span>)<span class="hljs-comment">; // true</span><br>   &#125;<br></code></pre></td></tr></table></figure><p>从上述的结果我们可以知道：</p><p>如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果</p><p>而调用intern方法，则会判断字符串常量池中是否存在JavaEEhadoop值，如果存在则返回常量池中的值，否者就在常量池中创建</p><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p>拼接操作的底层其实使用了StringBuilder</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200711102231129.png" alt="image-20200711102231129"></p><p>s1 + s2的执行细节</p><ul><li>StringBuilder s = new StringBuilder();</li><li>s.append(s1);</li><li>s.append(s2);</li><li>s.toString(); -&gt; 类似于new String(“ab”);</li></ul><p>在JDK5之后，使用的是StringBuilder，在JDK5之前使用的是StringBuffer</p><table><thead><tr><th>String</th><th>StringBuffer</th><th>StringBuilder</th></tr></thead><tbody><tr><td>String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且浪费大量优先的内存空间</td><td>StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量</td><td>可变类，速度更快</td></tr><tr><td>不可变</td><td>可变</td><td>可变</td></tr><tr><td></td><td>线程安全</td><td>线程不安全</td></tr><tr><td></td><td>多线程操作字符串</td><td>单线程操作字符串</td></tr></tbody></table><p>注意，我们左右两边如果是变量的话，就是需要new StringBuilder进行拼接，但是如果使用的是final修饰，则是从常量池中获取。所以说拼接符号左右两边都是字符串常量或常量引用 则仍然使用编译器优化。也就是说被final修饰的变量，将会变成常量，类和方法将不能被继承、</p><ul><li>在开发中，能够使用final的时候，建议使用上</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> s1 = <span class="hljs-string">&quot;a&quot;</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>    <span class="hljs-keyword">String</span> s3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>    <span class="hljs-keyword">String</span> s4 = s1 + s2;<br>    System.out.<span class="hljs-built_in">println</span>(s3 == s4);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="拼接操作和append性能对比"><a href="#拼接操作和append性能对比" class="headerlink" title="拼接操作和append性能对比"></a>拼接操作和append性能对比</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> highLevel)</span> </span>&#123;<br>    <span class="hljs-keyword">String</span> src = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; highLevel; i++) &#123;<br>        src += <span class="hljs-string">&quot;a&quot;</span>; <span class="hljs-comment">// 每次循环都会创建一个StringBuilder对象</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> highLevel)</span> </span>&#123;<br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; highLevel; i++) &#123;<br>        sb.append(<span class="hljs-string">&quot;a&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法1耗费的时间：4005ms，方法2消耗时间：7ms</p><p>结论：</p><ul><li>通过StringBuilder的append()方式添加字符串的效率，要远远高于String的字符串拼接方法</li></ul><p>好处</p><ul><li>StringBuilder的append的方式，自始至终只创建一个StringBuilder的对象</li><li>对于字符串拼接的方式，还需要创建很多StringBuilder对象和 调用toString时候创建的String对象</li><li>内存中由于创建了较多的StringBuilder和String对象，内存占用过大，如果进行GC那么将会耗费更多的时间</li></ul><p>改进的空间</p><ul><li>我们使用的是StringBuilder的空参构造器，默认的字符串容量是16，然后将原来的字符串拷贝到新的字符串中， 我们也可以默认初始化更大的长度，减少扩容的次数</li><li>因此在实际开发中，我们能够确定，前前后后需要添加的字符串不高于某个限定值，那么建议使用构造器创建一个阈值的长度</li></ul><h2 id="intern-的使用"><a href="#intern-的使用" class="headerlink" title="intern()的使用"></a>intern()的使用</h2><p>intern是一个native方法，调用的是底层C的方法</p><p>字符串池最初是空的，由String类私有地维护。在调用intern方法时，如果池中已经包含了由equals(object)方法确定的与该字符串对象相等的字符串，则返回池中的字符串。否则，该字符串对象将被添加到池中，并返回对该字符串对象的引用。</p><p>如果不是用双引号声明的string对象，可以使用string提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。</p><p>比如：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-built_in">String</span> myInfo = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;I love atguigu&quot;</span>).intern();<br></code></pre></td></tr></table></figure><p>也就是说，如果在任意字符串上调用string.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">（<span class="hljs-string">&quot;a&quot;</span>+<span class="hljs-string">&quot;b&quot;</span>+<span class="hljs-string">&quot;c&quot;</span>）<span class="hljs-string">.intern</span>（）==<span class="hljs-string">&quot;abc&quot;</span><br></code></pre></td></tr></table></figure><p>通俗点讲，Interned string就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）</p><h3 id="intern的空间效率测试"><a href="#intern的空间效率测试" class="headerlink" title="intern的空间效率测试"></a>intern的空间效率测试</h3><p>我们通过测试一下，使用了intern和不使用的时候，其实相差还挺多的</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用Intern() 测试执行效率</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringIntern2</span> &#123;</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_COUNT = <span class="hljs-number">1000</span> * <span class="hljs-number">10000</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>[MAX_COUNT];<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        Integer [] data = <span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;<br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_COUNT; i++) &#123;<br>            arr[i] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(<span class="hljs-keyword">String</span>.valueOf(data[i%data.length])).intern();<br>        &#125;<br>        <span class="hljs-keyword">long</span> <span class="hljs-built_in">end</span> = System.currentTimeMillis();<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;花费的时间为：&quot;</span> + (<span class="hljs-built_in">end</span> - start));<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.getStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结论</strong>：对于程序中大量使用存在的字符串时，尤其存在很多已经重复的字符串时，使用intern()方法能够节省内存空间。</p><p>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用intern() 方法，就会很明显降低内存的大小。</p><h1 id="122-字符串拼接操作的面试题讲解"><a href="#122-字符串拼接操作的面试题讲解" class="headerlink" title="122-字符串拼接操作的面试题讲解"></a>122-字符串拼接操作的面试题讲解</h1><h2 id="面试题-2"><a href="#面试题-2" class="headerlink" title="面试题"></a>面试题</h2><h3 id="new-String-“ab”-会创建几个对象"><a href="#new-String-“ab”-会创建几个对象" class="headerlink" title="new String(“ab”)会创建几个对象"></a>new String(“ab”)会创建几个对象</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * new String(&quot;ab&quot;) 会创建几个对象？ 看字节码就知道是2个对象</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 陌溪</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-07-11-11:17</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringNewTest</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        <span class="hljs-built_in">String</span> str = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;ab&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们转换成字节码来查看</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap"><span class="hljs-number"> 0 </span>new <span class="hljs-comment">#2 &lt;java/lang/String&gt;</span><br><span class="hljs-number"> 3 </span>dup<br><span class="hljs-number"> 4 </span>ldc <span class="hljs-comment">#3 &lt;ab&gt;</span><br><span class="hljs-number"> 6 </span>invokespecial <span class="hljs-comment">#4 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="hljs-number"> 9 </span>astore_1<br>10 return<br></code></pre></td></tr></table></figure><p>这里面就是两个对象</p><ul><li>一个对象是：new关键字在堆空间中创建</li><li>另一个对象：字符串常量池中的对象</li></ul><h3 id="new-String-“a”-new-String-“b”-会创建几个对象"><a href="#new-String-“a”-new-String-“b”-会创建几个对象" class="headerlink" title="new String(“a”) + new String(“b”) 会创建几个对象"></a>new String(“a”) + new String(“b”) 会创建几个对象</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * new String(&quot;ab&quot;) 会创建几个对象？ 看字节码就知道是2个对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringNewTest</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">String</span> str = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(<span class="hljs-string">&quot;b&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码文件为</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs gradle"> <span class="hljs-number">0</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">2</span> &lt;java<span class="hljs-regexp">/lang/</span>StringBuilder&gt;<br> <span class="hljs-number">3</span> dup<br> <span class="hljs-number">4</span> invokespecial #<span class="hljs-number">3</span> &lt;java<span class="hljs-regexp">/lang/</span>StringBuilder.&lt;init&gt;&gt;<br> <span class="hljs-number">7</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">4</span> &lt;java<span class="hljs-regexp">/lang/</span>String&gt;<br><span class="hljs-number">10</span> dup<br><span class="hljs-number">11</span> ldc #<span class="hljs-number">5</span> &lt;a&gt;<br><span class="hljs-number">13</span> invokespecial #<span class="hljs-number">6</span> &lt;java<span class="hljs-regexp">/lang/</span>String.&lt;init&gt;&gt;<br><span class="hljs-number">16</span> invokevirtual #<span class="hljs-number">7</span> &lt;java<span class="hljs-regexp">/lang/</span>StringBuilder.<span class="hljs-keyword">append</span>&gt;<br><span class="hljs-number">19</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">4</span> &lt;java<span class="hljs-regexp">/lang/</span>String&gt;<br><span class="hljs-number">22</span> dup<br><span class="hljs-number">23</span> ldc #<span class="hljs-number">8</span> &lt;b&gt;<br><span class="hljs-number">25</span> invokespecial #<span class="hljs-number">6</span> &lt;java<span class="hljs-regexp">/lang/</span>String.&lt;init&gt;&gt;<br><span class="hljs-number">28</span> invokevirtual #<span class="hljs-number">7</span> &lt;java<span class="hljs-regexp">/lang/</span>StringBuilder.<span class="hljs-keyword">append</span>&gt;<br><span class="hljs-number">31</span> invokevirtual #<span class="hljs-number">9</span> &lt;java<span class="hljs-regexp">/lang/</span>StringBuilder.toString&gt;<br><span class="hljs-number">34</span> astore_1<br><span class="hljs-number">35</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>我们创建了6个对象</p><ul><li>对象1：new StringBuilder()</li><li>对象2：new String(“a”)</li><li>对象3：常量池的 a</li><li>对象4：new String(“b”)</li><li>对象5：常量池的 b</li><li>对象6：toString中会创建一个 new String(“ab”)<ul><li>调用toString方法，不会在常量池中生成ab</li></ul></li></ul><h3 id="intern的使用：JDK6和JDK7"><a href="#intern的使用：JDK6和JDK7" class="headerlink" title="intern的使用：JDK6和JDK7"></a>intern的使用：JDK6和JDK7</h3><h4 id="JDK6中"><a href="#JDK6中" class="headerlink" title="JDK6中"></a>JDK6中</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span> s = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(<span class="hljs-string">&quot;1&quot;</span>);  <span class="hljs-comment">// 在常量池中已经有了</span><br>s.intern(); <span class="hljs-comment">// 将该对象放入到常量池。但是调用此方法没有太多的区别，因为已经存在了1</span><br><span class="hljs-keyword">String</span> s2 = <span class="hljs-string">&quot;1&quot;</span>;<br>System.out.<span class="hljs-built_in">println</span>(s == s2); <span class="hljs-comment">// false</span><br><br><span class="hljs-keyword">String</span> s3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(<span class="hljs-string">&quot;1&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>s3.intern();<br><span class="hljs-keyword">String</span> s4 = <span class="hljs-string">&quot;11&quot;</span>;<br>System.out.<span class="hljs-built_in">println</span>(s3 == s4); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>为什么对象会不一样呢？</p><ul><li>一个是new创建的对象，一个是常量池中的对象，显然不是同一个</li></ul><p>如果是下面这样的，那么就是true</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-built_in">String</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>s = s.intern();<br><span class="hljs-built_in">String</span> s2 = <span class="hljs-string">&quot;1&quot;</span>;<br>System.<span class="hljs-keyword">out</span>.println(s == s2); // <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>而对于下面的来说，因为 s3变量记录的地址是 new String(“11”)，然后这段代码执行完以后，常量池中不存在 “11”，这是JDK6的关系，然后执行 s3.intern()后，就会在常量池中生成 “11”，最后 s4用的就是s3的地址</p><blockquote><p>为什么最后输出的 s3 == s4 会为false呢？</p><p>这是因为在JDK6中创建了一个新的对象 “11”，也就是有了新的地址， s2 = 新地址</p><p>而在JDK7中，在JDK7中，并没有创新一个新对象，而是指向常量池中的新对象</p></blockquote><h4 id="JDK7中"><a href="#JDK7中" class="headerlink" title="JDK7中"></a>JDK7中</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span> s = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>s.intern();<br><span class="hljs-keyword">String</span> s2 = <span class="hljs-string">&quot;1&quot;</span>;<br>System.out.<span class="hljs-built_in">println</span>(s == s2); <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">String</span> s3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(<span class="hljs-string">&quot;1&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>s3.intern();<br><span class="hljs-keyword">String</span> s4 = <span class="hljs-string">&quot;11&quot;</span>;<br>System.out.<span class="hljs-built_in">println</span>(s3 == s4); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200711145925091.png" alt="image-20200711145925091"></p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span> s3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(<span class="hljs-string">&quot;1&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(<span class="hljs-string">&quot;1&quot;</span>);<br><span class="hljs-keyword">String</span> s4 = <span class="hljs-string">&quot;11&quot;</span>;  <span class="hljs-comment">// 在常量池中生成的字符串</span><br>s3.intern();  <span class="hljs-comment">// 然后s3就会从常量池中找，发现有了，就什么事情都不做</span><br>System.out.<span class="hljs-built_in">println</span>(s3 == s4);<br></code></pre></td></tr></table></figure><p>我们将 s4的位置向上移动一行，发现变化就会很大，最后得到的是 false</p><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>总结string的intern（）的使用：</p><p>JDK1.6中，将这个字符串对象尝试放入串池。</p><ul><li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li><li>如果没有，会把此<strong>对象复制一份</strong>，放入串池，并返回串池中的对象地址</li></ul><p>JDK1.7起，将这个字符串对象尝试放入串池。</p><ul><li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li><li>如果没有，则会把<strong>对象的引用地址</strong>复制一份，放入串池，并返回串池中的引用地址</li></ul><p>练习：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200711150859709.png" alt="image-20200711150859709"></p><ul><li>在JDK6中，在字符串常量池中创建一个字符串 “ab”</li><li>在JDK8中，在字符串常量池中没有创建 “ab”，而是将堆中的地址复制到 串池中。</li></ul><p>所以上述结果，在JDK6中是：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>在JDK8中是</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200711151326909.png" alt="image-20200711151326909"></p><p>针对下面这题，在JDK6和8中表现的是一样的</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200711151433277.png" alt="image-20200711151433277"></p><h2 id="StringTable的垃圾回收"><a href="#StringTable的垃圾回收" class="headerlink" title="StringTable的垃圾回收"></a>StringTable的垃圾回收</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * String的垃圾回收</span><br><span class="hljs-comment"> * -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringGCTest</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>            <span class="hljs-built_in">String</span>.valueOf(i).intern();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="G1中的String去重操作"><a href="#G1中的String去重操作" class="headerlink" title="G1中的String去重操作"></a>G1中的String去重操作</h2><p>注意这里说的重复，指的是在堆中的数据，而不是常量池中的，因为常量池中的本身就不会重复</p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>背景：对许多Java应用（有大的也有小的）做的测试得出以下结果：</p><ul><li>堆存活数据集合里面string对象占了25%</li><li>堆存活数据集合里面重复的string对象有13.5%</li><li>string对象的平均长度是45</li></ul><p>许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java堆中存活的数据集合差不多25%是string对象。更进一步，这里面差不多一半string对象是重复的，重复的意思是说： stringl.equals（string2）= true。堆上存在重复的string对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的string对象进行去重，这样就能避免浪费内存。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的string对象。</li><li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的string对象。</li><li>使用一个hashtab1e来记录所有的被string对象使用的不重复的char数组。当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。</li><li>如果存在，string对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li><li>如果查找失败，char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了。</li></ul><h3 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h3><p>命令行选项</p><blockquote><p>UsestringDeduplication（bool）：开启string去重，默认是不开启的，需要手动开启。 Printstringbeduplicationstatistics（bool）：打印详细的去重统计信息 stringpeduplicationAgeThreshold（uintx）：达到这个年龄的string对象被认为是去重的候选对象</p></blockquote><h1 id="134-垃圾回收相关章节的说明"><a href="#134-垃圾回收相关章节的说明" class="headerlink" title="134-垃圾回收相关章节的说明"></a>134-垃圾回收相关章节的说明</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>这次我们主要关注的是黄色部分，内存的分配与回收</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200712084539884.png" alt="image-20200712084539884"></p><h2 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h2><p>在提到什么是垃圾之前，我们先看下面一张图</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200712085456113.png" alt="image-20200712085456113"></p><p>从上图我们可以很明确的知道，Java 和 C++语言的区别，就在于垃圾收集技术和内存动态分配上，C语言没有垃圾收集技术，需要我们手动的收集。</p><p>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。 关于垃圾收集有三个经典问题：</p><ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul><p>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</p><h3 id="什么是垃圾？"><a href="#什么是垃圾？" class="headerlink" title="什么是垃圾？"></a>什么是垃圾？</h3><p>垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。</p><p>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序的结束，被保留的空间无法被其它对象使用，甚至可能导致内存溢出。</p><h3 id="磁盘碎片整理"><a href="#磁盘碎片整理" class="headerlink" title="磁盘碎片整理"></a>磁盘碎片整理</h3><p>机械硬盘需要进行磁盘整理，同时还有坏道</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200712090848669.png" alt="image-20200712090848669"></p><h3 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h3><h4 id="蚂蚁金服"><a href="#蚂蚁金服" class="headerlink" title="蚂蚁金服"></a>蚂蚁金服</h4><ul><li>你知道哪几种垃圾回收器，各自的优缺点，重点讲一下cms和G1？</li><li>JVM GC算法有哪些，目前的JDK版本采用什么回收算法？</li><li>G1回收器讲下回收过程GC是什么？为什么要有GC？</li><li>GC的两种判定方法？CMS收集器与G1收集器的特点</li></ul><h4 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h4><ul><li>说一下GC算法，分代回收说下</li><li>垃圾收集策略和算法</li></ul><h4 id="天猫"><a href="#天猫" class="headerlink" title="天猫"></a>天猫</h4><ul><li>JVM GC原理，JVM怎么回收内存</li><li>CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？</li></ul><h4 id="滴滴"><a href="#滴滴" class="headerlink" title="滴滴"></a>滴滴</h4><p>Java的垃圾回收器都有哪些，说下g1的应用场景，平时你是如何搭配使用垃圾回收器的</p><h4 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h4><ul><li>你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，</li><li>包括原理，流程，优缺点。垃圾回收算法的实现原理</li></ul><h4 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h4><ul><li>讲一讲垃圾回收算法。</li><li>什么情况下触发垃圾回收？</li><li>如何选择合适的垃圾收集算法？</li><li>JVM有哪三种垃圾回收器？</li></ul><h4 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h4><ul><li>常见的垃圾回收器算法有哪些，各有什么优劣？</li><li>System.gc（）和Runtime.gc（）会做什么事情？</li><li>Java GC机制？GC Roots有哪些？</li><li>Java对象的回收方式，回收算法。</li><li>CMS和G1了解么，CMS解决什么问题，说一下回收的过程。</li><li>CMS回收停顿了几次，为什么要停顿两次?</li></ul><h2 id="为什么需要GC"><a href="#为什么需要GC" class="headerlink" title="为什么需要GC"></a>为什么需要GC</h2><p>对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</p><p>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象。</p><p>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</p><h2 id="早期垃圾回收"><a href="#早期垃圾回收" class="headerlink" title="早期垃圾回收"></a>早期垃圾回收</h2><p>在早期的C/C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">MibBridge *pBridge= <span class="hljs-keyword">new</span> cmBaseGroupBridge（）；<br><span class="hljs-comment">//如果注册失败，使用Delete释放该对象所占内存区域</span><br><span class="hljs-keyword">if</span>（pBridge-&gt;Register（kDestroy）！=NO ERROR）<br><span class="hljs-keyword">delete</span> pBridge；<br></code></pre></td></tr></table></figure><p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存的管理负担。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生内存泄漏，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。</p><p>有了垃圾回收机制后，上述代码极有可能变成这样</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">MibBridge *pBridge=<span class="hljs-keyword">new</span> cm<span class="hljs-constructor">BaseGroupBridge()</span>; <br>pBridge-&gt;<span class="hljs-constructor">Register(<span class="hljs-params">kDestroy</span>)</span>;<br></code></pre></td></tr></table></figure><p>现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了线代开发语言必备的标准。</p><h2 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险</p><p>没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</p><p>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发</p><p>oracle官网关于垃圾回收的介绍 <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html</a></p><h3 id="担忧"><a href="#担忧" class="headerlink" title="担忧"></a>担忧</h3><p>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。</p><p>此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见outofMemoryError时，快速地根据错误异常日志定位问题和解决问题。</p><p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。</p><h3 id="GC主要关注的区域"><a href="#GC主要关注的区域" class="headerlink" title="GC主要关注的区域"></a>GC主要关注的区域</h3><p>GC主要关注于 方法区 和堆中的垃圾收集</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200712092427246.png" alt="image-20200712092427246"></p><p>垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收</p><ul><li>其中，Java堆是垃圾收集器的工作重点</li></ul><p>从次数上讲：</p><ul><li>频繁收集Young区</li><li>较少收集Old区</li><li>基本不收集Perm区（元空间）</li></ul><h1 id="138-垃圾回收相关算法概述"><a href="#138-垃圾回收相关算法概述" class="headerlink" title="138-垃圾回收相关算法概述"></a>138-垃圾回收相关算法概述</h1><h2 id="标记阶段：引用计数算法"><a href="#标记阶段：引用计数算法" class="headerlink" title="标记阶段：引用计数算法"></a>标记阶段：引用计数算法</h2><p>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。</p><p>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</p><p>判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法。</strong></p><p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</p><p>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p><p>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</p><p>缺点：它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。</p><blockquote><p>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。 引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</p></blockquote><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>当p的指针断开的时候，内部的引用形成一个循环，这就是循环引用，从而造成内存泄漏</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200712102205795.png" alt="image-20200712102205795"></p><h3 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h3><p>我们使用一个案例来测试Java中是否采用的是引用计数算法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 引用计数算法测试</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RefCountGC</span> </span>&#123;<br>    <span class="hljs-comment">// 这个成员属性的唯一作用就是占用一点内存</span><br>    <span class="hljs-keyword">private</span> byte[] bigSize = <span class="hljs-keyword">new</span> byte[<span class="hljs-number">5</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];<br>    <span class="hljs-comment">// 引用</span><br>    <span class="hljs-built_in">Object</span> reference = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        RefCountGC obj1 = <span class="hljs-keyword">new</span> RefCountGC();<br>        RefCountGC obj2 = <span class="hljs-keyword">new</span> RefCountGC();<br>        obj1.reference = obj2;<br>        obj2.reference = obj1;<br>        obj1 = <span class="hljs-literal">null</span>;<br>        obj2 = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 显示的执行垃圾收集行为，判断obj1 和 obj2是否被回收？</span><br>        System.gc();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">System</span><span class="hljs-operator">.</span><span class="hljs-variable">gc</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">15490</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">808</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">76288</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">15490</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">816</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">251392</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0061980</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.36</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <br><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">System</span><span class="hljs-operator">.</span><span class="hljs-variable">gc</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">808</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">76288</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">8</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">672</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">175104</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">816</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">672</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">251392</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3479</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3479</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0045983</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <br><span class="hljs-variable">Heap</span><br> <span class="hljs-variable">PSYoungGen</span>      <span class="hljs-variable">total</span> <span class="hljs-number">76288</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">used</span> <span class="hljs-number">655</span><span class="hljs-built_in">K</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076b500000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x0000000770a00000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x00000007c0000000</span><span class="hljs-punctuation">)</span><br>  <span class="hljs-variable">eden</span> <span class="hljs-variable">space</span> <span class="hljs-number">65536</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">1</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076b500000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076b5a3ee8</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076f500000</span><span class="hljs-punctuation">)</span><br>  <span class="hljs-variable">from</span> <span class="hljs-variable">space</span> <span class="hljs-number">10752</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076f500000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076f500000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076ff80000</span><span class="hljs-punctuation">)</span><br>  <span class="hljs-variable">to</span>   <span class="hljs-variable">space</span> <span class="hljs-number">10752</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076ff80000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076ff80000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x0000000770a00000</span><span class="hljs-punctuation">)</span><br> <span class="hljs-variable">ParOldGen</span>       <span class="hljs-variable">total</span> <span class="hljs-number">175104</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">used</span> <span class="hljs-number">672</span><span class="hljs-built_in">K</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000006c1e00000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x00000006cc900000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x000000076b500000</span><span class="hljs-punctuation">)</span><br>  <span class="hljs-variable">object</span> <span class="hljs-variable">space</span> <span class="hljs-number">175104</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000006c1e00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000006c1ea8070</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000006cc900000</span><span class="hljs-punctuation">)</span><br> <span class="hljs-variable">Metaspace</span>       <span class="hljs-variable">used</span> <span class="hljs-number">3486</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">capacity</span> <span class="hljs-number">4496</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">committed</span> <span class="hljs-number">4864</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">reserved</span> <span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><br>  <span class="hljs-variable">class</span> <span class="hljs-variable">space</span>    <span class="hljs-variable">used</span> <span class="hljs-number">385</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">capacity</span> <span class="hljs-number">388</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">committed</span> <span class="hljs-number">512</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">reserved</span> <span class="hljs-number">1048576</span><span class="hljs-built_in">K</span><br></code></pre></td></tr></table></figure><p>我们能够看到，上述进行了GC收集的行为，将上述的新生代中的两个对象都进行回收了</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">PSYoungGen</span>: <span class="hljs-number">15490</span>K-&gt;<span class="hljs-number">808</span>K(<span class="hljs-number">76288</span>K)] <span class="hljs-number">15490</span>K-&gt;<span class="hljs-number">816</span>K(<span class="hljs-number">251392</span>K)<br></code></pre></td></tr></table></figure><p>如果使用引用计数算法，那么这两个对象将会无法回收。而现在两个对象被回收了，说明Java使用的不是引用计数算法来进行标记的。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200712103230349.png" alt="image-20200712103230349"></p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。</p><p>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</p><p>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。Python如何解决循环引用？</p><blockquote><p>手动解除：很好理解，就是在合适的时机，解除引用关系。 使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。</p></blockquote><h2 id="标记阶段：可达性分析算法"><a href="#标记阶段：可达性分析算法" class="headerlink" title="标记阶段：可达性分析算法"></a>标记阶段：可达性分析算法</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>可达性分析算法：也可以称为 根搜索算法、追踪性垃圾收集</p><p>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。</p><p>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作追踪性垃圾收集（Tracing Garbage Collection）</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>所谓”GCRoots”根集合就是一组必须活跃的引用。</p><p>基本思路：</p><ul><li>可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。</li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）</li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li><li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200712104149246.png" alt="image-20200712104149246"></p><p>官场上的裙带关系，可达性分析在人类关系网中</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200712104312406.png" alt="image-20200712104312406"></p><h3 id="GC-Roots可以是哪些？"><a href="#GC-Roots可以是哪些？" class="headerlink" title="GC Roots可以是哪些？"></a>GC Roots可以是哪些？</h3><ul><li>虚拟机栈中引用的对象<ul><li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li></ul></li><li>本地方法栈内JNI（通常说的本地方法）引用的对象方法区中类静态属性引用的对象<ul><li>比如：Java类的引用类型静态变量</li></ul></li><li>方法区中常量引用的对象<ul><li>比如：字符串常量池（string Table）里的引用</li></ul></li><li>所有被同步锁synchronized持有的对象</li><li>Java虚拟机内部的引用。<ul><li>基本数据类型对应的Class对象，一些常驻的异常对象（如：Nu11PointerException、outofMemoryError），系统类加载器。</li></ul></li><li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200712104622677.png" alt="image-20200712104622677"></p><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>总结一句话就是，除了堆空间外的一些结构，比如 虚拟机栈、本地方法栈、方法区、字符串常量池 等地方对堆空间进行引用的，都可以作为GC Roots进行可达性分析</p><p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（PartialGC）。</p><p>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GCRoots集合中去考虑，才能保证可达性分析的准确性。</p><h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4><p>由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。</p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</p><p>这点也是导致GC进行时必须“stop The World”的一个重要原因。</p><p>即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</p><h2 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h2><p>Java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。</p><p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。</p><p>finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p><h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><p>永远不要主动调用某个对象的finalize（）方法I应该交给垃圾回收机制调用。理由包括下面三点：</p><ul><li>在finalize（）时可能会导致对象复活。</li><li>finalize（）方法的执行时间是没有保障的，它完全由Gc线程决定，极端情况下，若不发生GC，则finalize（）方法将没有执行机会。<ul><li>因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</li></ul></li><li>一个糟糕的finalize（）会严重影响Gc的性能。</li></ul><p>从功能上来说，finalize（）方法与c++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize（）方法在本质上不同于C++中的析构函数。</p><p>由于finalize（）方法的存在，虚拟机中的对象一般处于三种可能的状态。</p><h3 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h3><p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<strong>一个无法触及的对象有可能在某一个条件下“复活”自己</strong>，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：</p><ul><li>可触及的：从根节点开始，可以到达这个对象。</li><li>可复活的：对象的所有引用都被释放，但是对象有可能在finalize（）中复活。</li><li>不可触及的：对象的finalize（）被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为<strong>finalize()只会被调用一次</strong>。</li></ul><p>以上3种状态中，是由于finalize（）方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><p>判定一个对象objA是否可回收，至少要经历两次标记过程：</p><ul><li>如果对象objA到GC Roots没有引用链，则进行第一次标记。</li><li>进行筛选，判断此对象是否有必要执行finalize（）方法<ul><li>如果对象objA没有重写finalize（）方法，或者finalize（）方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</li><li>如果对象objA重写了finalize（）方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize（）方法执行。</li><li>finalize（）方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize（）方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200712110411885.png" alt="image-20200712110411885"></p><p>上图就是我们看到的Finalizer线程</p><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><p>我们使用重写 finalize()方法，然后在方法的内部，重写将其存放到GC Roots中</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试Object类中finalize()方法</span><br><span class="hljs-comment"> * 对象复活场景</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> CanReliveObj &#123;<br>    <span class="hljs-comment">// 类变量，属于GC Roots的一部分</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CanReliveObj canReliveObj;<br><br>    @Override<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> finalize() <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-keyword">super</span>.finalize();<br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;调用当前类重写的finalize()方法&quot;</span>);<br>        canReliveObj = <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        canReliveObj = <span class="hljs-keyword">new</span> CanReliveObj();<br>        canReliveObj = <span class="hljs-keyword">null</span>;<br>        System.gc();<br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;-----------------第一次gc操作------------&quot;</span>);<br>        <span class="hljs-comment">// 因为Finalizer线程的优先级比较低，暂停2秒，以等待它</span><br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>        <span class="hljs-keyword">if</span> (canReliveObj == <span class="hljs-keyword">null</span>) &#123;<br>            System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;obj is dead&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;obj is still alive&quot;</span>);<br>        &#125;<br><br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;-----------------第二次gc操作------------&quot;</span>);<br>        canReliveObj = <span class="hljs-keyword">null</span>;<br>        System.gc();<br>        <span class="hljs-comment">// 下面代码和上面代码是一样的，但是 canReliveObj却自救失败了</span><br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>        <span class="hljs-keyword">if</span> (canReliveObj == <span class="hljs-keyword">null</span>) &#123;<br>            System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;obj is dead&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;obj is still alive&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后运行结果</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment">-----------------第一次gc操作------------</span><br>调用当前类重写的finalize()方法<br>obj <span class="hljs-keyword">is</span> still alive<br><span class="hljs-comment">-----------------第二次gc操作------------</span><br>obj <span class="hljs-keyword">is</span> dead<br></code></pre></td></tr></table></figure><p>在进行第一次清除的时候，我们会执行finalize方法，然后 对象 进行了一次自救操作，但是因为finalize()方法只会被调用一次，因此第二次该对象将会被垃圾清除。</p><h2 id="MAT与JProfiler的GC-Roots溯源"><a href="#MAT与JProfiler的GC-Roots溯源" class="headerlink" title="MAT与JProfiler的GC Roots溯源"></a>MAT与JProfiler的GC Roots溯源</h2><h3 id="MAT是什么？"><a href="#MAT是什么？" class="headerlink" title="MAT是什么？"></a>MAT是什么？</h3><p>MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</p><p>MAT是基于Eclipse开发的，是一款免费的性能分析工具。</p><p>大家可以在<a href="http://www.eclipse.org/mat/%E4%B8%8B%E8%BD%BD%E5%B9%B6%E4%BD%BF%E7%94%A8MAT">http://www.eclipse.org/mat/下载并使用MAT</a></p><h3 id="命令行使用-jmap"><a href="#命令行使用-jmap" class="headerlink" title="命令行使用 jmap"></a>命令行使用 jmap</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200712112026317.png" alt="image-20200712112026317"></p><h3 id="使用JVIsualVM"><a href="#使用JVIsualVM" class="headerlink" title="使用JVIsualVM"></a>使用JVIsualVM</h3><p>捕获的heap dump文件是一个临时文件，关闭JVisualVM后自动删除，若要保留，需要将其另存为文件。可通过以下方法捕获heap dump：</p><p>在左侧“Application”（应用程序）子窗口中右击相应的应用程序，选择Heap Dump（堆Dump）。</p><p>在Monitor（监视）子标签页中点击Heap Dump（堆Dump）按钮。本地应用程序的Heap dumps作为应用程序标签页的一个子标签页打开。同时，heap dump在左侧的Application（应用程序）栏中对应一个含有时间戳的节点。</p><p>右击这个节点选择save as（另存为）即可将heap dump保存到本地。</p><h3 id="使用MAT打开Dump文件"><a href="#使用MAT打开Dump文件" class="headerlink" title="使用MAT打开Dump文件"></a>使用MAT打开Dump文件</h3><p>打开后，我们就可以看到有哪些可以作为GC Roots的对象</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200712112512720.png" alt="image-20200712112512720"></p><p>里面我们能够看到有一些常用的Java类，然后Thread线程。</p><h3 id="JProfiler的GC-Roots溯源"><a href="#JProfiler的GC-Roots溯源" class="headerlink" title="JProfiler的GC Roots溯源"></a>JProfiler的GC Roots溯源</h3><p>我们在实际的开发中，一般不会查找全部的GC Roots，可能只是查找某个对象的整个链路，或者称为GC Roots溯源，这个时候，我们就可以使用JProfiler</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200712113256075.png" alt="image-20200712113256075"></p><h3 id="如何判断什么原因造成OOM"><a href="#如何判断什么原因造成OOM" class="headerlink" title="如何判断什么原因造成OOM"></a>如何判断什么原因造成OOM</h3><p>当我们程序出现OOM的时候，我们就需要进行排查，我们首先使用下面的例子进行说明</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内存溢出排查</span><br><span class="hljs-comment"> * -Xms8m -Xmx8m -XX:HeapDumpOnOutOfMemoryError</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapOOM</span> &#123;</span><br>    <span class="hljs-comment">// 创建1M的文件</span><br>    <span class="hljs-keyword">byte</span> [] <span class="hljs-built_in">buffer</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        ArrayList&lt;HeapOOM&gt; <span class="hljs-built_in">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-built_in">list</span>.add(<span class="hljs-keyword">new</span> HeapOOM());<br>                count++;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.getStackTrace();<br>            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;count:&quot;</span> + count);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码就是不断的创建一个1M小字节数组，然后让内存溢出，我们需要限制一下内存大小，同时使用HeapDumpOnOutOfMemoryError将出错时候的dump文件输出</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">-Xms8m</span> <span class="hljs-selector-tag">-Xmx8m</span> <span class="hljs-selector-tag">-XX</span><span class="hljs-selector-pseudo">:HeapDumpOnOutOfMemoryError</span><br></code></pre></td></tr></table></figure><p>我们将生成的dump文件打开，然后点击Biggest Objects就能够看到超大对象</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200712150229048.png" alt="image-20200712150229048"></p><p>然后我们通过线程，还能够定位到哪里出现OOM</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200712150303710.png" alt="image-20200712150303710"></p><h2 id="清除阶段：标记-清除算法"><a href="#清除阶段：标记-清除算法" class="headerlink" title="清除阶段：标记-清除算法"></a>清除阶段：标记-清除算法</h2><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是</p><ul><li>标记一清除算法（Mark-Sweep）</li><li>复制算法（copying）</li><li>标记-压缩算法（Mark-Compact）</li></ul><p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。</p><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除</p><ul><li><p>标记</p><p>：Collector从引用根节点开始遍历，</p><p>标记所有被引用的对象</p><p>。一般是在对象的Header中记录为可达对象。</p><ul><li><strong>标记的是引用的对象，不是垃圾！！</strong></li></ul></li><li><p><strong>清除</strong>：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200712150935078.png" alt="image-20200712150935078"></p><h3 id="什么是清除？"><a href="#什么是清除？" class="headerlink" title="什么是清除？"></a>什么是清除？</h3><p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。</p><p>关于空闲列表是在为对象分配内存的时候 提过</p><ul><li>如果内存规整<ul><li>采用指针碰撞的方式进行内存分配</li></ul></li><li>如果内存不规整<ul><li>虚拟机需要维护一个列表</li><li>空闲列表分配</li></ul></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>标记清除算法的效率不算高</li><li>在进行GC的时候，需要停止整个应用程序，用户体验较差</li><li>这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表</li></ul><h2 id="清除阶段：复制算法"><a href="#清除阶段：复制算法" class="headerlink" title="清除阶段：复制算法"></a>清除阶段：复制算法</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky在该论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。</p><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200712151916991.png" alt="image-20200712151916991"></p><p>把可达的对象，直接复制到另外一个区域中复制完成后，A区就没有用了，里面的对象可以直接清除掉，其实里面的新生代里面就用到了复制算法</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200712152029615.png" alt="image-20200712152029615"></p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul><li>没有标记和清除过程，实现简单，运行高效</li><li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li><li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小</li></ul><h3 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h3><p>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，或者说非常低才行（老年代大量的对象存活，那么复制的对象将会有很多，效率会很低）</p><p>在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200712152847218.png" alt="image-20200712152847218"></p><h2 id="清除阶段：标记-整理算法"><a href="#清除阶段：标记-整理算法" class="headerlink" title="清除阶段：标记-整理算法"></a>清除阶段：标记-整理算法</h2><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</p><p>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JvM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。</p><p>1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</p><h3 id="执行过程-1"><a href="#执行过程-1" class="headerlink" title="执行过程"></a>执行过程</h3><p>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</p><p>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200712153236508.png" alt="image-20200712153236508"></p><h3 id="标清和标整的区别"><a href="#标清和标整的区别" class="headerlink" title="标清和标整的区别"></a>标清和标整的区别</h3><p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。</p><p>二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p><h3 id="标整的优缺点"><a href="#标整的优缺点" class="headerlink" title="标整的优缺点"></a>标整的优缺点</h3><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ul><li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li><li>消除了复制算法当中，内存减半的高额代价。</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>从效率上来说，标记-整理算法要低于复制算法。</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li><li>移动过程中，需要全程暂停用户应用程序。即：STW</li></ul><h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p><p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</p><table><thead><tr><th></th><th>标记清除</th><th>标记整理</th><th>复制</th></tr></thead><tbody><tr><td><strong>速率</strong></td><td>中等</td><td>最慢</td><td>最快</td></tr><tr><td><strong>空间开销</strong></td><td>少（但会堆积碎片）</td><td>少（不堆积碎片）</td><td>通常需要活对象的2倍空间（不堆积碎片）</td></tr><tr><td><strong>移动对象</strong></td><td>否</td><td>是</td><td>是</td></tr></tbody></table><p>综合我们可以找到，没有最好的算法，只有最合适的算法</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p><p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p><p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：string对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p><p>目前几乎所有的GC都采用分代手机算法执行垃圾回收的</p><p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p><ul><li>年轻代（Young Gen）</li></ul><p>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p><p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p><ul><li>老年代（Tenured Gen）</li></ul><p>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p><p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p><ul><li>Mark阶段的开销与存活对象的数量成正比。</li><li>Sweep阶段的开销与所管理区域的大小成正相关。</li><li>compact阶段的开销与存活对象的数据成正比。</li></ul><p>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用serial old执行FullGC以达到对老年代内存的整理。</p><p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</p><h2 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种stop the World的状态。在stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p><p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p><p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。<strong>增量收集算法通过对线程间冲突的妥善处理</strong>，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</p><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p><h2 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h2><p>一般来说，在相同条件下，堆空间越大，一次Gc时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p><p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。 每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200712165318590.png" alt="image-20200712165318590"></p><h2 id="写到最后-1"><a href="#写到最后-1" class="headerlink" title="写到最后"></a>写到最后</h2><p>注意，这些只是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。</p><h1 id="154-垃圾回收相关概念的概述"><a href="#154-垃圾回收相关概念的概述" class="headerlink" title="154-垃圾回收相关概念的概述"></a>154-垃圾回收相关概念的概述</h1><h2 id="System-gc-的理解"><a href="#System-gc-的理解" class="headerlink" title="System.gc()的理解"></a>System.gc()的理解</h2><p>在默认情况下，通过system.gc（）者Runtime.getRuntime().gc() 的调用，会显式触发FullGC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p><p>然而system.gc() )调用附带一个免责声明，无法保证对垃圾收集器的调用。(不能确保立即生效)</p><p>JVM实现者可以通过system.gc() 调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()</p><p>代码演示是否出发GC操作</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * System.gc()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SystemGCTest</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> SystemGCTest();<br>        <span class="hljs-comment">// 提醒JVM进行垃圾回收</span><br>        System.gc();<br>        <span class="hljs-comment">//System.runFinalization();</span><br>    &#125;<br><br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> throws Throwable </span>&#123;<br>        super.finalize();<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;SystemGCTest 执行了 finalize方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果，但是不一定会触发销毁的方法，调用System.runFinalization()会强制调用 失去引用对象的finalize()</p><figure class="highlight mercury"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mercury">SystemGCTest 执行了 <span class="hljs-keyword">finalize</span>方法<br></code></pre></td></tr></table></figure><h3 id="手动GC来理解不可达对象的回收"><a href="#手动GC来理解不可达对象的回收" class="headerlink" title="手动GC来理解不可达对象的回收"></a>手动GC来理解不可达对象的回收</h3><p>代码如下所示：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 局部变量回收</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalVarGC</span> &#123;</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 触发Minor GC没有回收对象，然后在触发Full GC将该对象存入old区</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">localvarGC1</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">byte</span>[] <span class="hljs-built_in">buffer</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];<br>        System.gc();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 触发YoungGC的时候，已经被回收了</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">localvarGC2</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">byte</span>[] <span class="hljs-built_in">buffer</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];<br>        <span class="hljs-built_in">buffer</span> = null;<br>        System.gc();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 不会被回收，因为它还存放在局部变量表索引为1的槽中</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">localvarGC3</span><span class="hljs-params">()</span> </span>&#123;<br>        &#123;<br>            <span class="hljs-keyword">byte</span>[] <span class="hljs-built_in">buffer</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];<br>        &#125;<br>        System.gc();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 会被回收，因为它还存放在局部变量表索引为1的槽中，但是后面定义的value把这个槽给替换了</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">localvarGC4</span><span class="hljs-params">()</span> </span>&#123;<br>        &#123;<br>            <span class="hljs-keyword">byte</span>[] <span class="hljs-built_in">buffer</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];<br>        &#125;<br>        <span class="hljs-keyword">int</span> value = <span class="hljs-number">10</span>;<br>        System.gc();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * localvarGC5中的数组已经被回收</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">localvarGC5</span><span class="hljs-params">()</span> </span>&#123;<br>        localvarGC1();<br>        System.gc();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        LocalVarGC localVarGC = <span class="hljs-keyword">new</span> LocalVarGC();<br>        localVarGC.localvarGC3();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><p>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</p><p>由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现ooM的情况。</p><p>大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Fu11GC操作，这时候会回收大量的内存，供应用程序继续使用。</p><p>javadoc中对outofMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。</p><p>首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。原因有二：</p><ul><li>Java虚拟机的堆内存设置不够。</li></ul><p>比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms 、-Xmx来调整。</p><ul><li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</li></ul><p>对于老版本的oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError:PermGen space”。</p><p>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的ooM有所改观，出现ooM，异常信息则变成了：“java.lang.OutofMemoryError:Metaspace”。直接内存不足，也会导致OOM。</p><p>这里面隐含着一层意思是，在抛出OutofMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p><blockquote><p>例如：在引用机制分析中，涉及到JVM会去尝试回收软引用指向的对象等。 在java.nio.BIts.reserveMemory（）方法中，我们能清楚的看到，System.gc（）会被调用，以清理空间。</p></blockquote><p>当然，也不是在任何情况下垃圾收集器都会被触发的</p><p>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutofMemoryError。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>也称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。</p><p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致00M，也可以叫做宽泛意义上的“内存泄漏”。</p><p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现outofMemory异常，导致程序崩溃。</p><p>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</p><blockquote><p>买房子：80平的房子，但是有10平是公摊的面积，我们是无法使用这10平的空间，这就是所谓的内存泄漏</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200712195158470.png" alt="image-20200712195158470"></p><p>Java使用可达性分析算法，最上面的数据不可达，就是需要被回收的。后期有一些对象不用了，按道理应该断开引用，但是存在一些链没有断开，从而导致没有办法被回收。</p><h3 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h3><ul><li>单例模式</li></ul><p>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p><ul><li>一些提供close的资源未关闭导致内存泄漏</li></ul><p>数据库连接（dataSourse.getConnection() ），网络连接（socket）和io连接必须手动close，否则是不能被回收的。</p><h2 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h2><p>stop-the-world，简称STw，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。</p><p>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿。</p><ul><li>分析工作必须在一个能确保一致性的快照中进行</li><li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li><li>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</li></ul><p>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STw的发生。</p><p>STW事件和采用哪款GC无关所有的GC都有这个事件。</p><p>哪怕是G1也不能完全避免Stop-the-world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p><p>STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p><p>开发中不要用system.gc() 会导致stop-the-world的发生。</p><h2 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。</p><p>并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200712202522051.png" alt="image-20200712202522051"></p><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，我们称之为并行（Paralle1）。</p><p>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。</p><p>适合科学计算，后台处理等弱交互场景</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200712202822129.png" alt="image-20200712202822129"></p><h3 id="并发和并行对比"><a href="#并发和并行对比" class="headerlink" title="并发和并行对比"></a>并发和并行对比</h3><p><strong>并发</strong>，指的是多个事情，在同一时间段内同时发生了。</p><p><strong>并行</strong>，指的是多个事情，在同一时间点上同时发生了。</p><p>并发的多个任务之间是互相抢占资源的。并行的多个任务之间是不互相抢占资源的。</p><p>只有在多CPU或者一个CPU多核的情况中，才会发生并行。</p><p>否则，看似同时发生的事情，其实都是并发执行的。</p><h3 id="垃圾回收的并行与并发-1"><a href="#垃圾回收的并行与并发-1" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h3><p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p><ul><li>并行（Paralle1）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。如ParNew、Parallel Scavenge、Parallel old；</li><li>串行（Serial）<ul><li>相较于并行的概念，单线程执行。</li><li>如果内存不够，则程序暂停，启动JM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200712203607845.png" alt="image-20200712203607845"></p><p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p><p>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。&gt;用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；</p><blockquote><p>如：CMS、G1</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200712203815517.png" alt="image-20200712203815517"></p><h2 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h2><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint）”。</p><p>Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。</p><p>如何在cc发生时，检查所有线程都跑到最近的安全点停顿下来呢？</p><ul><li><strong>抢先式中断</strong>：（目前没有虚拟机采用了）首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li><li><strong>主动式中断</strong>：设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。（有轮询的机制）</li></ul><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？例如线程处于sleep-状态或Blocked 状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</p><p>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始Gc都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。</p><p><strong>执行流程：</strong></p><ul><li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Relgion，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程</li><li>当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止；</li></ul><h2 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h2><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p><p>【既偏门又非常高频的面试题】强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？ 在JDK1.2版之后，Java对引用的概念进行了扩充，将引用分为：</p><ul><li>强引用（Strong Reference）</li><li>软引用（Soft Reference）</li><li>弱引用（Weak Reference）</li><li>虚引用（Phantom Reference）</li></ul><p>这4种引用强度依次逐渐减弱。除强引用外，其他3种引用均可以在java.1ang.ref包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</p><p>.<img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200712205813321.png" alt="image-20200712205813321"></p><p>Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用</p><ul><li>强引用（StrongReference）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“object obj=new Object（）”这种引用关系。无论任何情况下，==只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象==。</li><li>软引用（SoftReference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存流出异常。</li><li>弱引用（WeakReference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li><li>虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。==为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知==。</li></ul><h2 id="再谈引用：强引用"><a href="#再谈引用：强引用" class="headerlink" title="再谈引用：强引用"></a>再谈引用：强引用</h2><p>在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，也是默认的引用类型。</p><p>当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p><p>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</p><p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为nu11，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p><p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成Java内存泄漏的主要原因之一。</p><h3 id="举例-4"><a href="#举例-4" class="headerlink" title="举例"></a>举例</h3><p>强引用的案例说明</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">StringBuffer</span> str = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuffer</span>(<span class="hljs-string">&quot;hello mogublog&quot;</span>);<br></code></pre></td></tr></table></figure><p>局部变量str指向stringBuffer实例所在堆空间，通过str可以操作该实例，那么str就是stringBuffer实例的强引用对应内存结构：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200712211501377.png" alt="image-20200712211501377"></p><p>如果此时，在运行一个赋值语句</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">StringBuffer</span> str = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuffer</span>(<span class="hljs-string">&quot;hello mogublog&quot;</span>);<br><span class="hljs-built_in">StringBuffer</span> str1 = str;<br></code></pre></td></tr></table></figure><p>对应的内存结构为:</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200712211732976.png" alt="image-20200712211732976"></p><p>那么我们将 str = null; 则 原来堆中的对象也不会被回收，因为还有其它对象指向该区域</p><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>本例中的两个引用，都是强引用，强引用具备以下特点：</p><ul><li>强引用可以直接访问目标对象。</li><li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象。</li><li>强引用可能导致内存泄漏。</li></ul><h2 id="再谈引用：-软引用"><a href="#再谈引用：-软引用" class="headerlink" title="再谈引用： 软引用"></a>再谈引用： 软引用</h2><p>软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p><blockquote><p>注意，这里的第一次回收是不可达的对象</p></blockquote><p>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p><p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</p><p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p><blockquote><p>一句话概括：当内存足够时，不会回收软引用可达的对象。内存不够时，会回收软引用的可达对象</p></blockquote><p>在JDK1.2版之后提供了SoftReference类来实现软引用</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-comment">// 声明强引用</span><br><span class="hljs-built_in">Object</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><span class="hljs-comment">// 创建一个软引用</span><br>SoftReference&lt;<span class="hljs-built_in">Object</span>&gt; sf = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(obj);<br>obj = <span class="hljs-literal">null</span>; <span class="hljs-comment">//销毁强引用，这是必须的，不然会存在强引用和软引用</span><br></code></pre></td></tr></table></figure><h2 id="再谈引用：弱引用"><a href="#再谈引用：弱引用" class="headerlink" title="再谈引用：弱引用"></a>再谈引用：弱引用</h2><blockquote><p>发现即回收</p></blockquote><p>弱引用也是用来描述那些非必需对象，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p><p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</p><p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p><p>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p><p>在JDK1.2版之后提供了WeakReference类来实现弱引用</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 声明强引用</span><br><span class="hljs-keyword">Object</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Object</span>();<br><span class="hljs-comment">// 创建一个弱引用</span><br><span class="hljs-built_in">WeakReference</span>&lt;<span class="hljs-keyword">Object</span>&gt; sf = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakReference</span>&lt;&gt;(obj);<br>obj = <span class="hljs-literal">null</span>; <span class="hljs-comment">//销毁强引用，这是必须的，不然会存在强引用和弱引用</span><br></code></pre></td></tr></table></figure><p>弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易、更快被GC回收。</p><p>面试题：你开发中使用过WeakHashMap吗？</p><p>WeakHashMap用来存储图片信息，可以在内存不足的时候，及时回收，避免了OOM</p><h2 id="再谈引用：虚引用"><a href="#再谈引用：虚引用" class="headerlink" title="再谈引用：虚引用"></a>再谈引用：虚引用</h2><p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个</p><p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p><p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get（）方法取得对象时，总是null</p><p>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</p><p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</p><p>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</p><blockquote><p>虚引用无法获取到我们的数据</p></blockquote><p>在JDK1.2版之后提供了PhantomReference类来实现虚引用。</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-comment">// 声明强引用</span><br><span class="hljs-built_in">Object</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><span class="hljs-comment">// 声明引用队列</span><br>ReferenceQueue phantomQueue = <span class="hljs-keyword">new</span> ReferenceQueue();<br><span class="hljs-comment">// 声明虚引用（还需要传入引用队列）</span><br>PhantomReference&lt;<span class="hljs-built_in">Object</span>&gt; sf = <span class="hljs-keyword">new</span> PhantomReference&lt;&gt;(obj, phantomQueue);<br>obj = <span class="hljs-literal">null</span>; <br></code></pre></td></tr></table></figure><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><p>我们使用一个案例，来结合虚引用，引用队列，finalize进行讲解</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhantomReferenceTest</span> &#123;</span><br>    <span class="hljs-regexp">// 当前类对象的声明</span><br><span class="hljs-regexp">    public static PhantomReferenceTest obj;</span><br><span class="hljs-regexp">    //</span> 引用队列<br>    <span class="hljs-keyword">static</span> ReferenceQueue&lt;PhantomReferenceTest&gt; phantomQueue = <span class="hljs-literal">null</span>;<br><br>    @Override<br>    protected <span class="hljs-literal">void</span> finalize() throws Throwable &#123;<br>        <span class="hljs-built_in">super</span>.finalize();<br>        System.out.println(<span class="hljs-string">&quot;调用当前类的finalize方法&quot;</span>);<br>        obj = <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>        Thread thread = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;</span></span><br><span class="hljs-function"><span class="hljs-params">                <span class="hljs-keyword">if</span> (phantomQueue != <span class="hljs-literal">null</span>) &#123;</span></span><br><span class="hljs-function"><span class="hljs-params">                    PhantomReference&lt;PhantomReferenceTest&gt; objt = <span class="hljs-literal">null</span>;</span></span><br><span class="hljs-function"><span class="hljs-params">                    <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-function"><span class="hljs-params">                        objt = (PhantomReference&lt;PhantomReferenceTest&gt;) phantomQueue.remove();</span></span><br><span class="hljs-function"><span class="hljs-params">                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span></span><br><span class="hljs-function"><span class="hljs-params">                        e.getStackTrace();</span></span><br><span class="hljs-function"><span class="hljs-params">                    &#125;</span></span><br><span class="hljs-function"><span class="hljs-params">                    <span class="hljs-keyword">if</span> (objt != <span class="hljs-literal">null</span>) &#123;</span></span><br><span class="hljs-function"><span class="hljs-params">                        System.out.println(<span class="hljs-string">&quot;追踪垃圾回收过程：PhantomReferenceTest实例被GC了&quot;</span>);</span></span><br><span class="hljs-function"><span class="hljs-params">                    &#125;</span></span><br><span class="hljs-function"><span class="hljs-params">                &#125;</span></span><br><span class="hljs-function"><span class="hljs-params">            &#125;</span></span><br><span class="hljs-function"><span class="hljs-params">        &#125;, <span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function">        <span class="hljs-title">thread</span>.<span class="hljs-title">setDaemon</span><span class="hljs-params">(<span class="hljs-literal">true</span>)</span>;</span><br><span class="hljs-function">        <span class="hljs-title">thread</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">phantomQueue</span> = <span class="hljs-title">new</span> <span class="hljs-title">ReferenceQueue</span>&lt;&gt;<span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">obj</span> = <span class="hljs-title">new</span> <span class="hljs-title">PhantomReferenceTest</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        // 构造了<span class="hljs-title">PhantomReferenceTest</span>对象的虚引用，并指定了引用队列</span><br><span class="hljs-function">        <span class="hljs-title">PhantomReference</span>&lt;<span class="hljs-title">PhantomReferenceTest</span>&gt; <span class="hljs-title">phantomReference</span> = <span class="hljs-title">new</span> <span class="hljs-title">PhantomReference</span>&lt;&gt;<span class="hljs-params">(obj, phantomQueue)</span>;</span><br><span class="hljs-function">        <span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(phantomReference.get())</span>;</span><br><span class="hljs-function">            // 去除强引用</span><br><span class="hljs-function">            <span class="hljs-title">obj</span> = <span class="hljs-title">null</span>;</span><br><span class="hljs-function">            // 第一次进行<span class="hljs-title">GC</span>，由于对象可复活，<span class="hljs-title">GC</span>无法回收该对象</span><br><span class="hljs-function">            <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;第一次GC操作&quot;</span>)</span>;</span><br><span class="hljs-function">            <span class="hljs-title">System</span>.<span class="hljs-title">gc</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            <span class="hljs-title">Thread</span>.<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">1000</span>)</span>;</span><br><span class="hljs-function">            <span class="hljs-title">if</span> <span class="hljs-params">(obj == <span class="hljs-literal">null</span>)</span> &#123;</span><br><span class="hljs-function">                <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;obj 是 null&quot;</span>)</span>;</span><br><span class="hljs-function">            &#125; <span class="hljs-title">else</span> &#123;</span><br><span class="hljs-function">                <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;obj 不是 null&quot;</span>)</span>;</span><br><span class="hljs-function">            &#125;</span><br><span class="hljs-function">            <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;第二次GC操作&quot;</span>)</span>;</span><br><span class="hljs-function">            <span class="hljs-title">obj</span> = <span class="hljs-title">null</span>;</span><br><span class="hljs-function">            <span class="hljs-title">System</span>.<span class="hljs-title">gc</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            <span class="hljs-title">Thread</span>.<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">1000</span>)</span>;</span><br><span class="hljs-function">            <span class="hljs-title">if</span> <span class="hljs-params">(obj == <span class="hljs-literal">null</span>)</span> &#123;</span><br><span class="hljs-function">                <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;obj 是 null&quot;</span>)</span>;</span><br><span class="hljs-function">            &#125; <span class="hljs-title">else</span> &#123;</span><br><span class="hljs-function">                <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;obj 不是 null&quot;</span>)</span>;</span><br><span class="hljs-function">            &#125;</span><br><span class="hljs-function">        &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(Exception e)</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        &#125; <span class="hljs-title">finally</span> &#123;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>最后运行结果</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-literal">null</span><br><span class="hljs-string">第一次GC操作</span><br><span class="hljs-string">调用当前类的finalize方法</span><br><span class="hljs-string">obj</span> <span class="hljs-string">不是</span> <span class="hljs-literal">null</span><br><span class="hljs-string">第二次GC操作</span><br><span class="hljs-string">追踪垃圾回收过程：PhantomReferenceTest实例被GC了</span><br><span class="hljs-string">obj</span> <span class="hljs-string">是</span> <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>从上述运行结果我们知道，第一次尝试获取虚引用的值，发现无法获取的，这是因为虚引用是无法直接获取对象的值，然后进行第一次gc，因为会调用finalize方法，将对象复活了，所以对象没有被回收，但是调用第二次gc操作的时候，因为finalize方法只能执行一次，所以就触发了GC操作，将对象回收了，同时将会触发第二个操作就是 将回收的值存入到引用队列中。</p><h2 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h2><p>它用于实现对象的finalize() 方法，也可以称为终结器引用</p><p>无需手动编码，其内部配合引用队列使用</p><p>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象调用它的finalize()方法，第二次GC时才回收被引用的对象</p><h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="GC分类与性能指标"><a href="#GC分类与性能指标" class="headerlink" title="GC分类与性能指标"></a>GC分类与性能指标</h2><p>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。</p><p>由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。</p><p>从不同角度分析垃圾收集器，可以将GC分为不同的类型。</p><blockquote><p>Java不同版本新特性</p><ul><li>语法层面：Lambda表达式、switch、自动拆箱装箱、enum</li><li>API层面：Stream API、新的日期时间、Optional、String、集合框架</li><li>底层优化：JVM优化、GC的变化、元空间、静态域、字符串常量池位置变化</li></ul></blockquote><h3 id="垃圾收集器分类"><a href="#垃圾收集器分类" class="headerlink" title="垃圾收集器分类"></a>垃圾收集器分类</h3><h4 id="按线程数分"><a href="#按线程数分" class="headerlink" title="按线程数分"></a><strong>按线程数分</strong></h4><p><strong>按线程数分</strong>（垃圾回收线程数），可以分为串行垃圾回收器和并行垃圾回收器。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200713083030867.png" alt="image-20200713083030867"></p><p>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。</p><ul><li>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的Client模式下的JVM中</li><li>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。</li></ul><p>和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“stop-the-world”机制。</p><h4 id="按工作模式分"><a href="#按工作模式分" class="headerlink" title="按工作模式分"></a>按工作模式分</h4><p>按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。</p><ul><li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li><li>独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200713083443486.png" alt="image-20200713083443486"></p><h4 id="按碎片处理方式分"><a href="#按碎片处理方式分" class="headerlink" title="按碎片处理方式分"></a>按碎片处理方式分</h4><p>按碎片处理方式分，可分为压缩武垃圾回收器和非压缩式垃圾回收器。</p><ul><li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</li><li>非压缩式的垃圾回收器不进行这步操作。</li></ul><p>按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器。</p><h3 id="评估GC的性能指标"><a href="#评估GC的性能指标" class="headerlink" title="评估GC的性能指标"></a>评估GC的性能指标</h3><ul><li><strong>吞吐量</strong>：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）</li><li><strong>垃圾收集开销</strong>：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li><li><strong>暂停时间</strong>：执行垃圾收集时，程序的工作线程被暂停的时间。</li><li><strong>收集频率</strong>：相对于应用程序的执行，收集操作发生的频率。</li><li><strong>内存占用</strong>：Java堆区所占的内存大小。</li><li><strong>快速</strong>：一个对象从诞生到被回收所经历的时间。</li></ul><p>吞吐量、暂停时间、内存占用 这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。 这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。 简单来说，主要抓住两点：</p><p>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。 简单来说，主要抓住两点：</p><ul><li>吞吐量</li><li>暂停时间</li></ul><h3 id="性能指标：吞吐量"><a href="#性能指标：吞吐量" class="headerlink" title="性能指标：吞吐量"></a>性能指标：吞吐量</h3><p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间 /（运行用户代码时间+垃圾收集时间）</p><blockquote><p>比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p></blockquote><p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</p><p>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2+0.2=e.4</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200713084726176.png" alt="image-20200713084726176"></p><h3 id="性能指标：暂停时间"><a href="#性能指标：暂停时间" class="headerlink" title="性能指标：暂停时间"></a>性能指标：暂停时间</h3><p>“暂停时间”是指一个时间段内应用程序线程暂停，让Gc线程执行的状态</p><p>例如，GC期间1ee毫秒的暂停时间意味着在这1e0毫秒期间内没有应用程序线程是活动的。暂停时间优先，意味着尽可能让单次STW的时间最短：0.1+0.1 + 0.1+ 0.1+ 0.1=0.5</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200713085306400.png" alt="image-20200713085306400"></p><h3 id="吞吐量vs暂停时间"><a href="#吞吐量vs暂停时间" class="headerlink" title="吞吐量vs暂停时间"></a>吞吐量vs暂停时间</h3><p>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p><p>低暂停时间（低延迟）较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有低的较大暂停时间是非常重要的，特别是对于一个交互式应用程序。</p><p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。</p><p>因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收。</p><p>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</p><p>在设计（或使用）GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</p><p>现在标准：<strong>在最大吞吐量优先的情况下，降低停顿时间</strong></p><h2 id="不同的垃圾回收器概述"><a href="#不同的垃圾回收器概述" class="headerlink" title="不同的垃圾回收器概述"></a>不同的垃圾回收器概述</h2><p>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。这当然也是面试的热点。</p><p>那么，Java常见的垃圾收集器有哪些？</p><blockquote><p>GC垃圾收集器是和JVM一脉相承的，它是和JVM进行搭配使用，在不同的使用场景对应的收集器也是有区别</p></blockquote><h3 id="垃圾回收器发展史"><a href="#垃圾回收器发展史" class="headerlink" title="垃圾回收器发展史"></a>垃圾回收器发展史</h3><p>有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection，对应的产品我们称为Garbage Collector。</p><ul><li>1999年随JDK1.3.1一起来的是串行方式的serialGc，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本</li><li>2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布·</li><li>Parallel GC在JDK6之后成为HotSpot默认GC。</li><li>2012年，在JDK1.7u4版本中，G1可用。</li><li>2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。</li><li>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li><li>2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 “No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）</li><li>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。·2019年9月，JDK13发布。增强zGC，自动返回未用堆内存给操作系统。</li><li>2020年3月，JDK14发布。删除cMs垃圾回收器。扩展zGC在macos和Windows上的应用</li></ul><h3 id="7种经典的垃圾收集器"><a href="#7种经典的垃圾收集器" class="headerlink" title="7种经典的垃圾收集器"></a>7种经典的垃圾收集器</h3><ul><li>串行回收器：Serial、Serial old</li><li>并行回收器：ParNew、Parallel Scavenge、Parallel old</li><li>并发回收器：CMS、G11</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200713093551365.png" alt="image-20200713093551365"></p><h3 id="7款经典收集器与垃圾分代之间的关系"><a href="#7款经典收集器与垃圾分代之间的关系" class="headerlink" title="7款经典收集器与垃圾分代之间的关系"></a>7款经典收集器与垃圾分代之间的关系</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200713093757644.png" alt="image-20200713093757644"></p><p>新生代收集器：Serial、ParNew、Paralle1 Scavenge；</p><p>老年代收集器：Serial old、Parallel old、CMS；</p><p>整堆收集器：G1；</p><h3 id="垃圾收集器的组合关系"><a href="#垃圾收集器的组合关系" class="headerlink" title="垃圾收集器的组合关系"></a>垃圾收集器的组合关系</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200713094745366.png" alt="image-20200713094745366"></p><ul><li>两个收集器间有连线，表明它们可以搭配使用：Serial/Serial old、Serial/CMS、ParNew/Serial old、ParNew/CMS、Parallel Scavenge/Serial 0ld、Parallel Scavenge/Parallel 01d、G1；</li><li>其中Serial o1d作为CMs出现”Concurrent Mode Failure”失败的后备预案。</li><li>（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。</li><li>（绿色虚线）JDK14中：弃用Paralle1 Scavenge和Serialold GC组合（JEP366）</li><li>（青色虚线）JDK14中：删除CMs垃圾回收器（JEP363）</li></ul><p>为什么要有很多收集器，一个不够吗？因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p><p>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以我们选择的只是对具体应用最合适的收集器。</p><h3 id="如何查看默认垃圾收集器"><a href="#如何查看默认垃圾收集器" class="headerlink" title="如何查看默认垃圾收集器"></a>如何查看默认垃圾收集器</h3><p>-XX:+PrintcommandLineFlags：查看命令行相关参数（包含使用的垃圾收集器）</p><p>使用命令行指令：jinfo -flag 相关垃圾回收器参数 进程ID</p><h2 id="Serial回收器：串行回收"><a href="#Serial回收器：串行回收" class="headerlink" title="Serial回收器：串行回收"></a>Serial回收器：串行回收</h2><p>Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。</p><p>Serial收集器作为HotSpot中client模式下的默认新生代垃圾收集器。</p><p>Serial收集器采用复制算法、串行回收和”stop-the-World”机制的方式执行内存回收。</p><p>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial old收集器。Serial old收集器同样也采用了串行回收和”stop the World”机制，只不过内存回收算法使用的是标记-压缩算法。</p><ul><li>Serial old是运行在Client模式下默认的老年代的垃圾回收器</li><li>Serial 0ld在Server模式下主要有两个用途：<ul><li>与新生代的Parallel scavenge配合使用</li><li>作为老年代CMS收集器的后备垃圾收集方案</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200713100703799.png" alt="image-20200713100703799"></p><p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）</p><p>优势：简单而高效（与其他收集器的单线程比），对于限定单个cPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p><p>运行在client模式下的虚拟机是个不错的选择。</p><p>在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。</p><p>在HotSpot虚拟机中，使用-XX：+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器。</p><p>等价于新生代用Serial GC，且老年代用Serial old GC</p><h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核cpu才可以用。现在都不是单核的了。</p><p>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java web应用程序中是不会采用串行垃圾收集器的。</p><h2 id="ParNew回收器：并行回收"><a href="#ParNew回收器：并行回收" class="headerlink" title="ParNew回收器：并行回收"></a>ParNew回收器：并行回收</h2><p>如果说serialGC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是serial收集器的多线程版本。</p><ul><li>Par是Parallel的缩写，New：只能处理的是新生代</li></ul><p>ParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、”stop-the-World”机制。</p><p>ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200713102030127.png" alt="image-20200713102030127"></p><ul><li>对于新生代，回收次数频繁，使用并行方式高效。</li><li>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</li></ul><p>由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比serial收集器更高效？</p><ul><li><p>因为除Serial外，目前只有ParNew GC能与CMS收集器配合工作</p></li></ul><p>在程序中，开发人员可以通过选项”-XX：+UseParNewGC”手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p><p>-XX:ParallelGCThreads限制线程数量，默认开启和CPU数据相同的线程数。</p><h2 id="Parallel回收器：吞吐量优先"><a href="#Parallel回收器：吞吐量优先" class="headerlink" title="Parallel回收器：吞吐量优先"></a>Parallel回收器：吞吐量优先</h2><p>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了复制算法、并行回收和”Stop the World”机制。</p><p>那么Parallel 收集器的出现是否多此一举？</p><ul><li>和ParNew收集器不同，ParallelScavenge收集器的目标则是达到一个可控制的吞吐量（Throughput），它也被称为吞吐量优先的垃圾收集器。</li><li>自适应调节策略也是Paralle1 Scavenge与ParNew一个重要区别。</li></ul><p>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p><p>Paralle1收集器在JDK1.6时提供了用于执行老年代垃圾收集的Paralle1o1d收集器，用来代替老年代的serialold收集器。</p><p>Parallel old收集器采用了标记-压缩算法，但同样也是基于并行回收和”stop-the-World”机制。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200713110359441.png" alt="image-20200713110359441"></p><p>在程序吞吐量优先的应用场景中，IParalle1收集器和Parallel old收集器的组合，在server模式下的内存回收性能很不错。在Java8中，默认是此垃圾收集器。</p><h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><p>-XX：+UseParallelGC 手动指定年轻代使用Paralle1并行收集器执行内存回收任务。</p><p>-XX：+UseParalleloldcc 手动指定老年代都是使用并行回收收集器。</p><ul><li>分别适用于新生代和老年代。默认jdk8是开启的。</li><li>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</li></ul><p>-XX:ParallelGcrhreads设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</p><p>在默认情况下，当CPU数量小于8个，ParallelGcThreads的值等于CPU数量。</p><p>当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU Count]/8]</p><p>-XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间（即STw的时间）。单位是毫秒。</p><p>为了尽可能地把停顿时间控制在MaxGCPauseMi11s以内，收集器在工作时会调整Java堆大小或者其他一些参数。 对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。该参数使用需谨慎。</p><p>-XX:GCTimeRatio垃圾收集时间占总时间的比例（=1/（N+1））。用于衡量吞吐量的大小。</p><p>取值范围（0，100）。默认值99，也就是垃圾回收时间不超过1。</p><p>与前一个-xx:MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。</p><p>-XX:+UseAdaptivesizepplicy 设置Parallel scavenge收集器具有自适应调节策略</p><p>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</p><p>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMil1s），让虚拟机自己完成调优工作。</p><h2 id="CMS回收器：低延迟"><a href="#CMS回收器：低延迟" class="headerlink" title="CMS回收器：低延迟"></a>CMS回收器：低延迟</h2><p>在JDK1.5时期，Hotspot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：cMS（Concurrent-Mark-Sweep）收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，<strong>它第一次实现了让垃圾收集线程与用户线程同时工作</strong>。</p><p>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p><p>目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p><p>CMS的垃圾收集算法采用标记-清除算法，并且也会”stop-the-world”</p><p>不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。</p><p>在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200713205154007.png" alt="image-20200713205154007"></p><p>CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。(涉及STW的阶段主要是：初始标记 和 重新标记)</p><ul><li><strong>初始标记</strong>（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“stop-the-world”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是<strong>标记出GCRoots能直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</li><li><strong>并发标记</strong>（Concurrent-Mark）阶段：从Gc Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li><li><strong>重新标记</strong>（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li><li><strong>并发清除</strong>（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li></ul><p>尽管CMS收集器采用的是并发回收（非独占式），但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-the-World”，只是尽可能地缩短暂停时间。</p><p>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</p><p>另外，由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure” 失败，这时虚拟机将启动后备预案：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p><p>CMS收集器的垃圾收集算法采用的是<strong>标记清除算法</strong>，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200713212230352.png" alt="image-20200713212230352"></p><h3 id="CMS为什么不使用标记整理算法？"><a href="#CMS为什么不使用标记整理算法？" class="headerlink" title="CMS为什么不使用标记整理算法？"></a>CMS为什么不使用标记整理算法？</h3><p>答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“stop the world” 这种场景下使用</p><h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h3><ul><li>并发收集</li><li>低延迟</li></ul><h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><ul><li>会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发FullGC。</li><li>CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li><li>CMS收集器无法处理浮动垃圾。可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</li></ul><h3 id="设置的参数"><a href="#设置的参数" class="headerlink" title="设置的参数"></a>设置的参数</h3><ul><li>-XX：+UseConcMarkSweepGC手动指定使用CMS收集器执行内存回收任务。</li></ul><p>开启该参数后会自动将-xx：+UseParNewGC打开。即：ParNew（Young区用）+CMS（01d区用）+Serial old的组合。</p><ul><li>-XX:CMSInitiatingoccupanyFraction 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</li></ul><p>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次cMs回收。JDK6及以上版本默认值为92%</p><p>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Ful1Gc的执行次数。</p><ul><li>-XX：+UseCMSCompactAtFullCollection用于指定在执行完Ful1</li></ul><p>GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</p><ul><li>-XX:CMSFullGCsBeforecompaction 设置在执行多少次Ful1GC后对内存空间进行压缩整理。</li><li>-XX:ParallelcMSThreads 设置cMs的线程数量。</li></ul><p>CMs默认启动的线程数是（Paralle1GCThreads+3）/4，ParallelGCThreads是年轻代并行收集器的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</p><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个Gc有什么不同呢？</p><p>请记住以下口令：</p><ul><li>如果你想要最小化地使用内存和并行开销，请选Serial GC；</li><li>如果你想要最大化应用程序的吞吐量，请选Parallel GC；</li><li>如果你想要最小化GC的中断或停顿时间，请选CMs GC。</li></ul><h3 id="JDK后续版本中CMS的变化"><a href="#JDK后续版本中CMS的变化" class="headerlink" title="JDK后续版本中CMS的变化"></a>JDK后续版本中CMS的变化</h3><p><strong>JDK9新特性</strong>：CMS被标记为eprecate了（JEP291）&gt;如果对JDK9及以上版本的HotSpot虚拟机使用参数-XX： +UseConcMarkSweepGC来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。</p><p>JDK14新特性：删除CMs垃圾回收器（JEP363）移除了CMS垃圾收集器，如果在JDK14中使用 XX：+UseConcMarkSweepGC的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM</p><h2 id="G1回收器：区域化分代式"><a href="#G1回收器：区域化分代式" class="headerlink" title="G1回收器：区域化分代式"></a>G1回收器：区域化分代式</h2><h3 id="既然我们已经有了前面几个强大的GC，为什么还要发布Garbage-First（G1）？"><a href="#既然我们已经有了前面几个强大的GC，为什么还要发布Garbage-First（G1）？" class="headerlink" title="既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First（G1）？"></a>既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First（G1）？</h3><p>原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1（Garbage-First）垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</p><p>与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</p><p><strong>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望</strong>。</p><h3 id="为什么名字叫-Garbage-First-G1-呢？"><a href="#为什么名字叫-Garbage-First-G1-呢？" class="headerlink" title="为什么名字叫 Garbage First(G1)呢？"></a>为什么名字叫 Garbage First(G1)呢？</h3><p>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</p><p>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p><p>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）。</p><p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</p><p>在JDK1.7版本正式启用，移除了Experimenta1的标识，是JDK9以后的默认垃圾回收器，取代了CMS回收器以及Paralle1+Parallel old组合。被orac1e官方称为“全功能的垃圾收集器”。</p><p>与此同时，CMS已经在JDK9中被标记为废弃（deprecated）。在jdk8中还不是默认的垃圾回收器，需要使用-xx：+UseG1GC来启用。</p><h3 id="G1垃圾收集器的优点"><a href="#G1垃圾收集器的优点" class="headerlink" title="G1垃圾收集器的优点"></a>G1垃圾收集器的优点</h3><p>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：</p><p><strong>并行与并发</strong></p><ul><li>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</li><li>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li></ul><p><strong>分代收集</strong></p><ul><li>从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li><li>将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。</li><li>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li></ul><p>G1所谓的分代，已经不是下面这样的了</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200713215105293.png" alt="image-20200713215105293"></p><p>而是这样的一个区域</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200713215133839.png" alt="image-20200713215133839"></p><p><strong>空间整合</strong></p><ul><li>CMS：“标记-清除”算法、内存碎片、若干次Gc后进行一次碎片整理</li><li>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li></ul><p><strong>可预测的停顿时间模型（即：软实时soft real-time）</strong> 这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p><ul><li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li><li>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</li><li>相比于CMSGC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li></ul><h3 id="G1垃圾收集器的缺点"><a href="#G1垃圾收集器的缺点" class="headerlink" title="G1垃圾收集器的缺点"></a>G1垃圾收集器的缺点</h3><p>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（overload）都要比CMS要高。</p><p>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</p><h3 id="G1参数设置"><a href="#G1参数设置" class="headerlink" title="G1参数设置"></a>G1参数设置</h3><ul><li>-XX:+UseG1GC：手动指定使用G1垃圾收集器执行内存回收任务</li><li>-XX:G1HeapRegionSize设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</li><li>-XX:MaxGCPauseMillis 设置期望达到的最大Gc停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms</li><li>-XX:+ParallelGcThread 设置STW工作线程数的值。最多设置为8</li><li>-XX:ConcGCThreads 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGcThreads）的1/4左右。</li><li>-XX:InitiatingHeapoccupancyPercent 设置触发并发Gc周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</li></ul><h3 id="G1收集器的常见操作步骤"><a href="#G1收集器的常见操作步骤" class="headerlink" title="G1收集器的常见操作步骤"></a>G1收集器的常见操作步骤</h3><p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p><ul><li>第一步：开启G1垃圾收集器</li><li>第二步：设置堆的最大内存</li><li>第三步：设置最大的停顿时间</li></ul><p>G1中提供了三种垃圾回收模式：YoungGC、Mixed GC和Fu11GC，在不同的条件下被触发。</p><h3 id="G1收集器的适用场景"><a href="#G1收集器的适用场景" class="headerlink" title="G1收集器的适用场景"></a>G1收集器的适用场景</h3><p>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</p><p>最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；</p><p>如：在堆大小约6GB或更大时，可预测的暂停时间可以低于e.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次Gc停顿时间不会过长）。 用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用61可能比CMS好：</p><ul><li>超过5e%的Java堆被活动数据占用；</li><li>对象分配频率或年代提升频率变化很大；</li><li>GC停顿时间过长（长于e.5至1秒）</li></ul><p>HotSpot垃圾收集器里，除了61以外，其他的垃圾收集器使用内置的JVM线程执行Gc的多线程操作，而G1GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p><h3 id="分区Region：化整为零"><a href="#分区Region：化整为零" class="headerlink" title="分区Region：化整为零"></a>分区Region：化整为零</h3><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过</p><p>XX:G1HeapRegionsize设定。所有的Region大小相同，且在JVM生命周期内不会被改变。</p><p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200713223244886.png" alt="image-20200713223244886"></p><p>一个region有可能属于Eden，Survivor或者old/Tenured内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，s表示属于survivor内存区域，o表示属于01d内存区域。图中空白的表示未使用的内存空间。</p><p>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1.5个region，就放到H。</p><p><strong>设置H的原因：</strong>对于堆中的对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Fu11Gc。G1的大多数行为都把H区作为老年代的一部分来看待。</p><p>每个Region都是通过指针碰撞来分配空间</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200713223509993.png" alt="image-20200713223509993"></p><h3 id="G1垃圾回收器的回收过程"><a href="#G1垃圾回收器的回收过程" class="headerlink" title="G1垃圾回收器的回收过程"></a>G1垃圾回收器的回收过程</h3><p>G1GC的垃圾回收过程主要包括如下三个环节：</p><ul><li>年轻代GC（Young GC）</li><li>老年代并发标记过程（Concurrent Marking）</li><li>混合回收（Mixed GC）</li></ul><p>（如果需要，单线程、独占式、高强度的Fu11GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200713224113996.png" alt="image-20200713224113996"></p><p>顺时针，young gc-&gt;young gc+concurrent mark-&gt;Mixed GC顺序，进行垃圾回收。</p><p>应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</p><p>当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</p><p>标记完成马上开始混合回收过程。对于一个混合回收期，G1GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。</p><p>举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p><h3 id="Remembered-Set（记忆集）"><a href="#Remembered-Set（记忆集）" class="headerlink" title="Remembered Set（记忆集）"></a>Remembered Set（记忆集）</h3><p>一个对象被不同区域引用的问题</p><p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</p><p>在其他的分代收集器，也存在这样的问题（而G1更突出）回收新生代也不得不同时扫描老年代？这样的话会降低MinorGC的效率；</p><p><strong>解决方法：</strong></p><p>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描：</p><p>每个Region都有一个对应的Remembered Set；每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；</p><p>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；如果不同，通过cardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200713224716715.png" alt="image-20200713224716715"></p><h3 id="G1回收过程-年轻代GC"><a href="#G1回收过程-年轻代GC" class="headerlink" title="G1回收过程-年轻代GC"></a>G1回收过程-年轻代GC</h3><p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</p><p>YGC时，首先G1停止应用程序的执行（stop-The-Wor1d），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200713225100632.png" alt="image-20200713225100632"></p><p>然后开始如下回收过程：</p><ul><li>第一阶段，扫描根</li></ul><p>根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</p><ul><li>第二阶段，更新RSet</li></ul><p>处理dirty card queue（见备注）中的card，更新RSet。此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用。</p><ul><li>第三阶段，处理RSet</li></ul><p>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</p><ul><li>第四阶段，复制对象。</li></ul><p>此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到o1d区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</p><ul><li>第五阶段，处理引用</li></ul><p>处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p><h3 id="G1回收过程-并发标记过程"><a href="#G1回收过程-并发标记过程" class="headerlink" title="G1回收过程-并发标记过程"></a>G1回收过程-并发标记过程</h3><ul><li>初始标记阶段：标记从根节点直接可达的对象。这个阶段是sTw的，并且会触发一次年轻代GC。</li><li>根区域扫描（Root Region Scanning）：G1 Gc扫描survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在youngGC之前完成。</li><li>并发标记（Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被youngGC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li><li>再次标记（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot-at-the-beginning（SATB）。</li><li>独占清理（cleanup，STW）：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是sTw的。这个阶段并不会实际上去做垃圾的收集</li><li>并发清理阶段：识别并清理完全空闲的区域。</li></ul><h3 id="G1回收过程-混合回收"><a href="#G1回收过程-混合回收" class="headerlink" title="G1回收过程 - 混合回收"></a>G1回收过程 - 混合回收</h3><p>当越来越多的对象晋升到老年代o1d region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个old GC，除了回收整个Young Region，还会回收一部分的old Region。这里需要注意：<strong>是一部分老年代，而不是全部老年代</strong>。可以选择哪些o1d Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200713225810871.png" alt="image-20200713225810871"></p><p>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收</p><p>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</p><p>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，</p><p>XX:G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</p><p>混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent，默认值为1e%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于1e%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</p><h3 id="G1回收可选的过程4-Full-GC"><a href="#G1回收可选的过程4-Full-GC" class="headerlink" title="G1回收可选的过程4 - Full GC"></a>G1回收可选的过程4 - Full GC</h3><p>G1的初衷就是要避免Fu11GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（stop-The-world），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p><p>要避免Fu11GC的发生，一旦发生需要进行调整。什么时候会发生Ful1GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到ful1gc，这种情况可以通过增大内存解决。 导致61Fu11GC的原因可能有两个：</p><ul><li>EVacuation的时候没有足够的to-space来存放晋升的对象；</li><li>并发处理过程完成之前空间耗尽。</li></ul><h3 id="G1回收的优化建议"><a href="#G1回收的优化建议" class="headerlink" title="G1回收的优化建议"></a>G1回收的优化建议</h3><p>从oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p><p>年轻代大小</p><ul><li>避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小</li><li>固定年轻代的大小会覆盖</li></ul><p>暂停时间目标暂停时间目标不要太过严苛</p><ul><li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li><li>评估G1GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li></ul><h2 id="垃圾回收器总结"><a href="#垃圾回收器总结" class="headerlink" title="垃圾回收器总结"></a>垃圾回收器总结</h2><p>截止JDK1.8，一共有7款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200714075738203.png" alt="image-20200714075738203"></p><p>GC发展阶段：Seria l=&gt; Parallel（并行）=&gt; CMS（并发）=&gt; G1 =&gt; ZGC</p><p>不同厂商、不同版本的虚拟机实现差距比较大。HotSpot虚拟机在JDK7/8后所有收集器及组合如下图</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200714080151020.png" alt="image-20200714080151020"></p><h3 id="怎么选择垃圾回收器"><a href="#怎么选择垃圾回收器" class="headerlink" title="怎么选择垃圾回收器"></a>怎么选择垃圾回收器</h3><p>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。怎么选择垃圾收集器？</p><ul><li>优先调整堆的大小让JVM自适应完成。</li><li>如果内存小于100M，使用串行收集器</li><li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li><li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</li><li>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器</li><li>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</li></ul><p>最后需要明确一个观点：</p><ul><li>没有最好的收集器，更没有万能的收集</li><li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li></ul><h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><p>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。 这里较通用、基础性的部分如下：</p><p>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</p><p>垃圾收集器工作的基本流程。</p><p>另外，大家需要多关注垃圾回收器这一章的各种常用的参数</p><h2 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h2><p>通过阅读Gc日志，我们可以了解Java虚拟机内存分配与回收策略。 内存分配与垃圾回收的参数列表</p><ul><li>-XX:+PrintGc输出GC日志。类似：-verbose:gc</li><li>-XX:+PrintGcDetails输出Gc的详细日志</li><li>-XX:+PrintGcTimestamps 输出Gc的时间戳（以基准时间的形式）</li><li>-XX:+PrintGCDatestamps 输出Gc的时间戳（以日期的形式，如2013-05-04T21：53：59.234+0800）</li><li>-XX:+PrintHeapAtGC在进行Gc的前后打印出堆的信息</li><li>-Xloggc:../logs/gc.1og日志文件的输出路径</li></ul><h3 id="verbose-gc"><a href="#verbose-gc" class="headerlink" title="verbose:gc"></a>verbose:gc</h3><p>打开GC日志</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-attribute">-verbose</span>:gc<br></code></pre></td></tr></table></figure><p>这个只会显示总的GC堆的变化，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200714081610474.png" alt="image-20200714081610474"></p><p>参数解析</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200714081622526.png" alt="image-20200714081622526"></p><h3 id="PrintGCDetails"><a href="#PrintGCDetails" class="headerlink" title="PrintGCDetails"></a>PrintGCDetails</h3><p>打开GC日志</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-attribute">-verbose</span>:gc <span class="hljs-attribute">-XX</span>:+PrintGCDetails<br></code></pre></td></tr></table></figure><p>输入信息如下</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200714081909309.png" alt="image-20200714081909309"></p><p>参数解析</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200714081925767.png" alt="image-20200714081925767"></p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul><li>[GC”和”[Fu11GC”说明了这次垃圾收集的停顿类型，如果有”Fu11”则说明GC发生了”stop The World”</li><li>使用Seria1收集器在新生代的名字是Default New Generation，因此显示的是”[DefNew”</li><li>使用ParNew收集器在新生代的名字会变成”[ParNew”，意思是”Parallel New Generation”</li><li>使用Paralle1 scavenge收集器在新生代的名字是”[PSYoungGen”</li><li>老年代的收集和新生代道理一样，名字也是收集器决定的</li><li>使用G1收集器的话，会显示为”garbage-first heap”</li></ul><p>Allocation Failure表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</p><p>[PSYoungGen：5986K-&gt;696K（8704K）]5986K-&gt;704K（9216K）中括号内：GC回收前年轻代大小，回收后大小，（年轻代总大小）括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</p><p>user代表用户态回收耗时，sys内核态回收耗时，rea实际耗时。由于多核的原因，时间总和可能会超过rea1时间</p><h3 id="Young-GC图片"><a href="#Young-GC图片" class="headerlink" title="Young GC图片"></a>Young GC图片</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200714082555688.png" alt="image-20200714082555688"></p><h3 id="FullGC图片、"><a href="#FullGC图片、" class="headerlink" title="FullGC图片、"></a>FullGC图片、</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200714082714690.png" alt="image-20200714082714690"></p><h3 id="GC回收举例"><a href="#GC回收举例" class="headerlink" title="GC回收举例"></a>GC回收举例</h3><p>我们编写一个程序，用来说明GC收集的过程</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * GC垃圾收集过程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GCUseTest</span> &#123;</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer _1MB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">byte</span> [] allocation1, allocation2, allocation3, allocation4;<br>        allocation1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span> *_1MB];<br>        allocation2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span> *_1MB];<br>        allocation3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span> *_1MB];<br>        allocation4 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">4</span> *_1MB];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们设置JVM启动参数</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">-Xms10m</span> <span class="hljs-selector-tag">-Xmx10m</span> <span class="hljs-selector-tag">-XX</span><span class="hljs-selector-pseudo">:+PrintGCDetails</span><br></code></pre></td></tr></table></figure><p>首先我们会将3个2M的数组存放到Eden区，然后后面4M的数组来了后，将无法存储，因为Eden区只剩下2M的剩余空间了，那么将会进行一次Young GC操作，将原来Eden区的内容，存放到Survivor区，但是Survivor区也存放不下，那么就会直接晋级存入Old 区</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200714083332238.png" alt="image-20200714083332238"></p><p>然后我们将4M对象存入到Eden区中</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200714083526790.png" alt="image-20200714083526790"></p><p>可以用一些工具去分析这些GC日志</p><p>常用的日志分析工具有：GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat等</p><p><strong>GCViewer</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200714084921184.png" alt="image-20200714084921184"></p><p><strong>GC easy</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200714084726824.png" alt="image-20200714084726824"></p><h2 id="垃圾回收器的新发展"><a href="#垃圾回收器的新发展" class="headerlink" title="垃圾回收器的新发展"></a>垃圾回收器的新发展</h2><p>GC仍然处于飞速发展之中，目前的默认选项G1GC在不断的进行改进，很多我们原来认为的缺点，例如串行的Fu11GC、Card Table扫描的低效等，都已经被大幅改进，例如，JDK10以后，Fu11GC已经是并行运行，在很多场景下，其表现还略优于ParallelGC的并行Ful1GC实现。</p><p>即使是SerialGC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是GC相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，在serverless等新的应用场景下，Serial Gc找到了新的舞台。</p><p>比较不幸的是CMSGC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在JDK9中已经被标记为废弃，并在JDK14版本中移除</p><p>Epsilon:A No-Op GarbageCollector（Epsilon垃圾回收器，”No-Op（无操作）”回收器）<a href="http://openidk.iava.net/iep">http://openidk.iava.net/iep</a> s/318</p><p>ZGC:A Scalable Low-Latency Garbage Collector（Experimental）（ZGC：可伸缩的低延迟垃圾回收器，处于实验性阶段）</p><p>现在G1回收器已成为默认回收器好几年了。我们还看到了引入了两个新的收集器：ZGC（JDK11出现）和Shenandoah（Open JDK12）</p><blockquote><p>主打特点：低停顿时间</p></blockquote><h3 id="Open-JDK12的Shenandoash-GC"><a href="#Open-JDK12的Shenandoash-GC" class="headerlink" title="Open JDK12的Shenandoash GC"></a>Open JDK12的Shenandoash GC</h3><p>Open JDK12的shenandoash GC：低停顿时间的GC（实验性）</p><p>Shenandoah，无疑是众多GC中最孤独的一个。是第一款不由oracle公司团队领导开发的Hotspot垃圾收集器。不可避免的受到官方的排挤。比如号称openJDK和OracleJDk没有区别的Oracle公司仍拒绝在oracleJDK12中支持Shenandoah。</p><p>Shenandoah垃圾回收器最初由RedHat进行的一项垃圾收集器研究项目Pauseless GC的实现，旨在针对JVM上的内存回收实现低停顿的需求。在2014年贡献给OpenJDK。</p><p>Red Hat研发Shenandoah团队对外宣称，Shenandoah垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为200MB还是200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。不过实际使用性能将取决于实际工作堆的大小和工作负载。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200714090608807.png" alt="image-20200714090608807"></p><p>这是RedHat在2016年发表的论文数据，测试内容是使用Es对200GB的维基百科数据进行索引。从结果看：</p><blockquote><p>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。 而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</p></blockquote><p>总结</p><ul><li>shenandoah Gc的弱项：高运行负担下的吞吐量下降。</li><li>shenandoah GC的强项：低延迟时间。</li></ul><h3 id="革命性的ZGC"><a href="#革命性的ZGC" class="headerlink" title="革命性的ZGC"></a>革命性的ZGC</h3><p>zGC与shenandoah目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟。</p><p>《深入理解Java虚拟机》一书中这样定义zGC：2GC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-压缩算法的，以低延迟为首要目标的一款垃圾收集器。</p><p>ZGC的工作过程可以分为4个阶段：<strong>并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射</strong> 等。</p><p>ZGC几乎在所有地方并发执行的，除了初始标记的是STw的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200714091201073.png" alt="image-20200714091201073"></p><p>停顿时间对比</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200714091401511.png" alt="image-20200714091401511"></p><p>虽然ZGC还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。 未来将在服务端、大内存、低延迟应用的首选垃圾收集器。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200714093243028.png" alt="image-20200714093243028"></p><p>JDK14之前，2GC仅Linux才支持。</p><p>尽管许多使用zGc的用户都使用类Linux的环境，但在Windows和macos上，人们也需要zGC进行开发部署和测试。许多桌面应用也可以从ZGC中受益。因此，2GC特性被移植到了Windows和macos上。</p><p>现在mac或Windows上也能使用zGC了，示例如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">-XX</span><span class="hljs-selector-pseudo">:+UnlockExperimentalVMOptions-XX</span>：+<span class="hljs-selector-tag">UseZGC</span><br></code></pre></td></tr></table></figure><h3 id="AliGC"><a href="#AliGC" class="headerlink" title="AliGC"></a>AliGC</h3><p>AliGC是阿里巴巴JVM团队基于G1算法，面向大堆（LargeHeap）应用场景。指定场景下的对比：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20200714093604012.png" alt="image-20200714093604012"></p><p>当然，其它厂商也提供了各种别具一格的GC实现，例如比较有名的低延迟GC Zing</p><h1 id="205-字节码文件的跨平台性"><a href="#205-字节码文件的跨平台性" class="headerlink" title="205-字节码文件的跨平台性"></a>205-字节码文件的跨平台性</h1><h1 id="206-了解Java的前端编译器"><a href="#206-了解Java的前端编译器" class="headerlink" title="206-了解Java的前端编译器"></a>206-了解Java的前端编译器</h1><h1 id="207-透过字节码看代码执行细节举例1"><a href="#207-透过字节码看代码执行细节举例1" class="headerlink" title="207-透过字节码看代码执行细节举例1"></a>207-透过字节码看代码执行细节举例1</h1><h1 id="208-透过字节码看代码执行细节举例2"><a href="#208-透过字节码看代码执行细节举例2" class="headerlink" title="208-透过字节码看代码执行细节举例2"></a>208-透过字节码看代码执行细节举例2</h1><h1 id="209-透过字节码看代码执行细节举例3"><a href="#209-透过字节码看代码执行细节举例3" class="headerlink" title="209-透过字节码看代码执行细节举例3"></a>209-透过字节码看代码执行细节举例3</h1><h1 id="210-解读Class文件的三种方式"><a href="#210-解读Class文件的三种方式" class="headerlink" title="210-解读Class文件的三种方式"></a>210-解读Class文件的三种方式</h1><h1 id="211-Class文件本质和内部数据类型"><a href="#211-Class文件本质和内部数据类型" class="headerlink" title="211-Class文件本质和内部数据类型"></a>211-Class文件本质和内部数据类型</h1><h1 id="212-Class文件内部结构概述"><a href="#212-Class文件内部结构概述" class="headerlink" title="212-Class文件内部结构概述"></a>212-Class文件内部结构概述</h1><h1 id="213-字节码数据保存到excel中的操作"><a href="#213-字节码数据保存到excel中的操作" class="headerlink" title="213-字节码数据保存到excel中的操作"></a>213-字节码数据保存到excel中的操作</h1><h1 id="214-Class文件的标识：魔数"><a href="#214-Class文件的标识：魔数" class="headerlink" title="214-Class文件的标识：魔数"></a>214-Class文件的标识：魔数</h1><h1 id="215-Class文件版本号"><a href="#215-Class文件版本号" class="headerlink" title="215-Class文件版本号"></a>215-Class文件版本号</h1><h1 id="216-常量池概述"><a href="#216-常量池概述" class="headerlink" title="216-常量池概述"></a>216-常量池概述</h1><h1 id="217-常量池计数器"><a href="#217-常量池计数器" class="headerlink" title="217-常量池计数器"></a>217-常量池计数器</h1><h1 id="218-常量池表中的字面量和符号引用"><a href="#218-常量池表中的字面量和符号引用" class="headerlink" title="218-常量池表中的字面量和符号引用"></a>218-常量池表中的字面量和符号引用</h1><h1 id="219-解析得到常量池中所有的常量"><a href="#219-解析得到常量池中所有的常量" class="headerlink" title="219-解析得到常量池中所有的常量"></a>219-解析得到常量池中所有的常量</h1><h1 id="220-常量池表数据的解读1"><a href="#220-常量池表数据的解读1" class="headerlink" title="220-常量池表数据的解读1"></a>220-常量池表数据的解读1</h1><h1 id="221-常量池表数据的解读2"><a href="#221-常量池表数据的解读2" class="headerlink" title="221-常量池表数据的解读2"></a>221-常量池表数据的解读2</h1><h1 id="222-常量池表项数据的总结"><a href="#222-常量池表项数据的总结" class="headerlink" title="222-常量池表项数据的总结"></a>222-常量池表项数据的总结</h1><h1 id="223-访问标识"><a href="#223-访问标识" class="headerlink" title="223-访问标识"></a>223-访问标识</h1><h1 id="224-类索引、父类索引、接口索引集合"><a href="#224-类索引、父类索引、接口索引集合" class="headerlink" title="224-类索引、父类索引、接口索引集合"></a>224-类索引、父类索引、接口索引集合</h1><h1 id="225-字段表集合的整体理解"><a href="#225-字段表集合的整体理解" class="headerlink" title="225-字段表集合的整体理解"></a>225-字段表集合的整体理解</h1><h1 id="226-字段表数据的解读"><a href="#226-字段表数据的解读" class="headerlink" title="226-字段表数据的解读"></a>226-字段表数据的解读</h1><h1 id="227-方法表集合的整体理解"><a href="#227-方法表集合的整体理解" class="headerlink" title="227-方法表集合的整体理解"></a>227-方法表集合的整体理解</h1><h1 id="228-方法表数据的解读"><a href="#228-方法表数据的解读" class="headerlink" title="228-方法表数据的解读"></a>228-方法表数据的解读</h1><h1 id="229-属性表集合的整理理解"><a href="#229-属性表集合的整理理解" class="headerlink" title="229-属性表集合的整理理解"></a>229-属性表集合的整理理解</h1><h1 id="230-方法中Code属性的解读"><a href="#230-方法中Code属性的解读" class="headerlink" title="230-方法中Code属性的解读"></a>230-方法中Code属性的解读</h1><h1 id="231-LineNumberTable和LocalVariableTable属性的解读"><a href="#231-LineNumberTable和LocalVariableTable属性的解读" class="headerlink" title="231-LineNumberTable和LocalVariableTable属性的解读"></a>231-LineNumberTable和LocalVariableTable属性的解读</h1><h1 id="232-SourceFile属性的解读"><a href="#232-SourceFile属性的解读" class="headerlink" title="232-SourceFile属性的解读"></a>232-SourceFile属性的解读</h1><h1 id="233-Class文件结构的小结"><a href="#233-Class文件结构的小结" class="headerlink" title="233-Class文件结构的小结"></a>233-Class文件结构的小结</h1><h1 id="234-javac-g操作的说明"><a href="#234-javac-g操作的说明" class="headerlink" title="234-javac -g操作的说明"></a>234-javac -g操作的说明</h1><h1 id="235-javap主要参数的使用"><a href="#235-javap主要参数的使用" class="headerlink" title="235-javap主要参数的使用"></a>235-javap主要参数的使用</h1><h1 id="236-javap解析得到的文件结构的解读"><a href="#236-javap解析得到的文件结构的解读" class="headerlink" title="236-javap解析得到的文件结构的解读"></a>236-javap解析得到的文件结构的解读</h1><h1 id="237-javap使用小结"><a href="#237-javap使用小结" class="headerlink" title="237-javap使用小结"></a>237-javap使用小结</h1><h1 id="238-字节码指令集的概述"><a href="#238-字节码指令集的概述" class="headerlink" title="238-字节码指令集的概述"></a>238-字节码指令集的概述</h1><h1 id="239-指令与数据类型的关系及指令分类"><a href="#239-指令与数据类型的关系及指令分类" class="headerlink" title="239-指令与数据类型的关系及指令分类"></a>239-指令与数据类型的关系及指令分类</h1><h1 id="240-加载与存储指令概述"><a href="#240-加载与存储指令概述" class="headerlink" title="240-加载与存储指令概述"></a>240-加载与存储指令概述</h1><h1 id="241-再谈操作数栈与局部变量表"><a href="#241-再谈操作数栈与局部变量表" class="headerlink" title="241-再谈操作数栈与局部变量表"></a>241-再谈操作数栈与局部变量表</h1><h1 id="242-局部变量压栈指令"><a href="#242-局部变量压栈指令" class="headerlink" title="242-局部变量压栈指令"></a>242-局部变量压栈指令</h1><h1 id="243-常量入栈指令"><a href="#243-常量入栈指令" class="headerlink" title="243-常量入栈指令"></a>243-常量入栈指令</h1><h1 id="244-出栈装入局部变量表指令"><a href="#244-出栈装入局部变量表指令" class="headerlink" title="244-出栈装入局部变量表指令"></a>244-出栈装入局部变量表指令</h1><h1 id="245-算术指令及举例"><a href="#245-算术指令及举例" class="headerlink" title="245-算术指令及举例"></a>245-算术指令及举例</h1><h1 id="246-算法指令再举例"><a href="#246-算法指令再举例" class="headerlink" title="246-算法指令再举例"></a>246-算法指令再举例</h1><h1 id="247-彻底搞定-运算符"><a href="#247-彻底搞定-运算符" class="headerlink" title="247-彻底搞定++运算符"></a>247-彻底搞定++运算符</h1><h1 id="248-比较指令的说明"><a href="#248-比较指令的说明" class="headerlink" title="248-比较指令的说明"></a>248-比较指令的说明</h1><h1 id="249-宽化类型转换"><a href="#249-宽化类型转换" class="headerlink" title="249-宽化类型转换"></a>249-宽化类型转换</h1><h1 id="250-窄化类型转换"><a href="#250-窄化类型转换" class="headerlink" title="250-窄化类型转换"></a>250-窄化类型转换</h1><h1 id="251-创建类和数组实例的指令"><a href="#251-创建类和数组实例的指令" class="headerlink" title="251-创建类和数组实例的指令"></a>251-创建类和数组实例的指令</h1><h1 id="252-字段访问指令"><a href="#252-字段访问指令" class="headerlink" title="252-字段访问指令"></a>252-字段访问指令</h1><h1 id="253-数组操作指令"><a href="#253-数组操作指令" class="headerlink" title="253-数组操作指令"></a>253-数组操作指令</h1><h1 id="254-类型检查指令"><a href="#254-类型检查指令" class="headerlink" title="254-类型检查指令"></a>254-类型检查指令</h1><h1 id="255-方法调用指令"><a href="#255-方法调用指令" class="headerlink" title="255-方法调用指令"></a>255-方法调用指令</h1><h1 id="256-方法返回指令"><a href="#256-方法返回指令" class="headerlink" title="256-方法返回指令"></a>256-方法返回指令</h1><h1 id="257-操作数栈管理指令"><a href="#257-操作数栈管理指令" class="headerlink" title="257-操作数栈管理指令"></a>257-操作数栈管理指令</h1><h1 id="258-比较指令"><a href="#258-比较指令" class="headerlink" title="258-比较指令"></a>258-比较指令</h1><h1 id="259-条件跳转指令"><a href="#259-条件跳转指令" class="headerlink" title="259-条件跳转指令"></a>259-条件跳转指令</h1><h1 id="260-比较条件跳转指令"><a href="#260-比较条件跳转指令" class="headerlink" title="260-比较条件跳转指令"></a>260-比较条件跳转指令</h1><h1 id="261-多条件分支跳转指令"><a href="#261-多条件分支跳转指令" class="headerlink" title="261-多条件分支跳转指令"></a>261-多条件分支跳转指令</h1><h1 id="262-无条件跳转指令"><a href="#262-无条件跳转指令" class="headerlink" title="262-无条件跳转指令"></a>262-无条件跳转指令</h1><h1 id="263-抛出异常指令"><a href="#263-抛出异常指令" class="headerlink" title="263-抛出异常指令"></a>263-抛出异常指令</h1><h1 id="264-异常处理与异常表"><a href="#264-异常处理与异常表" class="headerlink" title="264-异常处理与异常表"></a>264-异常处理与异常表</h1><h1 id="265-同步控制指令"><a href="#265-同步控制指令" class="headerlink" title="265-同步控制指令"></a>265-同步控制指令</h1><h1 id="266-类的生命周期概述"><a href="#266-类的生命周期概述" class="headerlink" title="266-类的生命周期概述"></a>266-类的生命周期概述</h1><h1 id="267-加载完成的操作及二进制的获取方式"><a href="#267-加载完成的操作及二进制的获取方式" class="headerlink" title="267-加载完成的操作及二进制的获取方式"></a>267-加载完成的操作及二进制的获取方式</h1><h1 id="268-类模型与Class实例的位置"><a href="#268-类模型与Class实例的位置" class="headerlink" title="268-类模型与Class实例的位置"></a>268-类模型与Class实例的位置</h1><h1 id="269-链接之验证环节"><a href="#269-链接之验证环节" class="headerlink" title="269-链接之验证环节"></a>269-链接之验证环节</h1><h1 id="270-链接之准备环节"><a href="#270-链接之准备环节" class="headerlink" title="270-链接之准备环节"></a>270-链接之准备环节</h1><h1 id="271-链接之解析环节"><a href="#271-链接之解析环节" class="headerlink" title="271-链接之解析环节"></a>271-链接之解析环节</h1><h1 id="272-初始化过程与类初始化方法"><a href="#272-初始化过程与类初始化方法" class="headerlink" title="272-初始化过程与类初始化方法"></a>272-初始化过程与类初始化方法</h1><h1 id="273-初始化阶段赋值与准备阶段赋值的对比"><a href="#273-初始化阶段赋值与准备阶段赋值的对比" class="headerlink" title="273-初始化阶段赋值与准备阶段赋值的对比"></a>273-初始化阶段赋值与准备阶段赋值的对比</h1><h1 id="274-类初始化方法clinit-的线程安全性"><a href="#274-类初始化方法clinit-的线程安全性" class="headerlink" title="274-类初始化方法clinit()的线程安全性"></a>274-类初始化方法clinit()的线程安全性</h1><h1 id="275-何为类的主动使用和被动使用"><a href="#275-何为类的主动使用和被动使用" class="headerlink" title="275-何为类的主动使用和被动使用"></a>275-何为类的主动使用和被动使用</h1><h1 id="276-类的主动使用1"><a href="#276-类的主动使用1" class="headerlink" title="276-类的主动使用1"></a>276-类的主动使用1</h1><h1 id="277-类的主动使用2"><a href="#277-类的主动使用2" class="headerlink" title="277-类的主动使用2"></a>277-类的主动使用2</h1><h1 id="278-类的主动使用3"><a href="#278-类的主动使用3" class="headerlink" title="278-类的主动使用3"></a>278-类的主动使用3</h1><h1 id="279-类的主动使用4"><a href="#279-类的主动使用4" class="headerlink" title="279-类的主动使用4"></a>279-类的主动使用4</h1><h1 id="280-类的被动使用"><a href="#280-类的被动使用" class="headerlink" title="280-类的被动使用"></a>280-类的被动使用</h1><h1 id="281-类的使用介绍"><a href="#281-类的使用介绍" class="headerlink" title="281-类的使用介绍"></a>281-类的使用介绍</h1><h1 id="282-类的卸载相关问题"><a href="#282-类的卸载相关问题" class="headerlink" title="282-类的卸载相关问题"></a>282-类的卸载相关问题</h1><h1 id="283-类加载器的概述"><a href="#283-类加载器的概述" class="headerlink" title="283-类加载器的概述"></a>283-类加载器的概述</h1><h1 id="284-命名空间与类的唯一性"><a href="#284-命名空间与类的唯一性" class="headerlink" title="284-命名空间与类的唯一性"></a>284-命名空间与类的唯一性</h1><h1 id="285-类的加载器的分类"><a href="#285-类的加载器的分类" class="headerlink" title="285-类的加载器的分类"></a>285-类的加载器的分类</h1><h1 id="286-引导类加载器的说明"><a href="#286-引导类加载器的说明" class="headerlink" title="286-引导类加载器的说明"></a>286-引导类加载器的说明</h1><h1 id="287-扩展类加载器的说明"><a href="#287-扩展类加载器的说明" class="headerlink" title="287-扩展类加载器的说明"></a>287-扩展类加载器的说明</h1><h1 id="288-系统类加载器的说明"><a href="#288-系统类加载器的说明" class="headerlink" title="288-系统类加载器的说明"></a>288-系统类加载器的说明</h1><h1 id="289-用户自定义类加载器的说明"><a href="#289-用户自定义类加载器的说明" class="headerlink" title="289-用户自定义类加载器的说明"></a>289-用户自定义类加载器的说明</h1><h1 id="290-测试不同类使用的类加载器"><a href="#290-测试不同类使用的类加载器" class="headerlink" title="290-测试不同类使用的类加载器"></a>290-测试不同类使用的类加载器</h1><h1 id="291-ClassLoader与Launcher的初步剖析"><a href="#291-ClassLoader与Launcher的初步剖析" class="headerlink" title="291-ClassLoader与Launcher的初步剖析"></a>291-ClassLoader与Launcher的初步剖析</h1><h1 id="292-ClassLoader的源码解析1"><a href="#292-ClassLoader的源码解析1" class="headerlink" title="292-ClassLoader的源码解析1"></a>292-ClassLoader的源码解析1</h1><h1 id="293-ClassLoader的源码解析2"><a href="#293-ClassLoader的源码解析2" class="headerlink" title="293-ClassLoader的源码解析2"></a>293-ClassLoader的源码解析2</h1><h1 id="294-ClassLoader子类的结构剖析"><a href="#294-ClassLoader子类的结构剖析" class="headerlink" title="294-ClassLoader子类的结构剖析"></a>294-ClassLoader子类的结构剖析</h1><h1 id="295-双亲委派机制的优势与劣势"><a href="#295-双亲委派机制的优势与劣势" class="headerlink" title="295-双亲委派机制的优势与劣势"></a>295-双亲委派机制的优势与劣势</h1><h1 id="296-三次双亲委派机制的破坏"><a href="#296-三次双亲委派机制的破坏" class="headerlink" title="296-三次双亲委派机制的破坏"></a>296-三次双亲委派机制的破坏</h1><h1 id="297-热替换的代码实现"><a href="#297-热替换的代码实现" class="headerlink" title="297-热替换的代码实现"></a>297-热替换的代码实现</h1><h1 id="298-沙箱安全机制"><a href="#298-沙箱安全机制" class="headerlink" title="298-沙箱安全机制"></a>298-沙箱安全机制</h1><h1 id="299-自定义类加载器的好处和应用场景"><a href="#299-自定义类加载器的好处和应用场景" class="headerlink" title="299-自定义类加载器的好处和应用场景"></a>299-自定义类加载器的好处和应用场景</h1><h1 id="300-自定义类加载器的代码实现"><a href="#300-自定义类加载器的代码实现" class="headerlink" title="300-自定义类加载器的代码实现"></a>300-自定义类加载器的代码实现</h1><h1 id="301-Java9的新特性"><a href="#301-Java9的新特性" class="headerlink" title="301-Java9的新特性"></a>301-Java9的新特性</h1><h1 id="302-性能监控与调优篇概述"><a href="#302-性能监控与调优篇概述" class="headerlink" title="302-性能监控与调优篇概述"></a>302-性能监控与调优篇概述</h1><h1 id="303-见识一下大厂面试题"><a href="#303-见识一下大厂面试题" class="headerlink" title="303-见识一下大厂面试题"></a>303-见识一下大厂面试题</h1><h1 id="304-为什么调优及监控的依据"><a href="#304-为什么调优及监控的依据" class="headerlink" title="304-为什么调优及监控的依据"></a>304-为什么调优及监控的依据</h1><h1 id="305-性能优化的三部曲"><a href="#305-性能优化的三部曲" class="headerlink" title="305-性能优化的三部曲"></a>305-性能优化的三部曲</h1><h1 id="306-4个性能测试指标及相关关系"><a href="#306-4个性能测试指标及相关关系" class="headerlink" title="306-4个性能测试指标及相关关系"></a>306-4个性能测试指标及相关关系</h1><h1 id="307-JVM命令行监控工具的概述"><a href="#307-JVM命令行监控工具的概述" class="headerlink" title="307-JVM命令行监控工具的概述"></a>307-JVM命令行监控工具的概述</h1><h1 id="308-jps：查看正在运行的Java进程"><a href="#308-jps：查看正在运行的Java进程" class="headerlink" title="308-jps：查看正在运行的Java进程"></a>308-jps：查看正在运行的Java进程</h1><h1 id="309-jstat：基本语法"><a href="#309-jstat：基本语法" class="headerlink" title="309-jstat：基本语法"></a>309-jstat：基本语法</h1><h1 id="310-jstat：如何排查OOM和内存泄漏"><a href="#310-jstat：如何排查OOM和内存泄漏" class="headerlink" title="310-jstat：如何排查OOM和内存泄漏"></a>310-jstat：如何排查OOM和内存泄漏</h1><h1 id="311-jinfo：实时查看和修改JVM配置参数"><a href="#311-jinfo：实时查看和修改JVM配置参数" class="headerlink" title="311-jinfo：实时查看和修改JVM配置参数"></a>311-jinfo：实时查看和修改JVM配置参数</h1><h1 id="312-PrintFlagsFinal的使用"><a href="#312-PrintFlagsFinal的使用" class="headerlink" title="312-PrintFlagsFinal的使用"></a>312-PrintFlagsFinal的使用</h1><h1 id="313-jmap：各种option参数说明"><a href="#313-jmap：各种option参数说明" class="headerlink" title="313-jmap：各种option参数说明"></a>313-jmap：各种option参数说明</h1><h1 id="314-导出dump堆转储快照文件的两种方式"><a href="#314-导出dump堆转储快照文件的两种方式" class="headerlink" title="314-导出dump堆转储快照文件的两种方式"></a>314-导出dump堆转储快照文件的两种方式</h1><h1 id="315-jmap：如何显示堆内存等功能"><a href="#315-jmap：如何显示堆内存等功能" class="headerlink" title="315-jmap：如何显示堆内存等功能"></a>315-jmap：如何显示堆内存等功能</h1><h1 id="316-jhat：JDK自带堆分析工具"><a href="#316-jhat：JDK自带堆分析工具" class="headerlink" title="316-jhat：JDK自带堆分析工具"></a>316-jhat：JDK自带堆分析工具</h1><h1 id="317-jstack：追踪JVM中线程快照"><a href="#317-jstack：追踪JVM中线程快照" class="headerlink" title="317-jstack：追踪JVM中线程快照"></a>317-jstack：追踪JVM中线程快照</h1><h1 id="318-jcmd：多功能命令行工具"><a href="#318-jcmd：多功能命令行工具" class="headerlink" title="318-jcmd：多功能命令行工具"></a>318-jcmd：多功能命令行工具</h1><h1 id="319-jstatd：远程主机信息收集"><a href="#319-jstatd：远程主机信息收集" class="headerlink" title="319-jstatd：远程主机信息收集"></a>319-jstatd：远程主机信息收集</h1><h1 id="320-JVM监控及诊断的GUI工具概述"><a href="#320-JVM监控及诊断的GUI工具概述" class="headerlink" title="320-JVM监控及诊断的GUI工具概述"></a>320-JVM监控及诊断的GUI工具概述</h1><h1 id="321-jConsole的使用"><a href="#321-jConsole的使用" class="headerlink" title="321-jConsole的使用"></a>321-jConsole的使用</h1><h1 id="322-VisualVM的安装及连接方式"><a href="#322-VisualVM的安装及连接方式" class="headerlink" title="322-VisualVM的安装及连接方式"></a>322-VisualVM的安装及连接方式</h1><h1 id="323-VisualVM的基本功能"><a href="#323-VisualVM的基本功能" class="headerlink" title="323-VisualVM的基本功能"></a>323-VisualVM的基本功能</h1><h1 id="324-VisualVM生成和查看堆dump文件"><a href="#324-VisualVM生成和查看堆dump文件" class="headerlink" title="324-VisualVM生成和查看堆dump文件"></a>324-VisualVM生成和查看堆dump文件</h1><h1 id="325-Visual生成和分析线程dump文件"><a href="#325-Visual生成和分析线程dump文件" class="headerlink" title="325-Visual生成和分析线程dump文件"></a>325-Visual生成和分析线程dump文件</h1><h1 id="326-VisualVM的CPU抽样和内存抽样"><a href="#326-VisualVM的CPU抽样和内存抽样" class="headerlink" title="326-VisualVM的CPU抽样和内存抽样"></a>326-VisualVM的CPU抽样和内存抽样</h1><h1 id="327-MAT概述-获取dump的四种方式"><a href="#327-MAT概述-获取dump的四种方式" class="headerlink" title="327-MAT概述_获取dump的四种方式"></a>327-MAT概述_获取dump的四种方式</h1><h1 id="328-MAT界面主要功能概览"><a href="#328-MAT界面主要功能概览" class="headerlink" title="328-MAT界面主要功能概览"></a>328-MAT界面主要功能概览</h1><h1 id="329-MAT中Histogram的功能演示"><a href="#329-MAT中Histogram的功能演示" class="headerlink" title="329-MAT中Histogram的功能演示"></a>329-MAT中Histogram的功能演示</h1><h1 id="330-基于对象的出引用与入引用分析内存泄漏"><a href="#330-基于对象的出引用与入引用分析内存泄漏" class="headerlink" title="330-基于对象的出引用与入引用分析内存泄漏"></a>330-基于对象的出引用与入引用分析内存泄漏</h1><h1 id="331-ShallowHeap与RetainedHeap"><a href="#331-ShallowHeap与RetainedHeap" class="headerlink" title="331-ShallowHeap与RetainedHeap"></a>331-ShallowHeap与RetainedHeap</h1><h1 id="332-案例分析：StudentTrace"><a href="#332-案例分析：StudentTrace" class="headerlink" title="332-案例分析：StudentTrace"></a>332-案例分析：StudentTrace</h1><h1 id="333-支配树的理解及应用"><a href="#333-支配树的理解及应用" class="headerlink" title="333-支配树的理解及应用"></a>333-支配树的理解及应用</h1><h1 id="334-案例：Tomcat堆溢出分析"><a href="#334-案例：Tomcat堆溢出分析" class="headerlink" title="334-案例：Tomcat堆溢出分析"></a>334-案例：Tomcat堆溢出分析</h1><h1 id="335-内存泄漏的理解与分类"><a href="#335-内存泄漏的理解与分类" class="headerlink" title="335-内存泄漏的理解与分类"></a>335-内存泄漏的理解与分类</h1><h1 id="336-内存泄漏的8种情况"><a href="#336-内存泄漏的8种情况" class="headerlink" title="336-内存泄漏的8种情况"></a>336-内存泄漏的8种情况</h1><h1 id="337-内存泄漏分析案例1"><a href="#337-内存泄漏分析案例1" class="headerlink" title="337-内存泄漏分析案例1"></a>337-内存泄漏分析案例1</h1><h1 id="338-内存泄漏分析案例2"><a href="#338-内存泄漏分析案例2" class="headerlink" title="338-内存泄漏分析案例2"></a>338-内存泄漏分析案例2</h1><h1 id="339-OQL语句的使用举例"><a href="#339-OQL语句的使用举例" class="headerlink" title="339-OQL语句的使用举例"></a>339-OQL语句的使用举例</h1><h1 id="340-JProfiler的使用概述"><a href="#340-JProfiler的使用概述" class="headerlink" title="340-JProfiler的使用概述"></a>340-JProfiler的使用概述</h1><h1 id="341-JProfiler的安装和配置"><a href="#341-JProfiler的安装和配置" class="headerlink" title="341-JProfiler的安装和配置"></a>341-JProfiler的安装和配置</h1><h1 id="342-两种数据采集方式"><a href="#342-两种数据采集方式" class="headerlink" title="342-两种数据采集方式"></a>342-两种数据采集方式</h1><h1 id="343-遥感监测视图中相关监测数据"><a href="#343-遥感监测视图中相关监测数据" class="headerlink" title="343-遥感监测视图中相关监测数据"></a>343-遥感监测视图中相关监测数据</h1><h1 id="344-内存视图的分析"><a href="#344-内存视图的分析" class="headerlink" title="344-内存视图的分析"></a>344-内存视图的分析</h1><h1 id="345-Heap-Walker功能演示"><a href="#345-Heap-Walker功能演示" class="headerlink" title="345-Heap Walker功能演示"></a>345-Heap Walker功能演示</h1><h1 id="346-CPU视图的功能说明"><a href="#346-CPU视图的功能说明" class="headerlink" title="346-CPU视图的功能说明"></a>346-CPU视图的功能说明</h1><h1 id="347-Threads视图的功能说明"><a href="#347-Threads视图的功能说明" class="headerlink" title="347-Threads视图的功能说明"></a>347-Threads视图的功能说明</h1><h1 id="348-JProfiler使用案例1"><a href="#348-JProfiler使用案例1" class="headerlink" title="348-JProfiler使用案例1"></a>348-JProfiler使用案例1</h1><h1 id="349-JProfiler使用案例2"><a href="#349-JProfiler使用案例2" class="headerlink" title="349-JProfiler使用案例2"></a>349-JProfiler使用案例2</h1><h1 id="350-为什么要引入Arthas"><a href="#350-为什么要引入Arthas" class="headerlink" title="350-为什么要引入Arthas"></a>350-为什么要引入Arthas</h1><h1 id="351-Arthas的安装及对Java进程的监控"><a href="#351-Arthas的安装及对Java进程的监控" class="headerlink" title="351-Arthas的安装及对Java进程的监控"></a>351-Arthas的安装及对Java进程的监控</h1><h1 id="352-Arthas中基础指令的使用"><a href="#352-Arthas中基础指令的使用" class="headerlink" title="352-Arthas中基础指令的使用"></a>352-Arthas中基础指令的使用</h1><h1 id="353-dashboard命令和thread命令"><a href="#353-dashboard命令和thread命令" class="headerlink" title="353-dashboard命令和thread命令"></a>353-dashboard命令和thread命令</h1><h1 id="354-sysprop命令和heapdump命令"><a href="#354-sysprop命令和heapdump命令" class="headerlink" title="354-sysprop命令和heapdump命令"></a>354-sysprop命令和heapdump命令</h1><h1 id="355-sc命令和sm命令"><a href="#355-sc命令和sm命令" class="headerlink" title="355-sc命令和sm命令"></a>355-sc命令和sm命令</h1><h1 id="356-jad命令-mc命令-classloader命令"><a href="#356-jad命令-mc命令-classloader命令" class="headerlink" title="356-jad命令_mc命令_classloader命令"></a>356-jad命令_mc命令_classloader命令</h1><h1 id="357-monitor-watch-trace-stack-tt命令"><a href="#357-monitor-watch-trace-stack-tt命令" class="headerlink" title="357-monitor_watch_trace_stack_tt命令"></a>357-monitor_watch_trace_stack_tt命令</h1><h1 id="358-Arthas的其它相关命令"><a href="#358-Arthas的其它相关命令" class="headerlink" title="358-Arthas的其它相关命令"></a>358-Arthas的其它相关命令</h1><h1 id="359-JMC介绍-实时JVM监控"><a href="#359-JMC介绍-实时JVM监控" class="headerlink" title="359-JMC介绍_实时JVM监控"></a>359-JMC介绍_实时JVM监控</h1><h1 id="360-Java-Flight-Recorder介绍和取样分析"><a href="#360-Java-Flight-Recorder介绍和取样分析" class="headerlink" title="360-Java Flight Recorder介绍和取样分析"></a>360-Java Flight Recorder介绍和取样分析</h1><h1 id="361-火焰图的使用介绍"><a href="#361-火焰图的使用介绍" class="headerlink" title="361-火焰图的使用介绍"></a>361-火焰图的使用介绍</h1><h1 id="362-Tprofiler等工具的介绍"><a href="#362-Tprofiler等工具的介绍" class="headerlink" title="362-Tprofiler等工具的介绍"></a>362-Tprofiler等工具的介绍</h1><h1 id="363-JVM参数选项类型1：标准参数选项"><a href="#363-JVM参数选项类型1：标准参数选项" class="headerlink" title="363-JVM参数选项类型1：标准参数选项"></a>363-JVM参数选项类型1：标准参数选项</h1><h1 id="364-JVM参数选项类型2：-X参数选项"><a href="#364-JVM参数选项类型2：-X参数选项" class="headerlink" title="364-JVM参数选项类型2：-X参数选项"></a>364-JVM参数选项类型2：-X参数选项</h1><h1 id="365-JVM参数选项类型3：-XX参数选项"><a href="#365-JVM参数选项类型3：-XX参数选项" class="headerlink" title="365-JVM参数选项类型3：-XX参数选项"></a>365-JVM参数选项类型3：-XX参数选项</h1><h1 id="366-如何添加JVM参数选项的说明"><a href="#366-如何添加JVM参数选项的说明" class="headerlink" title="366-如何添加JVM参数选项的说明"></a>366-如何添加JVM参数选项的说明</h1><h1 id="367-打印设置的XX选项及值"><a href="#367-打印设置的XX选项及值" class="headerlink" title="367-打印设置的XX选项及值"></a>367-打印设置的XX选项及值</h1><h1 id="368-栈、堆、方法区内存的相关VM参数选项设置"><a href="#368-栈、堆、方法区内存的相关VM参数选项设置" class="headerlink" title="368-栈、堆、方法区内存的相关VM参数选项设置"></a>368-栈、堆、方法区内存的相关VM参数选项设置</h1><h1 id="369-OutOfMemory相关VM参数选项的设置"><a href="#369-OutOfMemory相关VM参数选项的设置" class="headerlink" title="369-OutOfMemory相关VM参数选项的设置"></a>369-OutOfMemory相关VM参数选项的设置</h1><h1 id="370-回顾经典的GC及相互搭配关系"><a href="#370-回顾经典的GC及相互搭配关系" class="headerlink" title="370-回顾经典的GC及相互搭配关系"></a>370-回顾经典的GC及相互搭配关系</h1><h1 id="371-不同垃圾回收器的VM参数选项设置"><a href="#371-不同垃圾回收器的VM参数选项设置" class="headerlink" title="371-不同垃圾回收器的VM参数选项设置"></a>371-不同垃圾回收器的VM参数选项设置</h1><h1 id="372-GC日志相关VM参数选项的设置"><a href="#372-GC日志相关VM参数选项的设置" class="headerlink" title="372-GC日志相关VM参数选项的设置"></a>372-GC日志相关VM参数选项的设置</h1><h1 id="373-了解其他VM参数选项"><a href="#373-了解其他VM参数选项" class="headerlink" title="373-了解其他VM参数选项"></a>373-了解其他VM参数选项</h1><h1 id="374-通过Java代码获取JVM参数"><a href="#374-通过Java代码获取JVM参数" class="headerlink" title="374-通过Java代码获取JVM参数"></a>374-通过Java代码获取JVM参数</h1><h1 id="375-复习GC的分类"><a href="#375-复习GC的分类" class="headerlink" title="375-复习GC的分类"></a>375-复习GC的分类</h1><h1 id="376-GC日志的分类"><a href="#376-GC日志的分类" class="headerlink" title="376-GC日志的分类"></a>376-GC日志的分类</h1><h1 id="377-MinorGC的日志解析"><a href="#377-MinorGC的日志解析" class="headerlink" title="377-MinorGC的日志解析"></a>377-MinorGC的日志解析</h1><h1 id="378-FullGC的日志解析"><a href="#378-FullGC的日志解析" class="headerlink" title="378-FullGC的日志解析"></a>378-FullGC的日志解析</h1><h1 id="379-在线日志分析工具：GCEasy"><a href="#379-在线日志分析工具：GCEasy" class="headerlink" title="379-在线日志分析工具：GCEasy"></a>379-在线日志分析工具：GCEasy</h1><h1 id="380-其它日志分析工具：GCViewer、GChisto、HPjmeter"><a href="#380-其它日志分析工具：GCViewer、GChisto、HPjmeter" class="headerlink" title="380-其它日志分析工具：GCViewer、GChisto、HPjmeter"></a>380-其它日志分析工具：GCViewer、GChisto、HPjmeter</h1><h1 id="381-OOM及性能优化案例与解决方案"><a href="#381-OOM及性能优化案例与解决方案" class="headerlink" title="381-OOM及性能优化案例与解决方案"></a>381-OOM及性能优化案例与解决方案</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1PJ411n7xZ">视频教程</a><br><a href="https://www.processon.com/view/link/601a1df3637689536e17bade">思维导图</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS篇-操作系统真象还原</title>
    <link href="/2021/02/21/os/OS%E7%AF%87-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/"/>
    <url>/2021/02/21/os/OS%E7%AF%87-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><ul><li>VirtualBox</li><li>Linux</li><li>Bochs</li></ul><h1 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h1><h2 id="软件是如何访问硬件的"><a href="#软件是如何访问硬件的" class="headerlink" title="软件是如何访问硬件的"></a>软件是如何访问硬件的</h2><blockquote><p>硬件是各种各样的,发展速度还是非常快的。各个硬件都有自己的个性,操作系统不可能及时更新各种硬件的驱动方法吧。比如,刚出来某个新硬件,OS 开发者们便开始为其写驱动,这不太现实,会把人累死的。于是乎,便出现了各种硬件适配设备,这就是 IO 接口。接口其实就是标准,大家生产出来的硬件按照这个标准工作就实现了通用。</p></blockquote><blockquote><p>硬件在输入输出上大体分为串行和并行,相应的接口也就是串行接口和并行接口。串行硬件通过串行接口与 CPU 通信,反过来也是,CPU 通过串行接口与串行设备数据传输。并行设备的访问类似,只不过是通过并行接口进行的。</p></blockquote><p>访问外部硬件有两个方式。</p><ul><li>(1)将某个外设的内存映射到一定范围的地址空间中,CPU 通过地址总线访问该内存区域时会落到外设的内存中,这种映射让 CPU 访问外设的内存就如同访问主板上的物理内存一样。有的设备是这样做的,比如显卡,显卡是显示器的适配器,CPU 不直接和显示器交互,它只和显卡通信。显卡上有片内存叫显存,它被映射到主机物理内存上的低端 1MB 的 0xB8000~0xBFFFF。CPU 访问这片内存就是访问显存,往这片内存上写字节便是往屏幕上打印内容。看上去这么高大上的做法是怎么实现的,这个我们就不关心了,前面说过,计算机中处处是分层,我们要充分相信上一层的工作。</li><li>(2)外设是通过 IO 接口与 CPU 通信的,CPU 访问外设,就是访问 IO 接口,由 IO 接口将信息传递给另一端的外设,也就是说,CPU 从来不知道有这些设备的存在,它只知道自己操作的 IO 接口,你看,处处体现着分层。于是问题来了,如何访问到 IO 接口呢,答案就是 IO 接口上面有一些寄存器,访问 IO 接口本质上就是访问这些寄存器,这些寄存器就是人们常说的端口。这些端口是人家 IO 接口给咱们提供的接口。人家接口电路也有自己的思维(系统),看到寄存器中写了什么就做出相应的反应。接口提供接口,哈哈,有意思。不过这是人家的约定,没有约定就乱了,各干各的,大家都累,咱们只要遵循人家的规定就能访问成功。</li></ul><h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2><blockquote><p>和操作系统是如何配合到一起的 应用程序是软件（似乎是废话，别急，往后看），操作系统也是软件。CPU 会将它们一视同仁，甚至， CPU 不知道自己在执行的程序是操作系统，还是一般应用软件，CPU 只知道去 cs：ip 寄存器中指向的内 存取指令并执行，它不知道什么是操作系统，也无需知道。 操作系统是人想出来的，为了让自己管理计算机方便而创造出来的一套管理办法。 应用程序要用某种语言编写，而语言又是编译器来提供的。其实根本就没有什么语言，有的只是编译 器。是编译器决定怎样解释某种关键字及某种语法。语言只是编译器和大家的约定，只要写入这样的代码， 编译器便将其翻译成某种机器指令，翻译成什么样取决于编译器的行为，和语言无关，比如说 C 语言的 printf 函数，它的功能不是说一定要把字符打印到屏幕上，这要看编译器对这种关键字的处理。 编译器提供了一套库函数，库函数中又有封装的系统调用，这样的代码集合称之为运行库。C 语言的 运行库称为 C 运行库，就是所谓的 CRT（C Runtime Library）。 应用程序加上操作系统提供功能才算是完整的程序。由于有了操作系统的支持，一些现成的东西已经摆 在那了，但这些是属于操作系统的，不是应用程序的，所以咱们平时所写的应用程序只是半成品，需要调用 操作系统提供好的函数才能完整地做成一件事，而这个函数便是系统调用。 用户态与内核态是对 CPU 来讲的，是指 CPU 运行在用户态（特权 3 级）还是内核态（特权 0 级）， 很多人误以为是对用户进程来讲的。 用户进程陷入内核态是指：由于内部或外部中断发生，当前进程被暂时终止执行，其上下文被内核的 中断程序保存起来后，开始执行一段内核的代码。是内核的代码，不是用户程序在内核的代码，用户代码 怎么可能在内核中存在，所以“用户态与内核态”是对 CPU 来说的。 当应用程序陷入内核后，它自己已经下 CPU 了，以后发生的事，应用程序完全不知道，它的上下文环境已 经被保存到自己的 0 特权级栈中了，那时在 CPU 上运行的程序已经是内核程序了。所以要清楚，内核代码并不 是成了应用程序的内核化身，操作系统是独立的部分，用户进程永远不会因为进入内核态而变身为操作系统了。 异步社区会员 databus(17602509427) 专享 尊重版权 第 0 章 一些你可能正感到迷惑的问题 4 应用程序是通过系统调用来和操作系统配合完成某项功能的，有人可能会问：我写应用程序时从来没 写什么系统调用的代码啊。这是因为你用到的标准库帮你完成了这些事，库中提供的函数其实都已经封装 好了系统调用，你需要跟下代码才会看到。其实也可以跨过标准库直接执行系统调用，对于 Linux 系统来 说，直接嵌入汇编代码“int 0x80”便可以直接执行系统调用，当然要提前设置好系统调用子功能号，该 子功能号用寄存器 eax 存储。 会不会有人又问，编译器怎么知道系统调用接口是什么，哈哈，您想啊，下载编译器时，是不是要选择系 统版本，编译器在设计时也要知道自己将来运行在哪个系统平台上，所以这都是和系统绑定好的，各个操作系 统都有自己的系统调用号，编译器厂商在代码中已经把宿主系统的系统调用号写死了，没什么神奇的。</p></blockquote><h2 id="用户态与内核态"><a href="#用户态与内核态" class="headerlink" title="用户态与内核态"></a>用户态与内核态</h2><blockquote><p>用户态与内核态是对 CPU 来讲的,是指 CPU 运行在用户态(特权 3 级)还是内核态(特权 0 级), 很多人误以为是对用户进程来讲的。</p></blockquote><h2 id="陷入内核"><a href="#陷入内核" class="headerlink" title="陷入内核"></a>陷入内核</h2><blockquote><p>如果把软件分层的话, 最外圈是应用程序,里面是操作系统,如图 0-1 所示。 应用程序处于特权级 3,操作系统内核处于特权级 0。当用户程序欲 访问系统资源时(无论是硬件,还是内核数据结构),它需要进行系统调用。这样 CPU 便进入了内核态,也称管态。看图中凹下去的部分,是不 是有陷进去的感觉,这就是“陷入内核”。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210222102733078.png" alt="image-20210222102733078" style="zoom:25%;" /><h2 id="内存访问为什么要分段"><a href="#内存访问为什么要分段" class="headerlink" title="内存访问为什么要分段"></a>内存访问为什么要分段</h2><p>按理说咱们应该先看看段是什么，不过了解段是什么之前，先看看内存是什么样子，如图 </p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210222230327991.png" alt="image-20210222230327991"></p><p>内存按访问方式来看，其结构就如同上面的长方形带子，地址依次升高。为了解释问题更明白，我们 假设还在实模式下，如果读者不清楚什么是实模式也不要紧，这并不影响理解段是 什么，故暂且先忽略。</p><blockquote><p>内存是随机读写设备，即访问其内部任何一处，不需要从头开始找，只要直接 给出其地址便可。如访问内存 0xC00，只要将此地址写入地址总线便可。问题来了， 分段是内存访问机制，是给 CPU 用的访问内存的方式，只有 CPU 才关注段，那为 什么 CPU 要用段呢，也就是为什么 CPU 非得将内存分成一段一段的才能访问呢？ </p></blockquote><blockquote><p>说来话长，现实行业中有很多问题都是历史遗留问题，计算机行业也不能例外。 分段是从 CPU 8086 开始的，限于技术和经济，那时候电脑还是非常昂贵的东西， 所以 CPU 和寄存器等宽度都是 16 位的，并不是像今天这样寄存器已经扩展到 64 位，当然编译器用的最多的还是 32 位。16 位寄存器意味着其可存储的数字范围是 2 的 16 次方，即 65536 字节，64KB。那时的计算机没有虚拟地址之说，只有物理 地址，访问任何存储单元都直接给出物理地址。 </p></blockquote><blockquote><p>编译器在编译程序时，肯定要根据 CPU 访问内存的规则将代码编译成机器指令，这样编译出来的程序才能 在该 CPU 上运行无误，所以说，在直接以绝对物理地址访问内存的 CPU 上运行程序，该程序中指令的地址也必 须得是绝对物理地址。总之，要想在该硬件上运行，就要遵从该硬件的规则，操作系统和编译器也无一例外。 若加载程序运行，不管其是内核程序，还是用户程序，程序中的地址若都是绝对物理地址，那该程序必须放 在内存中固定的地方，于是，两个编译出来地址相同的用户程序还真没法同时运行，只能运行一个。于是伟大的 计算机前辈们用分段的方式解决了这一问题，让 CPU 采用“段基址+段内偏移地址”的方式来访问任意内存。这 样的好处是程序可以重定位了，尽管程序指令中给的是绝对物理地址，但终究可以同时运行多个程序了。 </p></blockquote><blockquote><p>什么是重定位呢，简单来说就是将程序中指令的地址改写成另外一个地址，但该地址处的内容还是原</p></blockquote><p>CPU 采用“段基址+段内偏移地址”的形式访问内存，就需要专门提供段基址寄存器，这些是 cs、ds、 es 等。程序中需要用到哪块内存，只要先加载合适的段到段基址寄存器中，再给出相对于该段基址的偏移 地址便可，CPU 中的地址单元会将这两个地址相加后的结果用于内存访问，送上地址总线。 </p><blockquote><p>注意，很多读者都觉得段基址一定得是 65536 的倍数（16 位段基址寄存器的容量），这个真的不用， 段基址可以是任意的。这就是段可以重叠的原因。 </p></blockquote><blockquote><p>举个例子，看图 0-2，假设段基址为 0xC00，要想访问物理内存 0xC01，就要将用 0xC00：0x01 的方 式来访问才行。若将段基址改为 0xc01，还是访问 0xC01，就要用 0xC01：0x00 的方式来访问。同样，若 想访问物理内存 0xC04，段基址和段内偏移的组合可以是：0xC01：0x03、0xC02：0x02、0xC00：0xC04 等，总之要想访问某个物理地址，只要凑出合适的段基地址和段内偏移地址，其和为该物理地址就行了。 这时估计有人会问这样行不行，0xC05：-1，能这样提问的同学都是求知欲极强的，可以自己试一下。 说了这么多，我想告诉你的是只要程序分了段，把整个段平移到任何位置后，段内的地址相对于段基 址是不变的，无论段基址是多少，只要给出段内偏移地址，CPU 就能访问到正确的指令。于是加载用户 程序时，只要将整个段的内容复制到新的位置，再将段基址寄存器中的地址改成该地址，程序便可准确无 误地运行，因为程序中用的是段内偏移地址，相对于新的段基址， 该偏移地址处的内存内容还是一样的，如图 。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210222231547254.png" alt="image-20210222231547254"></p><p> 所以说，程序分段首先是为了重定位，我说的是首先，下面 还有其他理由呢。 偏移地址也要存入寄存器，而那时的寄存器是 16 位的，也就 是一个段最多可以访问到 64KB。而那时的内存再小也有 1MB， 改变段基址，由一个段变为另一个段，就像一个段在内存中飘移， 采用这种在内存中来回挪位置的方式可以访问到任意内存位置。 所以说，程序分段又是为了将大内存分成可以访问的小段， 通过这样变通的方法便能够访问到所有内存了。 但想一想，1M 是 2 的 20 次方，1MB 内存需要 20 位的地址 才能访问到，如何做到用 16 位寄存器访问 20 位地址空间呢？ 在 8086 的寻址方式中，有基址寻址，这是用基址寄存器 bx 或 bp 来提供偏移地址的，如“mov [bx]， 0x5；”指令便是将立即数 0x5 存入 ds：bx 指向的内存。 大家看，bx 寄存器是 16 位的，它最大只能表示 0～0xFFFF 的地址空间，即 64KB，也就是单一的一个寄存 器无法表示 20 位的地址空间—1MB。也许有人会说，段基址和段内偏移地址都搞到最大，都为 0xFFFF，对 不起，即使不溢出的话，其结果也只是由 16 位变成了 17 位，即两个 n 位的数字无论多大，其相加的结果也超不 过 n+1 位，因为即使是两个相同的数相加，其结果相当于乘以 2，也就是左移一位而已，依然无法访问 20 位的 地址空间。也许读者又有好建议了：CPU 的寻址方式又不是仅仅这一种，上面的限制是因为寄存器是 16 位，只 要不全部通过寄存器不就行了吗。既然段寄存器必须得用，那就在偏移地址上下功夫，不要把偏移地址写在寄存 器里了，把它直接写成 20 位立即数不就行啦。例如 mov ax，[0x12345]，这样最终的地址是 ds+0x12345，肯定 是 20 位，解决啦。不错，这种是直接寻址方式，至少道理上讲得通，这是通过编程技巧来突破这一瓶颈的，能 想到这一点我觉得非常 nice。但是作为一个严谨的 CPU，既然宣称支持了通过寄存器来寻址，那就要能够自圆 其说才行，不能靠程序员的软实力来克服 CPU 自身的缺陷。于是，一个大胆的想法出现了。 16 位的寄存器最多访问到 64KB 大小的内存。虽然 1MB 内存中可容纳 1MB/64KB=16 个最大段，但 这只是可以容纳而已，并不是说可以访问到。16 位的寄存器超过 0xffff 后将会回卷到 0，又从 0 重新开始。 20 位宽度的内存地址空间必然只能由 20 位宽度的地址来访问。问题又来了，在当时只有 16 位寄存器的 情况下是如何做到访问 20 位地址空间的呢？ 这是因为 CPU 设计者在地址处理单元中动了手脚，该地址部件接到“段基址+段内偏移地址”的地址后， 自动将段基址乘以 16，即左移了 4 位，然后再和 16 位的段内偏移地址相加，这下地址变成了 20 位了吧，行啦，有了 20 位的地址便可以访问 20 位的空间，可以在 1MB 空间内自由翱翔了。</p><h2 id="代码中为什么分为代码段、数据段？这和内存访问机制中的-段是一回事吗"><a href="#代码中为什么分为代码段、数据段？这和内存访问机制中的-段是一回事吗" class="headerlink" title="代码中为什么分为代码段、数据段？这和内存访问机制中的 段是一回事吗"></a>代码中为什么分为代码段、数据段？这和内存访问机制中的 段是一回事吗</h2><blockquote><p>首先，程序不是一定要分段才能运行的，分段只是为了使程序更加优美。就像用饭盒装饭菜一样，完 全可以将很多菜和米饭混合在一起，或者搅拌成一体，哈哈，但这样可能就没什么胃口啦。如果饭盒中有 好多小格子，方便将不同的菜和饭区分存放，这样会让我们胃口大开增加食欲。 x86 平台的处理器是必须要用分段机制访问内存的，正因为如此，处理器才提供了段寄存器，用来指定待访 问的内存段起始地址。我们这里讨论的程序代码中的段（用 section 或 segment 来定义的段，不同汇编编译器提 供的关键字有所区别，功能是一样的）和内存访问机制中的段本质上是一回事。在硬件的内存访问机制中，处理 器要用硬件—段寄存器，指向软件—程序代码中用 section 或 segment 以软件形式所定义的内存段。 分段是必然的，只是在平坦模型下，硬件段寄存器中指向的内存段为最大的 4GB，而在多段模式下编 程，硬件段寄存器中指向的内存段大小不一。 对于在代码中的分段，有的是操作系统做的，有的是程序员自己划分的。如果是在多段模型下编程， 我们必然会在源码中定义多个段，然后需要不断地切换段寄存器所指向的段，这样才能访问到不同段中的 数据，所以说，在多段模型下的程序分段是程序员人为划分的。如果是在平坦模型下编程，操作系统将整 个 4GB 内存都放在同一个段中，我们就不需要来回切换段寄存器所指向的段。对于代码中是否要分段， 这取决于操作系统是否在平坦模型下。 一般的高级语言不允许程序员自己将代码分成各种各样的段，这是因为其所用的编译器是针对某个操 作系统编写的，该操作系统采用的是平坦模型，所以该编译器要编译出适合此操作系统加载运行的程序。 由于处理器支持了具有分页机制的虚拟内存，操作系统也采用了分页模型，因此编译器会将程序按内容划 分成代码段和数据段，如编译器 gcc 会把 C 语言写出的程序划分成代码段、数据段、栈段、.bss 段、堆等 部分。这会由操作系统将编译器编译出来的用户程序中的各个段分配到不同的物理内存上。对于目前咱们 用高级语言编码来说，我们之所以不用关心如何将程序分段，正是由于编译器按平坦模型编译，而程序所 依赖的操作系统又采用了虚拟内存管理，即处理器的分页机制。像汇编这种低级语言允许程序员为自己的 程序分段，能够灵活地编排布局，这就属于人为将程序分成段了，也就是采用多段模型编程。 这么说似乎不是很清楚，一会再用例子和大伙儿解释就明白了。在这之前，先和大家明确一件事。 CPU 是个自动化程度极高的芯片，就像心脏一样，给它一个初始的收缩，它将永远地跳下去。突然 想到 Intel 的广告词：给你一颗奔腾的心。 只要给出 CPU 第一个指令的起始地址，CPU 在它执行本指令的同时，它会自动获取下一条的地址， 然后重复上述过程，继续执行，继续取址。假如执行的每条指令都正确，没有异常发生的话，我想它可以 运行到世界的尽头，能让它停下来的唯一条件就是断电。 它为什么能够取得下一条指令地址？也就是说为什么知道下一条指令在哪里。这是因为程序中的指令 都是挨着的，彼此之间无空隙。有同学可能会问，程序中不是有对齐这回事吗？为了对齐，编译器在程序 中塞了好多 0。是的，对齐确实是让程序中出现了好多空隙，但这些空隙是数据间的空隙，指令间不存在 空隙，下一条指令的地址是按照前面指令的尺寸大小排下来的，这就是 Intel 处理器的程序计数器 cs：eip 能够自动获得下一条指令的原理，即将当前 eip 中的地址加上当前指令机器码的大小便是内存中下一条指 令的起始地址。即使指令间有空隙或其他非指令的数据，这也仅仅是在物理上将其断开了，依然可以用 jmp 指令将非指令部分跳过以保持指令在逻辑上连续，我们在后面会通过实例验证这一原理。 为了让程序内指令接连不断地执行，要把指令全部排在一起，形成一片连续的指令区域，这就是代码 段。这样 CPU 肯定能接连不断地执行下去。指令是由操作码和操作数组成的，这对于数据也一样，程序 运行不仅要有操作码，也得有操作数，操作数就是指程序中的数据。把数据连续地并排在一起存储形成的段落，就称为数据段。 指令大小是由实际指令的操作码决定的，也就是说 CPU 在译码阶段拿到了操作码后，就知道实际指令所占 的大小。其实说来说去，本质上就是在解释地址是怎么来的。</p></blockquote><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>mov ds,ax<br><span class="hljs-symbol">2 </span>mov ax,[var]<br><span class="hljs-symbol">3 </span>label：<br><span class="hljs-symbol">4 </span>jmp label<br><span class="hljs-symbol">5 </span>var dw <span class="hljs-number">0</span>x99 <br></code></pre></td></tr></table></figure><p>本示例一共就 5 行，简单纯粹为演示。将其编译为二进制文件，程序内容是： </p><blockquote><p>8E D8 A1 07 00 EB FE 99 00</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210222234118777.png" alt="image-20210222234118777"></p><p> 0-1 第 1 行，地址 0 处的指令是“mov ds，ax”，其机器码是 8ED8，这是十六进制表示，可见其大 小是 2 字节。前面说过，下一条指令的地址是按照前面指令的尺寸排下来的，那第 2 行指令的起始地址是 0+2=2。在第 2 行的地址列中，地址确实是 2。这不是我故意写上去的，编译器真的就是这样编排的。第 2 列的指令是“mov ax，[0x7]”（0x7 是变量 var 经过编译后的地址），其机器码是 A10700，这是 3 字节大小。 所以第 3 条指令的地址是 2+3=5。后面的指令地址也是这样推算的。程序虽然很短，但麻雀虽小，五脏俱 全，完美展示了程序中代码紧凑无隙的布局。 现在大伙儿明白为什么 CPU 能源源不断获取到指令了吧，如前所述，原因首先是指令是连续紧凑的， 其次是通过指令机器码能够判断当前指令长度，当前指令地址+当前指令长度=下一条指令地址。 上面给出的例子，其指令在物理上是连续的，其实在 CPU 眼里，只要指令逻辑上是连续的就可以，没必要 一定得是物理上连续。所以，明确一点，即使数据和代码在物理上混在一起，程序也是可以运行的，这并不意味 着指令被数据“断开”了。只要程序中有指令能够跨过这些数据就行啦，最典型的就是用 jmp 跳过数据区。 比如这样的汇编代码：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>jmp start ;跳转到第三行的 start，这是 CPU 直接执行的指令<br><span class="hljs-symbol">2 </span>var dd <span class="hljs-number">1</span> ;定义变量 var 并赋值为 <span class="hljs-number">1</span>。分配变量不是 CPU 的工作 ;汇编器负责分配空间并为变量编址<br><span class="hljs-symbol">3 </span>start： ;标号名为 start，会被汇编器翻译为某个地址<br><span class="hljs-symbol">4 </span>mov ax,<span class="hljs-number">0</span> ；将 ax 赋值为 <span class="hljs-number">0</span> <br></code></pre></td></tr></table></figure><p>这几行代码没有实际意义，只是为了解释清楚问题，咱们只要关注在第 2 行的定义变量 var 之前为什 么要 jmp start。如果将上面的汇编代码按纯二进制编译，如果不加第 1 行的 jmp，CPU 也许会发出异常， 显示无效指令，也许不知道执行到哪里去了。因为 CPU 只会执行 cs：ip 中的指令，这两个寄存器记录的 是下一条待执行指令的地址，下一个地址 var 处的值为 1，显然我们从定义中看出这只是数据，但指令和 数据都是二进制数字，CPU 可分不出这是指令，还是数据。保不准某些“数据”误打误撞恰恰是某种指 令也说不定。既然 var 是我们定义的数据，那么必须加上 jmp start 跳过这个 var 所占的空间才可以。</p><blockquote><p>加个 jmp 指令，这样做一点都不影响运行，只不过这样写出来的程序，其中引用的地址大部分是不连 续的，也就是程序在取地址时会显得跳来跳去。就美观层面上看，这样的结构显得很凌乱，不利于程序员 阅读与维护。如果把第 2 行的 var 换到第 1 行，数据和代码就分开了，没有混在一起，标号都不用了，代 码简洁多了，如下。</p></blockquote><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">var <span class="hljs-built_in">dd</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span> <br></code></pre></td></tr></table></figure><p>做过开发的同学都清楚，尽量把同一属性的数据放在一起，这样易于维护。这一点类似于 MVC，在程序 逻辑中把模型、视图、控制这三部分分开，这样更新各部分时，不会影响到其他模块。 将数据和代码分开的好处有三点。 第一，可以为它们赋予不同的属性。 例如数据本身是需要修改的，所以数据就需要有可写的属性，不让数据段可写，那程序根本就无法执 行啦。程序中的代码是不能被更改的，这样就要求代码段具备只读的属性。真要是在运行过程中程序的下 一条指令被修改了，谁知道会产生什么样的灾难。 第二，为了提高 CPU 内部缓存的命中率。 大伙儿知道，缓存起作用的原因是程序的局部性原理。在 CPU 内部也有缓存机制，将程序中的指令 和数据分离，这有利于增强程序的局部性。CPU 内部有针对数据和针对指令的两种缓存机制，因此，将 数据和代码分开存储将使程序运行得更快。 第三，节省内存。 程序中存在一些只读的部分，比如代码，当一个程序的多个副本同时运行时（比如同时执行多个 ls 命令时），没必要在内存中同时存在多个相同的代码段，这将浪费有限的物理内存资源，只要把这一个代 码段共享就可以了。 后两点较容易理解，咱们深入讨论下第一点，不知您有没有想过，数据段或代码段的属性是谁给添加上的呢， 是谁又去根据属性保护程序的呢，是程序员吗？是编译器吗？是操作系统吗？还是 CPU 一级的硬件支持？ 首先肯定不是程序员，人家操作系统设计人员为了让程序员编写程序更加容易，肯定不会让他们分心去 处理这些与业务逻辑无关的事。看看编译器为我们做了什么，它将程序中那些只读的代码编译出来后，放在 一片连续的区域，这个区域叫代码段。将那些已经初始化的数据也放在一片连续的区域，这个区域叫数据段， 那些具有全局属性的但又未初始化的数据放在 bss 段。总之，程序中段的类型可多了，用“readelf –e elf”命 令便可以看到很多段的类型，感兴趣的读者请自行查阅。好了，编译器的工作到此就完事了，显然，数据段 和代码段的属性到现在还没有体现出来。 先看 CPU 为我们提供了哪些原生的支持。在保护模式下，有这样一个数据结构，它叫全局描述符表（Global Descriptor Table，GDT），这个表中的每一项称为段描述符。先递归学习一下，什么是描述符？描述符就是描 述某种数据的数据结构，是元信息，属于数据的数据。就像人们的身份证，上面有写性别、出生日期、地址等 描述个人情况的信息。在段描述符中有段的属性位，在以后的章节中可以看到，其实是有 2 个，一个是 S 字 段，占 1bit 大小，另外一个是占 4bit 大小的 TYPE 字段，这两个字段配合在一起使用就能组合出各种属性， 如只读、向下扩展、只执行等。提供归提供，可得有人去填写这张表啊，谁来做这事呢，有请操作系统登场。 接着看操作系统为我们做了什么。 操作系统在让 CPU 进入保护模式之前，首先要准备好 GDT，也就是要设置好 GDT 的相关项，填写好 段描述符。段描述符填写成什么样，段具备什么样的属性，这完全取决于操作系统了，在这里大家只要知道， 段描述符中的 S 字段和 TYPE 字段负责该段的属性，也就是该属性与安全相关。 说到这里，答案似乎浮出水面了。 （1）编译器负责挑选出数据具备的属性，从而根据属性将程序片段分类，比如，划分出了只读属性的 代码段和可写属性的数据段。再补充一下，编译器并没有让段具备某种属性，对于代码段，编译器所做的 只是将代码归类到一起而已，也就是将程序中的有关代码的多个 section 合并成一个大的 segment（这就是 我们所说的代码段），它并没有为代码段添加额外的信息。</p><p>（2）操作系统通过设置 GDT 全局描述符表来构建段描述符，在段描述符中指定段的位置、大小及属 性（包括 S 字段和 TYPE 字段）。也就是说，操作系统认为代码应该是只读的，所以给用来指向代码段的 那个段描述符设置了只读的属性，这才是真正给段添加属性的地方。 （3）CPU 中的段寄存器提前被操作系统赋予相应的选择子（后面章节会讲什么是选择子，暂时将其 理解为相当于段基址），从而确定了指向的段。在执行指令时，会根据该段的属性来判断指令的行为，若 有返回则发出异常。 总之，编译器、操作系统、CPU 三个配合在一起才能对程序保护，检测出指令中的违规行为。如果 GDT 中的代码段描述符具备可写的属性，那编译器再怎么划分代码段都没有用，有判断权利的只有 CPU。 好，现在大家对 GDT 有个感性认识，随着以后章节中讲 GDT 的时候，大家就会有深刻的理解了。 以上说明了程序按内容分段的原因，那么编译器编译出来的段和内存访问中的段是一回事吗？ 其实算一回事，也不算一回事。怎么说呢，我觉得当初 Intel 公司在设计 CPU 时，其采用分段机制访问内 存的原因，肯定不是为了上层软件的优美，毕竟那只是逻辑上的东西。那为什么也算一回事呢？ 分析一下，编译出来的代码段是指一片连续的内存区域。这个段有自己的起始地址，也有自己的大小 范围。用户进程中的段，只是为了便于管理，而编译器或程序员在“美学方面”做出的规划，本质上它并 不是 CPU 用于内存访问的段，但它们都是描述了一段内存，而且程序中的段，其起始地址和大小可以理 解为 CPU 访问内存分段策略中的“段基址：段内偏移地址”，这么说来，至少它们很接近了，让我们更近 一步：程序是可以被人为划分成段的，并且可以将划分出来的段地址加载到段寄存器中，见下面的代码</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"> <span class="hljs-number">1</span> <span class="hljs-meta">section</span> my_code vstart=<span class="hljs-number">0</span><br> <span class="hljs-number">2</span> <span class="hljs-comment">;通过远跳转的方式给代码段寄存器 CS 赋值 0x90</span><br> <span class="hljs-number">3</span> <span class="hljs-keyword">jmp</span> <span class="hljs-number">0x90</span>:start<br> <span class="hljs-number">4</span> start: <span class="hljs-comment">;标号 start 只是为了 jmp 跳到下一条指令</span><br> <span class="hljs-number">5</span><br> <span class="hljs-number">6</span> <span class="hljs-comment">;初始化数据段寄存器 DS</span><br> <span class="hljs-number">7</span> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-meta">section</span><span class="hljs-number">.</span>my_data<span class="hljs-number">.</span>start<br> <span class="hljs-number">8</span> <span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0x900</span> <span class="hljs-comment">;加 0x900 是因为本程序会被 mbr 加载到内存 0x900 处</span><br> <span class="hljs-number">9</span> <span class="hljs-keyword">shr</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4</span> <span class="hljs-comment">;提前右移 4 位,因为段基址会被 CPU 段部件左移 4 位</span><br><span class="hljs-number">10</span> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-number">11</span><br><span class="hljs-number">12</span> <span class="hljs-comment">;初始化栈段寄存器 SS</span><br><span class="hljs-number">13</span> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-meta">section</span><span class="hljs-number">.</span>my_stack<span class="hljs-number">.</span>start<br><span class="hljs-number">14</span> <span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0x900</span> <span class="hljs-comment">;加 0x900 是因为本程序会被 mbr 加载到内存 0x900 处</span><br><span class="hljs-number">15</span> <span class="hljs-keyword">shr</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4</span> <span class="hljs-comment">;提前右移 4 位,因为段基址会被 CPU 段部件左移 4 位</span><br><span class="hljs-number">16</span> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-number">17</span> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>,stack_top <span class="hljs-comment">;初始化栈指针</span><br><span class="hljs-number">18</span><br><span class="hljs-number">19</span> <span class="hljs-comment">;此时 CS､ DS､ SS 段寄存器已经初始化完成,下面开始正式工作</span><br><span class="hljs-number">20</span> <span class="hljs-keyword">push</span> <span class="hljs-built_in">word</span> [var2] <span class="hljs-comment">;变量名 var2 编译后变成 0x4</span><br><span class="hljs-number">21</span> <span class="hljs-keyword">jmp</span> $<br><span class="hljs-number">22</span><br><span class="hljs-number">23</span> <span class="hljs-comment">;自定义的数据段</span><br><span class="hljs-number">24</span> <span class="hljs-meta">section</span> my_data <span class="hljs-meta">align</span>=<span class="hljs-number">16</span> vstart=<span class="hljs-number">0</span><br><span class="hljs-number">25</span> var1 <span class="hljs-built_in">dd</span> <span class="hljs-number">0x1</span><br><span class="hljs-number">26</span> var2 <span class="hljs-built_in">dd</span> <span class="hljs-number">0x6</span><br><span class="hljs-number">27</span><br><span class="hljs-number">28</span> <span class="hljs-comment">;自定义的栈段</span><br><span class="hljs-number">29</span> <span class="hljs-meta">section</span> my_stack <span class="hljs-meta">align</span>=<span class="hljs-number">16</span> vstart=<span class="hljs-number">0</span><br><span class="hljs-number">30</span> <span class="hljs-built_in">times</span> <span class="hljs-number">128</span> <span class="hljs-built_in">db</span> <span class="hljs-number">0</span><br><span class="hljs-number">31</span> stack_top: <span class="hljs-comment">;此处用于栈顶,标号作用域是当前 section,;以当前 section 的 vstart 为基数</span><br></code></pre></td></tr></table></figure><p>其中自定义了三个段，为了和标准的段名（.code、.data 等）有所区 别，这里代码段取名为 my_code，数据段取名为 my_data，栈段取名为 my_stack。这段代码是由 MBR 加 载到物理内存地址 0x900 后，mbr 通过“jmp 0x900”跳过来的，我们的想法是让各段寄存器左移 4 位后 的段基址与程序中各分段实际内存位置相同，所以对于代码段，希望其基址是 0x900，故代码段 CS 的值 为 0x90（在实模式下，由 CPU 的段部件将其左移 4 位后变成 0x900，所以要初始化成左移 4 位前的值）。</p><blockquote><p>但没有办法直接为 CS 寄存器赋值，所以在代码 0-1 开头，用“jmp 0x90：0”初始化了程序计数器 CS 和 IP。这样段寄存器 CS 就是程序中咱们自己划分的代码段了。 在此提醒一下，各 section 中的定义都有 align=16 和 vstart=0，这是用来指定各 section 按 16 位对齐的， 各 section 的起始地址是 16 的整数倍，即用十六进制表示的话，最后一位是 0。所以右移操作如第 9 行的 shr ax，4，结果才是正确的，只是把 0 移出去了。否则不加 align=16 的话，section 的地址不能保证是 16 的整数倍，右移 4 位可能会丢数据。vstart=0 是指定各 section 内数据或指令的地址以 0 为起始编号，这样 做为段内偏移地址时更方便。具体 vstart 内容请参阅本书相应章节。 第 6～10 行是初始化数据段寄存器 DS，是用程序中自已划分的段 my_data 的地址来初始化的。由于 代码 0-1 本身是脱离操作系统的程序，是 MBR 将其加载到 0x900 后通过跳转指令“jmp 0x900”跳入执行 的，所以要将 my_data 在文件内的地址 section.my_data.start 加上 0x900 才是最终在内存中的真实地址。右 移 4 位的原因同代码段相同，都是 CPU 的段部件会自动将段基址左移 4 位，故提前右移 4 位。此地址作 为段基址赋值给 DS，这样段寄存器 DS 中的值是程序中咱们自己划分的数据段了。 第 12～17 行是初始化栈段寄存器，原理和数据段差不多，唯一区别是栈段初始化多了个针指针 SP， 为它初始化的值 stack_top 是最后一行，因为栈指针在使用过程中指向的地址越来越低，所以初始化时一 定得是栈段的最高地址。 经过代码段、数据段、栈段的初始化，CPU 中的段寄存器 CS、DS、SS 都是指向程序中咱们自己划 分的段地址，之后 CPU 的内存分段机制“段基址：段内偏移地址”，段基址就是程序中咱们自己划分的段， 段内偏移地址都是各自定义段内的指令和数据地址，由于在 section 中有 vstart=0 限制，地址都是从 0 开始 编号的。所以，程序中的分段和 CPU 内存访问的分段又是一回事。 让我们对此感到疑惑的原因，可能是我们一般都是用高级语言开发程序，在高级语言中，程序分 段这种工作不由我们控制，是由编译器在编译阶段完成的。而且现代操作系统都是在平坦模型（整个 4GB 空间为 1 个段）下工作，编译器也是按照平坦模型为程序布局，程序中的代码和数据都在同一个 段中整齐排列。大家可以用 readelf –e /bin/ls 查看一下 ls 命令，结果太长，就不截图啦。咱们主要关 注三段内容。 y Section Headers：列出了程序中所有的 section，这些 section 是 gcc 编译器帮忙划分的。 y Program Headers：列出了程序中的段，即 segment，这是程序中 section 合并后的结果。 y Section to Segment mapping：列出了一个 segment 中包含了哪些 section。 有关 section 和 segment 的内容请参见本书相关章节。 在 Section Headers 和 Program Headers 中您会发现，这些分段都是按照地址由低到高在 4GB 空间中连 续整洁地分布的，在平坦模型下和谐融洽。 显然，不用程序员手工分段，并且采用平坦模型，这种操作上的“隔离”固然让我们更加方便，但也让我 们更加感到进程空间布局的神秘。如果程序分段像代码 0-1 那样地直白、亲民，大家肯定不会感到迷惑了。其实 我想说的是无论是否为平坦模型，程序中的分段和 CPU 中的内存分段机制，它们属于物品与容器的关系。 举个例子，程序中划分的段相当于各种水果，比如代码段相当于 香蕉，数据段相当于葡萄，栈段相当于西瓜。CPU 内存分段策略中的 段寄存器相当于盛水果的盘子。可以用一个大盘子将各种水果都放进 来，但依然是分门别类地摆放，不能失去美感混成一锅粥，这就是段 大小为 4GB 的平坦模型。也可以把每种水果分别放在一个小盘子里一 块儿端上来，这就是普通的分段模型，如图</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210222234447598.png" alt="image-20210222234447598"></p><blockquote><p>总结一下，程序中的段只是逻辑上的划分，用于不同数据的归类， 但是可以用 CPU 中的段寄存器直接指向它们，然后用内存分段机制去 访问程序中的段，在这一点上看，它们很像相片和相框的关系：程序 中的段是内存中的内容，相当于相片，属于被展示的内容，而内存分段机制则是访问内存的手段，相当于 相框，有了相框，照片才能有地摆放。</p></blockquote><p><code>内存分段指的是处理器为 访问内存而采用的机制，称之为内存分段机制，程序分段是软件中人为逻辑划分的内存区域，它本身也是 内存，所以处理器在访问该区域时，也会采用内存分段机制，用段寄存器指向该区域的起始地址。</code></p><h2 id="物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别"><a href="#物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别" class="headerlink" title="物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别"></a>物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别</h2><p>物理地址就是物理内存真正的地址，相当于内存中每个存储单元的门牌号，具有唯一性。不管在什么模式下， 不管什么虚拟地址、线性地址，CPU 最终都要以物理地址去访问内存，只有物理地址才是内存访问的终点站。 在实模式下，“段基址+段内偏移地址”经过段部件的处理，直接输出的就是物理地址，CPU 可以直 接用此地址访问内存。 而在保护模式下，“段基址+段内偏移地址”称为线性地址，不过，此时的段基址已经不再是真正的地址 了，而是一个称为选择子的东西。它本质是个索引，类似于数组下标，通过这个索引便能在 GDT 中找到相应 的段描述符，在该描述符中记录了该段的起始、大小等信息，这样便得到了段基址。若没有开启地址分页功能， 此线性地址就被当作物理地址来用，可直接访问内存。若开启了分页功能，此线性地址又多了一个名字，就是 虚拟地址（虚拟地址、线性地址在分页机制下都是一回事）。虚拟地址要经过 CPU 页部件转换成具体的物理地 址，这样 CPU 才能将其送上地址总线去访问内存。 无论在实模式或是保护模式下，段内偏移地址又称为有效地址，也称为逻辑地址，这是程序员可 见的地址。这是因为，最终的地址是由段基址和段内偏移地址组合而成的。由于段基址已经有默认的 啦，要么是在实模式下的默认段寄存器中，要么是在保护模式下的默认段选择子寄存器指向的段描述 符中，所以只要给出段内偏移地址就行了，这个地址虽然只是段内偏移，但加上默认的段基址，依然 足够有效。 线性地址或称为虚拟地址，这都不是真实的内存地址。它们都用来描述程序或任务的地址空间。由于 分页功能是需要在保护模式下开启的，32 位系统保护模式下的寻址空间是 4GB，所以虚拟地址或线性地 址就是 0～4GB 的范围。转换过程如图</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210222234819600.png" alt="image-20210222234819600"></p><h2 id="什么是段重叠"><a href="#什么是段重叠" class="headerlink" title="什么是段重叠"></a>什么是段重叠</h2><blockquote><p>依然假设在实模式下（并不是说在保护模式下就不存在段重叠，只是这样就会少解释了相关数据结构， 如段描述符，不过这不重要，原理是一样的），一个段最大为 64KB，其大小由段内偏移地址寻址范围决定， 也就是 2 的 16 次方。其起始位置由段基地址决定。CPU 的内存寻址方式是：给我一个段基址，再给我一 个相对于该段起始位置的偏移地址，我就能访问到相应内存。 它并不要求一个内存地址只隶属于某一个段，所以在上面的 图 0-2 中，欲访问内存 0xC03，段基址可以选择 0xC00，0xC01， 0xC02，0xC03，只不过是段内偏移量要根据段基地址来调整 罢了。用这种“段基地址：段内偏移”的组合，0xC00：3 和 0xC02：1 是等价的，它们都访问到同一个物理内存块。但段 的大小决定于段内偏移地址寻址范围，假设段 A 的段基址是 从 0xC00 开始，段 B 的段基址是从 0xC02 开始，在 16 位宽 度的寻址范围内，这两个段都能访问到 0xC05 这块内存。用 段 A 去访问，其偏移为 5，用段 B 去访问，其偏移量为 3。 这样一来，用段 B 和段 A 在地址 0xC02 之后，一直到段 B 偏移地址为 0xfffe 的部分，像是重叠在一起了，这就是段重 叠了，如图</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210222234910886.png" alt="image-20210222234910886"></p><h2 id="什么是平坦模型"><a href="#什么是平坦模型" class="headerlink" title="什么是平坦模型"></a>什么是平坦模型</h2><blockquote><p>平坦模型是相对于多段模型来说的，所以说平坦模型指的就是一个段。比如在实模式下，访问超过 64KB 的内存，需要重新指定不同的段基址，通过这种迂回变通的方式才能达到目的。在保护模式下， 由于其是 32 位的，寻址范围便能够达到 4GB，段内偏移地址也是地址，所以也是 32 位。可见，在 32 位环境下用一个段就能够访问到硬件所支持的所有内存。也就是说，段的大小可以是地址总线能够到达 的范围。既然平坦模型是相对于多段模型来说的，为什么不称为单段模型，而称为平坦呢，我估计很多 读者已经明白了，用多个小段再加上不断换段基址的方式访问内存确实够麻烦的，可能换着换着就晕了， 别忘记了，这种多段模型为了访问到 1MB 地址空间，还需要额外打开 A20 地址线呢，这种访存方式本 身就是种补救措施，相当于给硬件打了个补丁，既然是补丁，访问内存的过程必然是不顺畅的。相对于 那么麻烦的多段模型，平坦模型不需要额外打开 A20 地址线，不需要来回切换段基址就可以在地址空间 内任意翱翔。如果把内存段比喻成小格子的话，平坦模型下的内存访问，没有众多小格子成为羁绊，可 谓一路“平坦”。 所以“平坦”这两个字，突显了当时的程序员受多段模型折磨之苦，迫不及待地想表达其优势的喜 悦之情。</p></blockquote><h2 id="cs、ds-这类-sreg-段寄存器，位宽是多少"><a href="#cs、ds-这类-sreg-段寄存器，位宽是多少" class="headerlink" title="cs、ds 这类 sreg 段寄存器，位宽是多少"></a>cs、ds 这类 sreg 段寄存器，位宽是多少</h2><p>CPU 中存在段寄存器是因为其内存是分段访问的，这是设计之初决定的，属于基因里的东西。前面 已经介绍过了内存分段访问的方法，这里不再赘述。 CPU 内部的段寄存器（Segment reg）如下。 </p><p>（1）CS—代码段寄存器（Code Segment Register），其值为代码段的段基值。</p><p>（2）DS—数据段寄存器（Data Segment Register），其值为数据段的段基值。 </p><p>（3）ES—附加段寄存器（Extra Segment Register），其值为附加数据段的段基值，称为“附加”是 因为此段寄存器用途不像其他 sreg 那样固定，可以额外做他用。 </p><p>（4）FS—附加段寄存器（Extra Segment Register），其值为附加数据段的段基值，同上，用途不固定， 使用上灵活机动。 </p><p>（5）GS—附加段寄存器（Extra Segment Register），其值为附加数据段的段基值。 </p><p>（6）SS—堆栈段寄存器（Stack Segment Register），其值为堆栈段的段值。 32 位 CPU 有两种不同的工作模式：实模式和保护模式。 </p><blockquote><p>每种模式下，段寄存器中值的意义是不同的，但不管其为何值，在段寄存器中所表达的都是指向的段 在哪里。在实模式下，CS、DS、ES、SS 中的值为段基址，是具体的物理地址，内存单元的逻辑地址仍为 “段基值：段内偏移量”的形式。在保护模式下，装入段寄存器的不再是段地址，而是“段选择子”（Selector）， 当然，选择子也是数值，其依然为 16 位宽度。 可见，在 32 位 CPU 中，sreg 无论是工作在 16 位的实模式，还是 32 位的保护模式，用的段寄存器都 是同一组，并且在 32 位下的段选择子是 16 位宽度，排除了段寄存器在 32 位环境下是 32 位宽的可能，综 上所述，sreg 都是 16 位宽。</p></blockquote><h2 id="为什么-Linux-系统下的应用程序不能在-Windows-系统下运行"><a href="#为什么-Linux-系统下的应用程序不能在-Windows-系统下运行" class="headerlink" title="为什么 Linux 系统下的应用程序不能在 Windows 系统下运行"></a>为什么 Linux 系统下的应用程序不能在 Windows 系统下运行</h2><p>其实，Windows 下的程序也无法直接在 Linux 下运行。 对于这个问题，很多同学都会马上给出答案：格式不同。其实……答对啦，确实是格式不同，不过这只 是一方面，还有另一方面，系统 API 不同，API 即 Application Programming Interface，应用程序编程接口。 先说说格式。其实格式也算是协议，就是在某个固定的位置有固定意义的数据。Linux 下的可执行程序格式 是 elf，也就是 “Executable and Linking Format”平时咱们用 readelf 命令可以查看 elf 文件头，里面有节（section） 信息、段（segment）信息、程序入口（entry_point）、哪个段由哪些节组成等信息。 而 Windows 下的可执行程序是 PE 格式（portable executable，可移植的可执行文件），因为我没了解 过，所以具体文件头咱们就不关注了，有兴趣的同学自行查看。 那如果 Linux 支持了 PE 格式就可以运行 Wndows 程序了吗？也不行，因为在上面说过了，还有系统 API 不同。Linux 中的 API 称为系统调用，是通过 int 0x80 这个软中断实现的。而 Windows 中的 API 是存 放在动态链接库文件中的，也就是 Windows 开发人员常说的 DLL，即 Dynamic Link Library 的缩写。LL 是 一个库，里面包含代码和数据，可供用户程序调用，DLL 不是可执行文件，不能够单独运行。也就是说， Linux 中的可执行程序获得系统资源的方法和 Windows 不一样，所以显然是不能在 Windows 中运行的。 除以上原因外，这还和编译器、标准库有关，不再列举。</p><h2 id="局部变量和函数参数为什么要放在栈中"><a href="#局部变量和函数参数为什么要放在栈中" class="headerlink" title="局部变量和函数参数为什么要放在栈中"></a>局部变量和函数参数为什么要放在栈中</h2><blockquote><p>局部变量，顾名思义其作用域属于局部，并不是像 static 那样属于全局性的。全局的变量，意味着谁 都可以随时随地访问，所以其放在数据段中。而局部变量只是自己在用，放在数据段中纯属浪费空间，没有必 要，故将其放在自己的栈中，随时可以清理，真正体现了局部的意义。这个就是堆栈框架，提到了就说一点吧， 栈由于是向下生长的，堆栈框架就是把 esp 指针提前加一个数，原 esp 指针到新 esp 指针之间的栈空间用来存 储局部变量。解释一个概念，堆是程序运行过程中用于动态内存分配的内存空间，是操作系统为每个用户进程 规划的，属于软件范畴。栈是处理器运行必备的内存空间，是硬件必需的，但又是由软件（操作系统）提供的。</p></blockquote><blockquote><p>堆是堆，而堆栈就是栈，和堆没关系，只是都这么叫。栈和堆栈都是指的栈，在 C 程序的内存布局中，由于 堆和栈的地址空间是接壤的，栈从高地址往低地址发展，堆是从低地址往高地址发展，堆和栈早晚会碰头，它 们各自的大小取决于实际的使用情况，界限并不明朗，所以这可能是堆栈常放在一直称呼的原因吧。 函数参数为什么会放到栈区呢？第一也是其局部性导致的，只有这个函数用这个参数，何必将其放在 数据段呢。第二，这是因为函数是在程序执行过程中调用的，属于动态的调用，编译时无法预测会何时调 用及被调用的次数，函数的参数及返回值都需要内存来存储，如果是递归调用的话，参数及返回值需要的 内存空间也就不确定了，这取决于递归的次数。也许这么说您也依然觉得费解，如果完全明白，需要了解 一下编译原理，很多知识都是通过实践后才搞明白的。当然我不是说让您为了搞明白这个问题而去尝试写 个编译器。 总之，在函数的编译阶段根本无法确定它会被调用几次，其参数和函数的返回地址也要内存来存储， 所以也不知道其会需要多少内存。我想，即使神通广大的编译器设计者可以预测这些了，那提前准备好内 存也是一种浪费，而且您想啊，在系统中可用内存紧缺的情况下，提前把内存分配给目前并不使用内存的 进程（只因为要存储其函数参数），而眼前需要内存的程序若无内存可用，引用罗永浩老师的一句话：“我 想不到比这个更伤感的事情了”所以编译器为了让世界更美好一些，选择将为函数参数动态分配内存，也 就是在每次调用函数时才为它在栈中分配内存。</p></blockquote><h2 id="为什么说汇编语言比-C-语言快"><a href="#为什么说汇编语言比-C-语言快" class="headerlink" title="为什么说汇编语言比 C 语言快"></a>为什么说汇编语言比 C 语言快</h2><blockquote><p>首先说这是谬论（有没有想喷我的冲动？大人且慢，请听我慢慢道来）。 不管用什么语言，程序最终都是给 CPU 运行的，只有 CPU 才能让程序跑起来。CPU 不知道什么是汇 编语言、C 语言，甚至 Java、PHP、Python 等，它根本不知道交给它的指令曾经经历过那么多的解释、编 译工序。不管什么语言，编译器最终翻译出来的都是机器指令。所以在这一点来说，汇编语言编译器编译 出来的机器指令和 C 编译器编译出来的机器指令无异。 那为什么还说汇编语言更快呢？ 我觉得应该说汇编语言生成的指令数更少，从而“显得”执行得快，并不是汇编语言本身有多少威 武霸气，而是因为汇编语言本身就是机器指令的符号化，意思是说，一个汇编语言中的符号对应一个机 器指令，它们是一一对应的。用汇编语言写程序就相当于直接在写机器指令，汇编语言编译器并不会添 加额外的语句，因此汇编语言写的程序会更直接，CPU 不会因多执行一些无关的指令而浪费时间，当然 会快。 再看看 C 编译器为咱们做了什么。为了让 C 程序员更加方便地编程，C 编译器在背后做了大量的工 作，不仅如此，出于通用性、易用性或者其他方面的考虑，C 编译器往往会在背后加入额外的 C 语言代码 来支撑，因此实际的 C 代码量就变得很大。另外在编译阶段，C 代码会率先被编译成汇编代码，然后再由 汇编器将汇编代码翻译成机器指令，由于 C 代码已经变得冗余了，编译出的汇编代码自然也会冗余，其 机器指令也会多很多。 大多数人愿意用 C 语言写程序是因为 C 语言强大且更容易掌握。但这份优势是有代价的。C 程序员 不用考虑切换栈，不用考虑用哪个段。这些必须要考虑的事情，程序员不考虑，只好由编译器帮着考虑了。 而且为了通用性、功能，甚至安全方面的考虑，自然在背后要多写一些代码。就拿打印字符串来说，C 语 言的 printf()，这里面的工作可多了去了，不仅要检查打印的数据类型，还要负责格式，小数点保留位数…… 而在汇编语言中只要往显存地址处 mov 一个字符就行了，字符串也就是多几个 mov 操作而已。您说，C 语 言为了让开发者用得爽，自己在背后做了多少贡献。 总结：高级语言如 C 语言为了通用性等，需要兼顾的东西比较多，往往还加入了一些额外的代码， 因此编译出来的汇编代码比较多，很多部分都是一些周边功能，并不是直接起作用的，不如用汇编语言直接 写功能相关的部分效果来得更直接，C 语言被编译成机器指令后，生成的机器指令当然也包括这些额外的部分， 相当于多执行了一些“看似没用”的指令，因此会比直接用汇编语言慢。</p></blockquote><h2 id="编译型程序与解释型程序的区别"><a href="#编译型程序与解释型程序的区别" class="headerlink" title="编译型程序与解释型程序的区别"></a>编译型程序与解释型程序的区别</h2><p>解释型语言，也称为脚本语言，如 JavaScript、Python、Perl、PHP、Shell 脚本等。它们本身是文本文 件，是某个应用程序的输入，这个应用程序是脚本解释器。 由于只是文本，这些脚本中的代码在脚本解释器看来和字符串无异。也就是说，脚本中的代码从来没真 正上过 CPU 去执行，CPU 的 cs：ip 寄存器从来没指向过它们，在 CPU 眼里只看得到脚本解释器，而这些 脚本中的代码，CPU 从来就不知道有它们的存在。这些脚本代码看似在按照开发人员的逻辑执行，本质上 是脚本解释器在时时分析这个脚本，动态根据关键字和语法来做出相应的行为。因此脚本中若出现错误，先 前正确的部分也会被正常执行，这和编译型程序有很大区别。 顺便猜想一下解释型语言是如何执行的。我们在执行一个 PHP 脚本时，其实就是启动一个 C 语言编 写出来的解释器而已，这个解释器就是一个进程，和一般的进程是没有区别的，只是这个进程的输入则是 这个 php 脚本，在 php 解释器中，这个脚本就是个长一些的字符串，根本不是什么指令代码之类。只是这 种解释器了解这种语法，按照语法规则来输出罢了。 举个例子，假设下面是文件名为 a.php 的 PHP 代码。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> 这是 php 语法中的固定开始标签<br> <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;abcd&quot;</span>； 输出字符串 abcd<br><span class="hljs-meta">?&gt;</span> 固定结束标签<br></code></pre></td></tr></table></figure><p>PHP 解释器分析文本文件 a.php 时，发现里面的 echo 关键字，将其后面的参数获取后就调用 C 语言中提供 的输出函数，如 printf（（echo 的参数））。PHP 解释器对于 PHP 脚本，就相当于浏览器对于 JavaScript 一样，不 过这个可完全是我猜测的，我不知道 PHP 解释器里面的具体工作，以上为了说清楚我的想法，请大家辩证地看。 而编译型语言编译出来的程序，运行时本身就是一个进程。它是由操作系统直接调用的。也就是由操作系 统加载到内存后，操作系统将 CS：IP 寄存器指向这个程序的入口，使它直接上 CPU 运行。总之调度器在就 绪队列中能看到此进程。而解释型程序是无法让调度器“入眼”的，调度器只会看到该脚本语言的解释器。</p><h2 id="什么是大端字节序、小端字节序"><a href="#什么是大端字节序、小端字节序" class="headerlink" title="什么是大端字节序、小端字节序"></a>什么是大端字节序、小端字节序</h2><p>内存是以字节为单位读写的，其最小的读写单位就是字节。故如果在内存中只写入一个字节，一个内 存的存储单元便可将其容纳了，只要访问这一内存地址就能够完整取出这 1 字节。可是 1 字节要能够表示的 范围只有 0～255（先只考虑无符号数），超过这个范围的数，只好用多个字节连在一起来表示。因此，在我 们的 32 位程序中，定义的数据类型很多。1 字节的数据类型只有 char 型，像 int 型要占 4 字节，double 型要 占用 8 字节。正如解决了一个问题又抛出了新的问题一样，解决了数值范围的问题，那带来的新的问题是这 么多个字节该以怎样的顺序排放呢。一个超过 255 的数字必然要占用 2 个字节以上，这两个字节，在物理内 存中，哪个在前？哪个在后？拿 0x1234 举例，数值中的高位 12 是放在内存的高地址处，还是低地址处？ 于是就产生了这两种相反的排列顺序。 （1）小端字节序是数值的低字节放在内存的低地址处，数值的高字节放在内存的高地址。 （2）大端字节序是数值的低字节放在内存的高地址处，数值的高字节放在内存的低地址。 为了让大家理解得更直观，我在虚拟机 bochs 中操作一下，咱们看一下真正的 0x12345678 在内存中 是怎样存储的，如图 0-9 所示。 上面的 b 0x7c00 是我在内存的 0x7c00 处插入了一个断点，其实这与要说明的问题无关，怕有同学好 奇就稍带说一句，因为 0x7c00 是 BIOS 把 mbr 加载到内存后会跳转过去的地址，所以在此处能停下来。 咱们只要关注 xp/4 0x200000，这是显示以物理内存 0x200000 开始处的 4 个字节，可见其为 00、00、00、 00，地址是从左到右逐渐升高的，其中每一对 00 就占用 1 个字节，它们的值都是 0。现在用 setpmem 命令 在该地址处写入 0x12345678 后，再用 xp/4 命令查看内存地址 0x200000 处的内容，可见已经不是 4 个 00 了， 由内存的低地址到高地址，依次变成了 0x78、0x56、0x34、0x12。这说明 bochs 模拟的 x86 体系结构虚拟 机是小端字节序，即数值上的低字节 0x78 在物理内存上的低地址，其他数值也依次符合小端字节序。 选择哪种字节序，这是硬件厂商考虑的问题，对于这种二选一的选择，选择了一方的时候，就必然丢 了另一方。 看看这两种字节序的优势。 （1）小端：因为低位在低字节，强制转换数据型时不需要再调整字节了。 （2）大端：有符号数，其字节最高位不仅表示数值本身，还起到了符号的作用。符号位固定为第一字 节，也就是最高位占据最低地址，符号直接可以取出来，容易判断正负。 简要说明一下小端的优势。因为在做强制数据类型转换时，如果转换是由低精度转向高精度，这数值 本身没什么变化，如 short 是 2 字节，将其转换为 4 字节的 int 类型，无非是由 0x1234 变成了 0x00001234， 数值上是不变的，只是存储形式上变了。如果转换是高精度转向低精度，也就是多个字节的数值要减少一 些存储字节，这必然是要丢弃一部分数值。编译器的转换原则是强制转换到低精度类型，丢弃数值的高字 节位，只保留数值的低字节，如图</p><p><img src="/home/mikey/snap/typora/33/.config/Typora/typora-user-images/image-20210222235457553.png" alt="image-20210222235457553"></p><p>由图 0-10 上输出可见，0x12345678 由 4 字节的 int 型强制转向了 2 字节的 short 型后，只保留了低字 节的 0x5678。 对于大端的优势，就硬件而言，就是符号位的判断变得方便了。最高位在最低地址，也就是直接就可以 取到了，不用再跨越几个字节，减少了时钟周期。另外，对于人类来说，还是大端看上去顺眼，毕竟咱们存 储 0x12345678 到内存时，它在内存中的存储顺序也是 0x12345678，而不是 0x78563412，这样看上去才直观。 常见 CPU 的字节序如下。</p><p>（1）大端字节序：IBM、Sun、PowerPC。 （2）小端字节序：x86、DEC。 ARM 体系的 CPU 则大小端字节序通吃，具体用哪类字节序由硬件选择。 字节序不仅是在 CPU 访问内存中的概念，而且也包括在文件存储和网络传输中。bmp 格式的图片就 属于小端字节序，而 jpeg 格式的图片则为大端字节序，这没什么可说的，采用什么序列完全是开发者设 计产品时的需要。 网络字节序就是大端字节序，所以在 x86 架构上的程序在发送网络数据时，要转换字节顺序。 关于字节序就介绍到这里，读者若觉得意犹未尽可以自行查阅。</p><h2 id="BIOS-中断、DOS-中断、Linux-中断的区别"><a href="#BIOS-中断、DOS-中断、Linux-中断的区别" class="headerlink" title="BIOS 中断、DOS 中断、Linux 中断的区别"></a>BIOS 中断、DOS 中断、Linux 中断的区别</h2><p>在计算机系统中，无论是在实模式，还是在保护模式，在任何情况下都会有来自外部或内部的事件发生。 如果事件来自于 CPU 内部就称为异常，即 Exception。例如，CPU 在计算算法时，发现分母为 0，就抛出了除 0 异常。如果事件来自于外部，也就是该事件由外部设备发出并通知了 CPU，这个事件就称为异常。 BIOS 和 DOS 都是存在于实模式下的程序，由它们建立的中断调用都是建立在中断向量表（Interrupt Vector Table，IVT）中的。它们都是通过软中断指令 int 中断号来调用的。 中断向量表中的每个中断向量大小是 4 字节。这 4 字节描述了一个中断处理例程（程序）的段基址和 段内偏移地址。因为中断向量表的长度为 1024 字节，故该表最多容纳 256 个中断向量处理程序。计算机 启动之初，中断向量表中的中断例程是由 BIOS 建立的，它从物理内存地址 0x0000 处初始化并在中断向 量表中添加各种处理例程。 BIOS 中断调用的主要功能是提供了硬件访问的方法，该方法使对硬件的操作变得简单易行。这句话 是否也表明了不通过 BIOS 调用也是可以访问硬件的？必须是的，否则 BIOS 中断处理程序又是如何操作 硬件呢？操作硬件无非是通过 in/out 指令来读写外设的端口，BIOS 中断程序处理是用来操作硬件的，故 该处理程序中一定到处都是 in/out 指令。 BIOS 为什么添加中断处理例程呢？ （1）给自己用，因为 BIOS 也是一段程序，是程序就很可能要重复性地执行某段代码，它直接将其写 成中断函数，直接调用多省心。 （2）给后来的程序用，如加载器或 boot loader。它们在调用硬件资源时就不需要自己重写代码了。 BIOS 是如何设置中断处理程序的呢？ BIOS 也要调用别人的函数例程。 BIOS 够底层吧？难道它还要依赖别人？是啊，BIOS 也是软件，也要有求于别人。首先硬件厂商为了 让自己生产的产品易用，肯定事先写好了一组调用接口，必然是越简单越好，直接给接口函数传一个参数， 硬件就能返回一个输出，如果不易用的话，厂商肯定倒闭了。 那这些硬件自己的接口代码在哪里呢？ 每个外设，包括显卡、键盘、各种控制器等，都有自己的内存（主板也有自己的内存，BIOS 就存放 在里面），不过这种内存都是只读存储器 ROM。硬件自己的功能调用例程及初始化代码就存放在这 ROM 中。根据规范，第 1 个内存单元的内容是 0x55，第 2 个存储单元是 0xAA，第 3 个存储单位是该 rom 中以 512 字节为单位的代码长度。从第 4 个存储单元起就是实际代码了，直到第 3 个存储单元所示的长度为止。 有问题了，CPU 如何访问到外设的 ROM 呢？ 访问外设有两种方式。 （1）内存映射：通过地址总线将外设自己的内存映射到某个内存区域（并不是映射到主板上插的内存条中）。 （2）端口操作：外设都有自己的控制器，控制器上有寄存器，这些寄存器就是所谓的端口，通过 in/out 指令读写端口来访问硬件的内存。 控制显卡用的便是内存映射+端口操作的方式。从内存的物理地址 0xA0000 开始到 0xFFFFF 这部分内存中，一部分是专门用来做映射的，如果硬件 存在，硬件自己的 ROM 会被映射到这片内存中的某处，至于如何映射过去的，咱们暂时先不要深入了， 这是硬件完成的工作。 如图 0-11 所示，BIOS 在运行期间会扫描 0xC0000 到 0xE0000 之间的内存，若在某个区域发现前两个字 节是 0x55 和 0xAA 时，这意味着该区域对应的 rom 中有代码存在，再对该区域做累加和检查，若结果与第 3 个字节的值相符，说明代码无误，就从第 4 个字节进入。这时开始执行了硬件自带的例程以初始化硬件自身， 最后，BIOS 填写中断向量表中相关项，使它们指向硬件自带的例程。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210222235628230.png" alt="image-20210222235628230"></p><p>中断向量表中第 0H～1FH 项是 BIOS 中断。 有没有新的疑问？外设的内存是如何被映射的？我也不知道，这是早期硬件工程师们大胆且天才的做 法，他们在很久以前就解决了。有知道的同学希望你告诉我，哈哈，在这里，我就先当它是我的公设了。 另外，上面说的是 BIOS 在填写中断向量表，那该表是谁创建的呢？答案就是 CPU 原生支持的，不用谁负 责创建。之前我曾说过，软件是靠硬件来运行的，软件能实现什么功能，很大程度上取决于硬件提供了哪些支持。 软件中只要执行 int 中断向量号，CPU 便会把向量号当作下标，去中断向量表中定位中断处理程序并执行。 如果哪位同学想查看下 BIOS 在中断向量表 IVT 中建立了哪些中断例程，可以在虚拟机 bochs 或 qume 中查看，我在这里贴个表，即表 0-2，大家可以先了解下。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210222235854059.png" alt="image-20210222235854059"></p><h2 id="什么是魔数"><a href="#什么是魔数" class="headerlink" title="什么是魔数"></a>什么是魔数</h2><p>魔数，magic number，这让一部分人感觉到迷惑，也让另一部分人迷惑。哈哈，两个迷惑，把我们都 搞迷惑了，作者你到底想表达什么意思啊。没错，其实魔数的本意就是让人感到迷惑的数，看到某个数， 不知道其代表何意，用东北话说，都蒙圈了。一部分人对这个概念迷惑的原因是这有什么好解释的，一种 司空见惯的东西，即使不知道是怎么来的，但由于大脑经常被其训练，对其已经形成深刻的印象，似乎理 所当然地接受了。当我向别人请教一个类似的问题时，如果被回复“这是规定”时，我就很无语。任何规 定都是出自于某种原因才做出的，很少有规定是靠拍脑门或抓阄决定的。就像国外的电视剧，一部称为一 季，季是由 season 翻译过来的，表示季节，一个时段。一个季节过去了，这和电视剧整体情节暂告一段 落是一样的，这较容易理解。 另一部分人感到迷惑的原因是真心想搞清楚概念是什么意思，我也属于这一类。 魔数，其实也称为神奇数字，我们大多数人是在学习计算机过程中接触到这个词的。它被用来为重要 的数据定义标签，用独特的数字唯一地标识该数据，这种独特的数字是只有少数人才能掌握其奥秘的“神 秘力量。” 对魔数简单的阐述就是：不明就理地出现一个数字，不知道其是什么意思，感觉看不透，猜不出，就 像魔法一样很神秘。了解一定上下文的人肯定知道是什么意思，一般局外人绞尽脑汁也不解其意。就像小 姑娘对着小伙子伸出大拇指和食指，小伙子马上就意会了，这是让我晚上 8 点在村口东边老槐树下见。 如果程序中出现这样的代码： </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> a = <span class="hljs-number">2014</span> – <span class="hljs-number">1987</span>；<br></code></pre></td></tr></table></figure><p> 根据直觉，似乎这是在求年龄，因为 2014 是和现在很接近的年份，而 1987 似乎是生日。但这只是主 观估计，万一这两个数字表示的是这个月和上个月的电表计数呢，人家在查电费不行吗……修改一下代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> birthday 1987； </span><br><span class="hljs-keyword">int</span> a = <span class="hljs-number">2014</span> – birthday；<br></code></pre></td></tr></table></figure><p> 由于 1987 用了一个宏代替，即使变量名称不改为 age，还叫作 a，大家也明确了这是在求年纪呢。 故，直接出现的一个数字，只要其意义不明确，感觉很诡异，就称之为魔数。魔数应用的地方太多了， 如 elf 文件头。 </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ELF</span> Header： Magic： <span class="hljs-number">7</span>f <span class="hljs-number">45</span> <span class="hljs-number">4</span>c <span class="hljs-number">46</span> <span class="hljs-number">01</span> <span class="hljs-number">01</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br></code></pre></td></tr></table></figure><p>这个 Magic 后面的一长串就是魔数，elf 解析器（通常是程序加载器）用它来校验文件的类型是否是 elf。 主引导记录最后的两个字节的内容是 0x55，0xaa，这表明这个扇区里面有可加载的程序，BIOS 就用 它来校验该扇区是否可引导。 有人说只要为这些数字赋予实际的意义不就行了吗。其实，无论怎么给这组陌生的数字赋予名称，它 都不像熟悉的出生日期那样直观易懂（如对于 19590318，不解释大家也会知道 0318 是 3 月 18 日），反而 还要额外增加一些内容来解释，得不偿失，所以这就是魔数不得不存在的原因。 可见，计算机中处处是协议、约定。不过为了程序意义清晰可维护性强，尽量还是少用魔数。</p><h2 id="操作系统是如何识别文件系统的"><a href="#操作系统是如何识别文件系统的" class="headerlink" title="操作系统是如何识别文件系统的"></a>操作系统是如何识别文件系统的</h2><p>我们知道，一个硬盘上可以有很多分区，每个分区的格式又可以不同。就拿 Linux 来说，既能识别 ext3， 又能识别 ext4。可能有同学会说，这两个分区的文件系统都是 Linux 自己专用的，当然认得自己的东西了。 可是自己的东西也得有个辨别的地方，否则凭什么说“认得”呢。 其实这是之前介绍过的魔数的作用，文件系统也有自己的魔数，魔数的神秘力量在此施展了。各分区 都有超级块，一般位于本分区的第 2 个扇区，比如若各分区的扇区以 0 开始索引，其第 1 个扇区便是超级 块的起始扇区。超级块里面记录了此分区的信息，其中就有文件系统的魔数，一种文件系统对应一个魔数， 比对此值便知道文件系统类型了</p><h2 id="如何控制-CPU-的下一条指令"><a href="#如何控制-CPU-的下一条指令" class="headerlink" title="如何控制 CPU 的下一条指令"></a>如何控制 CPU 的下一条指令</h2><blockquote><p>其实此问题我一直犹豫要不要写出来，因为大部人都觉得这个问题有些匪夷所思，CPU 是负责执行指令的， 它会按照程序的执行流程走，此问题的目的其实就是想知道如何牵着 CPU 的鼻子走。当初我被问这个问题时也 觉得很诧异，甚至我觉得自己可能没理解人家的意思。后来他这样跟我说：“CPU 要执行的下一条指令是在 CS： IP 寄存器吧?”我说：“是啊”。他又问：“CS 和 IP 寄存器，是用 mov 指令修改的吗？”我听后，顿时觉得他这 个问题很有意义，暗自对他有些小敬佩，我相信很多人都没想过，CS 和 IP 能不能用 mov 指令去修改。 是这样的，我们常说的用于存放下一条指令地址的寄存器称为程序计数器 PC（Program Counter）。这 个名词在我看来是个概念级别的内容，它只是 CPU 中有关下一条指令存放地址的统称，也就是说 PC 是 用来表示下一条指令的存放地址，具体的实现形式不限，后面会有所讨论。 CPU 按照指令集可以分为很多种，由于 PC 只是个概念，所以在不同种类的 CPU 中，有不同的实现。 注意啦，这里的“不同种类”不是指 CPU 品牌，而是指 CPU 体系结构，如 INTEL 和 AMD 同属 x86 构架， 如果您对此不了解，细心的我早已在下面为您准备好了体系结构、指令集的相关内容。由于此方面内容较 独立，我专门将其组织成一个小节供大伙儿参考，如果您现在感兴趣，可以先参阅“指令集、体系结构、 微架构、编程语言”这一节。 在 x86 体系结构的 CPU 中，也就是咱们大多数人使用的 INTEL 或 AMD 公司出品的桌面处理器，程 序计数器 PC 并不是单一的某种寄存器，它是一种寄存器组合，指的段寄存器 CS 和指令指令寄存器 IP。 CS 和 IP 是 CPU 待执行的下一条指令的段基址和段内偏移地址，不能直接用 mov 指令去改变它们， 我想可能的一个原因是：mov 指令一次只能改变一个寄存器，不能同时将 cs 和 ip 都改变。如果只改变了 其中一个会引起错误。如改变了 cs 的值后，ip 的值还是原先 cs 段的偏移，很难保证新的 cs 段内的偏移地 址 ip 处的指令是正确的。因此，有专门改变执行流的指令，如 jmp、call、int、ret，这些指令可以同时修 改 cs 和 ip，它们在硬件级别上实现了原子操作。 以上说的是x86体系的CPU，其他类型的CPU是怎样的呢？这就取决于具体实现啦，咱们这里拿ARM 举例，它的程序计数器有个专门的寄存器，名字就叫 PC，想要改变程序流程，直接对该寄存器赋值便可。 与 x86 不同的是在 ARM 中可以用 mov 指令来修改程序流，在 ARM 体系 CPU 的汇编器中，寄存器 的名称在汇编语言中是以“r 数字”的形式命名的，例如汇编代码：mov pc，r0，表示将寄存器 r0 中的内 容赋值给程序寄存器 PC，这样就直接改变了程序的执行流。 总结一下，程序计数器 PC 负责处理器的执行方向，它只是获取下一条指令的方法形式，在不同体系 结构的 CPU 中有不同的实现方法。</p></blockquote><h2 id="库函数是用户进程与内核的桥梁"><a href="#库函数是用户进程与内核的桥梁" class="headerlink" title="库函数是用户进程与内核的桥梁"></a>库函数是用户进程与内核的桥梁</h2><p>crt 是什么？CRT，即 C Run-Time library，是 C 运行时库。 什么是运行时库？ 运行时库是程序在运行时所需要的库，该库是由众多可复用的函数文件组成的，由编译器提供。 所以，C 运行时库，就是 C 程序运行时所需要的库文件，在我们的环境中，它由 gcc 提供。 大家这下应该明白了，我们在程序中简单地一句 include &lt;标准头文件&gt;之所以有效，是因为编译器提供 的 C 运行库中已经为我们准备好了这些标准函数的函数体所在的目标文件，在链接时默默帮我们链接上了。 顺便说一句，这些目标文件都是待重定位文件，重定位文件意思是文件中的函数是没有地址的，用 file 命 令查看它们时会显示 relocatable，它们中的地址是在与用户程序的目标文件链接成一个可执行文件时由链接器 统一分配的。所以 C 运行时库中同样的函数与不同的用户程序链接时，其生成的可执行文件中分配给库函数 的地址都可能是不同的。每一个用户程序都需要与它们链接合并成一个可执行文件，所以每一个可执行文件中 都有这些库文件的副本，这些库文件相当于被复制到每个用户程序中。所以您清楚了，即使咱们的代码只有十 几个字符，最终生成的文件也要几 KB，就是这个道理。 还有一点内容要解释，前面说过用户程序要使用系统调用才能使用操作系统的功能，我们的 func_inc.d 中，也用到了 printf 函数，照我这么说的话，打印字符是内核的功能，那么生成的 main.bin 文件在执行 printf 函数时，内部一定会执行系统调用？没错！我们来验证一下。 我们可以用 ltrace 命令跟踪一下程序 main.bin 的执行过程就好啦。ltrace 命令用来跟踪程序运行时调 用的库函数，我们的 printf 函数绝对是个标准的库函数，让我们先尝尝鲜，看看不加参数执行时的输出是 否是我们想要的。</p><h2 id="转义字符与-ASCII-码"><a href="#转义字符与-ASCII-码" class="headerlink" title="转义字符与 ASCII 码"></a>转义字符与 ASCII 码</h2><p>计算机世界中是以二进制来运行的，无论是指令、数据，都是以二进制的形式提交给硬件处理的，字 符也一样，必须转换成二进制才能被计算机识别。所以各种各样的字符编码产生，简单来说，字符编码就是用 唯一的一个二进制串表示唯一的一个字符。其中最著名的字符编码就是 ASCII 码。 ASCII 码表中字符按可见分成两大类，一类是不可见字符，共 33 个，它们的 ASCII 码值是 0～31 和 127，属于控制字符或通信专用字符。表中其余的字符是可见字符，它们的 ASCII 码值是 32～126，属于 数字、字母、各种符号。 对于计算机来说，任何字符都是用 ASCII 码表示的，人要是与计算机交流，虽然可以直接输入字符的 ASCII 码，但这太不人道了，计算机的发明是为了给人解决问题而并非制造问题。人习惯用所见即所得的 方式使用字符，我要输入字符 a 的时候，直接按下键盘上的 a 键就行了，不要让我输入其 ASCII 码 0x61。 这要求是合理的，我们在键盘上键入的每个按键，都会由输入系统根据 ASCII 码表转换成对应的二进制 ACSII 码形式。这对普通用户来说够用了，他们很少写程序，可是作为程序员，我们经常要输出字符串， 字符串中的可见字符直接从键盘敲入就行了，对于那些不可见字符，如回车换行符等，肯定不能用键盘在 字符串中直接敲下一个回车键。</p><p>我们的问题是不可见字符如何写出来，也就是说我们在写字符串时，如何在其中加入不可见的控制符， 这就需要编译器或解释器的支持了。 由于可见字符本身是看得见的，所见即所得，大家在使用中并不会有陌生感。对于那些不可见的控制 字符，如果想使用它们时，该怎样表示它们呢？比如我就是要让程序输出一段话，在结束处换行。控制字 符看不见摸不着，怎么写出来？所以在使用这些不可见字符时必须想办法让其可见，但又不能表示成其他 可见字符，所以，只能让可见字符不表示自身了，哈哈，有点难是吗？这么艰巨的任务显然只用一个可见 字符是不可能完成的，于是编译器想出了一个办法，它引用了另一个可见字符’&#39;来搭配其他可见字符，用 这种可见字符组合的形式表达不可见字符。表面上看，字符’&#39;是让其他可见字符的意义变了，所以称’&#39;为 转义字符，但本质上，这两个可见字符合起来才是完整的不可见字符，比如换行符’\n’，’&#39;和’n’放到一起才 是换行符的意义，并不是因为’n’前面有个’&#39;，’n’就不再是’n’，而是换行符，一定要清楚不是这样的。 ASCII 码表中任何字符都是 1 个字节大小，在字符串中不可见字符虽然用“转义字符+可见字符”两个字 符来表示，但这只是编译器为了让人们能写出不可见字符的方式，目的是让不可见字符变得“可见”，针对的 是人，这样人们写程序时就能在字符串中用到不可见字符。不可见字符本身在编译后还是那 1 个字节的 ASCII 码。说白了，我们能够将不可见字符显示出来，原因就是编译器在给我们做支持，它将“转义字符+可见字符” 这种形式的不可见字符转换成了该不可见字符的 ASCII 码。 为了说清楚，咱们以编译器为界限，在编译器左边的是人，这里的字符串是供人使用的，转义字符是 存在于这一边的。编译器右边的是机器，这里的字符串使用的都是 ASCII 码。</p><p>在编译器左边： </p><p>char* ptr=”abc\n”； </p><p>此部分对应的内容是 0x61 0x62 0x63 0x5c 0x6e。</p><p> 编译器右边： “abc\n”</p><p>对应的内容是 0x61 0x62 0x63 0xa</p><p>编译器的左边和右边是不一样的，区别是对“\n”的处理。编译器左边把它当成了两个字符，编译器 右边把它当成了一个字符。想想也是，毕竟代码只是文本字符串，字符串”abc\n”中的’&#39;和’n’肯定是两个 字符，编译器会把’&#39;和’n’组合到一起成为’\n’而解释成回车换行。可能您还是觉得怀疑，那我说一下编译器 对字符串的解释过程。 编译器对字符串的处理一般是逐个字符处理的，这样便于处理转义字符。若发现字符为’&#39;，就意识到 这是转义字符，按常理说后面肯定要跟着另一可见字符，于是先不做任何处理，马上把后面的字符读进来， 分析这两个字符的组合是哪个控制字符后一并处理。 咱们这里拿编译器解释字符串”abc\n”举例。 代码中的’\n’本身由两个字符’&#39;和’n’组成，’\n’是给人看的，用于在字符串中使用，其 ASCII 码是 0xa， 是给机器看的。在计算机中，所有的字符都已经成了 ASCII 码，字符串”abc\n”则变成了 ASCII 码：0x61 0x62 0x63 0x5c 0x6e。 编译器要逐个对比字符串中每个字符，前几个字符是’a’、’b’、’c’，这都是可见字符，没有异议，直接处理。 当发现字符是’&#39;，知道这是转义字符，得知道’&#39;后面的字符是什么才能确定是哪个不可见字符，于是暂停处理’&#39;， 把后面的字符读进来，发现是’n’，便知道这是’\n’，表示一个换行符，于是将’&#39;和’n’用换行符的 ASCII 代替，原来 字符串”abc\n”的 ASCII 码就变成了 0x61 0x62 0x63 0xa。</p><h2 id="MBR、EBR、DBR-和-OBR-各是什么"><a href="#MBR、EBR、DBR-和-OBR-各是什么" class="headerlink" title="MBR、EBR、DBR 和 OBR 各是什么"></a>MBR、EBR、DBR 和 OBR 各是什么</h2><p>这几个概念主要是围绕计算机系统的控制权交接展开的，整个交接过程就是个接力赛，咱们从头梳理。 计算机在接电之后运行的是基本输入输出系统 BIOS，大伙儿知道，BIOS 是位于主板上的一个小程序， 其所在的空间有限，代码量较少，功能受限，因此它不可能一人扛下所有的任务需求，也就是肯定不能充 当操作系统的角色（比如说让 BIOS 运行 QQ 是不可能的），必须采取控制权接力的方式，一步步地让处 理器执行更为复杂强大的指令，最终把处理器的使用权交给操作系统，这才让计算机走上了正轨，从而可 以完成各种复杂的功能，方便人们的工作和生活。采用接力式控制权交接，BIOS 只完成一些简单的检测 或初始化工作，然后找机会把处理器使用权交出去。交给谁呢？下一个接力棒的选手是 MBR，为了方便 BIOS 找到 MBR，MBR 必须在固定的位置等待，因此 MBR 位于整个硬盘最开始的扇区。 MBR 是主引导记录，Master 或 Main Boot Record，它存在于整个硬盘最开始的那个扇区，即 0 盘 0 道 1 扇区，这个扇区便称为 MBR 引导扇区。注意这里用 CHS 方式表示 MBR 引导扇区的地址，因此扇区 地址以 1 开始，顺便说一句，LBA 方式是以 0 为起始为扇区编址的，有关 CHS 和 LBA 的内容会在后面 章节介绍。一般情况下扇区大小是 512 字节，但大伙儿不要把这个当真理，有的硬盘扇区并不是 512 字节。</p><p>在 MBR 引导扇区中的内容是： （1）446 字节的引导程序及参数； （2）64 字节的分区表； （3）2 字节结束标记 0x55 和 0xaa。 在 MBR 引导扇区中存储引导程序，为的是从 BIOS 手中接过系统的控制权，也就是处理器的使用权。 任何一棒的接力都是由上一棒跳到下一棒，也就是上一棒得知道下一棒在哪里才能跳过去，否则权利还是 交不出去。BIOS 知道 MBR 在 0 盘 0 道 1 扇区，这是约定好的，因此它会将 0 盘 0 道 1 扇区中的 MBR 引 导程序加载到物理地址 0x7c00，然后跳过去执行，这样 BIOS 就把处理器使用权移交给 MBR 了。 既然 MBR 称为“主”引导程序，有“主”就得有“次”， MBR 的作用相当于下一棒的引导程序总 入口，BIOS 把控制权交给 MBR 就行了，由 MBR 从众多可能的接力选手中挑出合适的人选并交出系统控 制权，这个过程就是由“主引导程序”去找“次引导程序”，这么说的意思是“次引导程序”不止一个。 也许您会问，为什么 BIOS 不直接把控制权交给“次引导程序”？原因是 BIOS 受限于其主板上的存储空 间，代码量有限，本身的工作还做不过来呢，因此心有余而力不足。好啦，下面开始下一轮的系统控制权 接力。不要忘了，MBR 引导扇区中除了引导程序外，还有 64 字节大小的分区表，里面是分区信息。分区 表中每个分区表项占 16 字节，因此 MBR 分区表中可容纳 4 个分区，这 4 个分区就是“次引导程序”的 候选人群，MBR 引导程序开始遍历这 4 个分区，想找到合适的人选并把系统控制权交给他。 通常情况下这个“次引导程序”就是操作系统提供的加载器，因此 MBR 引导程序的任务就是把控制 权交给操作系统加载器，由该加载器完成操作系统的自举，最终使控制权交付给操作系统内核。但是各分 区都有可能存在操作系统，MBR 也不知道操作系统在哪里，它甚至不知道分区上的二进制 01 串是指令， 还是普通数据，好吧，它根本分不清楚上面的是什么，谈何权利交接呢。 为了让 MBR 知道哪里有操作系统，我们在分区时，如果想在某个分区中安装操作系统，就用分区工 具将该分区设置为活动分区，设置活动分区的本质就是把分区表中该分区对应的分区表项中的活动标记为 0x80。MBR 知道“活动分区”意味着该分区中存在操作系统，这也是约定好的。活动分区标记位于分区 表项中最开始的 1 字节（有关分区内容，后面介绍分区的章节中会细说），其值要么为 0x80，要么为 0， 其他值都是非法的。0x80 表示此分区上有引导程序，0 表示没引导程序，该分区不可引导。MBR 在分析 分区表时通过辨识“活动分区”的标记 0x80 开始找活动分区，如果找到了，就将 CPU 使用权交给此分区 上的引导程序，此引导程序通常是内核加载器，下面就直接以它为例。 “控制权交接”是处理器从“上一棒选手”跳到“下一棒选手”来完成的，内核加载器的入口地址是这里所 说的“下一棒选手”，但是内核加载器在哪里呢？虽然分区那么大，但 MBR 最想去看的是内核加载器，不想盲 目地看看。因此您想到了，为了 MBR 方便找到活动分区上的内核加载器，内核加载器的入口地址也必须在固定 的位置，这个位置就是各分区最开始的扇区，这也是约定好的。这个“各分区起始的扇区”中存放的是操作系统 引导程序—内核加载器，因此该扇区称为操作系统引导扇区，其中的引导程序（内核加载器）称为操作系统 引导记录 OBR，即 OS Boot Record，此扇区也称为 OBR 引导扇区。在 OBR 扇区的前 3 个字节存放了跳转指令， 这同样是约定，因此 MBR 找到活动分区后，就大胆主动跳到活动分区 OBR 引导扇区的起始处，该起始处的跳 转指令马上将处理器带入操作系统引导程序，从此 MBR 完成了交接工作，以后便是内核的天下了。 不过 OBR 中开头的跳转指令跳往的目标地址并不固定，这是由所创建的文件系统决定的，对于 FAT32 文件系统来说，此跳转指令会跳转到本扇区偏移 0x5A 字节的操作系统引导程序处。不管跳转目标地址是 多少，总之那里通常是操作系统的内核加载器。 计算机历史中向来把兼容性放在首位，这才是计算机蒸蒸日上的原因。OBR 是从 DBR 遗留下来的， 要想了解 OBR，还是先从了解 DBR 开始。DBR 是 DOS Boot Record，也就是 DOS 操作系统的引导记录 （程序），DBR 中的内容大概是： （1）跳转指令，使 MBR 跳转到引导代码； （2）厂商信息、DOS 版本信息； （3）BIOS 参数块 BPB，即 BIOS Parameter Block；</p><p>（4）操作系统引导程序； （5）结束标记 0x55 和 0xaa。 在 DOS 时代只有 4 个分区，不存在扩展分区，这 4 个分区都相当于主分区，所以各主分区最开始的扇 区称为 DBR 引导扇区。后来有了扩展分区之后，无论分区是主分区，还是逻辑分区，为了兼容，分区最开 始的扇区都作为 DOS 引导扇区。但是其他操作系统如 UNIX，Linux 等为了兼容 MBR 也传承了这个习俗， 都将各分区最开始的扇区作为自己的引导扇区，在里面存放自己操作系统的引导程序。由于现在这个“分区 最开始的扇区”引导的操作系统类型太多了，而且 DOS 还退出历史舞台了，所以 DBR 也称为 OBR。 这里提到了扩展分区就不得不提到 EBR。当初为了解决分区数量限制的问题才有了扩展分区，EBR 是扩展分区中为了兼容 MBR 才提出的概念，主要是兼容 MBR 中的分区表。分区是用分区表来描述的， MBR 中有分区表，扩展分区中的是一个个的逻辑分区，因此扩展分区中也要有分区表，为扩展分区存储 分区表的扇区称为 EBR，即 Expand Boot Record，从名字上看就知道它是为了“兼容”而“扩展”出来的 结构，兼容的内容是分区表，因此它与 MBR 结构相同，只是位置不同，EBR 位于各子扩展分区中最开始 的扇区（注意，各主分区和各逻辑分区中最开始的扇区是操作系统引导扇区），理论上 MBR 只有 1 个， EBR 有无数个。有关扩展分区的内容还是要参见后面有关分区的章节，那里介绍得更细致。 现在总结一下。 EBR 与 MBR 结构相同，但位置和数量都不同，整个硬盘只有 1 个 MBR，其位于整个硬盘最开始的 扇区—0 道 0 道 1 扇区。而 EBR 可有无数个，具体位置取决于扩展分区的分配情况，总之是位于各子扩 展分区最开始的扇区，如果此处不明白子扩展分区是什么，到了以后跟踪分区的章节中大伙儿就会明白。OBR 其实就是 DBR，指的都是操作系统引导程序，位于各分区（主分区或逻辑分区）最开始的扇区，访扇区称为 操作系统引导扇区，即 OBR 引导扇区。OBR 的数量与分区数有关，等于主分区数加逻辑分区数之和，友情提 示：一个子扩展分区中只包含 1 个逻辑分区。 MBR 和 EBR 是分区工具创建维护的，不属于操作系统管理的范围，因此操作系统不可以往里面写东 西，注意这里所说的是“不可以”，其实操作系统是有能力读写任何地址的，只是如果这样做的话会破坏 “系统控制权接力赛”所使用的数据，下次开机后就无法启动了。OBR 是各分区（主分区或逻辑分区）最 开始的扇区，因此属于操作系统管理。 DBR、OBR、MBR、EBR 都包含引导程序，因此它们都称为引导扇区，只要该扇区中存在可执行的 程序，该扇区就是可引导扇区。若该扇区位于整个硬盘最开始的扇区，并且以 0x55 和 0xaa 结束，BIOS 就认为该扇区中存在 MBR，该扇区就是 MBR 引导扇区。若该扇区位于各分区最开始的扇区，并且以 0x55 和 0xaa 结束，MBR 就认为该扇区中有操作系统引导程序 OBR，该扇区就是 OBR 引导扇区。 DBR、OBR、MBR、EBR 结构中都有引导代码和结束标记 0x55 和 0xaa，因此很多同学都容易把它 们搞混。不过它们最大的区别是分区表只在 MBR 和 EBR 中存在，DBR 或 OBR 中绝对没有分区表。MBR、 EBR、OBR 的位置关系如图</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210223000646630.png" alt="image-20210223000646630"></p><p>MBR 位于整个硬盘最开始的块，EBR 位于每个子扩展分区，各子扩展分区中只有一个逻辑分 区。MBR 和 EBR 位于分区之外的扇区，而 OBR 则属于主分区和逻辑分区最开始的扇区，每个主分区和逻 辑分区中都有 OBR 引导扇区。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/pdf/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F.pdf">《操作系统真相还原》</a></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络篇-计算机网络</title>
    <link href="/2021/02/15/network/%E7%BD%91%E7%BB%9C%E7%AF%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/02/15/network/%E7%BD%91%E7%BB%9C%E7%AF%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h1><h2 id="计算机网络的定义"><a href="#计算机网络的定义" class="headerlink" title="计算机网络的定义"></a>计算机网络的定义</h2><blockquote><p>计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</p></blockquote><p><code>互联网</code></p><blockquote><p>特指 Internet，它起源于美国，是由数量极大的各种计算机网络互连起来而形成的一个互连网络。它采用 TCP/IP 协议族作为通信规则，是一个覆盖全球、实现全球范围内连通性和资源共享的计算机网络。</p></blockquote><ul><li><p>第一阶段</p><blockquote><p>从单个网络 ARPANET 向互联网发展的过程。 1983 年，TCP/IP 协议成为 ARPANET 上的标准协议，使得所有使用 TCP/IP 协议的计算机都能利用互连网相互通信。人们把 1983 年作为互联网的诞生时间。1990年，ARPANET 正式宣布关闭。</p></blockquote></li><li><p>第二阶段</p><blockquote><p>建成了三级结构的互联网。 它是一个三级计算机网络，分为主干网、地区网和校园网（或企业网）。</p></blockquote></li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210217115739975.png" alt="image-20210217115739975"></p><ul><li><p>第三阶段</p><blockquote><p>逐渐形成了多层次 ISP 结构的互联网。 出现了互联网服务提供者 ISP (Internet Service Provider)。任何机构和个人只要向某个 ISP 交纳规定的费用，就可从该 ISP 获取所需 IP 地址的使用权，并可通过该 ISP 接入到互联网。根据提供服务的覆盖面积大小以及所拥有的IP地址数目的不同，ISP 也分成为不同层次的 ISP：主干 ISP、地区 ISP和本地 ISP。</p></blockquote></li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210217115816104.png" alt="image-20210217115816104"></p><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><blockquote><p>每一个分组的首部都含有地址（诸如目的地址和源地址）等控制信息。分组交换网中的结点交换机根据收到的分组首部中的地址信息，把分组转发到下一个结点交换机。每个分组在互联网中独立地选择传输路径。用这样的存储转发方式，最后分组就能到达最终目的地。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210217121147159.png" alt="image-20210217121147159"></p><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><blockquote><p>在路由器中的输入和输出端口之间没有直接连线。路由器处理分组的过程是：</p><p>把收到的分组先放入缓存（暂时存储）；</p><p>查找转发表，找出到某个目的地址应从哪个端口转发；</p><p>把分组送到适当的端口转发出去。</p></blockquote><p>主机和路由器的作用不同</p><blockquote><p>主机是为用户进行信息处理的，并向网络发送分组，从网络接收分组。路由器对分组进行存储转发，最后把分组交付目的主机。</p></blockquote><p>分组交换的优点</p><table><thead><tr><th><strong>优点</strong></th><th><strong>所采用的手段</strong></th></tr></thead><tbody><tr><td><strong>高效</strong></td><td><strong>在分组传输的过程中**</strong>动态分配**<strong>传输带宽，对通信链路是逐段**</strong>占用**<strong>。</strong></td></tr><tr><td><strong>灵活</strong></td><td><strong>为每一个分组**</strong>独立**<strong>地选择最合适的转发**</strong>路由**<strong>。</strong></td></tr><tr><td><strong>迅速</strong></td><td><strong>以分组作为传送单位，可以**</strong>不先建立连接**<strong>就能向其他主机发送**</strong>分组**<strong>。</strong></td></tr><tr><td><strong>可靠</strong></td><td><strong>保证可靠性的网络协议；分布式多路由的分组交换网，使网络有很好的**</strong>生存性**<strong>。</strong></td></tr></tbody></table><h2 id="网络类别"><a href="#网络类别" class="headerlink" title="网络类别"></a>网络类别</h2><ul><li>广域网 WAN (Wide Area Network)：作用范围通常为几十到几千公里。</li><li>城域网 MAN (Metropolitan Area Network)：作用距离约为 5~50 公里。</li><li>局域网 LAN (Local Area Network) ：局限在较小的范围（如 1 公里左右）。</li><li>个人区域网 PAN (Personal Area Network) ：范围很小，大约在 10 米左右。</li></ul><h3 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h3><ul><li>速率</li><li>带宽</li><li>吞吐率</li><li>时延</li><li>时延带宽积</li><li>往返时间 RTT</li><li>利用率</li></ul><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><blockquote><p>比特（bit）是计算机中数据量的单位，也是信息论中使用的信息量的单位。</p><p>比特（bit）来源于 binary digit，意思是一个“二进制数字”，因此一个比特就是二进制数字中的一个 1 或 0。速率是计算机网络中最重要的一个性能指标，指的是数据的传送速率，它也称为数据率 (data rate) 或比特率 (bit rate)。<br>速率的单位是 bit/s，或 kbit/s、Mbit/s、 Gbit/s等。<br>    例如4  1010  bit/s 的数据率就记为 40 Gbit/s。<br>速率往往是指额定速率或标称速率，非实际运行速率。  </p></blockquote><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><blockquote><p>两种不同意义：<br>“带宽”(bandwidth) 本来是指信号具有的频带宽度，其单位是赫（或千赫、兆赫、吉赫等）。<br>在计算机网络中，带宽用来表示网络中某通道传送数据的能力。表示在单位时间内网络中的某信道所能通过的“最高数据率”。单位是 bit/s，即 “比特每秒”。    </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210217121857705.png" alt="image-20210217121857705"></p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><blockquote><p>吞吐量 (throughput) 表示在单位时间内通过某个网络（或信道、接口）的数据量。<br>吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。<br>吞吐量受网络的带宽或网络的额定速率的限制。  </p></blockquote><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><blockquote><p>时延 (delay 或 latency) 是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。<br>有时也称为延迟或迟延。<br>网络中的时延由以下几个不同的部分组成：<br>发送时延<br>传播时延<br>处理时延<br>排队时延</p></blockquote><h3 id="时延-1"><a href="#时延-1" class="headerlink" title="时延"></a>时延</h3><blockquote><p>发送时延<br>也称为传输时延。<br>发送数据时，数据帧从结点进入到传输媒体所需要的时间。<br>也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。 </p></blockquote><p>$$<br>发送时延=\frac{数据帧长度(bit)}{发送速率(bit/s)}<br>$$</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210217122206127.png" alt="image-20210217122206127"></p><h2 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h2><blockquote><p>计算机网络的体系结构 (architecture) 是计算机网络的各层及其协议的集合。<br>体系结构就是这个计算机网络及其部件所应完成的功能的精确定义。<br>实现 (implementation) 是遵循这种体系结构的前提下用何种硬件或软件完成这些功能的问题。<br>体系结构是抽象的，而实现则是具体的，是真正在运行的计算机硬件和软件。</p></blockquote><h3 id="协议的体系结构"><a href="#协议的体系结构" class="headerlink" title="协议的体系结构"></a>协议的体系结构</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210217130824977.png" alt="image-20210217130824977"></p><h3 id="五层协议的体系结构"><a href="#五层协议的体系结构" class="headerlink" title="五层协议的体系结构"></a>五层协议的体系结构</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210217133142934.png" alt="image-20210217133142934"></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210217151356453.png" alt="image-20210217151356453"></p><h1 id="第二章-物-理-层"><a href="#第二章-物-理-层" class="headerlink" title="第二章 物 理 层"></a>第二章 物 理 层</h1><blockquote><p>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是要尽可能地屏蔽掉不同传输媒体和通信手段的差异。用于物理层的协议也常称为物理层规程 (procedure)。</p></blockquote><h3 id="数据通信系统的模型"><a href="#数据通信系统的模型" class="headerlink" title="数据通信系统的模型"></a>数据通信系统的模型</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210217154737343.png" alt="image-20210217154737343"></p><h3 id="常用编码方式"><a href="#常用编码方式" class="headerlink" title="常用编码方式"></a>常用编码方式</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210217174400795.png" alt="image-20210217174400795"></p><h3 id="基本的带通调制方法"><a href="#基本的带通调制方法" class="headerlink" title="基本的带通调制方法"></a>基本的带通调制方法</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210217180143193.png" alt="image-20210217180143193"></p><h3 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210217183052436.png" alt="电信领域使用的电磁波的频谱"></p><h2 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h2><ul><li>双绞线</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210217183955173.png" alt="image-20210217183955173"></p><ul><li>光纤</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210217184043500.png" alt="image-20210217184043500"></p><h3 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210217184232342.png" alt="image-20210217184232342"></p><ul><li>频分复用</li></ul><blockquote><p>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210217184710731.png" alt="image-20210217184710731"></p><ul><li>时分复用</li></ul><blockquote><p>时分复用则是将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</p><p>每一个用户所占用的时隙是周期性地出现（其周期就是TDM帧的长度）的。</p><p>TDM 信号也称为等时 (isochronous) 信号。</p><p>时分复用的所有用户在不同的时间占用同样的频带宽度。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210217184648314.png" alt="image-20210217184648314"></p><ul><li>波分复用</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210217185626867.png" alt="image-20210217185626867"></p><ul><li>码分复用</li></ul><blockquote><p>常用的名词是码分多址 CDMA (Code Division Multiple Access)。各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</p></blockquote><h1 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h1><blockquote><p>数据链路层是实现设备之间通信的非常重要的一层</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210217223724424.png" alt="image-20210217223724424"></p><blockquote><p>数据链路层的作用</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210217225709510.png" alt="image-20210217225709510"></p><blockquote><p>数据链路层使用的信道</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210217230114303.png" alt="image-20210217230114303"></p><blockquote><p>数据链路层传送的是帧</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210217231437098.png" alt="image-20210217231437098"></p><p>链路协议共同问题</p><ul><li>封装成帧</li></ul><blockquote><p>封装成帧 (framing) 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。首部和尾部的一个重要作用就是进行帧定界。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210217232327694.png" alt="image-20210217232327694"></p><ul><li>透明传输</li></ul><p><code>在数据链路层透明传送数据”表示无论发送什么样的比特组合的数据，这些数据都能够按照原样没有差错地通过这个数据链路层。</code></p><blockquote><p>如果数据中的某个字节的二进制代码恰好和 SOH 或 EOT 一样，数据链路层就会错误地“找到帧的边界”。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210217232502288.png" alt="image-20210217232502288"></p><blockquote><p>解决方法：字节填充 (byte stuffing) 或字符填充 (character stuffing)。<br>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是1B)。<br>接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。<br>如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC。当接收端收到连续的两个转义字符时，就删除其中前面的一个。 </p></blockquote><ul><li>差错控制</li></ul><blockquote><p>在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率 BER (Bit Error Rate)。<br>误码率与信噪比有很大的关系。<br>为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。<br>在数据链路层传送的帧中，广泛使用了循环冗余检验 CRC 的检错技术。</p></blockquote><h3 id="PPP-协议的特点"><a href="#PPP-协议的特点" class="headerlink" title="PPP 协议的特点"></a>PPP 协议的特点</h3><blockquote><p>对于点对点的链路，目前使用得最广泛的数据链路层协议是点对点协议 PPP (Point-to-Point Protocol)。<br>PPP 协议在 1994 年就已成为互联网的正式标准。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210217235335325.png" alt="image-20210217235335325"></p><blockquote><p>简单 —— 这是首要的要求。<br>封装成帧 —— 必须规定特殊的字符作为帧定界符。<br>透明性 —— 必须保证数据传输的透明性。<br>多种网络层协议 —— 能够在同一条物理链路上同时支持多种网络层协议。<br>多种类型链路 —— 能够在多种类型的链路上运行。<br>差错检测 —— 能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。</p></blockquote><h3 id="PPP-协议有三个组成部分："><a href="#PPP-协议有三个组成部分：" class="headerlink" title="PPP 协议有三个组成部分："></a>PPP 协议有三个组成部分：</h3><ul><li>一个将 IP 数据报封装到串行链路的方法。</li><li>链路控制协议 LCP (Link Control Protocol)。</li><li>网络控制协议 NCP (Network Control Protocol)。</li></ul><h3 id="PPP-协议的帧格式"><a href="#PPP-协议的帧格式" class="headerlink" title="PPP 协议的帧格式"></a>PPP 协议的帧格式</h3><blockquote><p>PPP 帧的首部和尾部分别为 4 个字段和 2 个字段。<br>标志字段 F = 0x7E （符号“0x”表示后面的字符是用十六进制表示。十六进制的 7E 的二进制表示是 01111110）。<br>地址字段 A 只置为 0xFF。地址字段实际上并不起作用。<br>控制字段 C 通常置为 0x03。<br>PPP 是面向字节的，所有的 PPP 帧的长度都是整数字节。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210217235923359.png" alt="PPP 协议的帧格式"></p><h3 id="透明传输问题"><a href="#透明传输问题" class="headerlink" title="透明传输问题"></a>透明传输问题</h3><blockquote><p>当 PPP 用在异步传输时，就使用一种特殊的<code>字符填充法</code>。<br>当 PPP 用在同步传输链路时，协议规定采用硬件来完成<code>比特填充</code>（和 HDLC 的做法一样）。  </p></blockquote><p>字符填充</p><blockquote><p>将信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列 (0x7D, 0x5E)。<br>若信息字段中出现一个 0x7D 的字节, 则将其转变成为 2 字节序列 (0x7D, 0x5D)。<br>若信息字段中出现 ASCII 码的控制字符（即数值小于 0x20 的字符），则在该字符前面要加入一个 0x7D 字节，同时将该字符的编码加以改变。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218000148542.png" alt="字符填充法"></p><p>零比特填充</p><blockquote><p>PPP 协议用在 SONET/SDH 链路时，使用同步传输（一连串的比特连续传送）。这时 PPP 协议采用零比特填充方法来实现透明传输。<br>在发送端，只要发现有 5 个连续 1，则立即填入一个 0。<br>接收端对帧中的比特流进行扫描。每当发现 5 个连续1时，就把这 5 个连续 1 后的一个 0 删除。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218000246157.png" alt="零比特填充"></p><h2 id="以太网的-MAC-层"><a href="#以太网的-MAC-层" class="headerlink" title="以太网的 MAC 层"></a>以太网的 MAC 层</h2><blockquote><p>在局域网中，硬件地址又称为物理地址，或 MAC 地址。<br>802 标准所说的“地址”严格地讲应当是每一个站的“名字”或标识符。<br>但鉴于大家都早已习惯了将这种 48 位的“名字”称为“地址”，所以本书也采用这种习惯用法，尽管这种说法并不太严格。</p></blockquote><h4 id="48-位的-MAC-地址"><a href="#48-位的-MAC-地址" class="headerlink" title="48 位的 MAC 地址"></a>48 位的 MAC 地址</h4><blockquote><p>一个地址块可以生成 224 个不同的地址。这种 48 位地址称为 MAC-48，它的通用名称是 EUI-48。<br>生产适配器时，6 字节的 MAC 地址已被固化在适配器的 ROM，因此，MAC 地址也叫做硬件地址 (hardware address) 或物理地址。<br>“MAC 地址”实际上就是适配器地址或适配器标识符 EUI-48。</p></blockquote><h4 id="单站地址，组地址，广播地址"><a href="#单站地址，组地址，广播地址" class="headerlink" title="单站地址，组地址，广播地址"></a>单站地址，组地址，广播地址</h4><blockquote><p>IEEE 规定地址字段的第一字节的最低位为 I/G 位。I/G 表示 Individual / Group。<br>当 I/G 位 = 0 时，地址字段表示一个单站地址。<br>当 I/G 位 = 1 时，表示组地址，用来进行多播（以前曾译为组播）。此时，IEEE 只分配地址字段前三个字节中的 23 位。<br>当 I/G 位分别为 0 和 1 时，一个地址块可分别生成 223 个单个站地址和 223 个组地址。<br>所有 48 位都为 1 时，为广播地址。只能作为目的地址使用。</p></blockquote><p>MAC 帧的格式</p><blockquote><p>常用的以太网 MAC 帧格式有两种标准：<br>DIX Ethernet V2 标准<br>IEEE 的 802.3 标准<br>最常用的 MAC 帧是以太网 V2 的格式。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218000626797.png" alt="以太网 V2 的 MAC 帧格式"></p><h4 id="以太网交换机的自学习功能"><a href="#以太网交换机的自学习功能" class="headerlink" title="以太网交换机的自学习功能"></a>以太网交换机的自学习功能</h4><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218000843461.png" alt="交换机自学习和转发帧的步骤归纳"></p><h1 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章 网络层"></a>第四章 网络层</h1><blockquote><p>在计算机网络领域，网络层应该向运输层提供怎样的服务（“面向连接”还是“无连接”）曾引起了长期的争论。<br>争论焦点的实质就是：在计算机通信中，可靠交付应当由谁来负责？是网络还是端系统？ </p></blockquote><p>网络提供数据报服务</p><blockquote><p>互联网的先驱者提出了一种崭新的网络设计思路。<br>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。<br>网络在发送分组时不需要先建立连接。每一个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）。<br>网络层不提供服务质量的承诺。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。 </p></blockquote><p><code>尽最大努力交付</code></p><blockquote><p>由于传输网络不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网的交换机相比较）。<br>如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责可靠交付（包括差错处理、流量控制等） 。<br>采用这种设计思路的好处是：网络的造价大大降低，运行方式灵活，能够适应多种应用。<br>互连网能够发展到今日的规模，充分证明了当初采用这种设计思路的正确性。 </p></blockquote><h3 id="分类的-IP-地址"><a href="#分类的-IP-地址" class="headerlink" title="分类的 IP 地址"></a>分类的 IP 地址</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218103629104.png" alt="各类 IP 地址的网络号字段和主机号字段">   </p><blockquote><p>常用的三种类别的 IP 地址</p></blockquote><table><thead><tr><th><strong>网络 类别</strong></th><th><strong>最大可</strong>指派的网络数</th><th><strong>第一个可指派的网络号</strong></th><th><strong>最后一个可指派的网络号</strong></th><th><strong>每个网络中最大主机数</strong></th></tr></thead><tbody><tr><td><strong>A</strong></td><td><strong>126 (2</strong>^7 <strong>– 2)</strong></td><td><strong>1</strong></td><td><strong>126</strong></td><td><strong>16777214</strong></td></tr><tr><td><strong>B</strong></td><td>**16383 (2^14 **– 1)</td><td><strong>128.1</strong></td><td><strong>191.255</strong></td><td><strong>65534</strong></td></tr><tr><td><strong>C</strong></td><td><strong>2097151 (2</strong>^21 <strong>– 1)</strong></td><td><strong>192.0.1</strong></td><td><strong>223.255.255</strong></td><td><strong>254</strong></td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218120140987.png" alt="image-20210218120140987"></p><h3 id="IP-地址与硬件地址"><a href="#IP-地址与硬件地址" class="headerlink" title="IP 地址与硬件地址"></a>IP 地址与硬件地址</h3><blockquote><p>IP 地址与硬件地址是不同的地址。<br>从层次的角度看，<br>硬件地址（或物理地址）是数据链路层和物理层使用的地址。<br>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址（称 IP 地址是逻辑地址是因为 IP 地址是用软件实现的）。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218120329039.png" alt="IP 地址与硬件地址"></p><h4 id="地址解析协议-ARP-的作用"><a href="#地址解析协议-ARP-的作用" class="headerlink" title="地址解析协议 ARP 的作用"></a>地址解析协议 ARP 的作用</h4><blockquote><p>已经知道了一个机器（主机或路由器）的IP地址，如何找出其相应的硬件地址？<br>地址解析协议 ARP 就是用来解决这样的问题的。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218120441777.png" alt="image-20210218120441777"></p><h4 id="地址解析协议-ARP-要点"><a href="#地址解析协议-ARP-要点" class="headerlink" title="地址解析协议 ARP 要点"></a>地址解析协议 ARP 要点</h4><blockquote><p>当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。<br>如有，就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。<br>如没有， ARP 进程在本局域网上广播发送一个 ARP 请求分组。收到 ARP 响应分组后，将得到的 IP 地址到硬件地址的映射写入 ARP 高速缓存。</p></blockquote><blockquote><p>ARP请求分组：包含发送方硬件地址 / 发送方 IP 地址 / 目标方硬件地址(未知时填 0) / 目标方 IP 地址。<br>本地广播 ARP 请求（路由器不转发ARP请求）。<br>ARP 响应分组：包含发送方硬件地址 / 发送方 IP地址 / 目标方硬件地址 / 目标方 IP 地址。<br>ARP 分组封装在物理网络的帧中传输。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218120903484.png" alt="image-20210218120903484"></p><h3 id="IP-数据报分片"><a href="#IP-数据报分片" class="headerlink" title="IP 数据报分片"></a>IP 数据报分片</h3><blockquote><p>一数据报的总长度为 3820 字节，其数据部分的长度为 3800 字节（使用固定首部），需要分片为长度不超过 1420 字节的数据报片。<br>因固定首部长度为 20 字节，因此每个数据报片的数据部分长度不能超过 1400 字节。<br>于是分为 3 个数据报片，其数据部分的长度分别为 1400、1400 和 1000 字节。<br>原始数据报首部被复制为各数据报片的首部，但必须修改有关字段的值。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218121147165.png" alt="image-20210218121147165"></p><h4 id="划分子网的基本思路"><a href="#划分子网的基本思路" class="headerlink" title="划分子网的基本思路"></a>划分子网的基本思路</h4><blockquote><p>划分子网纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。<br>从主机号借用若干个位作为子网号 subnet-id，而主机号 host-id 也就相应减少了若干个位。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218121348118.png" alt="image-20210218121348118"></p><blockquote><p>凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号 net-id，先找到连接在本单位网络上的路由器。<br>然后此路由器在收到 IP 数据报后，再按目的网络号 net-id 和子网号 subnet-id 找到目的子网。<br>最后就将 IP 数据报直接交付目的主机。</p></blockquote><h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><blockquote><p>从一个 IP 数据报的首部并无法判断源主机或目的主机所连接的网络是否进行了子网划分。<br>使用子网掩码 (subnet mask) 可以找出 IP 地址中的子网部分。<br>规则：<br>子网掩码长度 ＝ 32 位<br>子网掩码左边部分的一连串 1，对应于网络号和子网号<br>子网掩码右边部分的一连串 0，对应于主机号 </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218130211408.png" alt="image-20210218130211408"></p><blockquote><p>默认子网掩码</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218130757124.png" alt="image-20210218130757124"></p><h4 id="子网划分方法"><a href="#子网划分方法" class="headerlink" title="子网划分方法"></a>子网划分方法</h4><blockquote><p>有固定长度子网和变长子网两种子网划分方法。<br>在采用固定长度子网时，所划分的所有子网的子网掩码都是相同的。<br>虽然根据已成为互联网标准协议的 RFC 950 文档，子网号不能为全 1 或全 0，但随着无分类域间路由选择 CIDR 的广泛使用，现在全 1 和全 0 的子网号也可以使用了，但一定要谨慎使用，确认你的路由器所用的路由选择软件是否支持全 0 或全 1 的子网号这种较新的用法。<br>划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218133718489.png" alt="B 类地址的子网划分选择（使用固定长度子网）"></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218155425062.png" alt="image-20210218155425062"></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218155444824.png" alt="image-20210218155444824"></p><h3 id="网际控制报文协议-ICMP"><a href="#网际控制报文协议-ICMP" class="headerlink" title="网际控制报文协议 ICMP"></a>网际控制报文协议 ICMP</h3><blockquote><p>为了更有效地转发 IP 数据报和提高交付成功的机会，在网际层使用了网际控制报文协议 ICMP (Internet Control Message Protocol)。<br>ICMP 是互联网的标准协议。<br>ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。<br>但 ICMP 不是高层协议（看起来好像是高层协议，因为 ICMP 报文是装在 IP 数据报中，作为其中的数据部分），而是 IP 层的协议。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218161048740.png" alt="image-20210218161048740"></p><p>ICMP报文种类</p><ul><li><p>ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。 </p></li><li><p>ICMP 报文的前 4 个字节是统一的格式，共有三个字段：即类型、代码和检验和。接着的 4 个字节的内容与 ICMP 的类型有关。 </p></li></ul><p>ICMP 的应用举例</p><ul><li>PING (Packet InterNet Groper) </li><li>Traceroute 的应用举例</li></ul><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><blockquote><p>IP 是互联网的核心协议。<br>互联网经过几十年的飞速发展，到 2011 年 2 月，IPv4 的 32 位地址已经耗尽。<br>ISP 已经不能再申请到新的 IP 地址块了。<br>我国在 2014 – 2015 年也逐步停止了向新用户和应用分配 IPv4 地址。<br>解决 IP 地址耗尽的根本措施就是采用具有更大地址空间的新版本的 IP，即 IPv6。</p></blockquote><h4 id="IPv6-的基本首部"><a href="#IPv6-的基本首部" class="headerlink" title="IPv6 的基本首部"></a>IPv6 的基本首部</h4><blockquote><p>IPv6 仍支持无连接的传送，但将协议数据单元 PDU 称为分组。为方便起见，本书仍采用数据报这一名词。<br>所引进的主要变化如下：<br>更大的地址空间。IPv6 将地址从 IPv4 的 32 位 增大到了 128 位。<br>扩展的地址层次结构。<br>灵活的首部格式。 IPv6 定义了许多可选的扩展首部。<br>改进的选项。 IPv6 允许数据报包含有选项的控制信息，其选项放在有效载荷中。</p></blockquote><p>所引进的主要变化如下：</p><blockquote><p>允许协议继续扩充。<br>支持即插即用（即自动配置）。因此 IPv6 不需要使用 DHCP。<br>支持资源的预分配。  IPv6 支持实时视像等要求，保证一定的带宽和时延的应用。<br>IPv6 首部改为 8 字节对齐。首部长度必须是 8 字节的整数倍。原来的 IPv4 首部是 4 字节对齐。</p></blockquote><h3 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h3><blockquote><p>网络地址转换 NAT (Network Address Translation)  方法于1994年提出。<br>需要在专用网连接到互联网的路由器上安装 NAT 软件。装有 NAT 软件的路由器叫做 NAT路由器，它至少有一个有效的外部全球IP地址。<br>所有使用本地地址的主机在和外界通信时，都要在 NAT 路由器上将其本地地址转换成全球 IP 地址，才能和互联网连接。 </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218162742773.png" alt="网络地址转换的过程"></p><h1 id="第五章-运输层"><a href="#第五章-运输层" class="headerlink" title="第五章 运输层"></a>第五章 运输层</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218170051856.png" alt="image-20210218170051856"></p><h3 id="进程之间的通信"><a href="#进程之间的通信" class="headerlink" title="进程之间的通信"></a>进程之间的通信</h3><blockquote><p>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。<br>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。 </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218171409510.png" alt="image-20210218171409510"></p><h3 id="运输层的作用"><a href="#运输层的作用" class="headerlink" title="运输层的作用"></a>运输层的作用</h3><blockquote><p>“逻辑通信”的意思是“好像是这样通信，但事实上并非真的这样通信”。<br>从IP层来说，通信的两端是两台主机。但“两台主机之间的通信”这种说法还不够清楚。<br>严格地讲，两台主机进行通信就是两台主机中的应用进程互相通信。<br>从运输层的角度看，通信的真正端点并不是主机而是主机中的进程。也就是说，端到端的通信是应用进程之间的通信。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218172141009.png" alt="网络层和运输层有明显的区别"></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218172336702.png" alt="基于端口的复用和分用功能"></p><h2 id="两种不同的运输协议"><a href="#两种不同的运输协议" class="headerlink" title="两种不同的运输协议"></a>两种不同的运输协议</h2><blockquote><p>但这条逻辑通信信道对上层的表现却因运输层使用的不同协议而有很大的差别。<br>当运输层采用面向连接的 <code>TCP </code>协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。<br>当运输层采用无连接的<code>UDP</code>协议时，这种逻辑通信信道是一条不可靠信道。 </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218172527978.png" alt="可靠信道与不可靠信道"></p><h2 id="运输层的两个主要协议"><a href="#运输层的两个主要协议" class="headerlink" title="运输层的两个主要协议"></a>运输层的两个主要协议</h2><blockquote><p>TCP/IP 的运输层有两个主要协议：</p><ul><li>用户数据报协议 UDP (User Datagram Protocol)</li><li>传输控制协议 TCP (Transmission Control Protocol)</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218172838370.png" alt="image-20210218172838370"></p><h3 id="TCP-与-UDP"><a href="#TCP-与-UDP" class="headerlink" title="TCP 与 UDP"></a>TCP 与 UDP</h3><blockquote><p>两个对等运输实体在通信时传送的数据单位叫作运输协议数据单元 TPDU (Transport Protocol Data Unit)。<br>TCP 传送的数据单位协议是 TCP 报文段(segment)。<br> UDP 传送的数据单位协议是 UDP 报文或用户数据报。 </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218172940241.png" alt="image-20210218172940241"></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218172957509.png" alt="使用 UDP 和 TCP 的典型应用和应用层协议"></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218180348953.png" alt="两大类、三种类型的端口"></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218180413470.png" alt="常用的熟知端口"></p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><ul><li>UDP 是<code>无连接</code>的，发送数据之前不需要建立连接，，因此减少了开销和发送数据之前的时延。</li><li>UDP 使用<code>尽最大努力交付</code>，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。</li><li>UDP 是<code>面向报文</code>的。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。UDP 一次交付一个完整的报文。 </li><li>UDP 没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很适合多媒体通信的要求。 </li><li>UDP 支持一对一、一对多、多对一和多对多的交互通信。</li><li>UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218180728305.png" alt="UDP 是面向报文的"></p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><ul><li>TCP 是面向连接的运输层协议，在无连接的、不可靠的 IP 网络服务基础之上提供可靠交付的服务。为此，在 IP 的数据报服务基础之上，增加了保证可靠性的一系列措施。</li><li>TCP 是面向连接的运输层协议。</li><li>每一条 TCP 连接只能有两个端点 (endpoint)，每一条 TCP 连接只能是点对点的（一对一）。 </li><li>TCP 提供可靠交付的服务。</li><li>TCP 提供全双工通信。</li><li><code>面向字节流</code></li><li>TCP 中的“流”(stream) 指的是流入或流出进程的字节序列。</li><li>“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块，但 TCP 把应用程序交下来的数据看成仅仅是一连串无结构的字节流。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218181113075.png" alt="TCP 面向流的概念"></p><ul><li>TCP 连接是一条虚连接而不是一条真正的物理连接。</li><li>TCP 对应用进程一次把多长的报文发送到 TCP 的缓存中是不关心的。</li><li>TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。</li><li>TCP 可把太长的数据块划分短一些再传送。</li><li>TCP 也可等待积累有足够多的字节后再构成报文段发送出去。 </li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218181409466.png" alt="TCP 报文段的首部格式"></p><h1 id="第六章-应用层"><a href="#第六章-应用层" class="headerlink" title="第六章 应用层"></a>第六章 应用层</h1><blockquote><p>每个应用层协议都是为了解决某一类应用问题，而问题的解决又往往是通过位于不同主机中的多个应用进程之间的通信和协同工作来完成的。应用层的具体内容就是规定应用进程在通信时所遵循的协议。<br>应用层的许多协议都是基于客户服务器方式。客户 (client) 和服务器 (server) 都是指通信中所涉及的两个应用进程。客户服务器方式所描述的是进程之间服务和被服务的关系。客户是服务请求方，服务器是服务提供方。 </p></blockquote><ul><li>DNS</li><li>FTP</li><li>TFTP</li><li>TELNET</li><li>HTTP</li><li>SMTP</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218181918479.png" alt="互联网的域名空间"></p><h1 id="第七章-网络安全"><a href="#第七章-网络安全" class="headerlink" title="第七章 网络安全"></a>第七章 网络安全</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218182317551.png" alt="image-20210218182317551"></p><h3 id="分布式拒绝服务-DDoS"><a href="#分布式拒绝服务-DDoS" class="headerlink" title="分布式拒绝服务 DDoS"></a>分布式拒绝服务 DDoS</h3><blockquote><p>若从互联网上的成百上千的网站集中攻击一个网站，则称为分布式拒绝服务 DDoS (Distributed Denial of Service)。有时也把这种攻击称为网络带宽攻击或连通性攻击。</p></blockquote><h3 id="数据加密模型"><a href="#数据加密模型" class="headerlink" title="数据加密模型"></a>数据加密模型</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218182432670.png" alt="image-20210218182432670"></p><h1 id="第八章-互联网上的音频和视频服务"><a href="#第八章-互联网上的音频和视频服务" class="headerlink" title="第八章 互联网上的音频和视频服务"></a>第八章 互联网上的音频和视频服务</h1><blockquote><p>计算机网络最初是为传送数据信息设计的。<br>互联网 IP 层提供的“尽最大努力交付”服务，以及每一个分组独立交付的策略，对传送数据信息也是很合适的。<br>互联网使用的 TCP 协议可以很好地解决网络不能提供可靠交付这一问题。</p></blockquote><h2 id="使用-TCP，还是-UDP？"><a href="#使用-TCP，还是-UDP？" class="headerlink" title="使用 TCP，还是 UDP？"></a>使用 TCP，还是 UDP？</h2><blockquote><p>传送音频/视频文件可以使用 TCP，也可以使用 UDP。起初人们选用 UDP 来传送。<br>采用 UDP 会有以下几个缺点：<br>由于网络的情况多变，在接收端的播放器很难做到始终按规定的速率播放。<br>很多单位的防火墙往往阻拦外部 UDP 分组的进入，因而使用 UDP 传送  多媒体文件时会被防火墙阻拦掉。<br>使用 UDP 传送流式多媒体文件时，如果在用户端希望能够控制媒体的     播放，如进行暂停、快进等操作，那么还需要使用另外的协议 RTP 和 RTSP，增加了成本和复杂性。</p></blockquote><p><code>现在对流式存储音频/视频的播放，如 YouTube 和 Netflix，都是采用 TCP 来传送。</code></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218182712587.png" alt="image-20210218182712587"></p><p>使用 TCP 传送流式视频主要步骤</p><blockquote><p>用户使用 HTTP 获取存储在万维网服务器中的视频文件，然后把视频数据传   送到 TCP 发送缓存中。若发送缓存已填满，就暂时停止传送。<br>从 TCP 发送缓存通过互联网向客户机中的 TCP 接收缓存传送视频数据，直到 接收缓存被填满。<br>从 TCP 接收缓存把视频数据再传送到应用程序缓存（即媒体播放器的缓存）。当这个缓存中的视频数据存储到一定程度时，就开始播放。这个过程一般不超 过 1 分钟。<br>在播放时，媒体播放器等时地（即周期性地）把视频数据按帧读出，经解压缩 后，把视频节目显示在用户的屏幕上。</p></blockquote><p><code>如果是观看实况转播，那么最好应当首先考虑使用 UDP 来传送。 如果使用 TCP 传送，则当出现网络严重拥塞而产生播放的暂停时，就会使人难于接受。 使用 UDP 传送时，即使因网络拥塞丢失了一些分组，对观看的感觉也会比突然出现暂停要好些。</code></p><h3 id="实时流式协议-RTSP"><a href="#实时流式协议-RTSP" class="headerlink" title="实时流式协议 RTSP"></a>实时流式协议 RTSP</h3><blockquote><p>实时流式协议 RTSP (Real-Time Streaming Protocol) 本身并不传送数据，是一个多媒体播放控制协议。<br>它以客户服务器方式工作，用来使用户在播放从互联网下载的实时数据时能够进行控制，如：暂停/继续、后退、前进等。因此 RTSP 又称为“互联网录像机遥控协议”。<br>要实现 RTSP 的控制功能，我们不仅要有协议，而且要有专门的媒体播放器 (media player) 和媒体服务器 (media server)。 </p></blockquote><h1 id="第九章-无线网络和移动网络"><a href="#第九章-无线网络和移动网络" class="headerlink" title="第九章 无线网络和移动网络"></a>第九章 无线网络和移动网络</h1><blockquote><p>无线局域网 WLAN (Wireless Local Area Network) 指采用无线通信技术的局域网。</p></blockquote><p>特点：</p><blockquote><p>提供了移动接入的功能<br>节省投资，建网速度较快<br>支持便携设备联网<br>由于手机普及率日益增高，通过无线局域网接入到互联网已成为当今上网的最常用的方式。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218184106623.png" alt="image-20210218184106623"></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218184123596.png" alt="几种无线网络的比较"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/ppt/compute-network.pptx">计算机网络-PPT</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>健身篇-腹肌锻炼</title>
    <link href="/2021/02/10/another/%E5%81%A5%E8%BA%AB%E7%AF%87-%E8%85%B9%E8%82%8C%E9%94%BB%E7%82%BC/"/>
    <url>/2021/02/10/another/%E5%81%A5%E8%BA%AB%E7%AF%87-%E8%85%B9%E8%82%8C%E9%94%BB%E7%82%BC/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="腹肌锻炼"><a href="#腹肌锻炼" class="headerlink" title="腹肌锻炼"></a>腹肌锻炼</h1><ul><li><p>触足屈腹　30</p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jianshen-1.gif" style="hight:80%;width:80%"/></li><li><p>交替蜷缩　30</p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jianshen-2.gif" style="hight:80%;width:80%"/></li></ul><p class="note note-danger">休息30秒</p><ul><li><p>并掌穿梭　30</p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jianshen-3.gif" style="hight:80%;width:80%"/></li><li><p>四部收复　30</p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jianshen-4.gif" style="hight:80%;width:80%"/></li></ul><p class="note note-danger">休息30秒</p><ul><li><p>申臂屈腹　30</p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jianshen-5.gif" style="hight:80%;width:80%"/></li><li><p>触腿屈腹　30</p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jianshen-6.gif" style="hight:80%;width:80%"/></li></ul><p class="note note-danger">休息30秒</p><ul><li><p>交臂屈腹　30</p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jianshen-7.gif" style="hight:80%;width:80%"/></li><li><p>双重屈腹　30</p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jianshen-8.gif" style="hight:80%;width:80%"/></li></ul><p><a href="https://www.bilibili.com/video/BV1Ds411X7yi?from=search&seid=15817717619822105121">视频链接</a></p>]]></content>
    
    
    <categories>
      
      <category>健身</category>
      
    </categories>
    
    
    <tags>
      
      <tag>健身</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux篇-Linux操作系统教程</title>
    <link href="/2021/02/10/linux/Linux%E7%AF%87-Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"/>
    <url>/2021/02/10/linux/Linux%E7%AF%87-Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="第1章-Linux概述"><a href="#第1章-Linux概述" class="headerlink" title="第1章 Linux概述"></a>第1章 Linux概述</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226185336241.png" alt="操作系统简介"></p><ul><li>操作系统（Operation System，简称OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基石。</li><li>操作系统本质上是运行在计算机上的软件程序 ；</li><li>为用户提供一个与系统交互的操作界面 ；</li><li>操作系统分内核与外壳 ：</li></ul><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>目前最流行的个人桌面操作系统 。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226185613561.png" alt="image-20210226185613561"></p><h2 id="Unix"><a href="#Unix" class="headerlink" title="Unix"></a>Unix</h2><p>最早的多用户、多任务操作系统</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226185620701.png" alt="image-20210226185620701"></p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><ul><li>类Unix系统：Linux是一种自由、开放源码的类似Unix的操作系统 </li><li>Linux内核：严格来说，Linux这个词本身只表示Linux内核</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226185743281.png" alt="image-20210226185743281"></p><ul><li>1991年，芬兰的业余计算机爱好者Linus Torvalds</li><li>编写了一款类似Minix的系统（基于微内核架构的类Unix操作系统） </li><li>被ftp管理员命名为Linux </li><li>加入到自由软件基金的GNU计划中 </li><li>Linux以一只可爱的企鹅作为标志，象征着敢作敢为、热爱生活。</li></ul><p><code>内核版本</code></p><p>Linux内核版本由3个数字组成：a.b.c ：</p><p>a：当前发布的内核主版本；<br>b：偶数表示稳定版，奇数表示开发中的版本；<br>c：错误修补的次数。</p><p>Linux内核在内核官方网站<a href="http://www.kerenl.org上发布/">www.kerenl.org上发布</a> </p><table><thead><tr><th><strong>内核版本</strong></th><th><strong>日期</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>0.00</td><td>1991.2.4</td><td>两个进程，分别显示AAA和BBB</td></tr><tr><td>0.01</td><td>1991.9</td><td>第一个向外公布的Linux内核版本</td></tr><tr><td>0.02</td><td>1991.10.5</td><td>Linux第一个稳定的工作版本</td></tr><tr><td>0.11</td><td>1991.12.8</td><td>基本可以正常运行的内核版本</td></tr><tr><td>0.12</td><td>1992.1.15</td><td>主要加入数学协处理器的软件模拟程序</td></tr><tr><td>0.95(0.13)</td><td>1992.3.8</td><td>开始加入虚拟文件系统思想的内核版本</td></tr><tr><td>2.0</td><td>1996.2.9</td><td>支持多处理器</td></tr><tr><td>2.2</td><td>1999.1.26</td><td>支持许多新的文件系统类型，使用全新的文件缓存机制</td></tr><tr><td>2.4</td><td>2001.1.4</td><td>使用一种适应性很强的资源管理系统</td></tr><tr><td>2.6</td><td>2003.12.7</td><td>性能、安全性和驱动程序进行改进</td></tr><tr><td>2.6.30</td><td>2009.6</td><td>改善文件系统、加入完整性检验补丁、线程中断处理支持等</td></tr><tr><td>2.6.32</td><td>2009.12</td><td>改进Btrfs文件系统、内存控制器支持、运行时电源管理</td></tr><tr><td>2.6.34</td><td>2010.5</td><td>支持flash设备文件系统、新的Vhost net、新的perf功能等</td></tr><tr><td>2.6.38</td><td>2011.3.15</td><td>合并自动进程分组、优化进程调度，改善VFS虚拟文件系统可扩展性，透明化内存Huge Pages使用过程，实现按需自动调用等</td></tr></tbody></table><h2 id="Linux发行版"><a href="#Linux发行版" class="headerlink" title="Linux发行版"></a>Linux发行版</h2><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226190142767.png" alt="image-20210226190142767"></p><p>Ubuntu Linux系统具有如下特色：</p><ul><li><code>系统安全性高</code>，采用“sudo”工具，所有系统相关的任务均需要使用此指令，并输入密码，比起传统系统以管理员账号进行管理工作具有更大的安全性。</li><li><code>统易用性强</code>，传统的Linux系统软件安装和删除经常需要用户自己解决软件的依赖性问题，Ubuntu采用APT系统可轻松进行软件安装和删除。</li><li><code>供多种安装方式</code>，可以直接裸机安装或在虚拟机上进行安装，也可以通过安装程序提供的wubi.exe程序在Windows上进行安装，这为初学者学习和研究Linux带来了便利</li><li><code>界面友好</code>，Ubuntu提供的桌面操作方式特别适合熟悉Windows的用户，初学者易于上手</li></ul><hr><p>Ubuntu 每六个月发布一个新版本，用户可以免费升级到最新版本 。<br>Ubuntu版本的命名遵从“Y.MM (开发代号)”格式，Y代表年份，MM代表月份 。<br>由于受到来自官方的和非官方的社区支持，Ubuntu还有不少衍生版本 。</p><hr><p>流行的官方衍生版 ：</p><ul><li>Kubuntu：基于KDE桌面环境。与Ubuntu的唯一区别在于桌面环境。</li><li>Edubuntu：用于教育的衍生版，内置的软件全部免费</li><li>Xubuntu：基于XFce桌面环境。</li><li>Ubuntu Studio：更适合于多媒体设计人员的衍生版。</li></ul><h3 id="Redhat"><a href="#Redhat" class="headerlink" title="Redhat"></a>Redhat</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226190256321.png" alt="image-20210226190256321"></p><p>美国的“红帽子”公司，1995年发布了桌面版的Red Hat Linux2.0 ；<br>2003年，Red Hat Linux9.0发布 ；<br>2004年，Red Hat公司正式决定停止对Red Hat Linux9.0的支持；<br>原本的桌面版Red Hat Linux发行包则与来自民间的Fedora计划合并，成为Fedora Core发行版 </p><h3 id="Fedora"><a href="#Fedora" class="headerlink" title="Fedora"></a>Fedora</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226190326510.png" alt="image-20210226190326510"></p><p>由Fedora Project社区开发、Red Hat公司赞助一个开放的、创新的Linux操作系统，它允许任何人自由地使用、修改和重发布 。</p><h3 id="OpenSuse"><a href="#OpenSuse" class="headerlink" title="OpenSuse"></a>OpenSuse</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226190441643.png" alt="image-20210226190441643"></p><p>最早是由德国的四个Linux爱好者推出的项目，2003年被Novell公司收购。<br>OpenSUSE向用户提供了漂亮的桌面环境，并提供了优秀的系统管理工具YaST。</p><h3 id="Debian"><a href="#Debian" class="headerlink" title="Debian"></a>Debian</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226190506322.png" alt="image-20210226190506322"></p><p>创始人是伊恩默多克（Ian Murdock）。<br>发行版提供众多的软件包-deb包。<br>Ubuntu就是基于Debian发行版，两者使用APT作为软件管理系统。</p><h3 id="Mandriva"><a href="#Mandriva" class="headerlink" title="Mandriva"></a>Mandriva</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226190536314.png" alt="image-20210226190536314"></p><p>法国的Mandriva公司开发 。<br>众多国际级Linux发行版中唯一一个默认即支持中文环境的Linux。</p><h2 id="Linux和Windows的相似之处"><a href="#Linux和Windows的相似之处" class="headerlink" title="Linux和Windows的相似之处"></a>Linux和Windows的相似之处</h2><ul><li>都是多用户操作系统，都可以由许多不同的用户来使用，都可以以组成员的方式来控制资源的访问权限；</li><li>都支持多文件系统，文件资源可以通过FTP或者其他协议与其他客户机共享；</li><li>都支持多种网络协议，比如TCP/IP、NetBIOS等；</li><li>都可以提供网络服务能力，如DHCP和DNS等。</li></ul><h2 id="Linux和Windows的不同之处"><a href="#Linux和Windows的不同之处" class="headerlink" title="Linux和Windows的不同之处"></a>Linux和Windows的不同之处</h2><table><thead><tr><th><strong>比较项</strong></th><th><strong>Linux</strong></th><th><strong>Windows</strong></th></tr></thead><tbody><tr><td>定位</td><td>Linux的设计定位是网络，设计灵感来自于网络操作系统Unix，因此它的命令的设计比较简单、简洁。由于纯文本可以非常好地跨网络工作，所以Linux配置文件和数据都以文本为基础</td><td>Windows最初的目标是家庭和办公应用，例如打印、图形化服务</td></tr><tr><td>图形用户界面</td><td>图形环境并没有集成到Linux内核中，而是运行于系统之上的单独一层，这意味着可以在需要时再运行GUI</td><td>Windows是把GUI直接集成到操作系统内的</td></tr><tr><td>文件扩展名</td><td>Linux不使用文件扩展名来识别文件的类型，而是根据文件头的内容来识别其类型</td><td>使用文件扩展名来识别文件的类型</td></tr><tr><td>文件执行</td><td>Linux通过文件访问权限来判断是否为可执行文件。程序和脚本（其实是文本文件）的创建者或管理员可以将需要执行的文件赋予可执行权限，这样做有利于安全。保存到系统上的可执行文件不能自动执行，因此可以防止许多脚本病毒</td><td>对于Windows来说用户双击.exe为扩展名的文件系统都尝试加载执行</td></tr><tr><td>系统重启问题</td><td>Linux的设计思想之一是，遵循“牛顿运动定律”，一旦开始运行，它将保持运行状态，直到受到外界因素的干扰，比如硬件故障。除了内核之外，其他软件的安装、卸载都不需要重新引导系统</td><td>Windows在安装软件，特比是安装驱动程序后，经常需要重启系统</td></tr><tr><td>远程管理</td><td>可以远程地完成Linux中的很多工作。只要系统的基本网路服务在运行，就可以远程登录并管理系统。如果系统中一个特定的服务出现了问题，可以在进行故障诊断的同时让其他服务继续运行：当在一个系统上同时运行多个服务的时候（例如同时运行FTP、DNS、WWW服务），这种管理方式非常重要</td><td>Windows的远程管理功能较弱</td></tr></tbody></table><h1 id="第2章-基本操作"><a href="#第2章-基本操作" class="headerlink" title="第2章 基本操作"></a>第2章 基本操作</h1><h2 id="软件包"><a href="#软件包" class="headerlink" title="软件包"></a>软件包</h2><p>Internet上有专门为Ubuntu建立的软件包仓库，其中包含大量的软件包，它们按照是否遵守GPL协议分成四种类型：</p><table><thead><tr><th><strong>类型</strong></th><th><strong>特点</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>main（主要）</td><td>开源软件，可以被自由发布</td><td>Ubuntu开发团队提供完全技术支持的软件</td></tr><tr><td>restricted（受限）</td><td>专供特殊用途的软件</td><td>被Ubuntu开发团队支持，但因为不能直接修改程序，因而Ubuntu可能不能提供完全的技术支持。一般主要是硬件驱动程序</td></tr><tr><td>universe（公共）</td><td>自由发布</td><td>可以和“main”软件相安无事地共同运行，但没有安全升级的保障</td></tr><tr><td>multiverse（多元化）</td><td>不开源、不允许自由发布</td><td>不被Ubuntu开发团队支持，用户自己承担任何版权和技术风险</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226191433268.png" alt="image-20210226191433268"></p><h2 id="Linux桌面"><a href="#Linux桌面" class="headerlink" title="Linux桌面"></a>Linux桌面</h2><p>X Window：是Unix/Linux中的底层图形界面系统 ；</p><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>Shell命令可以分为内部命令和外部命令：</p><ul><li>内部命令，也称作内置命令，是Shell程序的一部分，其中包含的是一些比较简单的Linux系统命令，这些命令在Shell程序内部完成运行。</li><li>外部命令，是Linux系统中的实用应用程序，命令的可执行实体不在Shell内部，但是其执行过程由Shell控制。</li></ul><p><code>可以通过“which”命令来判断某个命令是否是外部命令</code></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226191706371.png" alt="image-20210226191706371"></p><ul><li>man命令，用于查看外部命令的帮助手册。</li><li>help命令，用于查看内部命令的帮助手册 </li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226220920398.png" alt="image-20210226220920398"></p><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install xxxx<br></code></pre></td></tr></table></figure><p>卸载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt remove xxxx<br></code></pre></td></tr></table></figure><h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><table><thead><tr><th><strong>类型</strong></th><th><strong>命令</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>进入vim</td><td>vim</td><td>启动vim</td></tr><tr><td>vim 文件名</td><td>启动vim并打开或新建文件</td><td></td></tr><tr><td>光标移动</td><td>h</td><td>向左移动一个字符</td></tr><tr><td>j</td><td>向下移动一行</td><td></td></tr><tr><td>k</td><td>向上移动一行</td><td></td></tr><tr><td>l</td><td>向右移动以行</td><td></td></tr><tr><td>0</td><td>移动到行开始（注意是数字0，不是字母o）</td><td></td></tr><tr><td>$</td><td>移动到行尾</td><td></td></tr><tr><td>屏幕翻滚</td><td>Ctrl+u</td><td>向文件首翻半屏</td></tr><tr><td>Ctrl+d</td><td>向文件尾翻半屏</td><td></td></tr><tr><td>Ctrl+f</td><td>向文件尾翻一屏</td><td></td></tr><tr><td>Ctrl+b</td><td>向文件首翻一屏</td><td></td></tr><tr><td>文本插入/追加</td><td>a</td><td>在光标后追加文本</td></tr><tr><td>A</td><td>在当前行尾追加</td><td></td></tr><tr><td>i</td><td>在光标前插入</td><td></td></tr><tr><td>I</td><td>在当前行首插入</td><td></td></tr><tr><td>o</td><td>在当前行下面新开一行</td><td></td></tr><tr><td>O</td><td>在当前行上面新开一行</td><td></td></tr><tr><td>文本删除</td><td>dd</td><td>删除当前行</td></tr><tr><td>dw</td><td>删除一个单词</td><td></td></tr><tr><td>nx</td><td>删除光标后n个字符，例如3x</td><td></td></tr><tr><td>nX</td><td>删除光标前n个字符，例如3X</td><td></td></tr><tr><td>撤销/重做</td><td>u</td><td>恢复上一个命令以前的状态，可以多次按下u命令</td></tr><tr><td>.</td><td>重复一条命令</td><td></td></tr><tr><td>搜索</td><td>/字符串</td><td>向下搜索字符串</td></tr><tr><td>?字符串</td><td>向上搜索字符串</td><td></td></tr><tr><td>n</td><td>继续搜索</td><td></td></tr><tr><td>N</td><td>继续向相反防线搜索</td><td></td></tr><tr><td>替换</td><td>:s/p1/p2/g</td><td>将当前行中所有p1均用p2替换</td></tr><tr><td>:n1,n2s/p1/p2/g</td><td>将底n1至n2行中所有p1均用p2替换</td><td></td></tr><tr><td>:g/p1/s//p2/g</td><td>将文件中所有p1均用p2替换</td><td></td></tr><tr><td>复制/粘贴</td><td>nyy</td><td>将当前n行放入缓冲区</td></tr><tr><td>p</td><td>将缓冲区的内容放到当前行下面</td><td></td></tr><tr><td>保存文件</td><td>w</td><td>存盘</td></tr><tr><td>w 文件名</td><td>存盘至文件</td><td></td></tr><tr><td>退出vim</td><td>q</td><td>退出</td></tr><tr><td>wq</td><td>保存退出</td><td></td></tr><tr><td>q!</td><td>强制退出</td><td></td></tr></tbody></table><h1 id="第3章-文件系统"><a href="#第3章-文件系统" class="headerlink" title="第3章 文件系统"></a>第3章 文件系统</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226223834451.png" alt="image-20210226223834451"></p><p>命令行打开文件管理系统GUI</p><blockquote><p>nautilus</p></blockquote><ul><li>当用户登录Linux时或在Ubuntu上打开一个终端后，首先进入一个特殊目录，称为“用户主目录” ；</li><li>Linux规定可以用符号“~”表示当前登录用户的“用户主目录”。 </li><li>当前所在的目录称为“当前工作目录”。当前工作目录可以用“.”表示，当前工作目录的父目录可以用“..”表示。</li></ul><p>对每个执行的命令，Linux系统都会自动打开3个文件，并且都有一个小的整数与之对应 ：</p><ul><li>stdin，标准输入文件，一般指键盘输入，用0表示；</li><li>stdout，标准输出文件，一般指显示器，用1表示；</li><li>stderr，标准错误输出文件，一般指显示器，用2表示。</li></ul><h2 id="比较文件"><a href="#比较文件" class="headerlink" title="比较文件"></a>比较文件</h2><p>diff命令用来比较两个文件的内容，通过把其中一个文件转换成另一个文件的命令的形式来显示这两个文件之间的区别<br>示例 ：使用Gedit或vim在当前用户主目录下创建两个文件t1.txt和t2.txt，然后使用命令比较两个文件的内容 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">diff t1.txt t2.txt<br></code></pre></td></tr></table></figure><h2 id="删除重复行"><a href="#删除重复行" class="headerlink" title="删除重复行"></a>删除重复行</h2><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226224321037.png" alt="image-20210226224321037"></p><h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><p>1、访问权限的分类：</p><ul><li>可读（r）</li><li>可写（w）</li><li>可执行（x）三种 </li></ul><p>2、访问权限的用户类别，有三种不同的类型的用户可对文件或目录进行访问：</p><ul><li>文件所有者</li><li>同组用户</li><li>其他用户 </li></ul><p>3、访问权限的表示：<br>共有10个字符组成，第一个字符指定了文件类型。剩下的是文件或目录的访问权限，分为三组，每组用三位表示，分别为：</p><ul><li>文件所有者的读、写和执行权限 </li><li>与文件所有者同组的用户的读、写和执行权限 </li><li>系统中其他用户的读、写和执行权限 </li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226224517215.png" alt="image-20210226224517215"></p><p>在Linux中，可以使用命令chmod来改变文件或目录的访问权限。<br>语法格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod [选项] [mode] &lt;文件或目录&gt;<br></code></pre></td></tr></table></figure><p>常用选项有 ：</p><ul><li>-c  若该档案权限确实已经更改，才显示其更改动作 ； </li><li>-f  若该档案权限无法被更改也不要显示错误信息； </li><li>-v  显示权限变更的详细资料；</li><li>-R  对目前目录下的所有档案与子目录进行相同的权限变更（即以递归的方式逐个变更）；</li></ul><ul><li>mode是权限标记，可以有两种格式：符号标记和八进制数；</li><li>文件或目录，是要设置的文件名或目录名，必须输入。</li></ul><p>使用符号标记法修改权限时，chmod命令中的mode是由<code>[who] [operator] [permission]</code>三部分组成。其中：<br>操作对象[who]可以是下述字母中任何一个或者它们的组合：</p><ul><li>u，表示“用户（user）”，即文件或目录的所有者；</li><li>g，表示“同组（group）用户”，即与文件所有者同组的所有者；</li><li>o，表示“其他（other）用户”； </li><li>a，表示“所有（all）用户”，它是系统默认值。</li></ul><p>其中：操作符<code>[operator]</code>可以是：</p><ul><li>+，添加某个权限；</li><li>-，取消某个权限；</li><li>=，赋予给定权限并取消其他权限,即设定唯一的权限；</li></ul><p>其中需要[permission]所表示的权限可用下述字母的任何一个或任意的组合：</p><ul><li>r，可读 ；</li><li>w，可写 ；</li><li>x，可执行 ； </li></ul><p>八进制数法修改权限<br>使用八进制数法修改权限时，chmod命令中的mode用三个八进制数abc表示，其中：</p><ul><li>a表示用户（user）的权限；</li><li>b表示同组（group）用户的权限；</li><li>c表示其他（other）的权限</li></ul><p>而八进制数是4（可读）、2（可写）、1（可执行）的组合。因此：</p><ul><li>若要读、写、执行权限（rwx），则4+2+1=7； </li><li>若要读、写权限（rw-），则4+2=6； </li><li>若要读、执行权限（r-x），则4+1=5 </li></ul><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式：描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串、将匹配的子串做替换或者从某个串中取出符合某个条件的子串等；<br>支持正则表达式的常用工具有grep、egrep、vim等，尤其是egrep能较好地支持正则表达式，而grep对正则表达式支持的较少 </p><table><thead><tr><th><strong>符号</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>\</td><td>将下一字符标记为特殊字符、文本、八进制转义符。例如，“n”匹配字符“n”，“\n”匹配换行符</td></tr><tr><td>^</td><td>匹配输入字符串开始的位置。例如，“^st”匹配以st开始的行</td></tr><tr><td>$</td><td>匹配输入字符串结尾的位置。例如，“st$”匹配以st结尾的行</td></tr><tr><td>*</td><td>零次或多次匹配前面的字符或表达式，例如，“zo*”匹配“z”和“zoo”</td></tr><tr><td>+</td><td>一次或多次匹配前面的字符或表达式，例如“zo+”与“zo”和“zoo”匹配，但与“z”不匹配</td></tr><tr><td>？</td><td>零次或一次匹配与前面的字符或表达式，例如“do?”匹配“do”或“does”中的“do”</td></tr><tr><td>{n}</td><td>n是非负整数，正好匹配n次，例如，“o｛2｝”与“Bob”中的“o”不匹配，但与“food”中的两“o”匹配</td></tr><tr><td>｛n，m｝</td><td>m和n是非负整数，其中n&lt;=m。匹配至少n次，至多m次，例如“o｛1，3｝”匹配“foooood”中的前三个“o”</td></tr><tr><td>x|y</td><td>匹配x或y。例如“z|food”匹配“z”或“food”，“(z|f)ood”匹配“zood”或“food”</td></tr><tr><td>[a-z]</td><td>字符范围，匹配指定范围内的任何字符，例如，“[a-z]”匹配“a”到“z”范围内的任何小写字母</td></tr><tr><td>[^a-z]</td><td>反向字符范围。匹配不在指定范围内的任何字符，例如“[^a-z]”匹配任何不在“a”到“z”范围内的任何字符</td></tr><tr><td>\b</td><td>匹配一个字边界，例如，“er\b”匹配“never”中的“er”，但不匹配“verb”中的“er”</td></tr><tr><td>\B</td><td>非字边界匹配，例如，“er\B”匹配“verb”中的“er”，但不匹配“never”中的“er”</td></tr><tr><td>\f</td><td>换页符匹配</td></tr><tr><td>\f</td><td>换页符匹配</td></tr><tr><td>\d</td><td>数字字符匹配，等效于[0-9]</td></tr><tr><td>\D</td><td>非数字字符匹配，等效于[^0-9]</td></tr><tr><td>\n</td><td>换行符匹配</td></tr><tr><td>\r</td><td>匹配一个回车符</td></tr><tr><td>\s</td><td>匹配任何空白字符，包括空格，制表符，换页符等。</td></tr><tr><td>\t</td><td>制表符匹配</td></tr><tr><td>\w</td><td>匹配任何字类字符</td></tr><tr><td>\W</td><td>匹配任何非字类字符</td></tr></tbody></table><h2 id="文件内容查找"><a href="#文件内容查找" class="headerlink" title="文件内容查找"></a>文件内容查找</h2><p>搜索文件内容的命令有grep、egrep和fgrep，三个命令中：</p><ul><li><p>fgrep命令是执行速度最快的，不过有较多的限制；</p></li><li><p>egrep是最慢的，但却是最灵活的，完全支持正则表达式；</p></li><li><p>grep具有合理的速度和部分正则表达式支持 </p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226230830381.png" alt="image-20210226230830381"></p><p>其中：<br>常用选项：<br>-c：显示匹配的行数；<br>-n：显示匹配内容所在的文档的行号；<br>-i：匹配时忽略大小写；<br>-v：输出不匹配内容；<br>-x：只选择能匹配完整一行的匹配。</p><p>其中：<br>模式，可以使用正则表达式描述字符串匹配的模式。<br>  常用的正则表达式操作符有：<br>‘^’：匹配的字符串在行首，如：‘^xyz’匹配所有以xyz开头的行<br>‘$’：匹配的字符串在行尾，如：‘xyz$’匹配所有以xyz结尾的行<br>‘&lt;’：指匹配表达式的开始，如：‘&lt;man’匹配‘manic’ 等<br> 。。。</p><p>其中：<br>文件列表，是要查找的文件名列表。<br>  如果没有文件列表，则从标准输入中读入数据<br>当使用“grep –E”等同于使用egrep；<br>  当使用“grep -F”等同于使用fgrep。</p><p>2、关于引号的使用<br>一般情况下当grep命令格式中的“模式”是一个不包含空格的简单字符串时，既可以使用单引号也可以使用双引号，或者甚至不适用引号<br>例如查找在abn文件中查找包含字符串hello的行，以下三个命令是等价的： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep  hello  abn<br>grep &#x27;hello&#x27; abn<br>grep &quot;hello&quot; abn<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep ‘$hello’ abn  #查找abn文件中包含字符串$hello的行<br>grep “$hello” abn  #查找abn文件中包含变量hello所代表的内容的行<br>grep  $hello  abn  #同上，与命令“grep  &quot;$hello&quot;  abn”意义相同<br></code></pre></td></tr></table></figure><h2 id="文件排序"><a href="#文件排序" class="headerlink" title="文件排序"></a>文件排序</h2><p>Linux中文件排序使用sort命令，该命令可以对文件内容进行排序输出，但不改变文件原有内容。其语法格式如下 </p><p><code>sort [选项] &lt;文件或目录&gt;</code></p><p>其中：<br>常用选项有：<br>-r，以反向的顺序来排序<br>-u，排序输出时，去掉重复行<br>文件或目录，是需要排序的文件名或目录名。</p><h2 id="文件压缩与解压缩"><a href="#文件压缩与解压缩" class="headerlink" title="文件压缩与解压缩"></a>文件压缩与解压缩</h2><p>文件压缩的命令有：<code>gzip</code>、<code>gzexe</code>、<code>zcat</code>。<br>本小结介绍gzip命令的应用。其语法格式如下 </p><p><code>gzip [选项] &lt;文件列表&gt;</code></p><p>其中：<br>常用选项有：<br>-c 将输出写到标准输出上，并保留原有文档<br>-d 将压缩文件解压<br>-r 递归式地查找指定目录并压缩其中的所有文件或是解压缩 </p><h2 id="文件备份和还原"><a href="#文件备份和还原" class="headerlink" title="文件备份和还原"></a>文件备份和还原</h2><p><code>tar [选项] &lt;文件或目录&gt;</code></p><p>其中“选项”是命令执行时可使用的参数，tar命令选项分为：主选项和辅助选项。</p><ul><li><p>常用主选项有 ：<br>-c 创建新的档案文件；<br>-r 把要存档的文件追加到档案的末尾；<br>-t 列出档案文件的内容，查看已经备份了哪些文件<br>-u 更新文件；<br>-x 从档案文件中释放文件。</p></li><li><p>常用辅助选项有 ：<br>-f 指定是要使用的文件名，这个选项通常是必选项，选项后面要有文件名；<br>-v 详细报告tar处理的文件信息；<br>-z 用gzip来压缩/解压缩文件，加上该选项后可以将档案文件进行压缩，但还原时也一定要使用该选项进行解压缩。</p></li></ul><h1 id="第4章-高级操作"><a href="#第4章-高级操作" class="headerlink" title="第4章 高级操作"></a>第4章 高级操作</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226231642366.png" alt="image-20210226231642366"></p><ul><li>Linux是多任务操作系统，每个运行着的程序实例就是一个进程。<br>在单CPU情况下，每个进程每次只执行很短的时间，执行过后CPU被Linux分配给另外一个进程，这种进程间的快速切换给用户的感觉就是可以同时运行多个程序。</li><li>Linux进程都需要从某个进程创建出来，此时创建者进程称为“父进程”，被创建的进程称为“子进程”。<br>进程可以具有多种状态中的一种，可以从一种状态切换到另一种状态，直到执行结束或非正常终止 </li></ul><table><thead><tr><th><strong>状态</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>就绪</td><td>进程准备执行，但没有得到CPU</td></tr><tr><td>执行</td><td>进程正在执行（使用CPU）</td></tr><tr><td>等待</td><td>进程等待事件发生。可能的事件包括I/O（例如磁盘读写操作）完成，父进程等待一个或多个子进程退出</td></tr><tr><td>交换</td><td>进程准备运行，但是它暂时被放置到磁盘上；或者该进程需要很多内存但是系统现在没有足够的内存空间可用</td></tr><tr><td>僵死</td><td>进程执行退出操作之前其父进程已经终止，该进程就变成僵死进程</td></tr></tbody></table><p>Linux操作系统包括三种不同类型的进程：</p><ul><li>交互进程：由用户启动（通过桌面点击操作或在终端中运行命令），可以工作在前台或后台；</li><li>批处理进程：和终端没有联系，是一个进程序列（提交给Linux进程等待队列的进程）；</li><li>守护进程；也称监控进程，由Shell或Linux系统自动启动，工作在后台，用于监视特定任务；</li></ul><p>启动进程的方式有两种：</p><ul><li>手工启动：<br>前台启动：直接在终端中输入程序名（外部命令名），例如：vim ；<br>后台启动：输入程序名时加“&amp;”，例如：vim&amp;。</li><li>调度启动 ：<br>指定系统在特定时间运行程序，可用at，batch和cron调度</li></ul><h2 id="作业机制"><a href="#作业机制" class="headerlink" title="作业机制"></a>作业机制</h2><p>事先进行调度安排，指定时间运行任务。<br>Linux中常用at、batch和crontab命令进行作业控制，他们之间的区别如下：</p><ul><li><code>at命令</code>：在指定的精确时间执行；</li></ul><p>语法格式：<code>at [选项]  &lt;时间&gt;</code></p><p>其中，若省略选项，表示是设定作业，常用“选项”如下：<br>-d，删除指定的调度作业；<br>-f 文件名，从指定文件中读取执行的命令 </p><table><thead><tr><th><strong>类型</strong></th><th><strong>时间表示法</strong></th><th><strong>说明</strong></th><th><strong>举例</strong></th></tr></thead><tbody><tr><td>绝对表示法</td><td>midnight</td><td>当天午夜</td><td>at midnight</td></tr><tr><td>moon</td><td>当天中午</td><td>at moon</td><td></td></tr><tr><td>hh:mm [mm/dd/yy]</td><td>时:分 月/日/年</td><td>at 12:23at 23:01 5/21/09</td><td></td></tr><tr><td>相对表示法</td><td>now+n minutes</td><td>现在起向后n分钟</td><td>at now+30 minutes</td></tr><tr><td>now+n hours</td><td>现在起向后n小时</td><td>at now +2 hours</td><td></td></tr><tr><td>now+n days</td><td>现在起向后n天</td><td>at now+5 days</td><td></td></tr><tr><td>now+n weeks</td><td>现在起向后n周</td><td>at now+1 weeks</td><td></td></tr></tbody></table><p>与at命令相关的还有atq命令（显示队列中的作业信息）和atrm命令（删除队列作业）。下图所示为atq和arm命令的使用方法 </p><ul><li><code>batch命令</code>：在系统负载较低的时候执；</li></ul><p>2、batcht命令：设定完作业后，会等到系统载荷小于0.8的时候执行作业。<br>在使用batch时，不需要参数，batch执行时依然是在at输入符下输入要执行的命令，最后输入Ctrl+d结束batch命令，如图所示。 </p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226232157429.png" alt="image-20210226232157429"></p><p>上述命令执行完毕后，立刻使用“ls”命令就可以看到“bt.txt”文件。如图所示 。这是因为此时系统负载较小，所以作业立即执行了 。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226232216555.png" alt="image-20210226232216555"></p><ul><li><code>crontab命令</code>：用于创建周期运行的任务作业。</li></ul><p>crontab命令：可以设定周期运行的任务作业 。<br>使用命令“crontab -e”，即可创建作业，该命令打开一个编辑窗口，用户需要将设定的任务写入文件中。<br>首次使用该命令时，系统要求选择默认的编辑器，如图所示。本例中选择“3”，使用vim作为默认编辑器。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226232247830.png" alt="image-20210226232247830"></p><p>3、crontab命令：可以设定周期运行的任务作业 。<br>在打开的编辑器内，需要按照如下固定格式输入要执行的任务：</p><p><code>分钟  小时  日期  月份  星期  命令</code></p><p>可以使用通配符“*”表示任何时间，例如要设定在每日10点20分执行一次“touch test.txt”，可以输入以下内容：</p><p><code>20 10 * * * touch test.txt</code></p><p>入完crontab作业后，按下ESC键，输入“:wq”，保存退出，crontab即可生效。若要编辑crontab作业，可以再次运行“crontab -e”命令；若要查询crontab作业，可以使用命令“crontab -l”，如图所示</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226232419159.png" alt="image-20210226232419159"></p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>Linux的进程管理是通过进程管理工具实现的，主要有以下工具命令：</p><ul><li>ps，查询列举进程；</li><li>pgrep，按名字查询进程；</li><li>pstree，显示进程树；</li><li>kill，杀死进程。</li></ul><h3 id="ps命令：查询进程"><a href="#ps命令：查询进程" class="headerlink" title="ps命令：查询进程"></a>ps命令：查询进程</h3><p>ps用于查询进程，其语法格式如下：</p><p><code>ps  [选项]  &lt;程序名&gt;</code></p><table><thead><tr><th><strong>选项参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>a</td><td>显示终端上的所有进程，包括其他用户的进程</td></tr><tr><td>u</td><td>按用户名和启动时间的顺序来显示进程</td></tr><tr><td>x</td><td>显示无控制终端的进程</td></tr><tr><td>l</td><td>长格式显示</td></tr><tr><td>-e</td><td>显示所有进程</td></tr><tr><td>-f</td><td>全格式输出，即可以看到进程的命令行</td></tr><tr><td>-u</td><td>有效使用者相关的进程</td></tr></tbody></table><p>ps命令常用的选项组合是“aux”、“-ef”等。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226232634201.png" alt="image-20210226232634201"></p><p>ps命令相关显示信息如下：<br>USER，运行进程的用户；<br>PID，进程的ID号；<br>%CPU，进程使用的CPU资源百分比；<br>%MEM，进程使用的内存资源百分比；<br>VSZ，进程使用的虚拟内存（Kbytes）；<br>RSS，进程所使用物理内存的大小；<br>TTY，进程关联的终端，如果没有终端显示“？”；<br>STAT，进程目前的状态，主要状态如表4- 4所示；<br>TIME，当前为止进程已经运行的时间，或休眠和停止之前运行的时间；<br>COMMAND，进程的程序名。</p><p>其中进程状态（stat），如下表所示。</p><table><thead><tr><th><strong>进程状态</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>R</td><td>正在运行，或等待被系统调度来使用CPU</td></tr><tr><td>S</td><td>休眠</td></tr><tr><td>T</td><td>停止或正在被系统侦测</td></tr><tr><td>Z</td><td>僵死进程</td></tr></tbody></table><h3 id="pgrep命令"><a href="#pgrep命令" class="headerlink" title="pgrep命令"></a>pgrep命令</h3><p>1、通过程序的名字来查询进程，一般用来判断程序是否正在运行，这在服务器的配置和管理中可以用到<br>语法格式如下：<code>pgrep  [选项]  &lt;程序名&gt;</code></p><p>其中，常用选项如下 ：<br>-l，列出程序名和进程ID；<br>-o，程序名匹配最早生成的进程；<br>-n，程序名匹配最新生成的进程。</p><p>2、pgrep命令：通过程序的名字来查询进程，一般用来判断程序是否正在运行，这在服务器的配置和管理中可以用到<br>例如，“/sbin/init”程序是一个系统进程，可以使用pgrep命令查看其进程ID，如图所示 ：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226233323912.png" alt="image-20210226233323912"></p><h3 id="pstree命令"><a href="#pstree命令" class="headerlink" title="pstree命令"></a>pstree命令</h3><p>使用树形结构显示进程间的关系。pstree有很多参数，一般情况下直接使用pstree命令获取进程间的关系情况。如图示 ：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226233435108.png" alt="image-20210226233435108"></p><h3 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h3><p>当某个进程由于某种原因（如死锁）需要用户干预以提前终止。一般结合ps或pgrep命令，找到进程的ID，然后用kill终止它。<br>kill命令语法格式如下：</p><p><code>kill [信号代码]  进程ID</code></p><p>其中，信号代码可以省略，常用的信号代码是-9，表示<code>强制终止</code>。</p><h2 id="多用户和多任务"><a href="#多用户和多任务" class="headerlink" title="多用户和多任务"></a>多用户和多任务</h2><p>有两个概念需要理解：</p><ul><li><p>单用户多任务：单个用户可以同时执行多个进程（程序），例如单个用户可以同时运行vim、gedit等多个进程；</p></li><li><p>多用户多任务：多个用户同时登录并使用系统，例如有本地用户、远程的网络用户同时登录系统。</p><p><code>Linux支持多用户同时使用系统，也支持单个用户运行多个任务 </code></p></li></ul><h3 id="用户和组管理"><a href="#用户和组管理" class="headerlink" title="用户和组管理"></a>用户和组管理</h3><table><thead><tr><th><strong>命令</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>useradd</td><td>创建新用户</td></tr><tr><td>userdel</td><td>删除用户</td></tr><tr><td>usermod</td><td>修改用户账号</td></tr><tr><td>passwd</td><td>修改用户口令</td></tr><tr><td>groupadd</td><td>创建组</td></tr><tr><td>groupdel</td><td>删除组</td></tr></tbody></table><h2 id="相关系统文件"><a href="#相关系统文件" class="headerlink" title="相关系统文件"></a>相关系统文件</h2><ul><li><p>/etc/passwd </p><blockquote><p>“/etc/passwd”是用户账号文件，该文件每行存放1个账户的一些信息，信息被“：”隔开成7个域，内容格式如下：</p></blockquote></li></ul><p><code>用户名:口令:用户ID:组ID:用户全名或描述:登录目录:登录Shell</code></p><p>上述信息中的“口令”，其实只是个特殊字符，如“x”或“*”，真正的口令在/etc/shadow文件中 </p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226234325106.png" alt="image-20210226234325106"></p><p>2、/etc/shadow<br>“/etc/shadow”是用户口令文件，其中存放已经加密的用户口令，每行一个用户信息，用“：”分割成9个域，包括：<br>用户名<br>加密后的口令<br>从1970年1月1日至今密码最近一次被修改的天数<br>从1970年1月1日起多少天内口令不能修改<br>从1970年1月1日多少天内口令必须修改<br>提前多少天警告用户口令将过期<br>在口令过期之后多少天禁用此用户<br>从1970年1月1日起多少天后口令失效<br>保留</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226234419850.png" alt="image-20210226234419850"></p><p>3、/etc/group<br>“/etc/group”是组账号文件，每行存放一个组账号信息，用“：”分割成4个域：</p><p><code>组名:组口令:组ID:组成员列表</code></p><p>其中“组口令”一般的Linux系统都不使用，通常这个位置是一个特殊字符，例如“x” </p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226234527544.png" alt="image-20210226234527544"></p><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><p>输出重定向用大于号“&gt;”，如果这条命令要往标准输出写入或者发送信息，那么都将写入输出文件中，而不是与命令所关联的显示器。<br>其语法格式有两条：</p><p><code>命令 &gt; 文件</code><br><code>命令 &gt;&gt; 文件</code></p><p>上述第一条命令，将命令的执行结果送至指定的文件中，若文件已存在，则<code>覆盖</code>；<br>第二条命令，将命令的执行结果<code>追加</code>到指定文件中。 </p><h3 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h3><p>输入重定向用小于号“&lt;”来表示，如果命令从标准输入中读取输入，这个输入就是来自输入文件，而不是和命令相关的键盘。<br>其语法格式如下：</p><p>&lt;命令&gt;  &lt;  &lt;文件&gt;</p><p>其中：</p><ul><li>命令，可以是任何一条Shell命令；</li><li>文件，是要作为输入命令的文件 </li></ul><h3 id="错误输出重定向"><a href="#错误输出重定向" class="headerlink" title="错误输出重定向"></a>错误输出重定向</h3><p>可以通过描述符（0、1、2）与操作符“&lt;”和“&gt;”相关联，来对标准输入、标准输出、错误输出重定向。<br>示例：通过使用“2&gt; ”对一条命令标准出错进行重定向 </p><p>$ cat a.c<br>$ cat a.c 2&gt; error.txt</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226234827588.png" alt="image-20210226234827588"></p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><h3 id="管道的概念"><a href="#管道的概念" class="headerlink" title="管道的概念"></a>管道的概念</h3><p>Linux系统允许通过管道操作将一条命令的输出作为另一条命令的标准输入。管道的操作符是一个竖杠“|”。下图说明了管道操作的含义 </p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210226235005809.png" alt="image-20210226235005809"></p><p>简单的说就是利用管道符“|”将两个命令分开，管道符左边命令的输出就会作为管道符右边命令的输入；<br>连续使用管道意味着第一个命令的输出会作为第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推。 </p><ul><li>使用ls和more命令，利用管道操作分屏显示目录“/usr/include”里的内容。具体操作步骤如下：</li></ul><p>1、用ls命令查看目录“/usr/include”里的内容<code>ls /usr/include</code></p><p>2、ls命令通过管道将内容输出到more命令，从而可以进行分屏控<code>ls /usr/include | more</code></p><ul><li>使用ls、grep和more命令，利用管道操作查找“/usr/include”目录内以字符串“lib”开头的“.h”文件，并分屏显示 </li></ul><p><code>ls /usr/include | grep &#39;^lib&#39; | more</code></p><h1 id="第5章-Shell编程"><a href="#第5章-Shell编程" class="headerlink" title="第5章 Shell编程"></a>第5章 Shell编程</h1><ul><li><p>在Linux系统中，虽然有各种各样的图形化操作工具，但是Shell仍然是一个非常灵活的工具：<br>Shell不仅能够执行命令，而且是一门非常优秀的编程语言。</p></li><li><p>通过使用Shell编程可以使大量的任务自动化。</p></li><li><p>Shell程序特别擅长系统管理任务，尤其适合那些易用性、可维护性和便携性比效率更重要的任务。</p></li></ul><h2 id="Shell特点"><a href="#Shell特点" class="headerlink" title="Shell特点"></a>Shell特点</h2><p>Linux系统中的Shell脚本通常具备以下特点：</p><ul><li>Shell脚本程序是由Shell环境解释执行的；</li><li>Shell脚本不需要编译、连接及生成可执行文件，直接由相应的解释器解释执行即可；</li><li>执行Shell程序时，Shell脚本文件需要具有可执行的权限；</li><li>Shell脚本可以使用变量、控制语句等比较复杂的结构；</li><li>Shell脚本是从上而下，顺序执行的。</li></ul><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><table><thead><tr><th><strong>环境变量</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>$PATH</td><td>以冒号分割的，统常用来搜索命令的目录列表</td></tr><tr><td>$HOME</td><td>当前用户的主目录</td></tr><tr><td>$0</td><td>shell脚本程序的名字</td></tr><tr><td>$#</td><td>传递给脚本的参数个数，如果脚本程序在调用时没有传递任何参数，则$#的值是0</td></tr><tr><td>$IFS</td><td>输入域分隔符。当Shell读取输入时，它给出用来分隔单词的一组字符，通常是空格、制表符和换行符等</td></tr><tr><td>$1,$2,…</td><td>脚本程序调用时传递过来的参数</td></tr><tr><td>$*</td><td>在一个变量中列出所有的参数，各个参数之间用$IFS中的第一个字符分隔</td></tr></tbody></table><p><a href="">参考资料</a></p><h1 id="第6章-网络操作"><a href="#第6章-网络操作" class="headerlink" title="第6章 网络操作"></a>第6章 网络操作</h1><p>TCP/IP协议应用层协议是直接为用户服务的网络协议，常见应用层协议如表所示：</p><table><thead><tr><th><strong>协议</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>HTTP</td><td>超文本传输协议，用于实现互联网中的www服务</td></tr><tr><td>FTP</td><td>文件传输协议，实现上传下载</td></tr><tr><td>DNS</td><td>域名解析服务，提供域名到IP地址之间的转换</td></tr><tr><td>Telnet</td><td>用户远程登录服务</td></tr></tbody></table><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>TCP/IP协议中的网络层也称为IP层，按照该层协议的要求，为连接在Internet上的每个主机分配一个32bit长的地址，称之为IP地址。</p><p> IP地址用二进制表示，32bit的IP地址可换算成4个字节。</p><p>为了方便使用，IP地址经常被写成十进制的形式，中间用“.”分开不同的字节，如“202.102.134.68”。 </p><h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>按照TCP/IP协议的要求，可以将IP地址划分成“网络地址”和“主机地址”两部分。 </p><p>为了方便计算，使用“子网掩码”来指明一个IP地址哪些位标示的是“主机”所在子网，哪些位标示的是主机的位掩码。</p><p>与IP地址相同，子网掩码也用二进制来表示，长度也是32位，且有以下规律：<br>子网掩码的二进制位1和0分别连续；<br>左边是网络位，用二进制数“1”表示，“1”的数目等于网络位的长度；<br>右边是主机位，用二进制数“0”表示，“0”的数目等于主机位的长度。</p><p>以上规则的设计目的是：<code>让子网掩码与IP地址做“与”运算时用“0”遮住原主机数，而不改变原网络段数字，且方便通过“0”的位数确定子网的主机数。</code> </p><h2 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>功能</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>ifconfig</td><td>查看和配置网络接口的参数</td><td></td></tr><tr><td>ping</td><td>用于查看网络上的主机是否在工作</td><td></td></tr><tr><td>ftp</td><td>登录到FTP服务器，以利用ftp协议上传和下载文件</td><td>需要安装FTP客户端软件，Ubuntu11.04已默认安装</td></tr><tr><td>telnet</td><td>利用telnet协议访问主机</td><td>需要安装telnet客户端软件，Ubuntu11.04已默认安装</td></tr><tr><td>ssh</td><td>利用ssh协议登录对方主机</td><td>需要ssh客户端软件，Ubuntu11.04已默认安装</td></tr><tr><td>iptables</td><td>网络数据包过滤设置</td><td></td></tr></tbody></table><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><p>1、查看网络配置情况<br>使用ifconfig查看当前系统网络配置情况的语法格式如下： </p><p><code>  ifconfig  [网络接口]</code></p><p>其中，“网络接口”是一个后跟单元号的驱动设备名，例如第一个以太网接口eth0、第二个以太网接口eth1等 ；<br>使用以上命令时，若省略“网路接口”，则查询本机所有网络接口的配置情况。 </p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210227000231844.png" alt="image-20210227000231844"></p><p>2、配置指定接口参数<br>使用ifconfig命令配置指定接口（如eth0、eth1）的参数（如IP地址、网络掩码、广播地址等），语法格式如下：</p><p><code>  ifocnifg &lt;网络接口&gt; [选项] &lt;IP地址&gt;</code></p><p>其中，常用“选项”如下：<br>down，关闭指定的网络设备<br>up，启动指定的网络设备<br>netmask&lt;子网掩码&gt;  </p><p>示例：设置本机eth0的IP地址为“192.168.1.6”子网掩码为“255.255.255.0”。 </p><p><code>sudo ifconfig eth0 192.168.1.6 netmask 255.255.255.0</code></p><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>使用ping命令可以检查网络是否能够连通。<br>常用语法格式如下：</p><p> <code>ping  &lt;IP地址&gt;</code></p><p>其中，“IP地址”是要测试能够通过网络到达的主机的IP地址。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210227000534701.png" alt="image-20210227000534701"></p><h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><p>使用ftp命令可登录到FTP服务器，ftp命令运行成功后，用户需要输入相应的用户名和密码，验证通过后，用户可以使用相关的FTP客户端命令进行远程文件操作。<br>FTP登录命令常用语法格式如下：</p><p><code>ftp  &lt;IP地址&gt;</code></p><p>其中，“IP地址”是提供FTP服务的主机IP地址。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210227000626239.png" alt="image-20210227000626239"></p><table><thead><tr><th><strong>命令</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>ls</td><td>列举服务器上的文件</td></tr><tr><td>get</td><td>下载文件</td></tr><tr><td>put</td><td>上传文件</td></tr><tr><td>mkdir</td><td>建立目录</td></tr><tr><td>rmdir</td><td>删除目录</td></tr><tr><td>cd</td><td>改变工作目录</td></tr><tr><td>help</td><td>查看帮助</td></tr><tr><td>bye</td><td>退出FTP</td></tr></tbody></table><h1 id="第7章-编程工具"><a href="#第7章-编程工具" class="headerlink" title="第7章 编程工具"></a>第7章 编程工具</h1><h2 id="编译链接"><a href="#编译链接" class="headerlink" title="编译链接"></a>编译链接</h2><p>在Linux中，C程序的编译用gcc程序，链接用ld程序，gcc编译完后可自动调用ld程序完成链接过程。因此这里重点介绍gcc程序。<br>调用gcc编译程序的的语法格式如下：</p><p><code>gcc [选项] &lt;文件名&gt;</code></p><p>其中，最常使用的选项有：<br>-c：只编译，不链接成为可执行文件<br>-o output_filename：确定输出文件,默认是a.out<br>-g：产生符号调试工具（GNU的gdb）所必要的符号信息<br>l-pg：产生代码剖析工具gprof使用的信息<br>-w：忽略警告信息<br>文件名：需要编译程序的文件名</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>Linux上调试C语言程序，可使用gdb程序。<br>使用gdb调试程序前，需要先使用gcc的“-g”选项编译程序，而后通过gdb命令加载编译好的程序， gdb会不断从键盘接收用户命令并完成相应的任务，直到输入q命令（quit的简写）让它退出为止。</p><p><code>&lt;gdb&gt; &lt;可执行程序&gt;</code></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210227000951646.png" alt="image-20210227000951646"></p><table><thead><tr><th><strong>命令</strong></th><th><strong>命令简写</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>list</td><td>l</td><td>列出程序的源代码</td></tr><tr><td>break</td><td>b</td><td>b &lt;代码行号&gt;，在某代码行设置断点</td></tr><tr><td>run</td><td>r</td><td>从头开始，全速运行程序至断点处</td></tr><tr><td>step</td><td>s</td><td>单步执行</td></tr><tr><td>continue</td><td>c</td><td>继续运行到下一个断点</td></tr><tr><td>delete</td><td>d</td><td>直接运行d命令，表示要删除所有断点；d &lt;代码行号&gt;，表示删除指定的断点</td></tr><tr><td>print</td><td>p</td><td>p &lt;变量名&gt;，显示某个变量的值</td></tr><tr><td>kill</td><td>k</td><td>停止被调试程序的运行</td></tr></tbody></table><h2 id="make工具"><a href="#make工具" class="headerlink" title="make工具"></a>make工具</h2><p>make工程管理器简称make工具，可以同时管理一个项目中多个文件的编译链接和生成。<br>make工具其实是个“自动编译管理器”， “自动”是指它能够根据文件时间去自动发现更新过的文件而减少编译的工作量。<br>make工具通过“Makefile”文件的内容自动执行大量的编译工作，而用户只需要编写一些简单的编辑语句，这极大地提高了实际项目的工作效率，几乎所有Linux下的项目均会使用它。</p><p>使用make工具时的语法格式如下：<code>make [选项] [目标]</code></p><p>其中，如果省略“选项”和“目标”，则make工具会寻找当前目录下的Makefile文件，解释执行其中的规则：<br>常用的“选项”如下<br>-f 文件，告诉make工具使用指定的文件作为Makefile文件<br>-d，显示调试信息<br>-n，测试模式，并不真正执行任何命令<br>-s，安静模式，不输出任何信息<br>“目标”：直接执行Makefile中的指定目标</p><p>Makefile文件由注释和一系列的“make规则”组成。“make规则”由以下格式组成</p><p><code>&lt;目标文件列表&gt;:[依赖文件列表][&lt;Tab&gt;命令列表]</code></p><p>其中：<br>目标文件列表：一系列文件名，文件之间要用空格隔开，是make最终需要创建的文件<br>依赖文件列表：一系列文件名，文件之间要用空格隔开，是生成目标文件所依赖的一个或多个其他文件<br>命令列表：必须有个前导TAB键操作。生成目标文件所需要执行的shell命令。一个make规则可以有多个命令行，每一条命令占一行。且每一个命令的第一个字符必须是制表符[Tab]。</p><blockquote><p>无论上述那个Makefile文件（本例假设使用上述第一个Makefile文件），都可以直接执行make命令，make工具自动寻找当前目录下的Makefile，并解释执行其中的规则：</p></blockquote><h2 id="gprof工具"><a href="#gprof工具" class="headerlink" title="gprof工具"></a>gprof工具</h2><p>gprof常用语法格式如下</p><p><code>gprof [选项] [可执行程序] [数据文件]</code></p><p>其中，“选项”是命令执行时可使用的参数，常用“选项”有中：<br>-b：不再输出统计图表中每个字段的详细描述<br>-p：输出函数的调用图<br>-q：输出函数时间消耗列表<br>-z：显示从未使用过的函数<br>可执行程序，指gcc用“-pg”选项编译的程序，可以省略，默认是是当前目录下的a.out文件<br>目标文件，可以省略，默认是当前目录下的gmon.out文件</p><p>使用gprof工具对程序进行静态分析。具体操作步骤如下<br>1、使用gcc的“-pg”选项编译程序</p><p><code>gcc –pg –o hello.exe hello.c</code></p><p>2、运行编译好的程序</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210227001247211.png" alt="image-20210227001247211"></p><p>3、用gprof命令查看gmon.out保存的信息</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210227001258170.png" alt="image-20210227001258170"></p><h2 id="time工具"><a href="#time工具" class="headerlink" title="time工具"></a>time工具</h2><p>time工具用于分析一个程序或任何Shell命令的运行效率。<br>Linux下time命令可以获取一个程序的执行时间，包括程序的实际运行时间（real time），以及程序运行在用户态的时间（user time）和内核态的时间（sys time）。它们的意义如下：</p><ul><li>实际运行时间，是指程序从开始运行到结束所花费的时间</li><li>用户态时间，是真正的代码执行时间</li><li>内核态时间，是指程序执行时系统活动所花费的时间</li></ul><p>time工具的常用语法格式如下：</p><p><code>&lt;time&gt; [选项] [用户程序]</code></p><p>其中，“选项”是命令执行时可使用的参数，常用“选项”有：<br>-o：将time的输出写入所指定的文件中，如果文件已经存在，系统将覆盖其内容<br>-a：配合-o使用，将结果写到文件末端，而不会覆盖掉原来的内容<br>-p：把显示格式设定为百分比的形式<br>用户程序，要动态分析的程序名，需要包含路径</p><p><code>time ./hello.exe</code></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210227001357047.png" alt="image-20210227001357047"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.xduph.com/">计算机组成与系统结构</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS篇-计算机组成与系统结构</title>
    <link href="/2021/02/10/os/OS%E7%AF%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    <url>/2021/02/10/os/OS%E7%AF%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="第1章-绪论"><a href="#第1章-绪论" class="headerlink" title="第1章 绪论"></a>第1章 绪论</h1><h2 id="摩尔定律"><a href="#摩尔定律" class="headerlink" title="摩尔定律"></a>摩尔定律</h2><blockquote><p>1965年4月,《电子学》杂志刊登了戈登•摩尔(Gordon　Moore)撰写的一篇文章。摩尔 当时是仙童半导体公司研发部门的主管。摩尔在该文中讲述了他如何将50个晶体管集成 在一块芯片中,并且预言,到1975年,就可能将6.5万只这样的元件密植在一块芯片上, 制成高度复杂的集成电路。　　摩尔的预言不仅对他本人,而且对整个社会都是意义深远的。后来摩尔与其他人共同 成立了英特尔(Intel)公司,并通过他所开创的技术创造了无数的财富。</p></blockquote><blockquote><p>摩尔定律并不是一个物理定律(物理定律是放之四海皆准的),而是一种预言,它鞭策 着工业界不断地改进,并努力去实现它。从人们认识摩尔定律开始,无论是Intel公司、 AMD公司,还是其他半导体器件公司,无一不是在不断地努力去实现摩尔定律,不断地推 出集成度更高的产品。下图为典型微处理器集成度随时间(年)的增长情况。由图可见,到目前为止,微 处理器芯片的集成度仍然随时间呈指数级增长。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218230340311.png" alt="image-20210218230340311"></p><ul><li>(1)虽然芯片的集成度快速提高,但单个芯片的成本变化不大,这意味着可以用更少 的芯片来实现计算机逻辑电路和存储电路,在相同性能的情况下,价格显著下降;在相同 价格的情况下,新一代的计算机功能更强,性能更好。 </li><li>(2)随着芯片集成度的提高,芯片中电路各部分之间的信号传输路径显著缩短,信号 传输延时小,微处理器的主频得以提高,计算机的速度更快。</li><li>(4)通过提高芯片的集成度,降低工作电压,可显著降低芯片的功耗,使得便携式、嵌 入式计算机用电池供电成为可能,也降低了高性能计算机对散热的要求。 </li><li>(5)芯片内部电路各部分之间的连接比外部连接更加可靠。随着芯片集成度的增加,构 成计算机所需的芯片数量越来越少,芯片之间所需的连线(焊点)也越来越少,计算机的可 靠性越来越高。</li></ul><h2 id="计算机的基本组成"><a href="#计算机的基本组成" class="headerlink" title="计算机的基本组成"></a>计算机的基本组成</h2><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218230804565.png" alt="冯·诺依曼计算机的设计思想"></p><blockquote><p>冯·诺依曼计算机工作的基本思想就是:将计算机要处理的问题用指令编成程序,并 将程序存放在存储器中,在控制器的控制下,从存储器中逐条取出指令并执行,通过执行 程序最终解决计算机所要处理的问题。尽管经历了几十年的发展,也出现了新的设计思想, 但冯·诺依曼的这种存储程序控制原理直到今天仍然在广泛地应用。</p></blockquote><p>特点</p><p>(1)计算机由运算器(算术逻辑部件 ALU)、存储器、控制器、输入设备和输出设备五 大部件组成。 </p><p>(2)指令和数据以二进制形式表示,以同等地位存放在存储器中,并可按地址访问。用 二进制不仅电路简单,使用方便,而且抗干扰能力强。 　</p><p>(3)指令由操作码和地址码组成。操作码指明指令的功能,地址码指明操作数与运算 结果的存放位置(地址)。</p><p>(4)将计算机要处理的问题用指令编成程序。</p><p>(5)在控制器的控制下,指令被逐条(顺序)从存储器中取出来执行,产生控制流,在控 制流的驱动下完成指令的功能。在此过程中,数据(流)则是被动地调用。 </p><p>(6)在特定条件下,可由跳转类指令根据运算结果或设定的条件改变程序中指令的执 行顺序。</p><p>(7)早期的冯·诺依曼计算机以运算器为中心,输入/输出设备通过运算器与存储器传 送数据。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218231212735.png" alt="微型计算机(PC)结构框图"></p><h2 id="指令集体系结构-ISA-概述"><a href="#指令集体系结构-ISA-概述" class="headerlink" title="指令集体系结构(ISA)概述"></a>指令集体系结构(ISA)概述</h2><blockquote><p>处理器支持的指令和指令的字节级编码称为指令集体系结构(Instruction-SetArchitec- ture,ISA)。ISA 是软件和硬件的分界面,软件(程序)是由ISA 规定的“指令”组成的,指令 通过二进制编码规定其功能、源操作数和目的操作数的位置等信息。计算机中的控制器在 执行指令时,根据上述信息产生相应的控制信号,控制计算机系统各硬件模块完成指令要 求的功能。</p></blockquote><h2 id="典型的ISA"><a href="#典型的ISA" class="headerlink" title="典型的ISA"></a>典型的ISA</h2><ul><li><p>1)x86 </p><blockquote><p>x86由Intel公司推出,于1978年首次用于8086处理器。随着个人计算机的兴起和飞 速发展,x86从最初的16位架构发展到32位、64位架构,越来越多的指令和功能被添加 进来,使得x86越来越臃肿。但是,保持软件的向后兼容远比技术更重要,这使得x86拥有 了广泛的软件资源和越来越多开发基于x86的软件的程序员。如今,x86已成为个人计算 机的标准处理器架构,成为桌面计算机和高性能计算领域最成功的ISA。</p></blockquote></li><li><p>2)ARM </p><blockquote><p>ARM(AdvancedRISC Machines)公司诞生于英国,总部位于英国剑桥,主要业务是设 计 ARM 架构的处理器,同时提供与 ARM 处理器相关的配套软件,以及各种 SOC 系统 IP、GPU、物联网平台等。</p></blockquote></li><li><p>3)POWER</p><blockquote><p>POWER(PerformanceOptimization WithEnhancedRISC,增强 RISC 性能优化)是 IBM 公司设计开发的指令集体系结构,最早于1990年推出,性能卓越。</p></blockquote></li><li><p>4)MIPS </p><blockquote><p>MIPS(MicroprocessorwithoutInterlockedPipedStages,无内部互锁流水线微处理器) 是一款经典的精简指令集架构,由美国斯坦福大学的JohnL.Hennessy教授领导的研究小 组于1981年开始设计。他们在1984年创立了 MIPSComputerSystem 公司,推出了商用 的 MIPS处理器。此后,MIPS指令集体系结构不断扩充与改进,从 MIPS Ⅰ、MIPS Ⅱ、 MIPS Ⅲ、MIPS Ⅳ、MIPS Ⅴ发展到了 MIPS32、MIPS64。</p></blockquote></li><li><p>5)SPARC</p><blockquote><p>从1980年开始,美国加州大学伯克利分校的 DavidA.Patterson教授领导了 RISC-I 的设计与实现工作,这是一台超大规模集成电路精简指令集计算机,为商业 SPARC 体系 结构奠定了基础。</p></blockquote></li><li><p>6)RISC-V</p><blockquote><p>RISC-V 架构是一款袖珍的、开源的ISA,于2011年推出,由美国加州大学伯克利分 校的 KrsteAsanovi’c教授、Andrew Waterman和 YunsupLee等开发人员发明,并得到了 DavidA.Patterson教授的大力支持。“RISC”表示精简指令集,“V”表示伯 克 利 分 校 从 RISC-I开始设计的第五代指令集。</p></blockquote></li></ul><h2 id="高级语言程序的执行过程"><a href="#高级语言程序的执行过程" class="headerlink" title="高级语言程序的执行过程"></a>高级语言程序的执行过程</h2><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218234706451.png" alt="插入排序的 C语言源代码"></p><p>该 C语言程序可运行在基于x86处理 器的 Windows操作系统下,使用 MicrosoftVisualC++2017编译,目标平台设置为Intelx86的32位指令集(IA-32),通过设置优化参数以减小输出代码,提高运行速度,同时使生 成的代码更简洁,更容易理解。生成的机器语言代码如表</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218234849684.png" alt="image-20210218234849684"></p><p>指令“subeax,4”(上表第21行)的功能为:</p><blockquote><p>寄存器eax的内容与立即数4(符号位扩 展至32位)相减,结果存入寄存器eax。该指令的机器语言代码为三个字节,内容为十六进 制数83E804,其二进制编码各部分含义如下图所示。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218235116294.png" alt="image-20210218235116294"></p><p>使用gcc编译器,将目标平台设置为 RISC-V RV32I指令集,通过设置优化参数以减 少输出代码的大小,使得生成的代码更简洁,更容易理解。插入排序的 C 语言源代码经过 gcc编译后,生成的汇编语言及机器语言代码如表</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218235523430.png" alt="image-20210218235523430"></p><p>指令“addia2,a2,-4”的功能为:源1(a2寄存器的内容)与源2(立即数“-4”,符号位 扩展至32位)相 加,结 果 存 入 目 的 寄 存 器 a2。该 指 令 的 机 器 语 言 代 码 为 十 六 进 制 数 ffc60613,其二进制编码各部分含义如图</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218235538463.png" alt="image-20210218235538463"></p><p>操作码规定指令的基本功能与格式;功能码规定指令具体的操作类型;源1 与目的寄存器编码为“01100”,即寄存器x12,其别名为a2(RISC-V 基础指令集(RV32I)规 定了32个寄存器(x0~x31),因此寄存器编号用5位二进制数进行编码。RISC-V 汇编语言 根据各寄存器的功能和使用方式的不同,规定了相应的别名);源2为立即数“-4”,直接 存储在指令中,用补码表示。</p><h2 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h2><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210218235814608.png" alt="计算机系统的层次结构"></p><h2 id="计算机属性"><a href="#计算机属性" class="headerlink" title="计算机属性"></a>计算机属性</h2><ul><li>数据的表示形式;</li><li>寻址方式; </li><li>内部寄存器组; </li><li>指令集; </li><li>中断系统; </li><li>处理器工作状态及其切换; </li><li>存储系统结构; </li><li>输入/输出结构; </li><li>信息保护及特权; </li><li>高性能设计等。</li></ul><p><code>吞吐量(Throughput)定义为在给定时间内(并行)完成的总任务数。</code></p><h1 id="第2章-计算机系统中的数据表示"><a href="#第2章-计算机系统中的数据表示" class="headerlink" title="第2章 计算机系统中的数据表示"></a>第2章 计算机系统中的数据表示</h1><ul><li><p>无符号数</p><blockquote><p>所谓无符号数,即没有符号的数,数中的每一位均用来表示数值。所以8位二进制无符号数所表示的数值范围是0<del>255,而16位无符号数的表示范围为0</del>65535。</p></blockquote></li><li><p>有符号数 </p><blockquote><p>由于机器无法直接识别“+”(正)、“-”(负)符号,而“正”“负”恰好是两种截然不同的 状态,因此若用“0”表示“正”,用“1”表示“负”,则符号可被数字化,再按规定将符号放在有 效数字的前面就组成了有符号数。</p></blockquote></li><li><p>定点数</p><blockquote><p>在机器数表示中,若约定小数点的位置固定不变,则称为定点数。有两种形式的定点 数,即定点整数(纯整数,规定小数点在数据最低有效数位之后)和定点小数(纯小数,规定 小数点在数据最高有效数位之前),如图</p></blockquote></li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210219001340876.png" alt="image-20210219001340876"></p><ul><li><p>浮点数</p><blockquote><p>基数为2的数F 的浮点表示为 F = M x 2^E</p></blockquote></li></ul><p>其中,M 称为尾数,E 称为阶码。尾数为带符号的纯小数,阶码为带符号的纯整数。按式(2.2)表示的数据既可以是纯整数,也可以是纯小数,还可以是同时含有整数和小 数的数据,其小数点的位置是不固定的,故称为浮点数。计算机中常用的一种浮点数的编 码格式如下图所示,其中数符(即数据的符号)就是尾符(即尾数的符号)。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210219001510678.png" alt="image-20210219001510678"></p><h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><blockquote><p>原码是机器数中最简单的一种表示形式,其符号位为0表示正数,符号位为1表示负 数,数值位即真值的绝对值。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210219144712557.png" alt="image-20210219144712557"></p><p>x=+35时，有[x]原＝00100011</p><p>x=-35时，有[x]原＝10100011</p><h3 id="小数原码的定义"><a href="#小数原码的定义" class="headerlink" title="小数原码的定义"></a>小数原码的定义</h3><p>x=0.46875时，有[x]原＝0.0111100</p><p>x=0.46875时，有[x]原＝1.0111100</p><h3 id="原码的特点"><a href="#原码的特点" class="headerlink" title="原码的特点"></a>原码的特点</h3><p>(1)数值原码表示法简单直观,但加减运算很麻烦。 </p><p>(2)对于数值0,用原码表示不是唯一的。以8位原码表示,有</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210219151319001.png" alt="image-20210219151319001"></p><h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210219151632091.png" alt="整数反码的定义"></p><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210219151408405.png" alt="补码的定义"></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210219151445153.png" alt="image-20210219151445153"></p><p>补码的特点</p><blockquote><p>(1)  n 位补码表示的整数数值范围为-2n-1<del>+(2n-1-1),n 位补码表示的小数数值 范围为-1</del>+(1-2-n+1)。</p><p>(2)  0 的表示是唯一的。以8位小数编码为例,有</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210219151601396.png" alt="image-20210219151601396"></p><h2 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h2><blockquote><p>由于移码多用于浮点数中表示阶码,均为整数,因此这里只介绍定点整数的移码表示。 当用包括符号位在内的n 位字长时,整数移码的定义为</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210219151758345.png" alt="image-20210219151758345"></p><blockquote><p>要获得整数的移码表示,可以利用定义计算,也可以先求出该数的补码后将符号位 取反。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210219151808472.png" alt="image-20210219151808472"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">(1)当真值为正时,原码、补码和反码的表示形式均相同,即符号位用“0”表示,数值 部分与真值相同。<br>(2)当真值为负时,原码、补码和反码的表示形式不同,但其符号位都用“1”表示,而 数值部分的关系为:反码是原码“每位取反”,补码是反码“加1”,补码是原码“求反加1”。<br>(3)移码较为特殊,当符号位为“0”时,表示真值为负数;当符号位为“1”时,表示真值 为正数。移码与补码编码仅符号位相反。<br></code></pre></td></tr></table></figure><h2 id="浮点数的表示方法"><a href="#浮点数的表示方法" class="headerlink" title="浮点数的表示方法"></a>浮点数的表示方法</h2><blockquote><p>由于计算机 字 长 的 限 制,当 需 要 表 示 的 数 据 有 很 大 的 数 值 范 围 (如 电 子 的 质 量 为 9×10-28克,太阳的质量为2×1033克)时,它们不能直接用定点小数或定点整数表示,而必 须用浮点数表示。由于计算机采用二进制,所以浮点数的一般表示形式为式</p></blockquote><p>例如,二进制数F=11.0101,用浮点数可表示为下列不同形态,即</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210219152104392.png" alt="image-20210219152104392"></p><h3 id="浮点数编码的规则"><a href="#浮点数编码的规则" class="headerlink" title="浮点数编码的规则"></a>浮点数编码的规则</h3><p>(1)尾数 M 必须为小数,用n+1位有符号定点小数表示,可以采用的编码有原码、补 码。阶码E 必须为整数,用k+1位有符号定点整数表示,可以采用的编码有原码、补码、 移码。浮点数编码位数为m=(n+1)+(k+1)。</p><p>(2)浮点数编码格式有多种,使用较多的格式如图2.2和图2.5所示,格式的选择可由 计算机设计人员决定。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210219152200059.png" alt="image-20210219152200059"></p><p>注意</p><blockquote><p>(1)阶码是整数,其位数k+1决定了浮点数表示的数值范围,也就是决定了数据的大 小,或小数点在数据中的真实位置。阶符决定阶码的正负。</p><p>(2)尾数是小数,其位数n+1决定了浮点数的精度如果尾数采用小数且位数n 足够长,则当浮点数运算需要对尾数运算结果舍入时,造成的数据精度损失会比较小。</p><p>(3)尾数的符号表示浮点数的正负。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210219152255347.png" alt="image-20210219152255347"></p><h1 id="第3章-运算方法与运算器"><a href="#第3章-运算方法与运算器" class="headerlink" title="第3章 运算方法与运算器"></a>第3章 运算方法与运算器</h1><h2 id="加减运算"><a href="#加减运算" class="headerlink" title="加减运算"></a>加减运算</h2><blockquote><p>有符号定点数的编码可以用原码、反码、补码、移码等形式表示。原则上讲,有符号数 的加减运算可以用任何一种编码来实现,但实际中用得最多、最普遍的是补码。</p></blockquote><p>$$<br>补码加法的运算法则为=[X+Y]_补＝[X]_补+[Y]_补<br>$$</p><p>$$<br>补码减法的运算法则为=[X-Y]_补＝[X]_补+[-Y]_补=[X]_补＋[[Y]_补]_补<br>$$</p><h2 id="一位全加器的实现"><a href="#一位全加器的实现" class="headerlink" title="一位全加器的实现"></a>一位全加器的实现</h2><blockquote><p>设一位全加器的输入分别为 Xi和Yi,低一位对该位的进位为Ci,全加器的结果(和) 为Zi,向高一位的进位为Ci+1,则实现一位全加器的逻辑表达式为</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210221130543183.png" alt="image-20210221130543183"></p><blockquote><p>其中,Gi为进位产生函数,Pi为进位传递函数。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210221130600459.png" alt="一位全加器逻辑电路及其框图"></p><h2 id="加法-减法器"><a href="#加法-减法器" class="headerlink" title="加法/减法器"></a>加法/减法器</h2><blockquote><p>在下图中,利用异或门和控制信号 M 可实现减法运算。当 M =0时,异或门输出Y, 实现加法 X+Y 的功能;当 M =1时,异或门输出Y,Y与最低进位C0=M =1相加,实现 减数求补(求负),然后与 X 做加法,从而实现减法 X-Y 的功能。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210221130723014.png" alt="行波进位的n 位加法/减法器"></p><h2 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h2><blockquote><p>在一些简单的计算机中,乘法运算可以用软件来实现。利用计算机中设置的加法、移 位等指令,编写一段程序完成两数相乘。若 CPU 硬件结构简单,则这种做法实现乘法所用 的时间较长,速度很慢。另一种情况是在 ALU 等硬件的基础上,适当增加一些硬件构成乘法器。这种乘法器 的硬件要复杂一些,但速度比较快。速度最快的是全部由硬件实现的阵列乘法器,其硬件 更加复杂。可见,可以用硬件来换取速度。</p></blockquote><h3 id="原码乘法运算"><a href="#原码乘法运算" class="headerlink" title="原码乘法运算"></a>原码乘法运算</h3><blockquote><p>1)原码一位乘法规则 假定被乘数 X、乘数Y 和乘积Z 为用原码表示的纯小数(下面的讨论同样适用于纯整 数),分别为</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210221131714158.png" alt="image-20210221131714158"></p><p>原码一位乘法规则如下: </p><blockquote><p>(1)乘积的符号为被乘数的符号位与乘数的符号位相异或。</p><p>(2)乘积的数值为被乘数的数值与乘数的数值之积,即</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210221131757022.png" alt="image-20210221131757022"></p><blockquote><p>(3)乘积的原码为</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210221131814964.png" alt="image-20210221131814964"></p><h3 id="补码乘法运算"><a href="#补码乘法运算" class="headerlink" title="补码乘法运算"></a>补码乘法运算</h3><blockquote><p>计算机中经常采用补码表示数据,这时用原码进行乘法运算很不方便,因此,较多计 算机采取补码进行乘法运算。一种经典的补码乘法算法为布斯法,它是补码一位乘法中的 一种,是由布斯(Booth)夫妇提出的。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210221132007877.png" alt="image-20210221132007877"></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210221132014254.png" alt="image-20210221132014254"></p><p>根据以上分析,可将布斯算法描述如下: </p><blockquote><p>(1)乘数与被乘数均用补码表示,连同符号位一起参加运算。</p><p>(2)乘数最低位后增加一个附加位(用 A-1表示),设定初始值为0。</p><p>(3)从附加位开始,依据表3.1所示的操作完成式(3.20)的运算。 实现布斯算法的流程如图3.13所示。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210221132055074.png" alt="image-20210221132055074"></p><h2 id="运算器基本结构"><a href="#运算器基本结构" class="headerlink" title="运算器基本结构"></a>运算器基本结构</h2><blockquote><p>运算器内部大多数采用总线互连。根据运算器内部总线的连接方式,可将运算器的基 本结构分为单总线结构、双总线结构及三总线结构,如图</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210221132211597.png" alt="image-20210221132211597"></p><h1 id="第4章-存储系统"><a href="#第4章-存储系统" class="headerlink" title="第4章 存储系统"></a>第4章 存储系统</h1><h2 id="存储系统的层次结构"><a href="#存储系统的层次结构" class="headerlink" title="存储系统的层次结构"></a>存储系统的层次结构</h2><blockquote><p>一台计算机中可能会包括各种存储器,如 CPU 内部的通用寄存器组、一级 Cache、二 级 Cache和三级 Cache,主板上的主存储器(简称主存),主板外的联机(在线)磁盘存储器 以及脱机(离线)的磁带、光盘存储器等。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210221132855855.png" alt="image-20210221132855855"></p><h2 id="主要的替换算法"><a href="#主要的替换算法" class="headerlink" title="主要的替换算法"></a>主要的替换算法</h2><ul><li>(1)随机替换(RAND)算法。</li><li>(2)先进先出(FirstInFirstOut,FIFO)算法。</li><li>(3)近期最少使用(LeastRecentlyUsed,LRU)算法。</li><li>(4)最不经常使用(LeastFrequentlyUsed,LFU)算法。</li><li>(5)最优替换(OptionalReplacement,OPT)算法</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210221134112903.png" alt="image-20210221134112903"></p><h3 id="更新策略"><a href="#更新策略" class="headerlink" title="更新策略"></a>更新策略</h3><blockquote><p>从前述内容可知,Cache的内容是主存部分内容的拷贝,其内容应当与主存的内容保 持一致。很显然,只是从 Cache中读出指令或数据是不会改变 Cache中的内容的,而 CPU 对 Cache单元的写就会改变其内容。为了保证主存与 Cache内容的一致性,主存的内容必 须随着 Cache内容的改变而更新。由于程序 Cache是只读的,不存在一致性问题,所以该 问题只发生在数据 Cache中。在数据 Cache被改写后,如何更新主存的内容,也即如何保 持主存与 Cache内容的一致性,可采取下述的更新策略(也称为写策略)。</p></blockquote><ul><li><p>1.写回法 </p><blockquote><p>写回法是当 CPU 写 Cache命中时,只将数据写入 Cache而不立即写入主存。只有当由 CPU 改写过的块被替换出去时该块才写回到主存中。</p></blockquote></li><li><p>2.写直达法 </p><blockquote><p>写直达法也称作全写法,是当 CPU 写 Cache命中时,在将数据写入 Cache的同时也写 入主存,从而较好地保证了主存与 Cache内容的一致性。</p></blockquote></li></ul><h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><blockquote><p>在虚拟存储器(VirtualMemory,VM)出现之前,计算机系统的所有程序共享一个主存 物理地址空间,为了防止冲突,每个机器语言程序必须十分清楚计算机的系统结构,这造 成了没有办法阻止用户程序访问任何计算机资源,从而可 能 给 系 统 运 行 带 来 灾 难 性 的 后果。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210221134335788.png" alt="image-20210221134335788"></p><blockquote><p>实际上,虚拟存储器就是主存与硬盘间的虚拟桥梁,用户与系统实体资源的真实屏障。 这个中间存储层的引入,使主存容量延伸到硬盘,解决了主存容量与成本的矛盾,同时其 屏障效应还带来了其硬件支持现代操作系统三大特征(转换、保护、共享)的好处。</p></blockquote><ul><li><p>(1)转换(Translation)。</p><blockquote><p>无论实际主存被谁占用,所有程序的主存空间是一致的;多线 程已成为可能,且已大量使用;仅程序中最重要(正在执行)的部分在主存中。 </p></blockquote></li><li><p>(2)保护(Protection)。</p><blockquote><p>不同的线程(或进程)互相保护;不同的页(或段)可以给予特定 的行为(只读、对用户程序不可见等);保护内核数据免受用户程序干扰,最重要的是免受 恶意程序干扰。</p></blockquote></li><li><p>(3)共享(Sharing)。</p><blockquote><p>可以将同一主存页映射到多个用户,即共享主存。</p></blockquote></li></ul><h3 id="虚拟存储器管理"><a href="#虚拟存储器管理" class="headerlink" title="虚拟存储器管理"></a>虚拟存储器管理</h3><ul><li><p>1.页式虚拟存储器</p><blockquote><p>在页式虚拟存储系统中,虚拟地址空间被分成许多固定大小的页,称为虚页或逻辑页。 主存地址空间也被分成若干同样大小的页,称为实页或物理页。页的大小为2的幂指数字 节或字,从几千字节到十几兆字节不等。所以,虚存地址(也称虚拟地址或逻辑地址)和主 存地址(也称实地址或物理地址)都包含两个字段,如图</p></blockquote></li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210221134545104.png" alt="image-20210221134545104"></p><ul><li><p>1)地址变换</p><blockquote><p>在管理页式虚拟存储器时,需要完成虚拟地址到物理地址的变换,该变换是基于全相 联地址映射并通过页表来实现的。在页表中每一条记录都包含虚页号所对应的实页号。如 图4.49所示,页表通常设置在主存中,表的起始地址可通过页表基址寄存器来设定。在页式 虚拟存储器的地址变换中,当程序给出虚拟地址后,CPU 以虚页号为偏移地址查页表,从而 获得相应的实页号。将实页号与虚拟页内地址连接到一起,便构成了主存的物理地址。</p></blockquote></li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210221134626090.png" alt="image-20210221134626090"></p><ul><li><p>2)快表与慢表</p><blockquote><p>由于页表设置在主存中,页式虚拟存储器工作时,首先要访问主存中的页表,进行地 址变换,获得主存地址。然后,再利用主存地址访问主存,获得指令/数据。显然,即使主存 命中,也需要两次访问主存才能获得主存信息。前面已提到主存速度比较慢,这必然会降 低 CPU 的速度。若是被访问的页不在主存中,那速度就更慢。</p></blockquote></li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210221134653708.png" alt="image-20210221134653708"></p><p>页式虚拟存储器的主要优点: </p><p>(1)主存的利用率高。由于页的容量较小,每一用户程序只有不到一页的浪费,故形成 的主存碎片小。</p><p>(2)页表的内容比较简单。 </p><p>(3)地址映射与地址变换速度比较快。 </p><p>页式虚拟存储器的主要缺点: </p><p>(1)程序的模块性差。因为页的大小是固定的,无法与程序模块保持一致。 </p><p>(2)页表很长。如前述例子中页表长达16M。</p><h1 id="第5章-指令系统"><a href="#第5章-指令系统" class="headerlink" title="第5章 指令系统"></a>第5章 指令系统</h1><blockquote><p>根据设计者、使用者不同的需求和要求,计算机系统通常采用分层方法构建。图5.1就 是一种通俗的计算机系统抽象分层结构。下图中,下面三层为微体系结构层、指令系统结 构(InstructionSystem Architecture,ISA)层、操作系统层。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210221134836240.png" alt="image-20210221134836240"></p><p>对于硬件设计者来说,一个好的指令系统更容易被高效率实现;对于软件设计者来说, 一个好的指令系统更便于编写程序代码。设计、评价指令系统一般从以下方面考虑: </p><p>(1)完备性:常用指令齐全,编程方便。 </p><p>(2)高效性:程序占主存空间少,运行速度快。 　　</p><p>(3)规整性:指令和数据使用规则统一简单,易学易记。 　　</p><p>(4)兼容性:同一系列的低档计算机的程序能在高档计算机上直接运行,即向后兼容 (BackwardCompatible)。</p><blockquote><p>指令有两种表现形式:机器指令和助记符指令。在计算机内部,每条指令用一定位数 (指令字长)、特定编码的二进制代码表示,称为机器指令(MachineInstruction)。机器指令 是 CPU 唯一能够识别、可执行的指令。但机器指令不便于人的识别和记忆,于是出现了用 特定英文符号来描述每条机器指令的做法,由此产生了助记符指令。所以,机器指令和助 记符指令是一对一的。下表给出了Intelx86和 RISC-V 指令系统中两条加法指令的示例。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210221134946387.png" alt="image-20210221134946387"></p><h3 id="存储模式"><a href="#存储模式" class="headerlink" title="存储模式"></a>存储模式</h3><ul><li>存储器结构</li><li>特殊存储区(如堆栈等)</li><li>数据存储顺序</li><li>边界对齐</li></ul><h2 id="指令类型"><a href="#指令类型" class="headerlink" title="指令类型"></a>指令类型</h2><blockquote><p>指令系统是指令系统结构层的主要特征,它的每一条指令规定了计算机的基本功能, 并可以被 CPU 执行。由指令构成的程序控制了计算机系统的运行,并决定了计算机系统要 完成的任务。</p><p>逻辑运算类指令提供处理用户希望使用的其他类型数据的能力。一般计算机中都设有与、 或、非、异或逻辑运算指令。有些计算机还设有位操作指令,如位测试、位清除、位设置等。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210221135125130.png" alt="image-20210221135125130"></p><h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><blockquote><p>​    寻址方式就是指令获取操作数的方式。换句话说,寻址方式是规定如何对地址码字段 作出解释以找到所需操作数的方式,或者程序转移时找到跳转地址的方式。<br>​    寻址方式的设定决定了每个地址码字段的长度(二进制位数),设计时要考虑两个方 面:一是要能够有效压缩地址码字段长度,二是要能够支持灵活的程序设计。</p></blockquote><ul><li><p>(1)隐式寻址:</p><blockquote><p>由操作码决定其寻址方式。 </p></blockquote></li></ul><ul><li><p>(2)显式寻址:</p><blockquote><p>指令中设置寻址方式字段,由寻址方式字段的不同编码来指定操作数 的寻址方式</p></blockquote></li></ul><h1 id="第6章-中央处理器"><a href="#第6章-中央处理器" class="headerlink" title="第6章 中央处理器"></a>第6章 中央处理器</h1><blockquote><p>利用大规模集成电路技术,计算机系统中的控制器、运算器、寄存器组(又称寄存器文 件)被集成在一块芯片上,形成了现在称之为 CPU 的中央处理单元,也称为(微)处理器。 由于控制器是计算机系统工作的控制核心,因此 CPU 成为现代计算机中的核心器件。</p></blockquote><h3 id="CPU的功能"><a href="#CPU的功能" class="headerlink" title="CPU的功能"></a>CPU的功能</h3><blockquote><p>到目前为止,所有商用计算机系统都是按照冯·诺依曼计算机的存储程序控制原理在 运行,所以CPU 是不可缺少的。CPU 的主要功能是执行存储在主存中的指令序列,也即执 行程序,具体操作如下: </p><p>(1)取得指令:CPU 从主存中取得指令,将其暂存在 CPU 内部的指令寄存器中。</p><p>(2)执行指令:CPU 对取得的指令进行译码、执行。</p><p>(3)确定下条指令地址:CPU 依据当前指令信息确定下条指令在主存中的地址(顺序 地址或由分支跳转类指令决定的跳转地址)。</p><p>(4)重复过程(1)~(3),直到将程序中所有指令执行完毕为止。</p><p>计算机的功能要通过 CPU 执行指令来体现,执行指令的核心部件就是控制器。控制器 的作用是为 CPU 内外的所有部件提供指令执行时所需的控制信号。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210221174228529.png" alt="指令周期"></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210221174448308.png" alt="image-20210221174448308"></p><h1 id="第7章-流水线技术"><a href="#第7章-流水线技术" class="headerlink" title="第7章 流水线技术"></a>第7章 流水线技术</h1><p>流水线的处理方式 </p><blockquote><p>流水线在我们日常生活和工厂生产线中经常采用。例如,工厂的自动化生产线均采用 流水作业的方式进行工件的加工处理,原材料每经过一道工序完成一步加工处理,变成半 成品,当半成品经过所有工序加工处理后就成为可用的成品。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210221174639346.png" alt="CPU 中流水线的一般结构"></p><h1 id="第8章-总线与输入-输出系统"><a href="#第8章-总线与输入-输出系统" class="headerlink" title="第8章 总线与输入/输出系统"></a>第8章 总线与输入/输出系统</h1><h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><blockquote><p>一台计算机由 CPU、存储器、I/O 设备三类模块组成,它们通过适当的通路进行连接, 连接三类模块的通路的集合称为互连结构(或互连网络)。仅在两个部件之间传递信息的通 路称为专用通路,而在不同时刻传递不同部件之间信息的通路称为共享(公用)总线。更广 义地讲,总线就是计算机系统中多个部件或设备共用的传递信息的数据通路(电子通道)。</p></blockquote><blockquote><p>现代计算机系统的典型互连结构是总线。一个总线结构的计算机是指其内部的各种子 系统和模块通过公用总线相互连接、通信而构成的计算机系统,它的基本架构如图8.1所 示。系统中的所有功能模块均连接在总线上,CPU 利用总线对存储器、I/O 资源进行管理 和操作。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210221180906060.png" alt="利用单总线进行连接通信的计算机系统"></p><h2 id="总线特性"><a href="#总线特性" class="headerlink" title="总线特性"></a>总线特性</h2><blockquote><p>总线不是简单的一组连接线,在所有标准化的总线规范中,总线是被全方位加以规 定的。</p></blockquote><blockquote><p>1)总线的特性 通常总线规范中会详细描述总线各方面的特性,如机械特性、电气特性、功能特性和 时间特性。</p></blockquote><p>(1)机械特性:规定了总线的线数,传输线采用的材料,总线插头、插座的形状、尺寸 和信号线的排列等要素。</p><p>(2)电气特性:规定了总线中每条信号线的有效形式、电流或电压的变化范围、信号传 送的方向(输入或输出)、信号采用单端或双端(差动)表示、信号是单向传输或双向传输、 信号上拉电阻阻值、驱动电路等要素。 </p><p>(3)功能特性:规定了总线中每条信号线的功能及数据传输协议。总线信号按功能分 为:地址信号、数据信号和控制信号三类,所有地址信号线组成地址总线,所有数据信号线 组成数据总线,所有控制信号线组成控制总线。　　</p><p>(4)时间特性:规定了总线的工作时序,即在总线上完成各种操作时,相关信号状态变 化与时钟节拍(时间)之间的关系。</p><p>##　中断处理速度 </p><blockquote><p>中断的快速响应特性使其可以应用于实时系统(Real-TimeSystem),但执行中断处理程序会影响中断的效率。一次中断过程需要有响应时间、信息保护与恢复时间,也许还需 要中断源识别时间(非向量中断),这些非实质中断处理时间统称为中断额外开销时间,所 以一次中断过程所需的完整时间是对中断源实质的处理时间与中断额外开销时间之和。因 为中断额外开销时间不会为零,所以中断频率(单位时间内响应中断的次数)受到一定限 制。更快速地响应中断、尽可能地缩短中断处理时间是提高中断处理速度的两个重要环节, 是中断方式实现中的关注点。</p></blockquote><h1 id="第9章-并行体系结构"><a href="#第9章-并行体系结构" class="headerlink" title="第9章 并行体系结构"></a>第9章 并行体系结构</h1><blockquote><p>并行计算是指同时对多个任务、多条指令或多个数据项进行的处理,完成并行计算的 计算机系统称为并行计算机系统,它是将多个处理器、多个计算机通过网络以一定的连接 方式组织起来的大规模系统。</p></blockquote><p>实现并行方式</p><ul><li>(1)时间重叠:运用的是时间并行技术,它通过让多个处理任务或子任务同时使用系 统中的不同功能部件,使系统处理任务的吞吐量增大,从而达到使系统运行速度提高的目 的。</li><li>(2)资源重复:运用的是空间并行技术,它通过大量重复设置硬件资源,使多个处理任 务或子任务同时使用系统中的多个相同功能的部件,使系统处理任务的吞吐量增大,从而 达到使系统运行速度提高的目的。</li><li>(3)时间重叠+资源重复:同时运用时间并行和空间并行技术,这已成为当前并行机 制的主流。</li><li>(4)资源共享:与前三种硬件方式不同,这是一种软件方式,通过操作系统的调度使多 个任务按一定规则(如时间片)轮流使用同一设备。资源共享既可以降低成本,提高设备利 用率,又可以实现多任务分时并行处理。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210221181437738.png" alt="image-20210221181437738"></p><h2 id="计算机体系结构的分类"><a href="#计算机体系结构的分类" class="headerlink" title="计算机体系结构的分类"></a>计算机体系结构的分类</h2><ul><li>(1)单指令流单数据流(SingleInstruction-streamSingleData-stream,SISD)。这是一 种单处理器系统,传统的冯·诺依曼计算机就是SISD系统。它只有一个指令流和一个数据 流,一个时刻只能做一件事情。</li><li>(2)单 指 令 流 多 数 据 流 (SingleInstruction-stream MultipleData-stream,SIMD)。 SIMD计算机中,同一条指令被多个使用不同数据流的多处理器执行。</li><li>(3)多 指 令 流 单 数 据 流 (MultipleInstruction-stream SingleData-stream,MISD)。 MISD计算机中,多条指令同时在同一数据上进行操作。至今还没有这类的商用机器。 </li><li>(4)多指令流多数据流(MultipleInstruction-stream MultipleData-stream,MIMD)。 这是一种同时有多个 CPU 执行不同操作的计算机系统,系统中每个处理器获取自己的指 令并对自己的数据进行操作处理。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210221181922460.png" alt="image-20210221181922460"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/ppt/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.pptx">计算机组成与系统结构</a></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微务篇-微服务架构实战</title>
    <link href="/2021/02/05/microservice/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AF%87-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98/"/>
    <url>/2021/02/05/microservice/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AF%87-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="常见的微服务组件"><a href="#常见的微服务组件" class="headerlink" title="常见的微服务组件"></a>常见的微服务组件</h1><ul><li><p>服务注册</p><blockquote><p>服务注册是一个记录当前可用的微服务实例的网络信息数据库,是服务发现机制的主要核心,服务注册表包含查陶 API 、 管 理 API ,使用查询 API 获得可用服务的实例,使用管理 API实现注册、注销 。</p></blockquote></li><li><p>服务发现</p><blockquote><p>服务调用方从服务注册中心找到自己需要调用的服务的地址。可以选择客户端服务发现,也可以选择服务端服务发现 。</p></blockquote></li><li><p>负载均衡</p><blockquote><p>服务提供方一般以多实例的形式提供服务,负载均衡功能能够让服务调用方连接到合适的服务节点,并且节点选择的工作对服务调用方来说是透明的。可以选择服务端的负载均衡,也可以选择客户端的负载均衡。</p></blockquote></li><li><p>服务网关</p><blockquote><p>服务网关是服务调用的唯一入口,可以在这个组件是实现用户鉴权、动态路由、灰度发布、AJB 测试、负载限流等功能。根据公司流量规模的大 小网关可以是 一个,也可以是多个 。</p></blockquote></li><li><p>配置中 心</p><blockquote><p>将本地化的配置信息( Properties 、 XML 、 YAML 等〉注册到配置中心,实现程序包在开发、测试、生产环境 的无差别性,方便程序包的迁移。配置部分可以单独使用高可用的分布式配置中心,确保一个配置服务出现问题时,其他服务也能够提供配置服务。</p></blockquote></li><li><p>API 管理</p><blockquote><p>以方便的形式编写及更新 API 文档,井以方便的形式供调用者查看和测试。通常 需要加入版本控制的概念,以确保服务的不同版本在升级过程中都能够提供服务。</p></blockquote></li><li><p>集成框架</p><blockquote><p>微服务组件都以职责单一的程序包对外提供服务,集成框架以配置的形式将所有微服务组件集成到统一的界面框架下,让用户能够在统一的界面中使用系统。</p></blockquote></li><li><p>分布式事务</p><blockquote><p>对于重要的业务,需要通过分布式事务技术 CTCC 、高可用消息服务、最大努力通知〉保证数据的一致性。根据业务的不同,适当地牺牲一些数据的一致性要求,确保数据的最终一致性。</p></blockquote></li><li><p>调用链</p><blockquote><p>记录完成一个业务逻辑时调用到的微服务,并将这种串行或并行的调用关系展示出来 。在系统出锚时,可以方便地找到出错点。同时统计各个服务的调用次数,确保 比 较热的服务能够被分配更多的资源。</p></blockquote></li><li><p>支撑平台</p><blockquote><p>系统微服务化后,系统变得更加碎片化,系统的部署、运维、监控等都比单体架构更加复杂,那么就需要将大部分的工作自动化。现在,可以通过 Docker 等工具来 中和这些微服务架构带来的弊端。例如,持续集成 、 蓝绿发布、健康检查、性能健康等。 可以 这么说,如果没有合适的支撑平台或工具,就不要使用微服务架构。</p></blockquote></li></ul><h1 id="常用的微服务框架"><a href="#常用的微服务框架" class="headerlink" title="常用的微服务框架"></a>常用的微服务框架</h1><p>各种语言都有自己的微服务框架 , 主要包括:</p><ul><li>主流微服务框架( Spring Cloud 、 Dubbo 〕:</li><li>新锐微服务框架 Clstio )。</li></ul><h1 id="Spring-顶级项目"><a href="#Spring-顶级项目" class="headerlink" title="Spring 顶级项目"></a>Spring 顶级项目</h1><ul><li>Spring I/O platform: 用于系统部署,是可集成的、构建现代化应用 的版本平台 , 具体来说当你使用 Maven Dependency 引 入 Spring jar 包时它就在工作了。</li><li>Spring Boot : 旨在简化创建产品级的 Spring 应用和服务 , 简化了配置文件,使用嵌入式 Web 服务器,含有诸 多开箱即用 的微服务功能,可以和 Spring Cloud 联合部署。</li><li>Spring Framework :即通常所说的 Spring 框架,是一个开源 的 Java/Java EE 全功能枝应用程序框架 ,其他 Spring 项目 如 Spring Boot 也依赖于 此框架 。</li><li>Spring Cloud : 微服务工具包,为开发者提供了在分布式系统 的配置管理 、服务发现、断路器、智能路由、微代理、控制总线等开发工具包。</li><li>Spring XD : 一种运行时环境(服务器软件 ,非开发框架),组合 Spring 技术,如 Springbatch 、 Spring Boot 、 Spring Data ,采集大数据并处理。</li><li>Spring Data : 一个数据访问及操作 的工具包,封装了很 多种数据及数据库的访 问相 关技术,包括 JDBC 、 Redis 、 MongoDB 、 Neo4j 等。</li><li>Spring Batch :批处理框架,或者说是批量任务执行管理器,功能包括任务调度、日志记录/跟踪等。</li><li>Spring Security : 一个能够为基于 Spring 的 企业应用系统提供声 明式的安全访 问 控制解决方案的安全框架。</li><li>Spring Integration : 面向企业应用集成( EAI尼SB )的编程框架,支持的通信方式包括HTTP, FTP 、 TCP几JDP, JMS 、 RabbitMQ 、 E-mail 等 。</li><li>Spring Social : 一组工具包,一组连接社交服务 API ,如 Twi忧町、 Facebook、 Linkedln 、G1出ub 等,有几十个 。</li><li>SpringAMQP :消息队列 操作的 工具包, 主要是封装了 RabbitMQ 的操作 。</li><li>Spring HATEOAS : 一个用于支持实现超文本驱动的 阻ST Web 服务的开发库。</li><li>Spring Mobile: Spring MVC 的扩展,用来简化手机上的 Web 应用开发。</li><li>Spring for Android: Spring 框架的 一个扩展,其主要目 的在于简化 Android 本地应用的开发,提供 RestTemplate 来访问阻ST 服务 。</li><li>Spring Web Flow :目标是成为 管理 Web 应用页面流程的 最佳方案,将页面跳转流程单独管理,并可配置。</li><li>SpringLDAP : 一个用 于操作 LDAP 的 Java 工具包, 基于 Spring 的 JdbcTemplate 模式,简化 LDAP 访问。</li><li>Spring Session: Session 管理 的开发工 具包,让你可以把 Session 保存到 Redis 等 ,进行集群化 S巳ssion 管理。</li><li>Spring Web Servic巳S : 基于 Spring 的 Web 服务框架 ,提供 SOAP 服务开发 ,允许通过多种方式创建 Web 服务。</li><li>Spring Shell : 提供交互式 的 Shell ,可以使用简单的基于 Spring 的编程模型来开发命令 ,比如 Spring Roo 命令。</li><li>Spring Roo : 一种 Spring 开发的辅助工具,使用命令行操作来生成自动化项目,操作非常类似于 Rails 。</li><li>Spring Scala: Scala 语言编程提供的 Spring 框架的封装(新的编程语言, Java 平 台的Scala 于 2003 年年底12004 年年初发布〉 。</li><li>Spring BlazeDS Integration : 一个开发阳A 工具包,可以集成 Adobe Flex 、 B lazeDS 、Spring 及 Java 技术创建 RIA 。</li><li>Spring Loaded :用于 实 现 Java 程序和 Web 应用的热部署 的开源 工具。</li><li>Spring REST Shell :可以调用阻ST 服务 的命令行工具 ,使用命令行操作阻ST 服务 。</li></ul><h1 id="微服务设计原则"><a href="#微服务设计原则" class="headerlink" title="微服务设计原则"></a>微服务设计原则</h1><h1 id="Spring-Cloud-Netflix"><a href="#Spring-Cloud-Netflix" class="headerlink" title="Spring Cloud Netflix"></a>Spring Cloud Netflix</h1><ul><li><p>Eureka :基于阻 ST 服务的分布式中间件,主要用于服务管理。</p></li><li><p>Hystrix : 容错框架,通过添加延迟阔值及容错的逻辑来帮助我们 控制分布式系统间组件的交互。</p></li><li><p>Feign :一个 REST 客户端,目的是简化 Web Servic巳 客户端的开发 。</p></li><li><p>Ribbon : 负载均衡框架,在微服务集群中为各个客户端的通信提供支持,它主要实现中间层应用程序的负载均衡 。</p></li><li><p>Zuul :为微服务集群提供过代理、过滤 、 路由等功能。除了 Spring Cloud Netflix 模块, Spring C loud 还包括以下几个重要的模块。</p></li><li><p>Spring Cloud Config :为分布式系统提供了配置服务器和配置客户端,通过对它们的配置,可以很好地管理集群 中的配置文件。</p></li><li><p>Spring Cloud Sleuth :服务跟踪框架 ,可以 与 Zipkin 、 Apache HTrace 和 ELK 等数据分析、服务跟踪系统进行整合,为服务跟踪 、 解决问题提供了便利 。</p></li><li><p>Spring Cloud S仕earn : 用于构建消息驱动微服务的框架,该框架在 Spring Boot 的基础上 , 整合了“ Spring Integration ,, 来连接消息、代理中 间 件。</p></li><li><p>Spring Cloud Bus :连接 RabbitMQ 、 Kafka 等消息代理的集群消息总线。</p></li></ul><h1 id="微服务窑错"><a href="#微服务窑错" class="headerlink" title="微服务窑错"></a>微服务窑错</h1><p>服务雪崩效应是一种因服务提供者的不可用而导致服务调用者的不可用的现象,并将不可用逐渐放大的过程。举例来说,我们使用链式设计模式构建的微服务,当其他的服务出现问题时,就会出现连锁支应,导致整个服务链条不可用。</p><p>造成服务不可用的原因包括:</p><ul><li>硬件故障;</li><li>网络连接缓慢;</li><li>程序 Bug;</li><li>缓存击穿, 一般发生在缓存应用 重启,所有缓存被清空时,以及短时间内大量缓存失效时。大量的缓存不命中,使请求直击后端,造成服务提供者超负荷运行,引起服务不可用:</li><li>用户大量请求。</li></ul><p>应对方案</p><ul><li><p>流量控制</p><blockquote><p>一般是使用 Nginx 进行流量控制,对流量大的应用采用分流和限制,这个功能也可以使用网关来完成 。</p></blockquote></li><li><p>服务自动扩容</p><blockquote><p>取决于硬件的限制,也可以使用第三方的云服务以达到扩容的效果 。 如果微服务构建得比较成熟,则可以通过容器的动态扩容来完成服务的扩容 。</p></blockquote></li><li><p>降级和资源隔离</p></li></ul><blockquote><p>资源隔离主要是对调用服务的线程池进行隔离,监控一般要细致到线程级别,当发现某个线程占用资源过高时,进行有效的处理来解决性能瓶颈 。</p></blockquote><p>我们根据具体业务将依赖服务分为强依赖和弱依赖 。 强依赖服务不可用会导致当前业务中止,而弱依赖服务的不可用不会导致当前业务的中止。</p><p><code>不可用服务的调用快速失败 一般通过超时机制、熔断器和 ;培断后的降级方法来实现。</code></p><h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><p><code>Servlet 的 生命周期有四 个阶段 : 加载并实例化、初始化、请求处理、销毁 。主要涉及 的方法有 in it 、 service 、 doGet 、 doPost 、 desto町 等。</code></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="">《微服务架构实战》</a></p><p><a href="https://github.com/mikeygithub/microservice-actual-combat">代码</a></p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法篇-字符串匹配算法</title>
    <link href="/2021/02/04/algorithm/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/"/>
    <url>/2021/02/04/algorithm/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="暴力法-Brute-force"><a href="#暴力法-Brute-force" class="headerlink" title="暴力法(Brute force)"></a>暴力法(Brute force)</h1><h1 id="Rabin-Karp-算法"><a href="#Rabin-Karp-算法" class="headerlink" title="Rabin-Karp 算法"></a>Rabin-Karp 算法</h1><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h1 id="Boyer-Moore算法"><a href="#Boyer-Moore算法" class="headerlink" title="Boyer-Moore算法"></a>Boyer-Moore算法</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.zhihu.com/question/21923021/answer/1032665486">如何更好地理解和掌握 KMP 算法</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务篇-Istio 大型微服务系统管理工具</title>
    <link href="/2021/02/03/microservice/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AF%87-%20Istio%20%E5%A4%A7%E5%9E%8B%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <url>/2021/02/03/microservice/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AF%87-%20Istio%20%E5%A4%A7%E5%9E%8B%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Introduce"><a href="#Introduce" class="headerlink" title="Introduce"></a>Introduce</h1><blockquote><p>Istio 是一个由谷歌、IBM 与 Lyft 共同开发的开源项目，旨在提供一种统一化的微服务连接、安全保障、管理与监控方式。Istio 项目能够为微服务架构提供流量管理机制，同时亦为其它增值功能（包括安全性、监控、路由、连接管理与策略等）创造了基础。这款软件利用久经考验的 Lyft Envoy 代理进行构建，可在无需对应用程序代码作出任何发动的前提下实现可视性与控制能力。Istio 项目是一款强大的工具，可帮助 CTO/CIO 们立足企业内部实施整体性安全、政策与合规性要求。</p></blockquote><h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><h1 id="What"><a href="#What" class="headerlink" title="What"></a>What</h1><h1 id="Where"><a href="#Where" class="headerlink" title="Where"></a>Where</h1><h1 id="HOW"><a href="#HOW" class="headerlink" title="HOW"></a>HOW</h1><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://istio.io/">Istio官网</a></p><p><a href="http://www.uml.org.cn/wfw/201909063.asp">Istio是啥？一文带你彻底了解</a></p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机相关书籍</title>
    <link href="/2021/01/27/another/%E5%85%B6%E4%BB%96%E7%AF%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3%E4%B9%A6%E7%B1%8D/"/>
    <url>/2021/01/27/another/%E5%85%B6%E4%BB%96%E7%AF%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3%E4%B9%A6%E7%B1%8D/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="入门书籍"><a href="#入门书籍" class="headerlink" title="入门书籍"></a>入门书籍</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/TA6z3m">《明解Java》</a> - 豆瓣评分 8.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/7urNtH">《Java从入门到精通（第4版 附光盘）》</a> - 豆瓣评分 6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/2dDnsY">《入门很简单丛书：Java Web开发入门很简单》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/7zm17P">《程序员炼成记 从小白到工程师》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ZCbVjQ">《Java从小白到大牛》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/mnkAJR">《JavaWeb项目开发实战入门（全彩版）》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/9TGA0S">《Java精彩编程200例（全彩版）》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/zMDeI7">《Java轻松学》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/td3bUo">《大话Java：程序设计从入门到精通（含DVD光盘1张）》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/HOFu01">《Java语言袖珍指南（第二版）》</a></li></ul><h1 id="基础书籍"><a href="#基础书籍" class="headerlink" title="基础书籍"></a>基础书籍</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ajylTp">《Java编程思想（第4版） [thinking in java]》</a> - 豆瓣评分 9.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/tp87o1">《Java核心技术 卷I：基础知识（原书第10版）》</a> - 豆瓣评分 8.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/fYGMsC">《Java核心技术卷II：高级特性（原书第10版）》</a> - 豆瓣评分 7.7</li></ul><h1 id="多线程与并发"><a href="#多线程与并发" class="headerlink" title="多线程与并发"></a>多线程与并发</h1><ul><li><p><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ERgtGV">《华章专业开发者丛书·Java并发编程实战》</a> - 豆瓣评分 9.1</p></li><li><p><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/XRUB8H">《Java多线程编程实战指南（设计模式篇）》</a> - 豆瓣评分 8.5</p></li><li><p><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/LDOFjh">《图解Java多线程设计模式》</a> - 豆瓣评分 8.4</p></li><li><p><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/WXhQuO">《实战Java高并发程序设计》</a> - 豆瓣评分 8.3</p></li><li><p><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/e5tZdf">《Java高并发编程详解：多线程与架构设计》</a> - 豆瓣评分 7.6</p></li><li><p><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/5p2KoJ">《Java核心技术系列：Java多线程编程核心技术 [Java Multi-thread Programming]》</a> - 豆瓣评分 5.1</p></li><li><p><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/RQu2W6">《Java并发编程：核心方法与框架》</a></p></li><li><p><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/fkn9NP">《Java多线程与Socket：实战微服务框架》</a></p></li><li><p><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ZwyPCp">《NIO与Socket编程技术指南》</a></p></li><li><p><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/vB6BA2">《Java并发编程之美》</a></p></li><li><p><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/fthTzf">《实战Java高并发程序设计（第2版）》</a></p><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1></li><li><p><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/osowEq">《Java网络编程（第四版） [Java network programming, forth edition]》</a> - 豆瓣评分 7.6</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1></li><li><p><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/wdrJls">《数据结构与算法分析：Java语言描述（原书第3版）》</a> - 豆瓣评分 8.3</p></li><li><p><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/9GKS26">《图解数据结构：使用Java》</a></p></li><li><p><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/DCJzy6">《数据结构与算法Java语言描述》</a></p></li></ul><h1 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/MNwLHg">《Java 8实战》</a> - 豆瓣评分 9.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/M6XqLp">《Java函数式编程》</a> - 豆瓣评分 8.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/YApFXv">《Java编程的逻辑》</a> - 豆瓣评分 8.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/UZgI0F">《O’Reilly：Head First Java（中文版 第2版 涵盖Java5.0）》</a> - 豆瓣评分 8.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ZCMWOr">《写给大忙人看的Java核心技术》</a> - 豆瓣评分 7.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ajoGad">《精通lambda表达式：Java多核编程 [Mastering Lambdas: Java Programming in a Multicore]》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/5HXsKg">《Java 9模块化开发：核心原则与实践》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/l7fy1C">《Java JDK 9学习笔记》</a></li><li>[《Java 9编程参考官方大全（第10版） <a href="https://www.coderxing.com/r.php?r=https://u.jd.com/CqmtBM">Java：Thte Complete Reference，Tenth Edition]》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/JMdy64">《写给大忙人的Java SE 9核心技术》</a></li></ul><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/MBhyO7">《深入分析Java Web技术内幕（修订版）》</a> - 豆瓣评分 7.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/GEdlD0">《Java RESTful Web Service实战（第2版）》</a></li></ul><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/qTFNCP">《Java性能优化权威指南 [Java performance]》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/6CYRQi">《Java程序性能优化：让你的Java程序更快、更稳定》</a> - 豆瓣评分 8.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/KmJo2x">《Java性能权威指南》</a> - 豆瓣评分 8.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/GKe55M">《51CTO学院系列丛书·实战Java虚拟机：JVM故障诊断与性能优化》</a> - 豆瓣评分 8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/sQPN8w">《Java性能调优指南》</a> - 豆瓣评分 7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Uqaj5n">《大话Java性能优化》</a> - 豆瓣评分 4.4</li></ul><h1 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/nvsfLb">《响应式架构：消息模式Actor实现与Scala、Akka应用集成》</a> - 豆瓣评分 8.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/HeIp16">《RxJava响应式编程》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/iIZc0A">《RxJava 2.x 实战》</a></li></ul><h1 id="JVM虚拟机"><a href="#JVM虚拟机" class="headerlink" title="JVM虚拟机"></a>JVM虚拟机</h1><ul><li><p><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/DgTnN2">《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》</a> - 豆瓣评分 8.9</p></li><li><p><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/73DIJB">《Java核心技术系列：Java虚拟机规范（Java SE 8版） [The Java Virtual Machine Specification Jave SE 8 Edition]》</a> - 豆瓣评分 8.3</p></li><li><p><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ct4KRw">《揭秘Java虚拟机：JVM设计原理与实现》</a> - 豆瓣评分 7.9</p></li><li><p><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/xJZjRH">《HotSpot实战》</a> - 豆瓣评分 7.1</p></li><li><p><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/0ZMjqZ">《Java从入门到动手写虚拟机1（套装共2册）》</a></p><h1 id="代码-amp-设计优化"><a href="#代码-amp-设计优化" class="headerlink" title="代码&amp;设计优化"></a>代码&amp;设计优化</h1></li><li><p><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/QSoCEv">《重构 改善既有代码的设计 Java语言版》</a> - 豆瓣评分 9.3</p></li><li><p><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/wxQc3i">《代码大全（第2版）》</a> - 豆瓣评分 9.3</p></li><li><p><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/syzAFD">《Effective Java中文版（原书第3版）》</a> - 豆瓣评分 9</p></li><li><p><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Rt31CM">《代码整洁之道 程序员的职业素养》</a> - 豆瓣评分 8.8</p></li><li><p><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/XBQxz8">《代码整洁之道 [Clean Code A Handbook of Agile Software Craftsmanship]》</a> - 豆瓣评分 8.6</p></li><li><p><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ld8p0r">《Spring实战（第4版）》</a> - 豆瓣评分 8.3</p></li><li><p><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/0hnAnw">《代码不朽：编写可维护软件的10大要则（Java版）》</a> - 豆瓣评分 7</p></li><li><p><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/tyYWro">《Java代码与架构之完美优化 实战经典》</a></p></li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/SJWtpV">《反应式设计模式》</a> - 豆瓣评分 9.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/IGKmVq">《O’Reilly：Head First设计模式（中文版）》</a> - 豆瓣评分 9.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/D59mge">《设计模式：可复用面向对象软件的基础》</a> - 豆瓣评分 9.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/lFwQdc">《实现领域驱动设计 [Implementing Domain-Driven Design]》</a> - 豆瓣评分 8.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/yxTBEJ">《原创精品系列：设计模式之禅（第2版）》</a> - 豆瓣评分 8.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/H9tRFl">《图解设计模式》</a> - 豆瓣评分 8.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/qfAaGS">《大话设计模式》</a> - 豆瓣评分 8.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/PllZtF">《领域驱动设计 软件核心复杂性应对之道 修订版》</a> - 豆瓣评分 8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/xRo8Ur">《Java测试驱动开发》</a> - 豆瓣评分 6.6</li></ul><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/i4KCQO">《高性能MySQL（第3版）》</a> - 豆瓣评分 9.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Th90ra">《MySQL技术内幕：InnoDB存储引擎（第2版）》</a> - 豆瓣评分 8.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/YivOvQ">《大型网站系统与Java中间件实践》</a> - 豆瓣评分 7.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/HjaHc2">《深入浅出MySQL 数据库开发 优化与管理维护 第2版》</a> - 豆瓣评分 7.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/oYHlHw">《PostgreSQL修炼之道：从小工到专家》</a> - 豆瓣评分 7.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/hKsMRX">《PostgreSQL技术内幕：查询优化深度探索》</a></li></ul><h1 id="缓存与NoSQL"><a href="#缓存与NoSQL" class="headerlink" title="缓存与NoSQL"></a>缓存与NoSQL</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/uZirI6">《Redis 深度历险：核心原理与应用实践》</a> - 豆瓣评分 9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/VMo7w2">《Redis实战》</a> - 豆瓣评分 8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/GmFr7B">《Redis入门指南（第2版）》</a> - 豆瓣评分 7.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/TKeCR2">《深入分布式缓存：从原理到实践》</a> - 豆瓣评分 7.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/8DuE9W">《人人都是架构师：分布式系统架构落地与瓶颈突破》</a> - 豆瓣评分 6.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/qd9tLA">《MongoDB应用设计模式》</a> - 豆瓣评分 6.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Mlefug">《MongoDB实战 架构、开发与管理》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/1QhhB6">《NoSQL数据库入门与实践（基于MongoDB、Redis）》</a></li></ul><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/4SyxGo">《RabbitMQ实战指南》</a> - 豆瓣评分 9.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/qIwmGY">《Kafka权威指南》</a> - 豆瓣评分 8.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/hqBGgy">《Kafka入门与实践》</a> - 豆瓣评分 7.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/vyU3eK">《RocketMQ实战与原理解析》</a> - 豆瓣评分 7.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/GZh0yK">《Kafka技术内幕 图文详解Kafka源码设计与实现》</a> - 豆瓣评分 6.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/sTtFQn">《深入理解Kafka：核心设计与实践原理》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/GzBNOZ">《分布式消息中间件实践》</a></li></ul><h1 id="ORM框架"><a href="#ORM框架" class="headerlink" title="ORM框架"></a>ORM框架</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/0GXsRh">《MyBatis从入门到精通》</a> - 豆瓣评分 7.7</li></ul><h1 id="Spring家族"><a href="#Spring家族" class="headerlink" title="Spring家族"></a>Spring家族</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ohN8uh">《Spring微服务实战》</a> - 豆瓣评分 8.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/z1QvAP">《Spring Cloud微服务实战》</a> - 豆瓣评分 7.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/FfCbxt">《深入理解Spring Cloud与微服务构建》</a> - 豆瓣评分 7.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/wAPeEw">《MyBatis技术内幕》</a> - 豆瓣评分 7.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/BcQznU">《Spring Boot实战》</a> - 豆瓣评分 7.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/k0xgoA">《深入浅出Spring Boot 2.x》</a> - 豆瓣评分 7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/4Rtvg3">《JavaEE开发的颠覆者：Spring Boot实战》</a> - 豆瓣评分 6.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/2rz8BY">《Spring技术内幕：深入解析Spring架构与设计原理（第2版）》</a> - 豆瓣评分 5.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/xrNcv1">《Spring Boot 2精髓：从构建小系统到架构分布式大系统》</a> - 豆瓣评分 4.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/dtDOqc">《Spring 5开发大全》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/oFsaYt">《Spring Cloud微服务架构进阶》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/SdhhtK">《Spring源码深度解析 第2版》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ghc04R">《Spring MVC实战》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/fCZpVU">《Spring Boot编程思想（核心篇）（限量版亲笔签名书签 随机发售）》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/HO244A">《互联网轻量级SSM框架解密：Spring、Spring MVC、MyBatis源码深度剖析》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/O9L5Nb">《Spring学习指南 第3版》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/k4WSg3">《精通Spring MVC 4》</a></li></ul><h1 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/htIJgi">《Netty实战》</a> - 豆瓣评分 7.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/81Pbod">《七周七并发模型》</a> - 豆瓣评分 7.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/7tGXx5">《Netty权威指南（第2版）》</a> - 豆瓣评分 6.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/VBYLE0">《Netty进阶之路：跟着案例学Netty》</a></li></ul><h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/3rp1Hv">《从Paxos到Zookeeper分布式一致性原理与实践》</a> - 豆瓣评分 7.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/LAyupw">《ZooKeeper：分布式过程协同技术详解》</a> - 豆瓣评分 7.2</li></ul><h1 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/IdftoH">《从Lucene到Elasticsearch：全文检索实战》</a></li></ul><h1 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/BlEDc7">《Hadoop权威指南：大数据的存储与分析(第4版)》</a> - 豆瓣评分 8.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/dW1kpa">《Hadoop构建数据仓库实践》</a> - 豆瓣评分 8.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/wqb9z0">《HBase权威指南 [HBase： The Definitive Guide]》</a> - 豆瓣评分 8.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/azPD8S">《图解Spark：核心技术与案例实战》</a> - 豆瓣评分 7.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/bd1YCS">《Hive编程指南 [Programming Hive]》</a> - 豆瓣评分 7.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/kFRuj2">《HBase应用架构》</a></li></ul><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/pTZ8xk">《Web性能权威指南》</a> - 豆瓣评分 8.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/7tOuAz">《从零开始学架构：照着做，你也能成为架构师》</a> - 豆瓣评分 8.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Qs9SXn">《Java应用架构设计：模块化模式与OSGi》</a> - 豆瓣评分 6.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/GVYZr9">《大型网站技术架构演进与性能优化》</a> - 豆瓣评分 6.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/7y5NpR">《高可用架构（第1卷）》</a> - 豆瓣评分 6.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/kPGIoj">《Java架构师指南》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Bc2TLN">《大话代码架构（项目实战版）》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/mzqn7f">《小团队构建大网站：中小研发团队架构实践》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/zDMNQs">《未来架构 从服务化到云原生(限量签名 随机发放)》</a></li></ul><h1 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/zpE3MI">《可伸缩架构：面向增长应用的高可用》</a> - 豆瓣评分 7.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/HQHcMY">《分布式服务架构：原理、设计与实战》</a> - 豆瓣评分 7.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/9JXTi8">《亿级流量网站架构核心技术 跟开涛学搭建高可用高并发系统》</a> - 豆瓣评分 6.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/zzctjK">《大型分布式网站架构设计与实践》</a> - 豆瓣评分 6.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/l4UA35">《可伸缩服务架构：框架与中间件》</a> - 豆瓣评分 5.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/1YUJxK">《架构探险：从零开始写分布式服务框架》</a> - 豆瓣评分 5.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/4trb76">《Cloud Native分布式架构原理与实践》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/QWumiy">《分布式系统常用技术及案例分析（第2版）》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/53hDaR">《云原生Java：Spring Boot、Spring Cloud与Cloud Foundry弹性系统设计》</a></li></ul><h1 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/5KB81a">《微服务设计》</a> - 豆瓣评分 8.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/LF3vzd">《生产微服务》</a> - 豆瓣评分 8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/xoCkW1">《架构解密：从分布式到微服务》</a> - 豆瓣评分 5.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/jk1V1F">《Java微服务》</a> - 豆瓣评分 5.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/QvfyPI">《Spring Cloud 微服务架构开发实战（全新升级版）》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/DyZQbc">《微服务实践》</a></li></ul><h1 id="架构方法论"><a href="#架构方法论" class="headerlink" title="架构方法论"></a>架构方法论</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/k8yxj0">《架构整洁之道》</a> - 豆瓣评分 8.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/pQOd7z">《企业应用架构模式 [Patterns of Enterprise Application Architecture]》</a> - 豆瓣评分 8.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ipHhzt">《企业IT架构转型之道 阿里巴巴中台战略思想与架构实战》</a> - 豆瓣评分 8.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/jRMw2b">《聊聊“架构”》</a> - 豆瓣评分 7.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/1gr9nd">《架构真经：互联网技术架构的设计原则（原书第2版）》</a> - 豆瓣评分 7.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/4Y77J0">《软件架构设计：程序员向架构师转型必备（第2版）》</a> - 豆瓣评分 7.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/XOr8py">《恰如其分的软件架构 [Just Enough Software Architecture]》</a> - 豆瓣评分 7.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/lSUYn8">《软件架构设计：大型网站技术架构与业务架构融合之道》</a></li></ul><h1 id="JVM周边语言"><a href="#JVM周边语言" class="headerlink" title="JVM周边语言"></a>JVM周边语言</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/R0JT1a">《Scala编程（第3版）》</a> - 豆瓣评分 9.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/AMZkGX">《Groovy程序设计》</a> - 豆瓣评分 8.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/h6Gnct">《快学Scala（第2版）》</a> - 豆瓣评分 8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/loJfwO">《Kotlin极简教程》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/WvMNgs">《Scala集合技术手册》</a></li></ul><h1 id="项目管理-amp-领导力-amp-流程"><a href="#项目管理-amp-领导力-amp-流程" class="headerlink" title="项目管理&amp;领导力&amp;流程"></a>项目管理&amp;领导力&amp;流程</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/5OmcTI">《构建之法 现代软件工程（第三版）》</a> - 豆瓣评分 9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/gcHfSY">《精益思想（白金版）》</a> - 豆瓣评分 8.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/uZ2nZV">《给产品经理讲技术》</a></li></ul><h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/TzKtiz">《持续交付：发布可靠软件的系统方法》</a> - 豆瓣评分 8.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/qEOLhm">《名家经典系列：人件（原书第3版） [Peopleware: Productive Projects and Teams]》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/gc719a">《硝烟中的Scrum和XP：我们如何实施Scrum》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ZHeyFS">《敏捷软件开发实践 估算与计划》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/mUkwcD">《人月神话（40周年中文纪念版） [The Mythical Man-Month：Essays on Software Engineering Anniversary Edition]》</a> - 豆瓣评分 8.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/T9HSMS">《Scrum敏捷软件开发》</a> - 豆瓣评分 8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/D8oZoG">《用户故事与敏捷方法 [User Stories Applied:For Agile Software Development]》</a> - 豆瓣评分 8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/P6RDR3">《用户故事地图 [User Story Mapping]》</a> - 豆瓣评分 7.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/1zgjNd">《知行合一 实现价值驱动的敏捷和精益开发》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Dtrvqn">《互联网项目管理实践精粹》</a></li></ul><h1 id="团队管理"><a href="#团队管理" class="headerlink" title="团队管理"></a>团队管理</h1><ul><li>[《卓有成效的管理者（珍藏版） <a href="https://www.coderxing.com/r.php?r=https://u.jd.com/f2kMe8">The Effective Executive]》</a> - 豆瓣评分 8.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/xLBU9J">《跃迁：从技术到管理的硅谷路径》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/w4p97S">《告别失控 软件开发团队管理必读》</a> - 豆瓣评分 7.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/K5DiJn">《赋能：打造应对不确定性的敏捷团队 [Team of Teams]》</a> - 豆瓣评分 7.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/8Gsrin">《OKR工作法：谷歌、领英等顶级公司的高绩效秘籍 [Radical Focus]》</a> - 豆瓣评分 7.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/PchUJJ">《CTO说》</a> - 豆瓣评分 7.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/wGQe5I">《轻流程 IT团队的积分式绩效管理》</a> - 豆瓣评分 7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/spqdp1">《技术领导力：程序员如何才能带团队》</a> - 豆瓣评分 5.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/pSHHhA">《敏捷文化：如何打造优秀的高效能团队 [The Agile Culture: Leading through Trust and Owner]》</a></li></ul><h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/lcuOQq">《数学之美（第二版）》</a> - 豆瓣评分 8.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Yte3WW">《程序员的数学2 概率统计》</a> - 豆瓣评分 8.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/WiKN9k">《程序员的数学3 线性代数》</a> - 豆瓣评分 8.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/iwv4Zd">《程序员的数学》</a> - 豆瓣评分 7.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/qhD5IJ">《程序员的数学思维修炼（趣味解读）》</a> - 豆瓣评分 5.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/vBLDyU">《统计之美：人工智能时代的科学思维》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/iCEv9a">《统计思维：程序员数学之概率统计（第2版）》</a></li></ul><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/AmwANr">《算法导论（原书第3版）/计算机科学丛书 [Introduction to Algorithms, third edition]》</a> - 豆瓣评分 9.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/J7HWa6">《算法图解》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Jt8KBI">《漫画算法：小灰的算法之旅（全彩）》</a></li></ul><h1 id="职业素养与个人成长"><a href="#职业素养与个人成长" class="headerlink" title="职业素养与个人成长"></a>职业素养与个人成长</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/DGNxfn">《我编程，我快乐：程序员职业规划之道》</a> - 豆瓣评分 7.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/THQJSq">《程序员的自我修养》</a> - 豆瓣评分 6.5</li></ul><h1 id="职业素养提升"><a href="#职业素养提升" class="headerlink" title="职业素养提升"></a>职业素养提升</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/J7iABA">《码农翻身：用故事给技术加点料》</a> - 豆瓣评分 9.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/TL272C">《程序员修炼之道：从小工到专家》</a> - 豆瓣评分 8.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/mAbLoA">《极客与团队：软件工程师的团队生存秘笈》</a> - 豆瓣评分 8.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/8l5o8l">《程序员思维修炼(修订版)》</a> - 豆瓣评分 8.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/s1OiZc">《高效能程序员的修炼》</a> - 豆瓣评分 8.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/XxVx3J">《O’Reilly：卓有成效的程序员 [Productive programmer]》</a> - 豆瓣评分 8.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ODjq2h">《Java工程师修炼之道》</a> - 豆瓣评分 7.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/DKrbwc">《程序员的成长课》</a> - 豆瓣评分 7.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/y36OqE">《高效程序员的45个习惯：敏捷开发修炼之道(修订版)》</a> - 豆瓣评分 7.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/JKgll1">《温伯格技术思想三部曲：颠覆完美软件 软件测试必须知道的几件事》</a> - 豆瓣评分 7.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/0K8XDo">《温伯格技术思想三部曲：程序开发心理学（银年纪念版）》</a> - 豆瓣评分 7.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/AlxMcW">《软件开发本质论：追求简约、体现价值、逐步构建》</a> - 豆瓣评分 7.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/W0uA76">《内外兼修：程序员的成长之路》</a> - 豆瓣评分 6.6</li></ul><h1 id="个人软技能"><a href="#个人软技能" class="headerlink" title="个人软技能"></a>个人软技能</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/I3D7Z0">《把时间当作朋友（第3版 全彩）》</a> - 豆瓣评分 8.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/GZgwi5">《暗时间》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/jpIkyt">《关键对话：如何高效能沟通（原书第2版） [Crucial Conversations: Tools for Talking When Stak]》</a> - 豆瓣评分 8.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/N6YwQD">《温伯格技术思想三部曲：成为技术领导者 掌握全面解决问题的方法》</a> - 豆瓣评分 8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/KkL3kA">《软技能 代码之外的生存指南》</a> - 豆瓣评分 8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/8YQH5T">《程序员健康指南》</a> - 豆瓣评分 7.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/NS6cLf">《如何把事情做到最好：改变全球9800万人的人生指导书 [Mastery]》</a> - 豆瓣评分 7.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Gt5VDT">《程序员的英语》</a> - 豆瓣评分 5.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/oG641c">《高效能人士的七个习惯（30周年纪念版）》</a></li></ul><h1 id="阿里巴巴技术丛书"><a href="#阿里巴巴技术丛书" class="headerlink" title="阿里巴巴技术丛书"></a>阿里巴巴技术丛书</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/mIi1ic">《码出高效：Java开发手册》</a> - 豆瓣评分 8.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/4888rh">《大数据之路 阿里巴巴大数据实践》</a> - 豆瓣评分 7.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/xHqHfG">《技术之瞳 阿里巴巴技术笔试心得》</a> - 豆瓣评分 7.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/uZYvrV">《淘宝技术这十年》</a> - 豆瓣评分 7.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/VA9xEV">《尽在双11 阿里巴巴技术演进与超越》</a> - 豆瓣评分 7.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/5NdzxY">《逆流而上：阿里巴巴技术成长之路》</a> - 豆瓣评分 6.9</li></ul><h1 id="京东技术丛书"><a href="#京东技术丛书" class="headerlink" title="京东技术丛书"></a>京东技术丛书</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ET1NkI">《京东基础架构建设之路（全彩）》</a> - 豆瓣评分 6.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/0OOBCc">《京东系统质量保障技术实战》</a> - 豆瓣评分 6.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/V6tLFs">《京东技术解密》</a> - 豆瓣评分 6.1</li></ul><h1 id="工具书"><a href="#工具书" class="headerlink" title="工具书"></a>工具书</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/5U9zkK">《Linux命令行与shell脚本编程大全（第3版）》</a> - 豆瓣评分 9.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/28U5lx">《阿里巴巴Java开发手册》</a> - 豆瓣评分 8.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/d5ADPR">《SQL即查即用 （全彩版）》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/VgrIgv">《Linux命令速查手册（第三版）》</a></li></ul><h1 id="面试求职"><a href="#面试求职" class="headerlink" title="面试求职"></a>面试求职</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/IgfC55">《剑指Offer：名企面试官精讲典型编程题（第2版）》</a> - 豆瓣评分 9.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/E4WimD">《编程之美：微软技术面试心得》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/UqcYlU">《Java程序员面试笔试宝典》</a> - 豆瓣评分 7.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/tm79JE">《Java程序员面试宝典（第4版）》</a> - 豆瓣评分 5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/7ujWIz">《编程之法：面试和算法心得》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/eE9uWg">《Java程序员面试算法宝典》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Jc9Xlt">《Java程序员面试笔试真题库》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/VqoEj5">《Java程序员面试笔试真题与解析》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/pfIsU6">《Java核心技术及面试指南》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/j0XMdh">《解忧程序员：高薪编程、求职面试与成长转型宝典》</a></li></ul><h1 id="格局与视野"><a href="#格局与视野" class="headerlink" title="格局与视野"></a>格局与视野</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/bgG9yE">《全球科技通史》</a> - 豆瓣评分 9.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/koCTxD">《浪潮之巅 第三版 套装上下册》</a> - 豆瓣评分 9.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/KbwmLQ">《黑客与画家：硅谷创业之父Paul Graham文集 [Hackers and Painters Big Ldeas From the Computer Age]》</a> - 豆瓣评分 8.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/EcKZym">《软件随想录 卷1》</a> - 豆瓣评分 8.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/px8Sgu">《软件随想录 卷2》</a> - 豆瓣评分 8.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/6jRwgY">《编程人生：15位软件先驱访谈录》</a> - 豆瓣评分 8.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/6Y4Mcd">《大教堂与集市（最新版） [The Cathedral &amp; the Bazaar]》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/3yyV1D">《硅谷之谜：浪潮之巅 续集》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/M7OrgY">《原则 [Principles]》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/PxHueV">《精益创业》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/rdipjJ">《态度：吴军博士新书》</a> - 豆瓣评分 8.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/cP4xDs">《见识》</a> - 豆瓣评分 8.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/oGJFTx">《极限创新 35岁之前改变世界的全球科技精英》</a> - 豆瓣评分 7.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/FBINiB">《大学的终结：泛在大学与高等教育革命》</a> - 豆瓣评分 7.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ZfHw4B">《未来版图 全球聪明公司的科技创新趋势和商业化路径》</a> - 豆瓣评分 7.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/cNCbEF">《你好哇，程序员——漫话程序员面试求职、升职加薪、创业与生活》</a> - 豆瓣评分 6.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/S1ZQhz">《图灵和ACM图灵奖（1966-2015 第五版） 纪念计算机诞生70周年》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/M3PkIU">《文明之光（全彩印刷套装1-4册）入选2014中国好书/第六届中华优秀出版物获奖图书》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/JHxmei">《大师访谈录：成就非凡的软件人生》</a></li></ul><h1 id="Java之外"><a href="#Java之外" class="headerlink" title="Java之外"></a>Java之外</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/RCgC9H">《计算机科学丛书：计算机程序的构造和解释（原书第2版）》</a> - 豆瓣评分 9.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/URRIW5">《计算机科学丛书：编译原理（第2版） [Compilers:Principle,Techniques and Tools]》</a> - 豆瓣评分 9.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/fbemS8">《一个APP的诞生——从零开始设计你的手机应用》</a> - 豆瓣评分 6.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/F4SUYQ">《大型网站性能优化实战：从前端、网络、CDN到后端、大促的全链路性能优化详解》</a></li></ul><h1 id="网络知识"><a href="#网络知识" class="headerlink" title="网络知识"></a>网络知识</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/q3lNRK">《图解HTTP》</a> - 豆瓣评分 8.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Ip1U7X">《图解TCP/IP 第5版》</a> - 豆瓣评分 7.8</li></ul><h1 id="安全知识"><a href="#安全知识" class="headerlink" title="安全知识"></a>安全知识</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/6oCOp8">《白帽子讲Web安全（纪念版）》</a> - 豆瓣评分 7.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/gecmeS">《Web安全攻防：渗透测试实战指南》</a></li></ul><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Fv9ksZ">《Maven实战》</a> - 豆瓣评分 8.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/JvxLfz">《大象：Thinking in UML（第2版）》</a> - 豆瓣评分 8.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/x06AA6">《Git学习指南》</a> - 豆瓣评分 6.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/W50GoO">《UML基础、案例与应用（第3版 修订版）》</a></li></ul><h1 id="运维-amp-DevOps"><a href="#运维-amp-DevOps" class="headerlink" title="运维&amp;DevOps"></a>运维&amp;DevOps</h1><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/3ejMcd">《编码：隐匿在计算机软硬件背后的语言 [Code:The Hidden Language of Computer Hardware and Software]》</a> - 豆瓣评分 9.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/pVBguN">《DevOps实践指南》</a> - 豆瓣评分 9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/RXZBkB">《性能之巅：洞悉系统、企业与云计算》</a> - 豆瓣评分 8.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/kzDG88">《鸟哥的Linux私房菜 基础学习篇 第四版》</a> - 豆瓣评分 8.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Slnb59">《DevOps开发运维训练营》</a></li></ul><h1 id="面试宝典"><a href="#面试宝典" class="headerlink" title="面试宝典"></a>面试宝典</h1><ul><li>程序员的算法趣题 <a href="https://pan.baidu.com/s/1nW6j_0PjpecwgblpseEE2g">百度云下载链接</a> 密码:5vnv</li><li>程序员代码面试指南：IT 名企算法与数据结构题目最优解 <a href="https://pan.baidu.com/s/10u8cLRCgBE4c4DsB0Zn3IA">百度云下载链接</a> 密码:5jpz</li><li>大厂面试真题（阿里，华为，腾讯等） <a href="https://pan.baidu.com/s/13vTI5YFceCErwWtib6vYqg">百度云下载链接</a> 密码:9yvj</li><li>黑客与画家 <a href="https://pan.baidu.com/s/1zohjssvCWc5pQOGedvdIKA">百度云下载链接</a> 密码:arnc</li><li>Java面试突击 <a href="https://pan.baidu.com/s/1cw2Y8cZVDj8WElQ7-OjDVg">百度云下载链接</a> 密码:70nv</li><li>阿里巴巴Java面试问题大全 <a href="https://pan.baidu.com/s/1x_qrmzaeeW646y6GWmG1Iw">百度云下载链接</a> 密码:qkal</li><li>程序员代码面试指南：IT 名企算法与数据结构题目最优解 <a href="https://pan.baidu.com/s/1UVAlodW0U9c6KQlBb1VNXQ">百度云下载链接</a> 密码:l4fh</li><li>程序员的算法趣题 <a href="https://pan.baidu.com/s/1KUTq3G7DIqwIPMandyFmVg">百度云下载链接</a> 密码:kfga</li></ul><h1 id="数据结构与算法相关书籍"><a href="#数据结构与算法相关书籍" class="headerlink" title="数据结构与算法相关书籍"></a>数据结构与算法相关书籍</h1><ul><li>漫画算法：小灰的算法之旅 <a href="https://pan.baidu.com/s/17jMzGKdMzcyP4GD3CtFtjQ">百度云下载链接</a> 密码:s9sb</li><li>算法（第4版） <a href="https://pan.baidu.com/s/1LWYHUd-gybF1AMkS_exymA">百度云下载链接</a> 密码:1a4z</li><li>剑指offer <a href="https://pan.baidu.com/s/1BLSt2i_QrR_2jDmEeK2PPA">百度云下载链接</a> 密码:ttfn</li><li>Java数据结构和算法 <a href="https://pan.baidu.com/s/1LmGhE83W4yzI7ZXcEi-cTw">百度云下载链接</a> 密码:a5am</li><li>数据结构与算法分析——Java语言描述 <a href="https://pan.baidu.com/s/1MuW73vGlGnIbCQ1A-ZVhPw">百度云下载链接</a> 密码:iqi8</li><li>数据结构与算法 Python语言描述_裘宗燕 <a href="https://pan.baidu.com/s/1WZ3S1PKgc7eEoQYCUG4DmA">百度云下载链接</a> 密码:qr8j</li><li>挑战程序设计竞赛 <a href="https://pan.baidu.com/s/1Tb1GOUR6LTz5s5BPA1psGg">百度云下载链接</a> 密码:byx1</li><li>大话数据结构 <a href="https://pan.baidu.com/s/1rRs2iS-arfsYB-FMXXnGAg">百度云下载链接</a> 密码:lpdq</li><li>数据结构与算法分析–C语言描述 <a href="https://pan.baidu.com/s/1y429aNjcWRsSiPcbWZ2qXA">百度云下载链接</a> 密码:u0an</li><li>啊哈算法 <a href="https://pan.baidu.com/s/12_cpFx_8TP_ujKFRhXmbBA">百度云下载链接</a> 密码:swxv</li></ul><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><ul><li>HTTP权威指南 <a href="https://pan.baidu.com/s/1uWxxIC-AEXM16YQEWojCVg">百度云下载链接</a> 密码:koaj</li><li>计算机网络 <a href="https://pan.baidu.com/s/10TA2eSZu8-e_pqpj9psrMQ">百度云下载链接</a> 密码:4519</li><li>图解HTTP <a href="https://pan.baidu.com/s/1LA7cvQC7cpuT4ODejh6o1Q">百度云下载链接</a> 密码:u3qi</li><li>UNIX网络编程 <a href="https://pan.baidu.com/s/1_Gyj-_j6Oq8yKk3ets5zgQ">百度云下载链接</a> 密码:dil7</li><li>图解TCP-IP <a href="https://pan.baidu.com/s/12zWs8w4Fla6esygC3jzEiw">百度云下载链接</a> 密码:no3g</li><li>网络是怎样连接的 <a href="https://pan.baidu.com/s/1kUDEvSNaXLi1pdyzKlweKQ">百度云下载链接</a> 密码:l7iq</li></ul><h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><ul><li>计算机是怎样跑起来的 <a href="https://pan.baidu.com/s/1bbOJ1mOEldsgdGWs84xXYQ">百度云下载链接</a> 密码:z8vz</li><li>隐匿在计算机软硬件背后的语言 <a href="https://pan.baidu.com/s/1J5LP6gpOIat6jRH0Uw0lPA">百度云下载链接</a> 密码:9284</li><li>大话计算机 <a href="https://pan.baidu.com/s/1Lx4jN0cT5y6oEhcP-vPM5Q">百度云下载链接</a> 密码:6iuh</li><li>隐匿在计算机软硬件背后的语言<strong>英文版</strong> <a href="https://pan.baidu.com/s/1NF3T1khX2YT1SLULDNo_YA">百度云下载链接</a> 密码:jrvw</li></ul><h1 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h1><ul><li>汇编语言【王爽，非常棒的一本书，通俗易懂】 <a href="https://pan.baidu.com/s/1xMm7PgeA7VK6ZhotvJs5Yg">百度云下载链接</a> 密码:j6mw</li></ul><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><ul><li>深入理解计算机操作系统 <a href="https://pan.baidu.com/s/1TKf45xXZyi0-SxhCSozR9A">百度云下载链接</a> 密码:pbvr</li><li>30天填自制操作系统 <a href="https://pan.baidu.com/s/1V78fbnrjKQpe9d2nHndpTw">百度云下载链接</a> 密码:z0zr</li><li>操作系统之哲学原理 <a href="https://pan.baidu.com/s/1KBVu0AkcOKWf3UEJ87aBrg">百度云下载链接</a> 密码:lfkd</li><li>程序是怎样跑起来的 <a href="https://pan.baidu.com/s/1fLCeujbZ9w5pIv1uVtIQVQ">百度云下载链接</a> 密码:i9go</li><li>现代操作系统 <a href="https://pan.baidu.com/s/1fHDAv6_An9dTHkPxFPktFw">百度云下载链接</a> 密码:6gg7</li></ul><h1 id="python系列"><a href="#python系列" class="headerlink" title="python系列"></a>python系列</h1><ul><li>python操作word,excel,pdf <a href="https://pan.baidu.com/s/10KTz_CPln20SK1z3h9nxng">百度云下载链接</a> 密码:7w6s</li></ul><h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><ul><li>Python编程：从入门到实践 <a href="https://pan.baidu.com/s/1yqPuGr5_Cbb7ByPpa6IneQ">百度云下载链接</a> 密码:dv8z</li><li>Python数据分析基础教程：NumPy学习指南 <a href="https://pan.baidu.com/s/15XzJ9uHBVMO9oKEvYXZ9CQ">百度云下载链接</a> 密码:78u3</li><li>Python知识手册 <a href="https://pan.baidu.com/s/1dhbfnwT2Q7tcGmF0tvV3Vw">百度云下载链接</a> 密码:zgrv</li><li>机器学习numpy和pandas基础 <a href="https://pan.baidu.com/s/19Nb0BUJrCdjUA0Epql4nIg">百度云下载链接</a> 密码:qb9a</li><li>Pandas Basics卡片 <a href="https://pan.baidu.com/s/1nHPDupVzyNTpI5FVaZRS7A">百度云下载链接</a> 密码:l5e2</li><li>NumPy Basics卡片 <a href="https://pan.baidu.com/s/1wx9O8hnt2qARXroa1RZ3TQ">百度云下载链接</a> 密码:zr3p</li><li>Python开发技术详解 <a href="https://pan.baidu.com/s/1wyHdC8aaYL_pZf6rfvrfeA">百度云下载链接</a> 密码:b5ye</li><li>Python开发实战 <a href="https://pan.baidu.com/s/1JUNFOiJb4DpZSkYeXgx1Lw">百度云下载链接</a> 密码:awp5</li><li>Python学习手册 <a href="https://pan.baidu.com/s/14Fh0TqEixVQkSkpd-4NQ6Q">百度云下载链接</a> 密码:c0j9</li><li>Python编程初学者指南 <a href="https://pan.baidu.com/s/19QElmLMR4yTZpjYQloIM6g">百度云下载链接</a> 密码:09xw</li><li>Python高级编程 <a href="https://pan.baidu.com/s/1PJKJ4oQOdMXfWLEGwJ0tsQ">百度云下载链接</a> 密码:xq05</li><li>Python编程入门经典 <a href="https://pan.baidu.com/s/1bQwIjpJB96GojQFK9Qz01A">百度云下载链接</a> 密码:67yk</li><li>Python灰帽子 <a href="https://pan.baidu.com/s/1c2meTscVawXlJuHXgHZUZQ">百度云下载链接</a> 密码:3dhw</li><li>Python网络编程基础 <a href="https://pan.baidu.com/s/1-XPbyorXtT-GK-ANE4LoPA">百度云下载链接</a> 密码:nhr6</li><li>编程小白的第一本Python入门书 <a href="https://pan.baidu.com/s/1mOd4uc4KA6YR-kgzzrm-fg">百度云下载链接</a> 密码:wetd</li></ul><h1 id="数据分析与爬虫"><a href="#数据分析与爬虫" class="headerlink" title="数据分析与爬虫"></a>数据分析与爬虫</h1><ul><li>《Python For Data Analysis》 <a href="https://pan.baidu.com/s/1wnMLGxG-36OpFyy-pcqjuA">百度云下载链接</a> 密码:i3qf</li><li>《Python3网络爬虫数据采集》 <a href="https://pan.baidu.com/s/12i25hBdN78J4enP7yzQ4Yg">百度云下载链接</a> 密码:twas</li><li>Data Structures and Algorithms in Python <a href="https://pan.baidu.com/s/1PfnHX4fgHMoHkeLO9LdPVg">百度云下载链接</a> 密码:qxfn</li><li>Python for Data Analysis <a href="https://pan.baidu.com/s/1GZ9RtBCFJ2evxjSlTjd5rA">百度云下载链接</a> 密码:9g28</li><li>《Python数据分析基础》 <a href="https://pan.baidu.com/s/1c8f4q_l_2yT8xKq5OnHIIg">百度云下载链接</a> 密码:6q61</li><li>利用python进行数据分析-第二版 <a href="https://pan.baidu.com/s/16rFXmmNW9fQDkqT8YzsiSQ">百度云下载链接</a> 密码:2ekn</li><li>利用Python进行数据分析 <a href="https://pan.baidu.com/s/1EqIgxrYp_8n1gVvH3YGP3g">百度云下载链接</a> 密码:p4o3</li><li>Python数据分析实战 <a href="https://pan.baidu.com/s/1ZLxV3rcc74Y1ofY1lqApkQ">百度云下载链接</a> 密码:rxaw</li><li>精通Scrapy网络爬虫 <a href="https://pan.baidu.com/s/1ErPU5u0jff4W5RmlP2wwzg">百度云下载链接</a> 密码:faxj</li><li>Python数据可视化编程实战 <a href="https://pan.baidu.com/s/1Mqf-eIn_OJssFpdYmft7Kg">百度云下载链接</a> 密码:qtfp</li><li>Python数据处理 <a href="https://pan.baidu.com/s/1CoR71pPdtsmXnv43swEutQ">百度云下载链接</a> 密码:d1cl</li><li>数据科学入门 <a href="https://pan.baidu.com/s/1LenwNtY_olKghtgsJnk9fw">百度云下载链接</a> 密码:gfvc</li><li>Python数据科学手册 <a href="https://pan.baidu.com/s/1MKs9PwnctsM9PPWZWq4eEQ">百度云下载链接</a> 密码:m4q4</li><li>用Python写网络爬虫 <a href="https://pan.baidu.com/s/1wVbngJq3THdAYGtFXxnI5Q">百度云下载链接</a> 密码:ni0k</li></ul><h1 id="人工智能AI系列"><a href="#人工智能AI系列" class="headerlink" title="人工智能AI系列"></a>人工智能AI系列</h1><h1 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a>计算机视觉</h1><ul><li>Computer vision <a href="https://pan.baidu.com/s/1RWVTJMFLgOoZXpr7-bm1BA">百度云下载链接</a> 密码:8z7n</li><li>图像处理分析与机器视觉(第二版)中译本 <a href="https://pan.baidu.com/s/19cXcCHFyBcEf1giY_tyEwg">百度云下载链接</a> 密码:u6i6</li><li>python计算机视觉 <a href="https://pan.baidu.com/s/13YYkO2XrLwrS9uzavQIDnA">百度云下载链接</a> 密码:6gx2</li></ul><h1 id="OpenCv"><a href="#OpenCv" class="headerlink" title="OpenCv"></a>OpenCv</h1><ul><li>OpenCV-Python-Tutorial-中文版 <a href="https://pan.baidu.com/s/1OyE0XoTQzJ_iQD3TziltZg">百度云下载链接</a> 密码:b3pn</li><li>学习OpenCV 3 中文版 <a href="https://pan.baidu.com/s/1ignJ07VCNLbMvJM3OWD3gA">百度云下载链接</a> 密码:3s4s</li></ul><h1 id="深度学习框架-tensorflow"><a href="#深度学习框架-tensorflow" class="headerlink" title="深度学习框架-tensorflow"></a>深度学习框架-tensorflow</h1><ul><li>TensorFlow 实战_黄文坚（完整） <a href="https://pan.baidu.com/s/1cdosRiSsP5lJ8f1bHdlP3g">百度云下载链接</a> 密码:j199</li><li>TensorFlow 面向机器智能的TensorFlow实践 (智能系统与技术丛书) <a href="https://pan.baidu.com/s/1gSB9NQ9nS9cr7tSc357bBQ">百度云下载链接</a> 密码:t3z9</li><li>TensorFlow 斯坦福大学-深度学习基础教程 <a href="https://pan.baidu.com/s/1LHLvixtDJz7yDotIHwPYcw">百度云下载链接</a> 密码:rmsj</li><li>TensorFlow 官方文档中文版 <a href="https://pan.baidu.com/s/1wVbngJq3THdAYGtFXxnI5Q">百度云下载链接</a> 密码:ni0k</li><li>Tensorflow 实战Google深度学习框架（完整版pdf) <a href="https://pan.baidu.com/s/1QkVL5VnGrBaNA4Py5iqsGA">百度云下载链接</a> 密码:oivb</li></ul><h1 id="深度学习框架-pytorch"><a href="#深度学习框架-pytorch" class="headerlink" title="深度学习框架-pytorch"></a>深度学习框架-pytorch</h1><ul><li>Programming-PyTorch-for-Deep-Learning <a href="https://pan.baidu.com/s/19NF6mPrkeVnqrjAHaAGxvg">百度云下载链接</a> 密码:2v1c</li></ul><h1 id="深度学习框架-keras"><a href="#深度学习框架-keras" class="headerlink" title="深度学习框架-keras"></a>深度学习框架-keras</h1><ul><li>Python For Data Science Cheat Sheet Keras <a href="https://pan.baidu.com/s/1ODoojrUQl8rPFV2kxM1cbg">百度云下载链接</a> 密码:b8ll</li><li>Keras中文手册 <a href="https://pan.baidu.com/s/1t83iFvuIxJRJ6W_j77Bafw">百度云下载链接</a> 密码:w5df</li></ul><h1 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h1><ul><li>deeplearning深度学习笔记 <a href="https://pan.baidu.com/s/1LL4nBvQ09Idy-6IAWeZzig">百度云下载链接</a> 密码:aaxv</li><li>深度学习_中文版 <a href="https://pan.baidu.com/s/1xh5CIyelL2traBRPm-c6LA">百度云下载链接</a> 密码:nq4w</li><li>深度学习入门：基于Python的理论与实现 <a href="https://pan.baidu.com/s/10cquG__AurkTacnp6iKJcA">百度云下载链接</a> 密码:lvj7</li><li>常用推荐算法（50页干货） <a href="https://pan.baidu.com/s/1LU6UlFTiSUSjwCQq2XLXlA">百度云下载链接</a> 密码:wiqd</li><li>动手学深度学习-李沐 <a href="https://pan.baidu.com/s/1Ox8cTBwxUia2oZawvGMqsg">百度云下载链接</a> 密码:f33l</li><li>深度学习(最全的中文版) <a href="https://pan.baidu.com/s/1R5SvO6kACs16aMO3kV9MlA">百度云下载链接</a> 密码:cxxi</li></ul><h1 id="机器学习实战"><a href="#机器学习实战" class="headerlink" title="机器学习实战"></a>机器学习实战</h1><ul><li>机器学习实战（附所有代码） <a href="https://pan.baidu.com/s/1to5tvBtfq6gnRU2Bmi4SAg">百度云下载链接</a> 密码:6o5p</li><li>PYTHON机器学习及实践－<strong>从零开始通往KAGGLE竞赛之路</strong> <a href="https://pan.baidu.com/s/1qTGsUkhRCAbIeszRZzpnNg">百度云下载链接</a> 密码:z87v</li><li>贝叶斯思维统计建模的Python学习法 <a href="https://pan.baidu.com/s/1iok5j7-kABCtoid8YoEryA">百度云下载链接</a> 密码:6qby</li></ul><h1 id="理论-周志华（机器学习）李航（统计学原理）等"><a href="#理论-周志华（机器学习）李航（统计学原理）等" class="headerlink" title="理论-周志华（机器学习）李航（统计学原理）等"></a>理论-周志华（机器学习）李航（统计学原理）等</h1><ul><li>机器学习_周志华 <a href="https://pan.baidu.com/s/1XabgcxQUp0udkn00b0uqfw">百度云下载链接</a> 密码:oug5</li><li>统计学习方法-李航 <a href="https://pan.baidu.com/s/1u1q37b8vQBwUOck5vTE1Uw">百度云下载链接</a> 密码:yu0u</li></ul><h1 id="自然语言处理-NLP"><a href="#自然语言处理-NLP" class="headerlink" title="自然语言处理(NLP)"></a>自然语言处理(NLP)</h1><ul><li>斯坦福CS224n_自然语言处理与深度学习 <a href="https://pan.baidu.com/s/1S5kBuHhtCKXlB3k6IuuDyw">百度云下载链接</a> 密码:n7rx</li><li>Writing Code for NLP Research <a href="https://pan.baidu.com/s/1sT7kKilkXxedYv4Dog_adg">百度云下载链接</a> 密码:am91</li><li>语音与语言处理Speech+and+Language+Processing <a href="https://pan.baidu.com/s/1Zu_PUmLiB9n3nDcagCsv4Q">百度云下载链接</a> 密码:4ysu</li><li>deep_learning_for_nlp <a href="https://pan.baidu.com/s/1hgmnPVKhpc8lxOp_Onfvng">百度云下载链接</a> 密码:r2ma</li><li>Embedding Methods for NLP emnlp tutorial <a href="https://pan.baidu.com/s/1CaS0DWw5uSvHXCsz6VkfVA">百度云下载链接</a> 密码:g1oy</li><li>PYTHON自然语言处理中文翻译 NLTK 中文版 <a href="https://pan.baidu.com/s/1xJHF99KX011C-KluEaNq7w">百度云下载链接</a> 密码:112z</li></ul><h1 id="AI面试系列"><a href="#AI面试系列" class="headerlink" title="AI面试系列"></a>AI面试系列</h1><ul><li>机器学习 <a href="https://pan.baidu.com/s/1qDqmFjRiOOPQ6nQO8ABFbA">百度云下载链接</a> 密码:ikee</li><li>机器学习常见面试题 <a href="https://pan.baidu.com/s/1n53vfCNDbe8kWSTZdW7rNA">百度云下载链接</a> 密码:8w3r</li><li>百面_机器学习 算法工程师带你去面试。高清版带书签 <a href="https://pan.baidu.com/s/16PAgoNenlm4P6KlfHEmjNA">百度云下载链接</a> 密码:nzqr</li></ul><h1 id="大数据系列"><a href="#大数据系列" class="headerlink" title="大数据系列"></a>大数据系列</h1><h1 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h1><ul><li>Hadoop The Definitive Guide <a href="https://pan.baidu.com/s/1fZohTOxScoH44_5LNETZsw">百度云下载链接</a> 密码:fz20</li></ul><h1 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h1><ul><li>Spark大数据处理：技术、应用与性能优化(全) <a href="https://pan.baidu.com/s/1YmOgV7N6UsxjsW27W_VcEg">百度云下载链接</a> 密码:t4cn</li><li>Spark最佳实践 <a href="https://pan.baidu.com/s/1WOAb6iOdrx-M1UzTrrIn0A">百度云下载链接</a> 密码:963f</li><li>图解Spark++核心技术与案例实战 <a href="https://pan.baidu.com/s/1Z3_v8G6PzQ6E6WUXvn6_KA">百度云下载链接</a> 密码:ju28</li><li>Spark快速大数据分析 <a href="https://pan.baidu.com/s/1Xk9YSD7NCc_tofmyXIWI9A">百度云下载链接</a> 密码:9ai8</li><li>深入理解Spark：核心思想与源码分析 <a href="https://pan.baidu.com/s/1hdC0kvxFP_grpFRhj0qltQ">百度云下载链接</a> 密码:mopd</li><li>Spark机器学习 <a href="https://pan.baidu.com/s/1AEYKo_bxwtOXG0HErGLXqg">百度云下载链接</a> 密码:jmib</li></ul><h1 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h1><ul><li>Scala编程中文版(33章全) <a href="https://pan.baidu.com/s/1YCVBnHp6ud0HYR8Cd5DNYQ">百度云下载链接</a> 密码:wkmi</li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li>大数据架构师指南 <a href="https://pan.baidu.com/s/14Rxan_IhRKCfpr7GJFeQ2Q">百度云下载链接</a> 密码:3dtd</li><li>大数据之路：阿里巴巴大数据实践 <a href="https://pan.baidu.com/s/1WTZjCmuwlaBUTxTAaBjgpg">百度云下载链接</a> 密码:5123</li><li>Apache+Kylin权威指南 <a href="https://pan.baidu.com/s/1vVjn9tP-Z_QK7AaasyCj7A">百度云下载链接</a> 密码:0ypz</li><li>Kafka &amp; Mafka技术分享及讨论 <a href="https://pan.baidu.com/s/1BbNHZGFHioSoBQ4Zm3Jnfg">百度云下载链接</a> 密码:w7qs</li><li>【高扬】白话深度学习姊妹篇–白话大数据与ML <a href="https://pan.baidu.com/s/1O2lcJ-cvWTZjbKuGgLPdcw">百度云下载链接</a> 密码:d9yp</li></ul><h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><ul><li>C Primer Plus <a href="https://pan.baidu.com/s/1uKLaF1_TlHrcLZCe9Th5bw">百度云下载链接</a> 密码:njif</li><li>C和指针 <a href="https://pan.baidu.com/s/1D1C93Y6qcwC3Z7lv3hpEeA">百度云下载链接</a> 密码:22lz</li><li>C专家编程 <a href="https://pan.baidu.com/s/19cSD4k4d5cdu0nZWZq4MRg">百度云下载链接</a> 密码:eik1</li><li>C语言解析教程 <a href="https://pan.baidu.com/s/1ARQBYbjWKgZq7jJVl8GPfw">百度云下载链接</a> 密码:o9ej</li><li>C程序设计语言-各种版本的C程序设计语言及其课后题答案 <a href="https://pan.baidu.com/s/1ssyYVh0ZtSKko1hXYI2_pQ">百度云下载链接</a> 密码:5zl9</li><li>经典C程序100例 <a href="https://pan.baidu.com/s/1wj32oi-7pwjjGPamCzcdAw">百度云下载链接</a> 密码:ww8k</li><li>C语言编程精粹 <a href="https://pan.baidu.com/s/1p6pZovi4UmQAdzO253nKKg">百度云下载链接</a> 密码:22df</li><li>C语言参考手册 <a href="https://pan.baidu.com/s/1E4zVZDD-HFOkI9xVIEs9Fg">百度云下载链接</a> 密码:db3g</li><li>C语言函数大全 <a href="https://pan.baidu.com/s/1GQfFi9qtN_cnykkFsv9Zjg">百度云下载链接</a> 密码:14cm</li><li>C语言深度剖析 <a href="https://pan.baidu.com/s/1UL5R9cF3oipNXguQZ2xsCA">百度云下载链接</a> 密码:2lvj</li></ul><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><ul><li>C++大学教程 <a href="https://pan.baidu.com/s/1u0xKMjQyLeytrn0ZV7_amw">百度云下载链接</a> 密码:cuvn</li><li>STL源码剖析 <a href="https://pan.baidu.com/s/1fLWhQnmVyksk3BpmG_zGfQ">百度云下载链接</a> 密码:o9rv</li><li>C++编程思想 <a href="https://pan.baidu.com/s/1Uyt9Uhv7Jy80ykzPwes9Yg">百度云下载链接</a> 密码:q97e</li><li>C++沉思录中文第2版 <a href="https://pan.baidu.com/s/1VvGqaVso5eqIEMoeGkOpLA">百度云下载链接</a> 密码:xrxv</li><li>C++ Primer <a href="https://pan.baidu.com/s/11uKddTH2DhpKMILljyh0bw">百度云下载链接</a> 密码:aeao</li><li>深入探索C++对象模型 <a href="https://pan.baidu.com/s/1wKHreRYK1ngSmAjU3LUjNQ">百度云下载链接</a> 密码:qltd</li><li>C++对象模型 <a href="https://pan.baidu.com/s/1RhaifqkDc2D125yg1SmlmQ">百度云下载链接</a> 密码:6zpm</li><li>C++ Templates <a href="https://pan.baidu.com/s/1xZXozU-d8dEOBzezqLf8Vg">百度云下载链接</a> 密码:rmt1</li><li>C++编程规范-101条规则准则与最佳实践 <a href="https://pan.baidu.com/s/1ymum8hAGzObRG8stFYNddg">百度云下载链接</a> 密码:7f7s</li><li>C++设计新思维-泛型编程与设计之应用 <a href="https://pan.baidu.com/s/1Ht1Ji11v52P_p4gY6osuvA">百度云下载链接</a> 密码:nail</li><li>Effective STL 中文版 <a href="https://pan.baidu.com/s/16kaPHB9MgHVamNX6K84Z5w">百度云下载链接</a> 密码:86q5</li><li>More Effective C++中文版 <a href="https://pan.baidu.com/s/13sO6Ct64A-SHBdCeL0JgsA">百度云下载链接</a> 密码:c7av</li></ul><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><ul><li>码出高效 <a href="https://pan.baidu.com/s/1Nu-r8G8EAIo62J4FzYoKVw">百度云下载链接</a> 密码:nedl</li><li>Head First Java <a href="https://pan.baidu.com/s/16zkC7riCEo3Cnt-3BllUJg">百度云下载链接</a> 密码:f39y</li><li>Java并发编程实践 <a href="https://pan.baidu.com/s/1gSyCcJl2OheOqkQhHtfTNg">百度云下载链接</a> 密码:fwhs</li><li>Java从小白到大牛 <a href="https://pan.baidu.com/s/1FFxvNltEY34Pba_dRd_kqg">百度云下载链接</a> 密码:tolg</li><li>深入理解Java虚拟机 <a href="https://pan.baidu.com/s/1pYyEgyf5kl9tQB-XGd32EQ">百度云下载链接</a> 密码:vfzi</li><li>Java8实战 <a href="https://pan.baidu.com/s/1rTV7cC382rUWxpb7U8WCRA">百度云下载链接</a> 密码:57bv</li><li>Java编程思想 <a href="https://pan.baidu.com/s/1JITtexXMiLCwQlW5YI2GRQ">百度云下载链接</a> 密码:8xli</li><li>Java并发编程的艺术 <a href="https://pan.baidu.com/s/1xhFNTE1ywJxmhvDuemqo5A">百度云下载链接</a> 密码:tauv</li><li>阿里巴巴Java开发手册 <a href="https://pan.baidu.com/s/1HYeuwkENhh2Nbfav1WI1lw">百度云下载链接</a> 密码:98zo</li></ul><h1 id="Java进阶"><a href="#Java进阶" class="headerlink" title="Java进阶"></a>Java进阶</h1><ul><li>代码大全 <a href="https://pan.baidu.com/s/1dfRdyevYc7xVPjb0wcja6Q">百度云下载链接</a> 密码:o3zq</li><li>Java性能优化权威指南 <a href="https://pan.baidu.com/s/1ClJMQlWPq6FDb_XJxleizQ">百度云下载链接</a> 密码:4tfv</li><li>敏捷软件开发 <a href="https://pan.baidu.com/s/1iYeZ5AqyQLBTDuug5_rnSA">百度云下载链接</a> 密码:8uqr</li><li>Effective Java <a href="https://pan.baidu.com/s/1m7OVyyhgjbs6HSIt_zeRvw">百度云下载链接</a> 密码:74ba</li><li>代码整洁之道 <a href="https://pan.baidu.com/s/1ATMm0vmDURZqxMv9lIht_g">百度云下载链接</a> 密码:0jco</li><li>Effective Java（<strong>英文版</strong>） <a href="https://pan.baidu.com/s/17VvfSKSdLWtezMcQYF7rqw">百度云下载链接</a> 密码:jk2z</li></ul><h1 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h1><ul><li>轻量级JavaEE企业应用实战 <a href="https://pan.baidu.com/s/1AZUULdcVFSArx1Jbiz1I8w">百度云下载链接</a> 密码:uwge</li><li>Head First Servlet and JSP <a href="https://pan.baidu.com/s/1XQ4xBQvWxfhWhPp1y7WzMA">百度云下载链接</a> 密码:xlpu</li><li>Maven实战 <a href="https://pan.baidu.com/s/1hpGhWnn7wZFrI3PDzfvrvg">百度云下载链接</a> 密码:zjt5</li><li>Spring实战 <a href="https://pan.baidu.com/s/1SSFmd3KewFbouXQL6N19xQ">百度云下载链接</a> 密码:z32s</li><li>深入分析JavaWeb技术内幕 <a href="https://pan.baidu.com/s/1WuOFZuBdeui2gohif0c-2g">百度云下载链接</a> 密码:2gcd</li><li>深入剖析Tomcat <a href="https://pan.baidu.com/s/1Qr6WaBh_pkq-i8hIpu6f7A">百度云下载链接</a> 密码:o4tr</li><li>Camel in Action <a href="https://pan.baidu.com/s/1dbp0zXE6xs3XMiJYq04uNw">百度云下载链接</a> 密码:itrz</li></ul><h1 id="设计模式-1"><a href="#设计模式-1" class="headerlink" title="设计模式"></a>设计模式</h1><ul><li>研磨设计模式 <a href="https://pan.baidu.com/s/196JsKSEtDoKYZB3yYIigjg">百度云下载链接</a> 密码:a0xy</li><li>图解设计模式 <a href="https://pan.baidu.com/s/1JCX_9HtlWxHy9XcpXyoyTA">百度云下载链接</a> 密码:ba3z</li><li>Head First设计模式《important》 <a href="https://pan.baidu.com/s/1v_7byjgNEwZCEisJltlzHA">百度云下载链接</a> 密码:v2rl</li></ul><h1 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库"></a>数据库</h1><ul><li>SQL查询的艺术 <a href="https://pan.baidu.com/s/1Fucoluf9TQn9a6Vq-XchPA">百度云下载链接</a> 密码:xfrz</li><li>MySQL必知必会 <a href="https://pan.baidu.com/s/1xKPH21U4OJwWWqV4gWX0hQ">百度云下载链接</a> 密码:hwk3</li><li>高性能MySQL <a href="https://pan.baidu.com/s/1G1E-HucJYQ32lvtlIZJbPw">百度云下载链接</a> 密码:sjp8</li><li>MySQL技术内幕InnoDB存储引擎 <a href="https://pan.baidu.com/s/1PKjeIt5Wrq9hRkYxA3YMtg">百度云下载链接</a> 密码:lsto</li><li>MongoDB权威指南 <a href="https://pan.baidu.com/s/1pdCKtNdA2YLMzgmbfMs5kQ">百度云下载链接</a> 密码:cw6a</li><li>SQLite 权威指南 <a href="https://pan.baidu.com/s/18ldoXc9cWyQ78UROeud-SQ">百度云下载链接</a> 密码:b58t</li></ul><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><ul><li>HTML5与CSS3基础教程 <a href="https://pan.baidu.com/s/1uGoURdRyKOOspvHJSyor1w">百度云下载链接</a> 密码:7srp</li><li>Bootstrap实战 <a href="https://pan.baidu.com/s/1Jw34Xuj2_2q9bICm3yFlkw">百度云下载链接</a> 密码:fnf0</li><li>jQuery高级编程 <a href="https://pan.baidu.com/s/1Al0WLj-6tNKHfDr319XJ0w">百度云下载链接</a> 密码:zx8d</li><li>疯狂aJax讲义 <a href="https://pan.baidu.com/s/1Mc1fuKtqL-F9VYI4n3RxPQ">百度云下载链接</a> 密码:3szv</li><li>jQuery技术内幕 <a href="https://pan.baidu.com/s/1tnr-VAMKqSDv0qjtu9rywA">百度云下载链接</a> 密码:crcu</li><li>JavaScript DOM编程艺术 <a href="https://pan.baidu.com/s/1Un4NvZZ7x-HaOViCIcNNeA">百度云下载链接</a> 密码:rn2e</li><li>HTML5揭秘 <a href="https://pan.baidu.com/s/1TfP15JglC7rgI_M1UaIimQ">百度云下载链接</a> 密码:g3av</li><li>【JavaScript高级程序设计（第3版）】中文 高清 <a href="https://pan.baidu.com/s/1-kWjkZ9taGTxnCdLRGqscg">百度云下载链接</a> 密码:2bnz</li><li>JavaScript高效图形编程 <a href="https://pan.baidu.com/s/1yj4mh_aC8dXsIJn09UWPQQ">百度云下载链接</a> 密码:hxhk</li><li>jQuery权威指南 <a href="https://pan.baidu.com/s/1e_bo4bQmBB1rrkAwB9xZ3Q">百度云下载链接</a> 密码:jgsq</li><li>Node.js开发指南 <a href="https://pan.baidu.com/s/1GJ_dmgJMM6Bb2zBsOeH7hw">百度云下载链接</a> 密码:4bie</li><li>HTML5揭秘 <a href="https://pan.baidu.com/s/1TfP15JglC7rgI_M1UaIimQ">百度云下载链接</a> 密码:g3av</li></ul><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><ul><li>Linux系统命令及shell脚本实践指南linuxunix技术丛书 <a href="https://pan.baidu.com/s/1G1EI-amN7DN5Vuz8NLztKA">百度云下载链接</a> 密码:9d27</li><li>鸟哥的Linux私房菜 <a href="https://pan.baidu.com/s/10tCGLa9y5G-VNefEexIDeQ">百度云下载链接</a> 密码:djoc</li><li>Linux高级程序设计 <a href="https://pan.baidu.com/s/1oLBCW3lVBZLcSQnx5XbZMg">百度云下载链接</a> 密码:6d08</li><li>汇编语言基于linux环境第3版 <a href="https://pan.baidu.com/s/1fm7gt4qFiEMfNzAB5rfDfA">百度云下载链接</a> 密码:c7k8</li><li>Linux命令详解词典 <a href="https://pan.baidu.com/s/18mp0g_eVLQPkhZSuvVBu1Q">百度云下载链接</a> 密码:ukq3</li><li>Linux防火墙 <a href="https://pan.baidu.com/s/1i52MZc8FC9H8HKjL2uCfWA">百度云下载链接</a> 密码:14p6</li><li>深入Linux内核架构 <a href="https://pan.baidu.com/s/13TfK2DCWVxeMdV5Y40nDOw">百度云下载链接</a> 密码:h1k5</li><li>Linux环境编程 <a href="https://pan.baidu.com/s/1BsPOjilroe6nHk3PXU-4Bg">百度云下载链接</a> 密码:fyrn</li><li>精通正则表达式 <a href="https://pan.baidu.com/s/1cP5pPjkSUyDUEdGeKbHHUw">百度云下载链接</a> 密码:jzgx</li><li>Linux常用命令大全 <a href="https://pan.baidu.com/s/1t98pEifGrfUYqiLCMx5rgg">百度云下载链接</a> 密码:7v30</li></ul><h1 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h1><ul><li>Go语言实战 <a href="https://pan.baidu.com/s/1v4LSutDDJgkm6Ag1GCnfQQ">百度云下载链接</a> 密码:3wmy</li><li>Go web编程 <a href="https://pan.baidu.com/s/1mumaypjjR39ZzddL3IFYsg">百度云下载链接</a> 密码:3e3f</li><li>redis实战 <a href="https://pan.baidu.com/s/1xJ9nJkeAsFF924uPEuMqqQ">百度云下载链接</a> 密码:ufxn</li><li>学习Go语言 <a href="https://pan.baidu.com/s/1vVCSRsMvaDwuTZi3iWtzQg">百度云下载链接</a> 密码:0hzt</li></ul><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><ul><li>《Pro Git》中文版 <a href="https://pan.baidu.com/s/1-JIkWeIIRzJwP3h4-H2sQQ">百度云下载链接</a> 密码:1zrt</li><li>快速入门Git <a href="https://pan.baidu.com/s/1jRUzM5KwK94FFTS2e86lyw">百度云下载链接</a> 密码:0u6n</li><li>专业git中文 <a href="https://pan.baidu.com/s/1nx2_xQ71na8p7JYtL59J5A">百度云下载链接</a> 密码:lsdl</li><li>Git参考手册 <a href="https://pan.baidu.com/s/18QC1-p_yGw4ILqB-v8XPHw">百度云下载链接</a> 密码:qq2v</li></ul><h1 id="数字信号"><a href="#数字信号" class="headerlink" title="数字信号"></a>数字信号</h1><ul><li>数字信号处理教程 第3版 by 程佩青 (z-lib.org) <a href="https://pan.baidu.com/s/11xO0H9pWiADvM9435OmlKw">百度云下载链接</a> 密码:tvmt</li></ul><h1 id="提升能力"><a href="#提升能力" class="headerlink" title="提升能力"></a>提升能力</h1><ul><li>重构：改善既有代码的设计（第2版） <a href="https://pan.baidu.com/s/1ZDP7cMNQppfyogJ6X53LVg">百度云下载链接</a> 密码:7lve</li><li>码农翻身 <a href="https://pan.baidu.com/s/1blFwoNWdMmTfPyyvb_3s6w">百度云下载链接</a> 密码:5c26</li><li>浪潮之巅 <a href="https://pan.baidu.com/s/11I2DZtrgJaY1OvRJZg6FqQ">百度云下载链接</a> 密码:6416</li><li>程序员面试宝典 <a href="https://pan.baidu.com/s/1e9I4on3zsfNLE9WFqEZxhQ">百度云下载链接</a> 密码:ukzv</li><li>奔跑吧，程序员：从零开始打造产品、技术和团队 <a href="https://pan.baidu.com/s/1yZKsc1NoQgHrlI1eeOZFkw">百度云下载链接</a> 密码:43ul</li></ul>]]></content>
    
    
    <categories>
      
      <category>书籍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发相关书籍</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Terraform-基础架构管理工具</title>
    <link href="/2021/01/26/devops/Terraform-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <url>/2021/01/26/devops/Terraform-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><blockquote><p>Terraform 是一种安全有效地构建、更改和版本控制基础设施的工具(基础架构自动化的编排工具)。它的目标是 “Write, Plan, and create Infrastructure as Code”, 基础架构即代码。Terraform 几乎可以支持所有市面上能见到的云服务。具体的说就是可以用代码来管理维护 IT 资源，把之前需要手动操作的一部分任务通过程序来自动化的完成，这样的做的结果非常明显：高效、不易出错。</p></blockquote><h1 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h1><p class="note note-primary">下载软件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jshelllanguage">wget https:&#x2F;&#x2F;releases.hashicorp.com&#x2F;terraform&#x2F;0.14.5&#x2F;terraform_0.14.5_linux_amd64.zip<br>unzip terraform_0.14.5_linux_amd64.zip<br>mv terraform &#x2F;usr&#x2F;bin&#x2F;<br></code></pre></td></tr></table></figure><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p>TODO</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.terraform.io/docs/index.html">官方文档</a></p><p><a href="https://www.cnblogs.com/sparkdev/p/10052310.html">相关博客</a></p>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编排工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ansible-计算机系统配置管理器</title>
    <link href="/2021/01/26/devops/Ansible-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <url>/2021/01/26/devops/Ansible-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="软件简介"><a href="#软件简介" class="headerlink" title="软件简介"></a>软件简介</h1><p>Ansible 提供一种最简单的方式用于发布、管理和编排计算机系统的工具，你可在数分钟内搞定。</p><p>Ansible 是一个模型驱动的配置管理器，支持多节点发布、远程任务执行。默认使用 SSH 进行远程连接。无需在被管理节点上安装附加软件，可使用各种编程语言进行扩展。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/01064642_9GyL.png" alt="ansible architecture diagram"></p><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自动编排</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nacos-动态服务发现配置和服务管理平台</title>
    <link href="/2021/01/25/middleware/Nacos-%E5%8A%A8%E6%80%81%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E9%85%8D%E7%BD%AE%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0/"/>
    <url>/2021/01/25/middleware/Nacos-%E5%8A%A8%E6%80%81%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E9%85%8D%E7%BD%AE%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="什么是-Nacos"><a href="#什么是-Nacos" class="headerlink" title="什么是 Nacos"></a>什么是 Nacos</h1><p>服务（Service）是 Nacos 世界的一等公民。Nacos 支持几乎所有主流类型的服务的发现、配置和管理：</p><ul><li><a href="https://kubernetes.io/docs/concepts/services-networking/service/">Kubernetes Service</a></li><li><a href="https://grpc.io/docs/guides/concepts.html#service-definition">gRPC</a> &amp; <a href="https://dubbo.incubator.apache.org/">Dubbo RPC Service</a></li><li><a href="https://spring.io/understanding/REST">Spring Cloud RESTful Service</a></li></ul><h1 id="Nacos-特性包括"><a href="#Nacos-特性包括" class="headerlink" title="Nacos 特性包括"></a>Nacos 特性包括</h1><ul><li><strong>服务发现和服务健康监测</strong></li></ul><p>Nacos 支持基于 DNS 和基于 RPC 的服务发现。服务提供者使用 <a href="https://nacos.io/zh-cn/docs/sdk.html">原生SDK</a>、<a href="https://nacos.io/zh-cn/docs/open-API.html">OpenAPI</a>、或一个<a href="https://nacos.io/zh-cn/docs/other-language.html">独立的Agent TODO</a>注册 Service 后，服务消费者可以使用<a href="https://nacos.io/zh-cn/docs/xx">DNS TODO</a> 或<a href="https://nacos.io/zh-cn/docs/xx">HTTP&amp;API TODO</a>查找和发现服务。</p><p>Nacos 提供实时健康检查，阻止服务向不健康的主机或服务实例发送请求。Nacos 支持传输层(PING 或 TCP)和应用层(如 HTTP、Redis、MySQL、用户自定义）的健康检查。 对于复杂的云环境和网络拓扑环境中（如 VPC、边缘服务等）服务的健康检查，Nacos 提供了 agent 模式和服务端2种健康检查模式。Nacos 还提供统一的健康检查仪表盘，帮助您管理服务可用性及流量。</p><ul><li><strong>动态配置服务</strong></li></ul><p>动态配置服务可以让您以中心化、外部化和动态化的方式管理所有环境的应用配置和服务配置。</p><p>动态配置消除了配置变更时重新部署应用和服务的需要，让配置变得更加高效和敏捷。</p><p>配置中心化管理让无状态服务实现变得更简单，让服务按需弹性扩展变得更容易。</p><p>Nacos 提供了一个 <a href="https://nacos.io/zh-cn/docs/xx">简单易用的UI TODO</a> 帮助您管理所有的服务和应用的配置。Nacos 还提供包括配置版本跟踪、金丝雀发布、回滚配置以及客户进程配置更新状态跟踪在内的一系列开箱即用的配置管理特性，帮助您更安全地管理配置变更和控制配置变更的风险。</p><ul><li><strong>动态 DNS 服务</strong></li></ul><p>动态 DNS 服务支持权重路由，让您更容易地实现中间层负载均衡、更灵活的路由策略、流量控制以及数据中心内网的简单DNS解析服务。动态DNS服务还能让您更容易地实现以DNS协议为基础的服务发现，以消除耦合到厂商私有服务发现API上的风险。</p><p>Nacos 提供了一些简单的 <a href="https://nacos.io/zh-cn/docs/xx">DNS APIs TODO</a> 帮助您管理服务的关联域名和可用的 IP:PORT 列表.</p><ul><li><strong>服务及其元数据管理</strong></li></ul><p>Nacos 能让您从微服务平台建设的视角管理数据中心的所有服务及元数据，包括管理服务的描述、生命周期、服务的静态依赖分析、服务的健康状态、服务的流量管理、路由及安全策略、服务的 SLA 以及最首要的 Metrics 统计数据。</p><h1 id="Nacos-全景图"><a href="#Nacos-全景图" class="headerlink" title="Nacos 全景图"></a>Nacos 全景图</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/29102804_XygY.png" alt="nacos_landscape.png"></p><p>如 Nacos 全景图所示，Nacos 无缝支持一些主流的开源生态，例如 <a href="https://nacos.io/zh-cn/docs/xx">Dubbo and Dubbo Mesh TODO</a>、<a href="https://nacos.io/zh-cn/docs/xx">Spring Cloud TODO</a>、<a href="https://nacos.io/zh-cn/docs/xx">Kubernetes and CNCF TODO</a>。</p><p>使用 Nacos 简化服务发现、配置管理、服务治理及管理的解决方案，让微服务管理、共享、组合更加容易。</p><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p class="note note-primary">方式一通过下载源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jshelllanguage">git clone https:&#x2F;&#x2F;github.com&#x2F;alibaba&#x2F;nacos.git<br>cd nacos&#x2F;<br>mvn -Prelease-nacos -Dmaven.test.skip&#x3D;true clean install -U <br>ls -al distribution&#x2F;target&#x2F;<br><br>&#x2F;&#x2F; change the $version to your actual path<br>cd distribution&#x2F;target&#x2F;nacos-server-$version&#x2F;nacos&#x2F;bin<br></code></pre></td></tr></table></figure><p class="note note-primary">方式二下载可运行包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jshelllanguage">unzip nacos-server-$version.zip  OR tar -xvf nacos-server-$version.tar.gz<br>cd nacos&#x2F;bin<br></code></pre></td></tr></table></figure><p class="note note-primary">启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jshelllanguage">bash startup.sh -m standalone<br></code></pre></td></tr></table></figure><p class="note note-primary">服务注册</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jshelllanguage">curl -X POST &#39;http:&#x2F;&#x2F;127.0.0.1:8848&#x2F;nacos&#x2F;v1&#x2F;ns&#x2F;instance?serviceName&#x3D;nacos.naming.serviceName&amp;ip&#x3D;20.18.7.10&amp;port&#x3D;8080&#39;<br></code></pre></td></tr></table></figure><p class="note note-primary">服务发现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jshelllanguage">curl -X GET &#39;http:&#x2F;&#x2F;127.0.0.1:8848&#x2F;nacos&#x2F;v1&#x2F;ns&#x2F;instance&#x2F;list?serviceName&#x3D;nacos.naming.serviceName&#39;<br></code></pre></td></tr></table></figure><p class="note note-primary">发布配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jshelllanguage">curl -X POST &quot;http:&#x2F;&#x2F;127.0.0.1:8848&#x2F;nacos&#x2F;v1&#x2F;cs&#x2F;configs?dataId&#x3D;nacos.cfg.dataId&amp;group&#x3D;test&amp;content&#x3D;helloWorld&quot;<br></code></pre></td></tr></table></figure><p class="note note-primary">获取配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jshelllanguage">curl -X GET &quot;http:&#x2F;&#x2F;127.0.0.1:8848&#x2F;nacos&#x2F;v1&#x2F;cs&#x2F;configs?dataId&#x3D;nacos.cfg.dataId&amp;group&#x3D;test&quot;<br></code></pre></td></tr></table></figure><p class="note note-primary">关闭服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jshelllanguage">sh shutdown.sh<br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://nacos.io/en-us/docs/quick-start.html">官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务发现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo-高性能的Java-RPC框架</title>
    <link href="/2021/01/22/java/Dubbo-%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84Java-RPC%E6%A1%86%E6%9E%B6/"/>
    <url>/2021/01/22/java/Dubbo-%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84Java-RPC%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="框架简介"><a href="#框架简介" class="headerlink" title="框架简介"></a>框架简介</h1><blockquote><p>Apache Dubbo is a high-performance, java based open source RPC framework.</p></blockquote><h1 id="框架特点"><a href="#框架特点" class="headerlink" title="框架特点"></a>框架特点</h1><ul><li><p>基于透明接口的RPC</p><blockquote><p>Dubbo提供了基于高性能接口的RPC，对用户是透明的。</p></blockquote></li><li><p>智能负载均衡</p><blockquote><p>Dubbo支持开箱即用的多种负载平衡策略，可感知下游服务状态以减少总体延迟并提高系统吞吐量。</p></blockquote></li><li><p>自动服务注册和发现</p><blockquote><p>Dubbo支持多个服务注册表，可以立即检测在线/离线服务。</p></blockquote></li><li><p>高扩展性</p><blockquote><p>Dubbo的微内核和插件设计确保第三方实现可以轻松地将其扩展为协议，传输和序列化等核心功能。</p></blockquote></li><li><p>运行时流量路由</p><blockquote><p>可以在运行时配置Dubbo，以便可以根据不同的规则路由流量，这使得支持蓝绿色部署，数据中心感知路由等功能变得容易。</p></blockquote></li><li><p>可视化服务治理</p><blockquote><p>Dubbo提供了用于服务管理和维护的丰富工具，例如查询服务元数据，运行状况和统计信息。</p></blockquote></li></ul><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p class="note note-primary">下载源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jshelllanguage">git clone https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;dubbo.git dubbo<br>cd dubbo&#x2F;dubbo-demo&#x2F;dubbo-demo-xml<br>mvn clean install<br></code></pre></td></tr></table></figure><p class="note note-primary">运行Zookeeper</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jshelllanguage">wget https:&#x2F;&#x2F;downloads.apache.org&#x2F;zookeeper&#x2F;zookeeper-3.6.2&#x2F;apache-zookeeper-3.6.2-bin.tar.gz<br>tar -zxvf apache-zookeeper-3.6.2-bin.tar.gz<br>cd apache-zookeeper-3.6.2-bin&#x2F;bin<br>.&#x2F;zkServer.sh start<br></code></pre></td></tr></table></figure><p class="note note-primary">运行程序</p><p>先运行<code>org.apache.dubbo.demo.provider.Application</code></p><p>再运行<code>org.apache.dubbo.demo.consumer.Application</code></p><h1 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/dubbo-framework.jpg" alt="框架设计图"></p><p>图例说明：</p><ul><li>图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。</li><li>图中从下至上分为十层，各层均为单向依赖，右边的黑色箭头代表层之间的依赖关系，每一层都可以剥离上层被复用，其中，Service 和 Config 层为 API，其它各层均为 SPI。</li><li>图中绿色小块的为扩展接口，蓝色小块为实现类，图中只显示用于关联各层的实现类。</li><li>图中蓝色虚线为初始化过程，即启动时组装链，红色实线为方法调用过程，即运行时调时链，紫色三角箭头为继承，可以把子类看作父类的同一个节点，线上的文字为调用的方法。</li></ul><h2 id="各层说明"><a href="#各层说明" class="headerlink" title="各层说明"></a>各层说明</h2><ul><li><strong>config 配置层</strong>：对外配置接口，以 <code>ServiceConfig</code>, <code>ReferenceConfig</code> 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</li><li><strong>proxy 服务代理层</strong>：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 <code>ServiceProxy</code> 为中心，扩展接口为 <code>ProxyFactory</code></li><li><strong>registry 注册中心层</strong>：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 <code>RegistryFactory</code>, <code>Registry</code>, <code>RegistryService</code></li><li><strong>cluster 路由层</strong>：封装多个提供者的路由及负载均衡，并桥接注册中心，以 <code>Invoker</code> 为中心，扩展接口为 <code>Cluster</code>, <code>Directory</code>, <code>Router</code>, <code>LoadBalance</code></li><li><strong>monitor 监控层</strong>：RPC 调用次数和调用时间监控，以 <code>Statistics</code> 为中心，扩展接口为 <code>MonitorFactory</code>, <code>Monitor</code>, <code>MonitorService</code></li><li><strong>protocol 远程调用层</strong>：封装 RPC 调用，以 <code>Invocation</code>, <code>Result</code> 为中心，扩展接口为 <code>Protocol</code>, <code>Invoker</code>, <code>Exporter</code></li><li><strong>exchange 信息交换层</strong>：封装请求响应模式，同步转异步，以 <code>Request</code>, <code>Response</code> 为中心，扩展接口为 <code>Exchanger</code>, <code>ExchangeChannel</code>, <code>ExchangeClient</code>, <code>ExchangeServer</code></li><li><strong>transport 网络传输层</strong>：抽象 mina 和 netty 为统一接口，以 <code>Message</code> 为中心，扩展接口为 <code>Channel</code>, <code>Transporter</code>, <code>Client</code>, <code>Server</code>, <code>Codec</code></li><li><strong>serialize 数据序列化层</strong>：可复用的一些工具，扩展接口为 <code>Serialization</code>, <code>ObjectInput</code>, <code>ObjectOutput</code>, <code>ThreadPool</code></li></ul><h2 id="关系说明"><a href="#关系说明" class="headerlink" title="关系说明"></a>关系说明</h2><ul><li>在 RPC 中，Protocol 是核心层，也就是只要有 Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用，然后在 Invoker 的主过程上 Filter 拦截点。</li><li>图中的 Consumer 和 Provider 是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用 Client 和 Server 的原因是 Dubbo 在很多场景下都使用 Provider, Consumer, Registry, Monitor 划分逻辑拓普节点，保持统一概念。</li><li>而 Cluster 是外围概念，所以 Cluster 的目的是将多个 Invoker 伪装成一个 Invoker，这样其它人只要关注 Protocol 层 Invoker 即可，加上 Cluster 或者去掉 Cluster 对其它层都不会造成影响，因为只有一个提供者时，是不需要 Cluster 的。</li><li>Proxy 层封装了所有接口的透明化代理，而在其它层都以 Invoker 为中心，只有到了暴露给用户使用时，才用 Proxy 将 Invoker 转成接口，或将接口实现转成 Invoker，也就是去掉 Proxy 层 RPC 是可以 Run 的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。</li><li>而 Remoting 实现是 Dubbo 协议的实现，如果你选择 RMI 协议，整个 Remoting 都不会用上，Remoting 内部再划为 Transport 传输层和 Exchange 信息交换层，Transport 层只负责单向消息传输，是对 Mina, Netty, Grizzly 的抽象，它也可以扩展 UDP 传输，而 Exchange 层是在传输层之上封装了 Request-Response 语义。</li><li>Registry 和 Monitor 实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。</li></ul><h2 id="模块分包"><a href="#模块分包" class="headerlink" title="模块分包"></a>模块分包</h2><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/dubbo-modules.jpg" alt="模块分包"></p><p>模块说明：</p><ul><li><strong>dubbo-common 公共逻辑模块</strong>：包括 Util 类和通用模型。</li><li><strong>dubbo-remoting 远程通讯模块</strong>：相当于 Dubbo 协议的实现，如果 RPC 用 RMI协议则不需要使用此包。</li><li><strong>dubbo-rpc 远程调用模块</strong>：抽象各种协议，以及动态代理，只包含一对一的调用，不关心集群的管理。</li><li><strong>dubbo-cluster 集群模块</strong>：将多个服务提供方伪装为一个提供方，包括：负载均衡, 容错，路由等，集群的地址列表可以是静态配置的，也可以是由注册中心下发。</li><li><strong>dubbo-registry 注册中心模块</strong>：基于注册中心下发地址的集群方式，以及对各种注册中心的抽象。</li><li><strong>dubbo-monitor 监控模块</strong>：统计服务调用次数，调用时间的，调用链跟踪的服务。</li><li><strong>dubbo-config 配置模块</strong>：是 Dubbo 对外的 API，用户通过 Config 使用Dubbo，隐藏 Dubbo 所有细节。</li><li><strong>dubbo-container 容器模块</strong>：是一个 Standlone 的容器，以简单的 Main 加载 Spring 启动，因为服务通常不需要 Tomcat/JBoss 等 Web 容器的特性，没必要用 Web 容器去加载服务。</li></ul><p>整体上按照分层结构进行分包，与分层的不同点在于：</p><ul><li>container 为服务容器，用于部署运行服务，没有在层中画出。</li><li>protocol 层和 proxy 层都放在 rpc 模块中，这两层是 rpc 的核心，在不需要集群也就是只有一个提供者时，可以只使用这两层完成 rpc 调用。</li><li>transport 层和 exchange 层都放在 remoting 模块中，为 rpc 调用的通讯基础。</li><li>serialize 层放在 common 模块中，以便更大程度复用。</li></ul><h2 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h2><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/dubbo-relation.jpg" alt="依赖关系"></p><p>图例说明：</p><ul><li>图中小方块 Protocol, Cluster, Proxy, Service, Container, Registry, Monitor 代表层或模块，蓝色的表示与业务有交互，绿色的表示只对 Dubbo 内部交互。</li><li>图中背景方块 Consumer, Provider, Registry, Monitor 代表部署逻辑拓扑节点。</li><li>图中蓝色虚线为初始化时调用，红色虚线为运行时异步调用，红色实线为运行时同步调用。</li><li>图中只包含 RPC 的层，不包含 Remoting 的层，Remoting 整体都隐含在 Protocol 中。</li></ul><h2 id="调用链"><a href="#调用链" class="headerlink" title="调用链"></a>调用链</h2><p>展开总设计图的红色调用链，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/dubbo-extension.jpg" alt="总设计图"></p><h2 id="暴露服务时序"><a href="#暴露服务时序" class="headerlink" title="暴露服务时序"></a>暴露服务时序</h2><p>展开总设计图左边服务提供方暴露服务的蓝色初始化链，时序图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/dubbo-export.jpg" alt="时序图"></p><h2 id="引用服务时序"><a href="#引用服务时序" class="headerlink" title="引用服务时序"></a>引用服务时序</h2><p>展开总设计图右边服务消费方引用服务的蓝色初始化链，时序图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/dubbo-refer.jpg" alt="时序图"></p><h2 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h2><p>在 Dubbo 的核心领域模型中：</p><ul><li>Protocol 是服务域，它是 Invoker 暴露和引用的主功能入口，它负责 Invoker 的生命周期管理。</li><li>Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。</li><li>Invocation 是会话域，它持有调用过程中的变量，比如方法名，参数等。</li></ul><h2 id="基本设计原则"><a href="#基本设计原则" class="headerlink" title="基本设计原则"></a>基本设计原则</h2><ul><li>采用 Microkernel + Plugin 模式，Microkernel 只负责组装 Plugin，Dubbo 自身的功能也是通过扩展点实现的，也就是 Dubbo 的所有功能点都可被用户自定义扩展所替换。</li><li>采用 URL 作为配置信息的统一格式，所有扩展点都通过传递 URL 携带配置信息。</li></ul><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jshelllanguage">git clone https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;dubbo.git dubbo<br></code></pre></td></tr></table></figure><h2 id="简单用例分析"><a href="#简单用例分析" class="headerlink" title="简单用例分析"></a>简单用例分析</h2><p class="note note-primary">provider端</p><p>目录结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jshelllanguage">dubbo-demo-xml-provider&#x2F;src&#x2F;<br>└── main<br>    ├── java<br>    │   └── org<br>    │       └── apache<br>    │           └── dubbo<br>    │               └── demo<br>    │                   └── provider<br>    │                       ├── Application.java<br>    │                       ├── DemoServiceImpl.java<br>    │                       └── GreetingServiceImpl.java<br>    └── resources<br>        ├── dubbo.properties<br>        ├── log4j.properties<br>        └── spring<br>            └── dubbo-provider.xml<br></code></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:dubbo</span>=<span class="hljs-string">&quot;http://dubbo.apache.org/schema/dubbo&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;demo-provider&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:parameter</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;mapping-type&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;metadata&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:application</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:config-center</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;zookeeper://127.0.0.1:2181&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:metadata-report</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;zookeeper://127.0.0.1:2181&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:registry</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;registry1&quot;</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;zookeeper://127.0.0.1:2181&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;-1&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demoService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.dubbo.demo.provider.DemoServiceImpl&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;greetingService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.dubbo.demo.provider.GreetingServiceImpl&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;org.apache.dubbo.demo.DemoService&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;3000&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;demoService&quot;</span> <span class="hljs-attr">registry</span>=<span class="hljs-string">&quot;registry1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.0.0&quot;</span> <span class="hljs-attr">group</span>=<span class="hljs-string">&quot;greeting&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;5000&quot;</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;org.apache.dubbo.demo.GreetingService&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;greetingService&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>应用类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ClassPathXmlApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;spring/dubbo-provider.xml&quot;</span>);<br>        context.start();<span class="hljs-comment">//启动上下文</span><br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DemoService</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(DemoServiceImpl.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;Hello &quot;</span> + name + <span class="hljs-string">&quot;, request from consumer: &quot;</span> + RpcContext.getContext().getRemoteAddress());<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello &quot;</span> + name + <span class="hljs-string">&quot;, response from provider: &quot;</span> + RpcContext.getContext().getLocalAddress();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CompletableFuture&lt;String&gt; <span class="hljs-title">sayHelloAsync</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        CompletableFuture&lt;String&gt; cf = CompletableFuture.supplyAsync(() -&gt; &#123;<br><span class="hljs-comment">//            try &#123;</span><br><span class="hljs-comment">//                Thread.sleep(1000);</span><br><span class="hljs-comment">//            &#125; catch (InterruptedException e) &#123;</span><br><span class="hljs-comment">//                e.printStackTrace();</span><br><span class="hljs-comment">//            &#125;</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;async result&quot;</span>;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> cf;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreetingServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GreetingService</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Greetings!&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p class="note note-primary">consumer端</p><p>目录结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jshelllanguage">dubbo-demo-xml-consumer&#x2F;src&#x2F;<br>└── main<br>    ├── java<br>    │   └── org<br>    │       └── apache<br>    │           └── dubbo<br>    │               └── demo<br>    │                   └── consumer<br>    │                       └── Application.java<br>    └── resources<br>        ├── dubbo.properties<br>        ├── log4j.properties<br>        └── spring<br>            └── dubbo-consumer.xml<br></code></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:dubbo</span>=<span class="hljs-string">&quot;http://dubbo.apache.org/schema/dubbo&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;demo-consumer&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:parameter</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;mapping-type&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;metadata&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:parameter</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;enable-auto-migration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:application</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--注册地址--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:registry</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;zookeeper://127.0.0.1:2181&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--引用服务--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">provided-by</span>=<span class="hljs-string">&quot;demo-provider&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demoService&quot;</span> <span class="hljs-attr">check</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">                     <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;org.apache.dubbo.demo.DemoService&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">provided-by</span>=<span class="hljs-string">&quot;demo-provider&quot;</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.0.0&quot;</span> <span class="hljs-attr">group</span>=<span class="hljs-string">&quot;greeting&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;greetingService&quot;</span> <span class="hljs-attr">check</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">                     <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;org.apache.dubbo.demo.GreetingService&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>应用类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * In order to make sure multicast registry works, need to specify &#x27;-Djava.net.preferIPv4Stack=true&#x27; before</span><br><span class="hljs-comment">     * launch the application</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//获取服务相关信息</span><br>        ClassPathXmlApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;spring/dubbo-consumer.xml&quot;</span>);<br>        context.start();<br>        <span class="hljs-comment">//获取Service</span><br>        DemoService demoService = context.getBean(<span class="hljs-string">&quot;demoService&quot;</span>, DemoService.class);<br>        GreetingService greetingService = context.getBean(<span class="hljs-string">&quot;greetingService&quot;</span>, GreetingService.class);<br>        <span class="hljs-comment">//多线程调用</span><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-comment">//调用服务</span><br>                String greetings = greetingService.hello();<br>                System.out.println(greetings + <span class="hljs-string">&quot; from separated thread.&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>        <span class="hljs-comment">//循环调用</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            CompletableFuture&lt;String&gt; hello = demoService.sayHelloAsync(<span class="hljs-string">&quot;world&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;result: &quot;</span> + hello.get());<br><br>            String greetings = greetingService.hello();<br>            System.out.println(<span class="hljs-string">&quot;result: &quot;</span> + greetings);<br><br>            Thread.sleep(<span class="hljs-number">500</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://dubbo.apache.org/zh/docs/v2.7/">官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dubbo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch-分布式搜索和分析引擎</title>
    <link href="/2021/01/21/database/Elasticsearch-%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%92%8C%E5%88%86%E6%9E%90%E5%BC%95%E6%93%8E/"/>
    <url>/2021/01/21/database/Elasticsearch-%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%92%8C%E5%88%86%E6%9E%90%E5%BC%95%E6%93%8E/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="软件简介"><a href="#软件简介" class="headerlink" title="软件简介"></a>软件简介</h1><blockquote><p>Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。 作为 Elastic Stack 的核心。其底层是基于Lucene</p></blockquote><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p><a href="https://www.elastic.co/downloads/elasticsearch">下载软件</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jshelllanguage">curl -L -O https:&#x2F;&#x2F;artifacts.elastic.co&#x2F;downloads&#x2F;elasticsearch&#x2F;elasticsearch-7.10.2-linux-x86_64.tar.gz<br>tar -xzvf elasticsearch-7.10.2-linux-x86_64.tar.gz<br>cd elasticsearch-7.10.2<br>.&#x2F;bin&#x2F;elasticsearch<br></code></pre></td></tr></table></figure><p>华为云加速<code>wget https://mirrors.huaweicloud.com/elasticsearch/7.9.3/elasticsearch-7.9.3-linux-x86_64.tar.gz</code></p><p class="note note-danger">无法使用root启动</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">can not run elasticsearch as root<br></code></pre></td></tr></table></figure><p>1、创建用户：elasticsearch</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jshelllanguage">adduser elasticsearch<br></code></pre></td></tr></table></figure><p>2、创建用户密码，需要输入两次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jshelllanguage">passwd elasticsearch<br></code></pre></td></tr></table></figure><p>3、将对应的文件夹权限赋给该用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jshelllanguage">chown -R elasticsearch elasticsearch-6.0.0<br></code></pre></td></tr></table></figure><p>4、切换至elasticsearch用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jshelllanguage">su elasticsearch<br></code></pre></td></tr></table></figure><p>5、进入启动目录启动 /usr/local/elasticsearch-6.0.0/bin  使用后台启动方式：./elasticsearch -d</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jshelllanguage">.&#x2F;elasticsearch -d<br></code></pre></td></tr></table></figure><p>6、启动后测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jshelllanguage">curl ip:9200<br></code></pre></td></tr></table></figure><p>如果返回一个json数据说明启动成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jshelllanguage">&#123;<br>  &quot;name&quot; : &quot;mikey&quot;,<br>  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,<br>  &quot;cluster_uuid&quot; : &quot;02UVRTOaS7mSdfs2oRc43A&quot;,<br>  &quot;version&quot; : &#123;<br>    &quot;number&quot; : &quot;7.9.3&quot;,<br>    &quot;build_flavor&quot; : &quot;default&quot;,<br>    &quot;build_type&quot; : &quot;tar&quot;,<br>    &quot;build_hash&quot; : &quot;c4138e51121ef06a6404866cddc601906fe5c868&quot;,<br>    &quot;build_date&quot; : &quot;2020-10-16T10:36:16.141335Z&quot;,<br>    &quot;build_snapshot&quot; : false,<br>    &quot;lucene_version&quot; : &quot;8.6.2&quot;,<br>    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,<br>    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;<br>  &#125;,<br>  &quot;tagline&quot; : &quot;You Know, for Search&quot;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h1><blockquote><p>Kibana是一个开源分析和可视化平台，旨在与Elasticsearch合作。您可以使用Kibana来搜索、查看和交互存储在Elasticsearch索引中的数据。您可以轻松地执行高级数据分析，并在各种图表、表格和地图中可视化数据。</p></blockquote><p>下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jshelllanguage">curl -L -O https:&#x2F;&#x2F;artifacts.elastic.co&#x2F;downloads&#x2F;kibana&#x2F;kibana-7.10.2-linux-x86_64.tar.gz<br>tar xzvf kibana-7.10.2-linux-x86_64.tar.gz<br>cd kibana-7.10.2-linux-x86_64&#x2F;<br>.&#x2F;bin&#x2F;kibana<br></code></pre></td></tr></table></figure><p>华为云加速<code>wget https://mirrors.huaweicloud.com/kibana/7.9.3/kibana-7.9.3-linux-x86_64.tar.gz</code></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.elastic.co/guide/index.html">官方文档</a></p><p><a href="https://www.jianshu.com/p/d48c32423789">Elasticsearch简介与实战</a></p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搜索引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sentinel-高可用流量管理框架</title>
    <link href="/2021/01/21/microservice/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AF%87-Sentinel-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B5%81%E9%87%8F%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6/"/>
    <url>/2021/01/21/microservice/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AF%87-Sentinel-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B5%81%E9%87%8F%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="软件简介"><a href="#软件简介" class="headerlink" title="软件简介"></a>软件简介</h3><p>Sentinel 是面向分布式服务架构的高可用流量防护组件，主要以流量为切入点，从限流、流量整形、熔断降级、系统负载保护、热点防护等多个维度来帮助开发者保障微服务的稳定性。</p><p>Sentinel 具有以下特性:</p><ul><li><strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li><li><strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li><li><strong>广泛的开源生态</strong>：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</li><li><strong>完善的 SPI 扩展点</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/up-2ba39572a1e10a01ca50460f470f599905e.png" alt="Sentinel-features-overview"></p><p>Sentinel 的开源生态：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/up-f82e88eac21b9eb66b9a79af0ab0afe844b.png" alt="img"></p><h3 id="Sentinel-的历史"><a href="#Sentinel-的历史" class="headerlink" title="Sentinel 的历史"></a>Sentinel 的历史</h3><ul><li>2012 年，Sentinel 诞生，主要功能为入口流量控制。</li><li>2013-2017 年，Sentinel 在阿里巴巴集团内部迅速发展，成为基础技术模块，覆盖了所有的核心场景。Sentinel 也因此积累了大量的流量归整场景以及生产实践。</li><li>2018 年，Sentinel 开源，并持续演进。</li><li>2019 年，Sentinel 朝着多语言扩展的方向不断探索，推出 <a href="https://github.com/alibaba/sentinel-cpp">C++ 原生版本</a>，同时针对 Service Mesh 场景也推出了 <a href="https://github.com/alibaba/Sentinel/tree/master/sentinel-cluster/sentinel-cluster-server-envoy-rls">Envoy 集群流量控制支持</a>，以解决 Service Mesh 架构下多语言限流的问题。</li><li>2020 年，推出 <a href="https://github.com/alibaba/sentinel-golang">Sentinel Go 版本</a>，继续朝着云原生方向演进。</li></ul><h3 id="Sentinel-基本概念"><a href="#Sentinel-基本概念" class="headerlink" title="Sentinel 基本概念"></a>Sentinel 基本概念</h3><h4 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h4><p>资源是 Sentinel 的关键概念。它可以是 Java 应用程序中的任何内容，例如，由应用程序提供的服务，或由应用程序调用的其它应用提供的服务，甚至可以是一段代码。在接下来的文档中，我们都会用资源来描述代码块。</p><p>只要通过 Sentinel API 定义的代码，就是资源，能够被 Sentinel 保护起来。大部分情况下，可以使用方法签名，URL，甚至服务名称作为资源名来标示资源。</p><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><p>围绕资源的实时状态设定的规则，可以包括流量控制规则、熔断降级规则以及系统保护规则。所有规则可以动态实时调整。</p><h3 id="Sentinel-功能和设计理念"><a href="#Sentinel-功能和设计理念" class="headerlink" title="Sentinel 功能和设计理念"></a>Sentinel 功能和设计理念</h3><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p><strong>什么是流量控制</strong></p><p>流量控制在网络传输中是一个常用的概念，它用于调整网络包的发送数据。然而，从系统稳定性角度考虑，在处理请求的速度上，也有非常多的讲究。任意时间到来的请求往往是随机不可控的，而系统的处理能力是有限的。我们需要根据系统的处理能力对流量进行控制。Sentinel 作为一个调配器，可以根据需要把随机的请求调整成合适的形状，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/0f45bb7a3bff394ae69c041bfd3ec5afc3e.jpg" alt="img"></p><h3 id="流量控制设计理念"><a href="#流量控制设计理念" class="headerlink" title="流量控制设计理念"></a>流量控制设计理念</h3><p>流量控制有以下几个角度:</p><ul><li>资源的调用关系，例如资源的调用链路，资源和资源之间的关系；</li><li>运行指标，例如 QPS、线程池、系统负载等；</li><li>控制的效果，例如直接限流、冷启动、排队等。</li></ul><p>Sentinel 的设计理念是让您自由选择控制的角度，并进行灵活组合，从而达到想要的效果。</p><h2 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h2><h3 id="什么是熔断降级"><a href="#什么是熔断降级" class="headerlink" title="什么是熔断降级"></a>什么是熔断降级</h3><p>除了流量控制以外，及时对调用链路中的不稳定因素进行熔断也是 Sentinel 的使命之一。由于调用关系的复杂性，如果调用链路中的某个资源出现了不稳定，可能会导致请求发生堆积，进而导致级联错误。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/up-dfe09265ed95990d7cce0af62df5458918a.png" alt="img"></p><p>Sentinel 和 Hystrix 的原则是一致的: 当检测到调用链路中某个资源出现不稳定的表现，例如请求响应时间长或异常比例升高的时候，则对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联故障。</p><p><strong>熔断降级设计理念</strong></p><p>在限制的手段上，Sentinel 和 Hystrix 采取了完全不一样的方法。</p><p>Hystrix 通过 <a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works#benefits-of-thread-pools">线程池隔离</a> 的方式，来对依赖（在 Sentinel 的概念中对应 <em>资源</em>）进行了隔离。这样做的好处是资源和资源之间做到了最彻底的隔离。缺点是除了增加了线程切换的成本（过多的线程池导致线程数目过多），还需要预先给各个资源做线程池大小的分配，并且对于一些使用了 ThreadLocal 的场景来说会有问题（如 Spring 事务）。</p><p>Sentinel 对这个问题采取了两种手段:</p><ul><li>通过并发线程数进行限制</li></ul><p>和资源池隔离的方法不同，Sentinel 通过限制资源并发线程的数量，来减少不稳定资源对其它资源的影响。这样不但没有线程切换的损耗，也不需要您预先分配线程池的大小。当某个资源出现不稳定的情况下，例如响应时间变长，对资源的直接影响就是会造成线程数的逐步堆积。当线程数在特定资源上堆积到一定的数量之后，对该资源的新请求就会被拒绝。堆积的线程完成任务后才开始继续接收请求。</p><ul><li>针对慢调用和异常对资源进行降级</li></ul><p>除了对并发线程数进行控制以外，Sentinel 还可以根据响应时间和异常等不稳定因素来快速对不稳定的调用进行熔断。当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定的时间窗口之后才重新渐进式地恢复。</p><p><strong>系统自适应保护</strong></p><p>Sentinel 同时提供系统维度的自适应保护能力。防止雪崩，是系统防护中重要的一环。当系统负载较高的时候，如果还持续让请求进入，可能会导致系统崩溃，无法响应。在集群环境下，网络负载均衡会把本应这台机器承载的流量转发到其它的机器上去。如果这个时候其它的机器也处在一个边缘状态的时候，这个增加的流量就会导致这台机器也崩溃，最后导致整个集群不可用。</p><p>针对这个情况，Sentinel 提供了对应的保护机制，让系统的入口流量和系统的负载达到一个平衡，保证系统在能力范围之内处理最多的请求。</p><h3 id="Sentinel-是如何工作的"><a href="#Sentinel-是如何工作的" class="headerlink" title="Sentinel 是如何工作的"></a>Sentinel 是如何工作的</h3><p>Sentinel 的主要工作机制如下：</p><ul><li>对主流框架提供适配或者显示的 API，来定义需要保护的资源，并提供设施对资源进行实时统计和调用链路分析。</li><li>根据预设的规则，结合对资源的实时统计信息，对流量进行控制。同时，Sentinel 提供开放的接口，方便您定义及改变规则。</li><li>Sentinel 提供实时的监控系统，方便您快速了解目前系统的状态。</li></ul>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sentinel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>麻省理工·哈佛大学-虚拟大脑 思想与机器</title>
    <link href="/2021/01/19/machine/%E8%99%9A%E6%8B%9F%E5%A4%A7%E8%84%91-%E6%80%9D%E6%83%B3%E4%B8%8E%E6%9C%BA%E5%99%A8-Summer-Course-2020/"/>
    <url>/2021/01/19/machine/%E8%99%9A%E6%8B%9F%E5%A4%A7%E8%84%91-%E6%80%9D%E6%83%B3%E4%B8%8E%E6%9C%BA%E5%99%A8-Summer-Course-2020/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="BMM-Virtual-Summer-Course-2020-Introduction"><a href="#BMM-Virtual-Summer-Course-2020-Introduction" class="headerlink" title="BMM Virtual Summer Course 2020 Introduction"></a>BMM Virtual Summer Course 2020 Introduction</h1><h1 id="Reverse-engineering-visual-object-recognition"><a href="#Reverse-engineering-visual-object-recognition" class="headerlink" title="Reverse engineering visual object recognition"></a>Reverse engineering visual object recognition</h1><h1 id="Using-population-decoding-to-understand-neural-content-and-coding"><a href="#Using-population-decoding-to-understand-neural-content-and-coding" class="headerlink" title="Using population decoding to understand neural content and coding"></a>Using population decoding to understand neural content and coding</h1><h1 id="Panel-Discussion-Hilbert-questions-in-AI"><a href="#Panel-Discussion-Hilbert-questions-in-AI" class="headerlink" title="Panel Discussion - Hilbert questions in AI"></a>Panel Discussion - Hilbert questions in AI</h1><h1 id="Relating-the-structure-of-the-brain-to-its-function-by-tracking-a-net-wave-of"><a href="#Relating-the-structure-of-the-brain-to-its-function-by-tracking-a-net-wave-of" class="headerlink" title="Relating the structure of the brain to its function by tracking a net-wave of"></a>Relating the structure of the brain to its function by tracking a net-wave of</h1><h1 id="Adversarial-Examples-and-Human-ML-Alignment"><a href="#Adversarial-Examples-and-Human-ML-Alignment" class="headerlink" title="Adversarial Examples and Human-ML Alignment"></a>Adversarial Examples and Human-ML Alignment</h1><h1 id="Recurrent-computations-to-the-rescue"><a href="#Recurrent-computations-to-the-rescue" class="headerlink" title="Recurrent computations to the rescue"></a>Recurrent computations to the rescue</h1><h1 id="Dynamics-and-Generalization-in-deep-neural-networks"><a href="#Dynamics-and-Generalization-in-deep-neural-networks" class="headerlink" title="Dynamics and Generalization in deep neural networks"></a>Dynamics and Generalization in deep neural networks</h1><h1 id="From-Zero-to-CNNs-to-Brains"><a href="#From-Zero-to-CNNs-to-Brains" class="headerlink" title="From Zero to CNNs to Brains"></a>From Zero to CNNs to Brains</h1><h1 id="Panel-Discussion-What-is-the-relationship-between-biological-brains-and-AI"><a href="#Panel-Discussion-What-is-the-relationship-between-biological-brains-and-AI" class="headerlink" title="Panel Discussion - What is the relationship between biological brains and AI"></a>Panel Discussion - What is the relationship between biological brains and AI</h1><h1 id="Grounding-language-acquisition"><a href="#Grounding-language-acquisition" class="headerlink" title="Grounding language acquisition"></a>Grounding language acquisition</h1><h1 id="Language-amp-Vision"><a href="#Language-amp-Vision" class="headerlink" title="Language &amp; Vision"></a>Language &amp; Vision</h1><h1 id="Reverse-engineering-common-sense"><a href="#Reverse-engineering-common-sense" class="headerlink" title="Reverse engineering common sense"></a>Reverse engineering common sense</h1><h1 id="Learning-from-Biased-Data"><a href="#Learning-from-Biased-Data" class="headerlink" title="Learning from Biased Data"></a>Learning from Biased Data</h1><h1 id="Is-there-anything-special-about-human-intelligence-vs-non-human-animals"><a href="#Is-there-anything-special-about-human-intelligence-vs-non-human-animals" class="headerlink" title="Is there anything special about human intelligence_ (vs. non-human animals,"></a>Is there anything special about human intelligence_ (vs. non-human animals,</h1><h1 id="Neural-Representations-of-Categories"><a href="#Neural-Representations-of-Categories" class="headerlink" title="Neural Representations of Categories"></a>Neural Representations of Categories</h1><h1 id="Language-in-the-Brain"><a href="#Language-in-the-Brain" class="headerlink" title="Language in the Brain"></a>Language in the Brain</h1><h1 id="Towards-Complex-Language-in-Partially-Observed-Environments"><a href="#Towards-Complex-Language-in-Partially-Observed-Environments" class="headerlink" title="Towards Complex Language in Partially Observed Environments"></a>Towards Complex Language in Partially Observed Environments</h1><h1 id="Doing-for-our-robots-what-nature-did-for-us"><a href="#Doing-for-our-robots-what-nature-did-for-us" class="headerlink" title="Doing for our robots what nature did for us"></a>Doing for our robots what nature did for us</h1><h1 id="Toward-Brain-Computer-Interface-Deep-Generative-Models-for-Brain-Reading"><a href="#Toward-Brain-Computer-Interface-Deep-Generative-Models-for-Brain-Reading" class="headerlink" title="Toward Brain Computer Interface - Deep Generative Models for Brain Reading"></a>Toward Brain Computer Interface - Deep Generative Models for Brain Reading</h1><h1 id="Hippocampal-mechanisms-of-memory-and-cognition"><a href="#Hippocampal-mechanisms-of-memory-and-cognition" class="headerlink" title="Hippocampal mechanisms of memory and cognition"></a>Hippocampal mechanisms of memory and cognition</h1><h1 id="CBMM-Alumni-Panel"><a href="#CBMM-Alumni-Panel" class="headerlink" title="CBMM Alumni Panel"></a>CBMM Alumni Panel</h1><h1 id="The-quest-for-provably-efficient-ML-algorithms"><a href="#The-quest-for-provably-efficient-ML-algorithms" class="headerlink" title="The quest for provably efficient ML algorithms"></a>The quest for provably efficient ML algorithms</h1><h1 id="Understanding-Auditory-Cortical-Computation"><a href="#Understanding-Auditory-Cortical-Computation" class="headerlink" title="Understanding Auditory Cortical Computation"></a>Understanding Auditory Cortical Computation</h1><h1 id="Perceptual-invariance-in-Humans-and-Machines"><a href="#Perceptual-invariance-in-Humans-and-Machines" class="headerlink" title="Perceptual invariance in Humans and Machines"></a>Perceptual invariance in Humans and Machines</h1><h1 id="Functional-Specificity-in-the-Human-Brain-What-Whether-and-Why"><a href="#Functional-Specificity-in-the-Human-Brain-What-Whether-and-Why" class="headerlink" title="Functional Specificity in the Human Brain - What, Whether, and Why"></a>Functional Specificity in the Human Brain - What, Whether, and Why</h1><h1 id="How-did-you-learn-the-natural-numbers"><a href="#How-did-you-learn-the-natural-numbers" class="headerlink" title="How did you learn the natural numbers"></a>How did you learn the natural numbers</h1><h1 id="related-data"><a href="#related-data" class="headerlink" title="related data"></a>related data</h1><p><a href="https://www.bilibili.com/video/BV1Dz4y1U7PF">video course</a></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>虚拟大脑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库篇-SQL之COUNT函数详解</title>
    <link href="/2021/01/11/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87-SQL%E4%B9%8BCOUNT%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/01/11/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87-SQL%E4%B9%8BCOUNT%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="COUNT-函数用法"><a href="#COUNT-函数用法" class="headerlink" title="COUNT 函数用法"></a>COUNT 函数用法</h1><blockquote><p>COUNT() 函数返回匹配指定条件的行数。</p></blockquote><p class="note note-primary">   SQL COUNT(column_name) 语法 </p><blockquote><p>COUNT(column_name) 函数返回指定列的值的数目（<code>NULL 不计入</code>）：</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(column_name) <span class="hljs-keyword">FROM</span> table_name;<br></code></pre></td></tr></table></figure><p class="note note-primary">   SQL COUNT(*) 语法</p><blockquote><p>COUNT(*) 函数返回表中的记录数：</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">FROM</span> table_name;<br></code></pre></td></tr></table></figure><p class="note note-primary">   SQL COUNT(DISTINCT column_name) 语法 </p><blockquote><p>COUNT(DISTINCT column_name) 函数返回指定列的不同值的数目：</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> column_name) <span class="hljs-keyword">FROM</span> table_name;<br></code></pre></td></tr></table></figure><p>注释：<code>COUNT(DISTINCT) 适用于 ORACLE 和 Microsoft SQL Server，但是无法用于 Microsoft Access。</code></p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><blockquote><p>COUNT(常量) 和 COUNT(*)表示的是直接查询符合条件的数据库表的行数。而COUNT(列名)表示的是查询符合条件的列的值不为NULL的行数。</p></blockquote><h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">count(*)和count(1)执行的效率是完全一样的。<br>count(*)的执行效率比count(col)高，因此可以用count(*)的时候就不要去用count(col)。<br>count(col)的执行效率比count(distinct col)高，不过这个结论的意义不大，这两种方法也是看需要去用。<br>如果是对特定的列做count的话建立这个列的非聚集索引能对count有很大的帮助。<br>如果经常count(*)的话则可以找一个最小的col建立非聚集索引以避免全表扫描而影响整体性能。<br>在不加WHERE限制条件的情况下，COUNT(*)与COUNT(COL)基本可以认为是等价的；<br>但是在有WHERE限制条件的情况下，COUNT(*)会比COUNT(COL)快非常多；<br>count(0)=count(1)=count(*)<br>1. count(指定的有效值)--执行计划都会转化为count(*)<br>2. 如果指定的是列名，会判断是否有null，null不计算<br></code></pre></td></tr></table></figure><h1 id="COUNT常见问题"><a href="#COUNT常见问题" class="headerlink" title="COUNT常见问题"></a>COUNT常见问题</h1><p>1、COUNT有几种用法？</p><p>2、COUNT(字段名)和COUNT(*)的查询结果有什么不同？</p><p>3、COUNT(1)和COUNT(*)之间有什么不同？</p><p>4、COUNT(1)和COUNT(*)之间的效率哪个更高？</p><p>5、为什么《阿里巴巴Java开发手册》建议使用COUNT(*)</p><p>6、MySQL的MyISAM引擎对COUNT(*)做了哪些优化？</p><p>7、MySQL的InnoDB引擎对COUNT(*)做了哪些优化？</p><p>8、上面提到的MySQL对COUNT(*)做的优化，有一个关键的前提是什么？</p><p>9、SELECT COUNT(*) 的时候，加不加where条件有差别吗？</p><p>10、COUNT(*)、COUNT(1)和COUNT(字段名)的执行过程是怎样的？</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>聚合函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wireshark使用教程</title>
    <link href="/2021/01/09/tool/Wireshark%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <url>/2021/01/09/tool/Wireshark%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="工具简介"><a href="#工具简介" class="headerlink" title="工具简介"></a>工具简介</h1><p>Wireshark是一个网络数据包分析器。网络包分析器尽可能详细地呈现捕获的包数据。<br>你可以把网络数据包分析仪想象成一个测量设备，用来检测网络电缆内部发生的事情，就像电工用伏特计检测电缆内部发生的事情一样（当然是在更高的层次上）。<br>在过去，这些工具要么非常昂贵，要么是专有的，要么两者兼而有之。然而，随着Wireshark的出现，情况发生了变化。Wireshark是免费的，是开源的，是当今最好的数据包分析器之一。</p><h1 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h1><p>环境 <code>Ubuntu18.04</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install wireshark<br></code></pre></td></tr></table></figure><p>启动缺少权限</p><p class="note note-danger">    wireshark:Couldn't run /usr/bin/dumpcap in child process: Permission denied</p><p>解决方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install libcap2-bin wireshark<br>sudo chgrp myusername /usr/bin/dumpcap<br>sudo chmod 750 /usr/bin/dumpcap<br>sudo setcap cap_net_raw,cap_net_admin+eip /usr/bin/dumpcap<br></code></pre></td></tr></table></figure><h1 id="上手使用"><a href="#上手使用" class="headerlink" title="上手使用"></a>上手使用</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/wireshark-cat.png" alt="功能详解"></p><h1 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h1><p>（1）Frame:   物理层的数据帧概况</p><p>（2）Ethernet II: 数据链路层以太网帧头部信息</p><p>（3）Internet Protocol Version 4: 互联网层IP包头部信息</p><p>（4）Transmission Control Protocol:  传输层T的数据段头部信息，此处是TCP</p><p>（5）Hypertext Transfer Protocol:  应用层的信息，此处是HTTP协议</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.wireshark.org/docs/wsug_html_chunked/">Wireshark User’s Guide</a></p><p><a href="https://www.cnblogs.com/mq0036/p/11187138.html">wireshark抓包新手使用教程</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Wireshark</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牛顿迭代法求平方根</title>
    <link href="/2021/01/08/algorithm/%E7%AE%97%E6%B3%95%E7%AF%87-%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9/"/>
    <url>/2021/01/08/algorithm/%E7%AE%97%E6%B3%95%E7%AF%87-%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p class="note note-primary">    牛顿迭代法（Newton's method）又称为牛顿-拉夫逊（拉弗森）方法（Newton-Raphson method），它是牛顿在17世纪提出的一种在实数域和复数域上近似求解方程的方法。</p><p>联系知识</p><p class="note note-primary">    泰勒公式:泰勒公式是一个用函数在某点的信息描述其附近取值的公式。如果函数足够平滑的话，在已知函数在某一点的各阶导数值的情况之下，泰勒公式可以用这些导数值做系数构建一个多项式来近似函数在这一点的邻域中的值。</p><p>公式 = <code>f(x)=f(x0)+f&#39;(x0)*(x-x0)+f&#39;&#39;(x0)/2!*(x-x0)^2+...+f(n)(x0)/n!*(x-x0)^n</code></p><p>$$f(x)=\sum_{i=0}^\infty\frac{f^n(a)}{n!}{(x-a)}^n$$</p><p>f(n)(x.)是f(x.)的n阶导数</p><h1 id="具体内容"><a href="#具体内容" class="headerlink" title="具体内容"></a>具体内容</h1><p class="note note-primary">    其采用一阶泰勒展开，f(x) = 0,求 x = ? </p><p>$$f(x)=f(x_0)+(x-x_0)f’(x_0)$$</p><p>$$x=x_0-\frac{f(x_0)}{f’(x_0)}$$</p><p>$$x_{n+1}=x_n-\frac{f(x_n)}{f’(x_n)}$$</p><h1 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h1><p class="note note-primary">    求x平方根？</p><p>$$\sqrt{x}$$<br>$$y=\sqrt{x}$$<br>$$y^2=x$$<br>$$y^2-x=0$$</p><p>令 $$y_0=x$$<br>则 $$y_{n+1}=y_n-\frac{f(y_n)}{f’(y_n)}=y_n-\frac{y_n^2-x}{2y_n}=\frac{y_n^2+x}{2y_n}=\frac{y_n+\frac{x}{y_n}}{2}$$</p><p class="note note-primary">    求三次方根？</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>Java实现开平方的牛顿迭代法. 求c(c&gt;0)的算术平方根就是求 $$f(x) = x^2-c$$ 的正根,<br>得迭代公式: $$x_{n+1}=\frac{1}{2}(x_n+\frac{c}{x_n})$$<br>代码中取初始值 c , 误差控制在 $$ 1*10^{-15} $$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(<span class="hljs-keyword">double</span> c)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> Double.NaN;<br>        <span class="hljs-keyword">double</span> e = <span class="hljs-number">1e-15</span>;<br>        <span class="hljs-keyword">double</span> x = c;<br>        <span class="hljs-keyword">double</span> y = (x + c / x) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (Math.abs(x - y) &gt; e) &#123;<br>            x = y;<br>            y = (x + c / x) / <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.matongxue.com/madocs/205/">如何通俗易懂地讲解牛顿迭代法？</a></p><p><a href="https://blog.csdn.net/ethmery/article/details/50670297">基本数学公式语法(of MathJax)</a></p><p><a href="https://www.mobibrw.com/2020/23324">牛顿迭代法</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>求平方根</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么DNS使用UDP而不是TCP</title>
    <link href="/2021/01/06/reference/%E4%B8%BA%E4%BB%80%E4%B9%88DNS%E4%BD%BF%E7%94%A8UDP%E8%80%8C%E4%B8%8D%E6%98%AFTCP/"/>
    <url>/2021/01/06/reference/%E4%B8%BA%E4%BB%80%E4%B9%88DNS%E4%BD%BF%E7%94%A8UDP%E8%80%8C%E4%B8%8D%E6%98%AFTCP/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="为什么DNS使用UDP而不是TCP"><a href="#为什么DNS使用UDP而不是TCP" class="headerlink" title="为什么DNS使用UDP而不是TCP"></a>为什么DNS使用UDP而不是TCP</h2><p>DNS在进行区域传输的时候使用TCP，普通的查询使用UDP。为什么查询是使用UDP呢？网络上大部分答案都说UDP性能更好，打开网页速度快。如果是这样的话，为什么HTTP却是使用TCP呢？</p><p class="note note-primary">    衡量计算机通信快慢的指标是“响应时间”，即从用户发出通信指令（输入网址敲回车键）开始，到用户看到完整页面为止，所流逝的时间。</p><h1 id="响应时间（ResponseTime）"><a href="#响应时间（ResponseTime）" class="headerlink" title="响应时间（ResponseTime）"></a>响应时间（ResponseTime）</h1><p>以浏览器为例，这个响应时间大体分为三部分：</p><p><code>响应时间</code>= <code>DNS域名解析时间</code> + <code>TCP 连接建立时间</code> + <code>HTTP交易时间</code></p><p>如果让响应时间尽可能小，只有让等号右侧的三者尽可能小。TCP连接是固定的三次握手，所以很难有进一步缩小的空间。HTTP交易，基于Request / Response，也很难有提升的空间。 所以，只能让DNS域名解析的时间越小越好。</p><h1 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h1><ul><li><p>采用TCP传输，则域名解析时间为：  <code>DNS域名解析时间</code> = <code>TCP连接时间</code> + <code>DNS交易时间</code></p></li><li><p>采用UDP传输，则域名解析时间为：  <code>DNS域名解析时间</code> = <code>DNS交易时间</code></p></li></ul><p class="note note-danger">  很显然，采用UDP传输，DNS域名解析时间更小  </p><h1 id="不就多一次TCP连接时间吗？"><a href="#不就多一次TCP连接时间吗？" class="headerlink" title="不就多一次TCP连接时间吗？"></a>不就多一次TCP连接时间吗？</h1><p>NO!</p><p>在很多时候，用户在访问一些冷门网站时，由于DNS服务器没有冷门网站的解析缓存，需要到域名根服务器、一级域名服务器、二级域名服务器迭代查询，直到查询到冷门网站的权威服务器，这中间可能涉及到多次的查询。 如果使用TCP传输，多几次查询，就多几次TCP连接时间，这多出来的时间不容小觑。</p><h1 id="UDP传输的弱点"><a href="#UDP传输的弱点" class="headerlink" title="UDP传输的弱点"></a>UDP传输的弱点</h1><p>由于历史的原因，互联网上物理链路的最小MTU = 576，基于UDP传输的DNS为了限制报文不超过576，所以将DNS报文限制在512字节。</p><p>这样一旦DNS查询应答超过512字节，基于UDP的DNS就只有截短为512字节，那么用户得到的DNS应答就是不完整的。</p><p>为了克服这种困难，最简单的方式就是使用TCP，来重新查询。尽管交易时间可能比较长，但毕竟可以得到完整的答案，总比得到不完整的答案要好。</p><h2 id="难道UDP没有办法传输超过大于576字节的数据吗？"><a href="#难道UDP没有办法传输超过大于576字节的数据吗？" class="headerlink" title="难道UDP没有办法传输超过大于576字节的数据吗？"></a>难道UDP没有办法传输超过大于576字节的数据吗？</h2><p>并不是这样。</p><p>DNS是由于自身的限制，原因上述文字已经解释。</p><p>当基于UDP传输的DNS有1000字节需要传输时，会将1000字节砍成两个500字节的报文传输？</p><p>不会！只会保留前面的512字节，剩下的488字节会抛弃！</p><h2 id="为什么要这样？"><a href="#为什么要这样？" class="headerlink" title="为什么要这样？"></a>为什么要这样？</h2><p>DNS没有字段来标识报文ID，比如1、2、3，所以默认只有一个报文，剩下的多余数据只有被扔的份！</p><h1 id="互联网的不安全性"><a href="#互联网的不安全性" class="headerlink" title="互联网的不安全性"></a>互联网的不安全性</h1><p>互联网经过多年的发展，鱼龙混杂，欺骗横行，用户的域名服务器是8.8.8.8，用户能够拍着胸脯说，从8.8.8.8返回的DNS应答真的就是8.8.8.8回答的吗?</p><p>不能！</p><p>无论是采用UDP、还是TCP传输，都无法保证！</p><h2 id="怎么办呢？"><a href="#怎么办呢？" class="headerlink" title="怎么办呢？"></a>怎么办呢？</h2><p>如果8.8.8.8 返回的应答，使用自己的私钥签名，那么主机得到应答之后，先检查签名是否来自于8.8.8.8的签名，如果是，接收。如果不是，拒绝！</p><p>这样是不是就可以拍着胸脯说，应答真的是来自于8.8.8.8。但签名带来了很多负面问题，DNS应答由于携带了证书链，整个报文有几千字节，无法使用UDP传输，那也只好使用TCP传输了。</p><h1 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h1><ul><li>使用UDP传输是由于效率高，传输小于等于512字节报文。</li><li>使用TCP传输是由于可以传输大于512字节报文。</li><li>使用签名是保证数据来源的可靠性。</li><li>使用TCP传输，同样是可以传输证书链、签名。</li><li>使用UDP同样可以传输远远大于576字节的数据，只要应用程序可以标识数据ID。 </li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DNS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Coding for Distributed Storage Systems - 微软研究院</title>
    <link href="/2021/01/02/note/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A0%81/"/>
    <url>/2021/01/02/note/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="现代分布式存储系统的编码一"><a href="#现代分布式存储系统的编码一" class="headerlink" title="现代分布式存储系统的编码一"></a>现代分布式存储系统的编码一</h1><h1 id="现代分布式存储系统的编码二"><a href="#现代分布式存储系统的编码二" class="headerlink" title="现代分布式存储系统的编码二"></a>现代分布式存储系统的编码二</h1><h1 id="现代分布式存储系统的编码三"><a href="#现代分布式存储系统的编码三" class="headerlink" title="现代分布式存储系统的编码三"></a>现代分布式存储系统的编码三</h1><h1 id="现代分布式存储系统的编码四"><a href="#现代分布式存储系统的编码四" class="headerlink" title="现代分布式存储系统的编码四"></a>现代分布式存储系统的编码四</h1><h1 id="网络偏好：方向和开放问题"><a href="#网络偏好：方向和开放问题" class="headerlink" title="网络偏好：方向和开放问题"></a>网络偏好：方向和开放问题</h1><h1 id="Alex-Dimakis-A-Friendly-Introduction-To-Causality-MLconf-SF-2016"><a href="#Alex-Dimakis-A-Friendly-Introduction-To-Causality-MLconf-SF-2016" class="headerlink" title="Alex Dimakis - A Friendly Introduction To Causality - MLconf SF 2016"></a>Alex Dimakis - A Friendly Introduction To Causality - MLconf SF 2016</h1><h1 id="针对大型分布式系统的代码搽除问题"><a href="#针对大型分布式系统的代码搽除问题" class="headerlink" title="针对大型分布式系统的代码搽除问题"></a>针对大型分布式系统的代码搽除问题</h1><h1 id="Restricted-Strong-Convexity-Implies-Weak-Submodularity-Alex-Dimakis"><a href="#Restricted-Strong-Convexity-Implies-Weak-Submodularity-Alex-Dimakis" class="headerlink" title="Restricted Strong Convexity Implies Weak Submodularity, Alex Dimakis"></a>Restricted Strong Convexity Implies Weak Submodularity, Alex Dimakis</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1aX4y1T7yg">微软研究院-分布式存储系统编码 Coding for Distributed Storage Systems（中文字幕）</a></p>]]></content>
    
    
    <categories>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式存储系统编码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS篇-分布式系统(麻省理工大学)</title>
    <link href="/2021/01/02/os/OS%E7%AF%87-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F(%E9%BA%BB%E7%9C%81%E7%90%86%E5%B7%A5%E5%A4%A7%E5%AD%A6)/"/>
    <url>/2021/01/02/os/OS%E7%AF%87-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F(%E9%BA%BB%E7%9C%81%E7%90%86%E5%B7%A5%E5%A4%A7%E5%AD%A6)/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h1 id="RPC-and-Threads"><a href="#RPC-and-Threads" class="headerlink" title="RPC and Threads"></a>RPC and Threads</h1><h1 id="GFS"><a href="#GFS" class="headerlink" title="GFS"></a>GFS</h1><h1 id="Primary-Backup-Replication"><a href="#Primary-Backup-Replication" class="headerlink" title="Primary-Backup Replication"></a>Primary-Backup Replication</h1><h1 id="Go-Threads-and-Raft"><a href="#Go-Threads-and-Raft" class="headerlink" title="Go, Threads, and Raft"></a>Go, Threads, and Raft</h1><h1 id="Fault-Tolerance-Raft-1"><a href="#Fault-Tolerance-Raft-1" class="headerlink" title="Fault Tolerance - Raft (1)"></a>Fault Tolerance - Raft (1)</h1><h1 id="Fault-Tolerance-Raft-2"><a href="#Fault-Tolerance-Raft-2" class="headerlink" title="Fault Tolerance - Raft (2)"></a>Fault Tolerance - Raft (2)</h1><h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h1><h1 id="More-Replication-CRAQ"><a href="#More-Replication-CRAQ" class="headerlink" title="More Replication, CRAQ"></a>More Replication, CRAQ</h1><h1 id="Cloud-Replicated-DB-Aurora"><a href="#Cloud-Replicated-DB-Aurora" class="headerlink" title="Cloud Replicated DB, Aurora"></a>Cloud Replicated DB, Aurora</h1><h1 id="Cache-Consistency-Frangipani"><a href="#Cache-Consistency-Frangipani" class="headerlink" title="Cache Consistency - Frangipani"></a>Cache Consistency - Frangipani</h1><h1 id="Distributed-Transactions"><a href="#Distributed-Transactions" class="headerlink" title="Distributed Transactions"></a>Distributed Transactions</h1><h1 id="Spanner"><a href="#Spanner" class="headerlink" title="Spanner"></a>Spanner</h1><h1 id="Optimistic-Concurrency-Control"><a href="#Optimistic-Concurrency-Control" class="headerlink" title="Optimistic Concurrency Control"></a>Optimistic Concurrency Control</h1><h1 id="Big-Data-Spark"><a href="#Big-Data-Spark" class="headerlink" title="Big Data - Spark"></a>Big Data - Spark</h1><h1 id="Cache-Consistency-Memcached-at-Facebook"><a href="#Cache-Consistency-Memcached-at-Facebook" class="headerlink" title="Cache Consistency - Memcached at Facebook"></a>Cache Consistency - Memcached at Facebook</h1><h1 id="COPS-Causal-Consistency"><a href="#COPS-Causal-Consistency" class="headerlink" title="COPS, Causal Consistency"></a>COPS, Causal Consistency</h1><h1 id="Fork-Consistency-Certificate-Transparency"><a href="#Fork-Consistency-Certificate-Transparency" class="headerlink" title="Fork Consistency, Certificate Transparency"></a>Fork Consistency, Certificate Transparency</h1><h1 id="Bitcoin"><a href="#Bitcoin" class="headerlink" title="Bitcoin"></a>Bitcoin</h1><h1 id="Bitcoin-1"><a href="#Bitcoin-1" class="headerlink" title="Bitcoin"></a>Bitcoin</h1><h1 id="Blockstack"><a href="#Blockstack" class="headerlink" title="Blockstack"></a>Blockstack</h1><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p><a href="https://www.bilibili.com/video/BV1rp4y1k7nL/?spm_id_from=333.788.recommend_more_video.17">麻省理工学院-分布式系统 || Distributed Systems (中字幕)MIT2020年</a></p>]]></content>
    
    
    <categories>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习与强化学习-伦敦大学</title>
    <link href="/2021/01/02/machine/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E4%BC%A6%E6%95%A6%E5%A4%A7%E5%AD%A6/"/>
    <url>/2021/01/02/machine/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E4%BC%A6%E6%95%A6%E5%A4%A7%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="基于机器学习的ai简介"><a href="#基于机器学习的ai简介" class="headerlink" title="基于机器学习的ai简介"></a>基于机器学习的ai简介</h1><h1 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a>TensorFlow</h1><h1 id="神经网络基础"><a href="#神经网络基础" class="headerlink" title="神经网络基础"></a>神经网络基础</h1><h1 id="强化学习简介"><a href="#强化学习简介" class="headerlink" title="强化学习简介"></a>强化学习简介</h1><h1 id="探索与开发"><a href="#探索与开发" class="headerlink" title="探索与开发"></a>探索与开发</h1><h1 id="马尔可夫决策与动态"><a href="#马尔可夫决策与动态" class="headerlink" title="马尔可夫决策与动态"></a>马尔可夫决策与动态</h1><h1 id="无模型的检测与控制"><a href="#无模型的检测与控制" class="headerlink" title="无模型的检测与控制"></a>无模型的检测与控制</h1><h1 id="超越图像识别"><a href="#超越图像识别" class="headerlink" title="超越图像识别"></a>超越图像识别</h1><h1 id="功能近似与深度强化学习"><a href="#功能近似与深度强化学习" class="headerlink" title="功能近似与深度强化学习"></a>功能近似与深度强化学习</h1><h1 id="Policy-Gradients-and-Actor-Critics"><a href="#Policy-Gradients-and-Actor-Critics" class="headerlink" title="Policy Gradients and Actor Critics"></a>Policy Gradients and Actor Critics</h1><h1 id="机器学习优化"><a href="#机器学习优化" class="headerlink" title="机器学习优化"></a>机器学习优化</h1><h1 id="计划模型"><a href="#计划模型" class="headerlink" title="计划模型"></a>计划模型</h1><h1 id="NLP"><a href="#NLP" class="headerlink" title="NLP"></a>NLP</h1><h1 id="高级主题"><a href="#高级主题" class="headerlink" title="高级主题"></a>高级主题</h1><h1 id="Attention-and-Memory-in-Deep-Learning"><a href="#Attention-and-Memory-in-Deep-Learning" class="headerlink" title="Attention and Memory in Deep Learning"></a>Attention and Memory in Deep Learning</h1><h1 id="RL简析"><a href="#RL简析" class="headerlink" title="RL简析"></a>RL简析</h1><h1 id="经典游戏案例简析"><a href="#经典游戏案例简析" class="headerlink" title="经典游戏案例简析"></a>经典游戏案例简析</h1><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p><a href="https://www.bilibili.com/video/BV1ba4y1n7ZQ">深度学习与强化学习 Advanced Deep Learning &amp; Reinforcement Learning</a></p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习,强化学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020-年终总结</title>
    <link href="/2020/12/30/another/%E5%85%B6%E4%BB%96%E7%AF%87-2020-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <url>/2020/12/30/another/%E5%85%B6%E4%BB%96%E7%AF%87-2020-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="总结前言"><a href="#总结前言" class="headerlink" title="总结前言"></a>总结前言</h1><blockquote><p>今年因为疫情原因，开学一拖再拖推迟到了四月份，还没开学就要放假了，所以今年暑假直接留下和老师做项目了。在学校的日子多多少少经历过一些事情，做一些总结吧。</p></blockquote><h1 id="学习方面"><a href="#学习方面" class="headerlink" title="学习方面"></a>学习方面</h1><blockquote><p>以前总觉得多学一些，扩充知识面，把大量时间浪费在框架上，只是熟悉其使用，殊不知基础更为重要。但是也不能一味地的啃，要将其运用起来，才可领悟其原理，<code>学习相关技术知识时要建立自己的知识体系结构，别人写的再好那也是别人的思维，将其转化为自己的，做博客记录，方便自己回过头来快速唤醒。</code><br>多看一些优秀的文章，逛逛论坛，和技术大牛交流可以提高认知广度和深度。</p></blockquote><h1 id="工作方面"><a href="#工作方面" class="headerlink" title="工作方面"></a>工作方面</h1><blockquote><p>一回到学校没多久老师就开始布置项目任务了，有两个系统是给学校招生办使用的，另外我还维护一个之前的项目，事情确实忙起来还是挺多的也感觉很充实。但是我已经厌倦了这些CMS的开发，一心想早点做完去多了解一些其他东西，包括比赛这一年我参加的比赛也很少，主要还是想把精力集中在技术的积累上，<br>参加的话基本上就是挂个名，还是很感谢我的一位好伙伴H承担了组长的角色，带躺我。从大一加入学校软件开发中心开始两个就一起学习，然后一起开发项目，一起写BUG，期间也发生了一些矛盾，后面也得到解决。</p></blockquote><blockquote><p>转眼间大学四年就要过去了、匆匆忙忙赶完毕业论文我就开始找工作了。<code>多吸取先人的意见、可以避免走很多弯路</code>，早在大二的时候老师H在课上就要求我们注重算法、数据结构、叫我们多刷题。每当上他的课他都会讲一算法道题，一个学期下来也讲解了一些，可是我没能坚持下来。到了校招笔试的时候无从下手<br>才着手刷，直到差不多十二月份才算系统性的学过。在秋季学期我基本上就是写论文和找工作，前前后后投了很多公司，大中厂的笔试多数没过，第一次面的是360的后端开发，面试官很不错意识到我基础薄弱给了我很多建议，但是面试结果也就自然的挂了。经过这次面试让我意识到我的薄弱之处，开始进行复盘，<br>后面又投了好多家，前前后后收到了六七个offer但感觉不太符合我想走的方向，后面也不了了之，但是有家深圳公司两次打电话希望我去，先是Hr打电话来后面技术领导主动打电话来，经过详细沟通后我还是拒绝了，技术领导非常NICE，还问我想去哪家公司如果他有熟人可以帮忙内推，确实非常感谢。后来得知<br>当初技术领导面试时我说道我未来希望往架构师方向发展，他对我较为感兴趣。</p></blockquote><blockquote><p>十一月份的参加一家公司笔试，个人感觉也不是很理想，编程题是TopK问题，而我采用排序，时间复杂度太高，说到底还是刷的太少。一面时不知道是面试官电话问题还是我的问题，时不时听不到对方声音，没有得到很好的发挥。二面的技术领导一看就是大佬和让我说说项目，然后我就把在开发中心做的一个区块链<br>项目拿来说了，为什么说这个项目呢，因为这个项目是我投入时间精力最大的一个项目，<code>在说项目时一定要对其进行准备，干练的说出要点，采用的技术、难点在哪里、如何解决</code>从当初初始区块链，再到后面区块链网络的搭建，再加上本身其不成熟。我把我前前后后学习过程，遇到的问题都描述出，面试管很NICE，<br>后面再问一些补充问题就结束了。HR面的面试官在我说出期望薪资后可能惊了一下，问我为什么报这个价位，我说因为其他offer好像都是这个价位，后面我反问了了加班情况，再后面就是测评和签三方了。</p></blockquote><h1 id="其他方面"><a href="#其他方面" class="headerlink" title="其他方面"></a>其他方面</h1><ul><li>如果你的亲人是普通阶层，那对于人生中一些大事来说，他们给的建议往往就是普通阶层的思维，他们的阶层就是他们一生思维决策的结果，如果你的目标是跳出本阶层，那最好只把他们的建议当成参考。</li><li>在做事情前一定要考虑后果，不要一时冲动，造成不可挽回的损失。</li></ul><h1 id="未来方向"><a href="#未来方向" class="headerlink" title="未来方向"></a>未来方向</h1><ul><li>恶补专业基础知识，积累技术</li></ul>]]></content>
    
    
    <categories>
      
      <category>个人总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习-深度学习入门资料汇总</title>
    <link href="/2020/12/29/machine/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/"/>
    <url>/2020/12/29/machine/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="机器学习-深度学习入门资料汇总"><a href="#机器学习-深度学习入门资料汇总" class="headerlink" title="机器学习/深度学习入门资料汇总"></a>机器学习/深度学习入门资料汇总</h1><p>经常被同学和朋友询问机器学习或深度学习入门，有哪些不错的参考资料。老实讲，这个问题在网上随便一搜就是一大把的答案。我自己在最开始的时候也有同样的困惑，同样在搜索引擎和论坛里翻找答案。但大多数答案并不怎么让人满意：搜索结果要么星稀零散，只见树木不见森林；要么过于详尽，让人无从下手（很多资料作者自己都没看过）。<br>在这篇文章里，我把自己在学习过程中的参考资料进行了梳理。一方面，希望能给你一个相对系统的学习路线参考；另一方面，自己真实的实践经历，遇过坎，掉过坑，希望能给正准备入门的同学更多真实的借鉴。</p><h2 id="入门视频"><a href="#入门视频" class="headerlink" title="入门视频"></a><strong>入门视频</strong></h2><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a><strong>机器学习</strong></h2><p>很多人会推荐吴恩达在斯坦福的公开课CS229，但对于初学的同学来说，我觉得并不适合。虽然Andrew在课的最开始就说了，他的这门看更侧重于实践。但真实情况是，里面有太多的数学推导和证明。直接使用这门课来入门，对初学的同学来说，在信心上会是不小的打击。特别是很多从应用开发转到机器学习的同学，毕竟在平常的工作中，大学的数学知识在实际的开发中应用的并不多，估计很多现在都已经生疏了。<br>对于机器学习，我推荐吴恩达在Coursera开设的机器学习课程，课程免费，侧重于基本的原理和工程实现，对初学者相对友好。字幕中英可选。<br>课程链接：<a href="https://link.zhihu.com/?target=https://www.coursera.org/learn/machine-learning">https://www.coursera.org/learn/machine-learning</a></p><h2 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a><strong>深度学习</strong></h2><p>大家可能看过《一天搞懂深度学习》的PPT，作者是台湾大学的李宏毅老师。其实，李宏毅老师还有门深度学习的课程，视频也挂在网上。这门课主要针对初学者，而且，不需要有经典的机器学习基础（其实，深度学习入门，比经典的机器学习更容易）。课程的内容深入浅出，训练和预测样本都是各种数码宝贝和二次元卡通人物，绝对让你耳目一新。好像没有字幕，中文授课（台湾腔）。<br>课程链接：<a href="https://link.zhihu.com/?target=http://speech.ee.ntu.edu.tw/~tlkagk/courses_ML17.html">http://speech.ee.ntu.edu.tw/~tlkagk/courses_ML17.html</a></p><p>在看李宏毅老师的视频时，Andrew的《深度学习工程师》项目还没开始。后来把Andrew的课程看完（一共五部分，目前只出了前四部分），觉得Andrew的课程同样很棒。两者对比，李宏毅老师的课，课时相对较短，内容相对全面（对无监督学习、对抗学习、强化学习都有介绍），课程偏重概念介绍，但涉及到数学的部分跳跃性较大，不容易跟上。Andrew的课学时相对较长（一共五个大的部分），内容相对集中（主要讲解监督学习，集中在DNN、CNN和RNN），但讲解和分析更加细致，学习曲线相对平坦。针对于初学者可以先看李宏毅老师的课程对深度学习有个整体的框架认识，然后看Andrew的课程把握更多的细节知识。Andrew的课程本来是Coursera的付费课程，目前跟网易云课堂合作，不用翻墙就可以看了。</p><p>课程链接：<a href="https://link.zhihu.com/?target=https://mooc.study.163.com/smartSpec/detail/1001319001.htm">https://mooc.study.163.com/smartSpec/detail/1001319001.htm</a></p><h2 id="入门书籍"><a href="#入门书籍" class="headerlink" title="入门书籍"></a><strong>入门书籍</strong></h2><h2 id="机器学习-1"><a href="#机器学习-1" class="headerlink" title="机器学习"></a><strong>机器学习</strong></h2><p><img src="https://pic2.zhimg.com/80/v2-819ca8d8c5dc407b7ccdc1d938de7abd_720w.jpg" alt="img"></p><p>机器学习的入门书籍，当仁不让的就是周志华老师的西瓜书《机器学习》了。这本书基本囊括了绝大多数经典的机器学习方法。但坦白的讲，这本书入门也不是那么轻松，大量篇幅的数学推导和证明。建议初学者可以在第一遍的时候跳过具体的数学推导，更侧重在知识框架和原理的学习和提炼，后面可以通过第二遍或第三遍来深入其中的数学原理。</p><h2 id="深度学习-1"><a href="#深度学习-1" class="headerlink" title="深度学习"></a><strong>深度学习</strong></h2><p><img src="https://pic4.zhimg.com/80/v2-cc9539790c762bee6e621c2270156f63_720w.jpg" alt="img"></p><p>这一本称为目前深度学习领域的圣经，而作者们也确实做到了深入浅出，循序渐进。不是单纯的抛一个结论，而是逐步的深入，最终阐明原理。建议像《机器学习》一样使用：不要求第一遍就能全部吸收，可以先从框架和基本原理入手，跳过部分细节，后面再逐步深入。</p><h2 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a><strong>数学基础</strong></h2><p>看前面的视频和书籍，对于很多从事应用开发的同学来说，可能最大的障碍就是对数学的恐惧。这种感觉大概就像没经历过算法训练的同学面对算法面试一样。其实，恐惧只要能直面它，那就一定能够克服掉。就好比在LeetCode这样的OJ平台刷完200道左右的题目，再去面试算法一样。以前觉得是天大的障碍，现在回过头来，也不觉得有什么了不起。<br>我个人的经验是，通过前面的视频和书籍已经对机器学习和深度学习有了基本的系统框架和原理认识，同时，也积累了对数学知识进行系统复习的强烈欲望。这时候就可以有的放矢的复习大学知识了。数学知识的复习，我都是通过看网易公开课来完成的。</p><h2 id="微积分"><a href="#微积分" class="headerlink" title="微积分"></a><strong>微积分</strong></h2><p>MIT《单变量微积分》：<a href="https://link.zhihu.com/?target=http://open.163.com/special/sp/singlevariablecalculus.html">http://open.163.com/special/sp/singlevariablecalculus.html</a><br>虽说是MIT的课程，但坦白的讲，老师的节奏真是比国内的课程还要慢，真正做到了通俗易懂。<br>网易公开课还有MIT的《多变量微积分》，但我没有看，我觉得复习完单变量微积分，也就基本够用了。</p><h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a><strong>线性代数</strong></h2><p>MIT《线性代数》<br><a href="https://link.zhihu.com/?target=http://open.163.com/special/opencourse/daishu.html">http://open.163.com/special/opencourse/daishu.html</a><br>这门课就没有上面的《单变量微积分》那么Nice了，老师思路跳跃性很强，稍一走神就不知道讲到什么地方了 。但这门课有个很大的优点，就是从一开始就引入了向量空间的概念，而且贯穿始终。不像国内的课程，直到课程结束都以为线性代数只是求解方程组的另一种表达形式。</p><h2 id="概率-统计"><a href="#概率-统计" class="headerlink" title="概率 / 统计"></a><strong>概率 / 统计</strong></h2><p>可汗学院《概率》<br><a href="https://link.zhihu.com/?target=http://open.163.com/special/Khan/probability.html">http://open.163.com/special/Khan/probability.html</a><br>可汗学院《统计学》<br><a href="https://link.zhihu.com/?target=http://open.163.com/special/Khan/khstatistics.html">http://open.163.com/special/Khan/khstatistics.html</a><br>老实讲，可汗的公开课真是太细致了，细致到觉得拖沓（可能是复习，而不是初学者的缘故）。建议根据自己的需要做适当的跳跃。同时，两门课有部分内容是完全重合的，可以直接跳过。</p><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a><strong>Python</strong></h2><p>有了前面的基础相信你已经跃跃欲试了，但别急，工欲善其事必先利其器。可能你已经有MATLAB、C/C++、Java的编程经验，但建议再入手一款新武器-Python。虽然前面的语言也可以用于机器学习和深度学习相关的研究和开发，但Python的使用范围更广，参考资料也更加丰富。<br>我的自己经验是，</p><ul><li>1-在网上找一篇Python入门的帖子，搭建环境，运行简单的例子（半天）</li><li>2-找一本基础书籍，系统的熟悉下语言的基本特性和完整框架（1~2天）<br>ps：我之前有C/C++和Java的语音基础</li><li>3-开始正常使用Python进行开发，遇到问题，求助搜索引擎（2个月以上）</li><li>4-觉得自己对语言就基本的掌握后，可以根据选择进行进阶学习了<br>上面1~2天时间来系统的熟悉Python语言特性和语言框架的书籍我推荐，<br><strong>《Python基础教程》</strong><br>（这本书很厚，初期把目录扫完就可以了，后面当做字典来使用）</li></ul><p><img src="https://pic4.zhimg.com/80/v2-f4ee54c36f894001fac1c8d57b140b6f_720w.jpg" alt="img"></p><p>进阶阶段，推荐，<br><strong>《流畅的Python》</strong></p><p><img src="https://pic1.zhimg.com/80/v2-fb8682201e717f46b43d5f5d90f6c9e8_720w.jpg" alt="img"></p><h2 id="动手实践"><a href="#动手实践" class="headerlink" title="动手实践"></a><strong>动手实践</strong></h2><h2 id="初级"><a href="#初级" class="headerlink" title="初级"></a><strong>初级</strong></h2><p>好了现在我们终于可以动手实践了，<br><strong>《Python机器学习及实践：从零开始通往Kaggle竞赛之路》</strong></p><p><img src="https://pic1.zhimg.com/80/v2-e302bfe1e1ee5a9941c384de597ec804_720w.jpg" alt="img"></p><p>这是很薄的一本书，但对于初学者实践来说却是非常棒的一本书。书中的大多数算法都是基于sk-learn来实现的。使用现成的Python库，而不用关心具体算法实现过程，可以快速体验机器学习算法的效果。同时，书的最后比较细致的介绍了Kaggle竞赛平台的使用，实战性更强。</p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a><strong>进阶</strong></h2><p>《Python机器学习及实践：从零开始通往Kaggle竞赛之路》使用现成的Python库（工程中也大多是这样的）。但很多同学还是更希望能手工实现具体的算法，觉得这样基本功才扎实，那下面的这两本书就能很好的满足有这样想法的同学了。<br><strong>《机器学习实战》</strong></p><p><img src="https://pic1.zhimg.com/80/v2-8d39e78b857c824ac67b98933216d6ec_720w.jpg" alt="img"></p><p>经典的机器学习算法手工实现，书中包含大量的代码实例。但这本书出本的比较早，深度学习内容基本没有涉猎。针对这种情况，就有了下面这本的推荐，</p><p><strong>《TensorFlow Machine Learning Cookbook》</strong></p><p><img src="https://pic2.zhimg.com/80/v2-cb356448772070bcd2e6d4f09a3a3e95_720w.jpg" alt="img"></p><p>这本书主要是基于TensorFlow的，手工编织网络。而且，书的内容就像它的名字一样，结构编排跟类似菜谱：开始前需要准备什么，开始后需要遵从哪些步骤，最后又会得到怎样的结果，条理非常清晰。目前这本书已经有了中文版。</p><h2 id="领域应用"><a href="#领域应用" class="headerlink" title="领域应用"></a><strong>领域应用</strong></h2><p>虽然我们花费了很长的时间，投入了很多精力，但我们目前的阶段仍然像做大学作业，跟真实的工业场景相差很远。那机器学习和深度学习在实际的AI场景是如何应用的呢？带着这样的问题，我推荐两本书，<br><strong>《数学之美》</strong></p><p><img src="https://pic4.zhimg.com/80/v2-5c43770febcefee82e0c1a5b1c3014cf_720w.jpg" alt="img"></p><p>吴军老师的经典之作。虽然这本书火的时候，AI都还没有现在这么火，但书中介绍的很多场景，使用的很多技术，基本都是来自我们学习的机器学习。</p><p><strong>《统计自然语言处理》</strong></p><p><img src="https://pic4.zhimg.com/80/v2-3ec8230e15b3e69083945a565c97b21f_720w.jpg" alt="img"></p><p>选择这边书是因为自己当前的工作跟自然语言处理相关。当然了，这也是自然语言处理领域非常经典的一本书，内容全面丰富。但学术的气息比较重，读起来又找到了当初读研看Paper的感觉。</p><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a><strong>杂项</strong></h2><p>比较正统的学习基本就算介绍完毕了。其实，除了上面的主线内容外，很多比较零散的资料，对于学习来说也还是很有裨益的。<br><strong>《莫烦视频》</strong><br>莫烦的个人主页有很多机器学习和深度学习相关的个人录制视频。以非常简洁的方式介绍了机器学习和深度学习相关的概念和框架，对初学者快速建立概念很有帮助(PS:92年的小鲜肉，真是不得了)。<br>地址：<a href="https://link.zhihu.com/?target=https://morvanzhou.github.io/about/">https://morvanzhou.github.io/about/</a></p><p><strong>《深度学习简化版》</strong><br>形式跟莫凡的视频类似，是老外录制的。相比于莫烦的视频，内容更丰富多样，形式更新颖。通过YouTube播放，需要翻墙。<br>地址：<a href="https://link.zhihu.com/?target=https://www.youtube.com/watch?list=PLjJh1vlSEYgvGod9wWiydumYl8hOXixNu&v=b99UVkWzYTQ">https://www.youtube.com/watch?list=PLjJh1vlSEYgvGod9wWiydumYl8hOXixNu&amp;v=b99UVkWzYTQ</a></p><p><strong>《AI技术内参》</strong><br>这是《极客时间》的一个付费专栏。主要推送AI相关的技术历史、当前行业信息和科研成果，从目前的使用情况来说，在品质上还是有保障的。</p><p>** 加州理工的Yaser Abu-Mostafa教授出品的机器学习网络课程**</p><p>课程名称：Machine Learning Course - CS 156<br>视频地址：<a href="https://link.zhihu.com/?target=https://www.youtube.com/watch?v=mbyG85GZ0PI&list=PLD63A284B7615313A">https://www.youtube.com/watch?v=mbyG85GZ0PI&amp;list=PLD63A284B7615313A</a></p><p><strong>Geoffrey Hinton的课程</strong></p><p>课程名称：Neural Networks for Machine Learning</p><p>课程地址：<a href="https://link.zhihu.com/?target=https://www.coursera.org/learn/neural-networks">Neural Networks for Machine Learning | Coursera</a></p><p>作为深度学习的根目录人物，我就不多夸赞Hinton的课了吧</p><p><strong>吴恩达</strong></p><p><a href="https://link.zhihu.com/?target=http://open.163.com/special/opencourse/machinelearning.html">斯坦福大学公开课 ：机器学习课程</a><br><a href="https://link.zhihu.com/?target=http://ufldl.stanford.edu/wiki/index.php/UFLDL%E6%95%99%E7%A8%8B">UFLDL教程 - Ufldl</a></p><p>机器学习那个，我总会时不时看看视频，每次看都有收获。</p><p><strong>Goodfellow</strong></p><p><a href="https://link.zhihu.com/?target=http://www.deeplearningbook.org/">Deep Learning</a></p><p>这应该是讲深度学习最好的书，没有之一，作者作为深度学习根目录人物的弟子，而且是GAN对抗网络的提出这，作者的功力直接决定了这本书的水平</p><p><strong>CS224D</strong></p><p><a href="https://link.zhihu.com/?target=http://cs224d.stanford.edu/">CS224d: Deep Learning for Natural Language Processing</a></p><p>虽然讲的是NLP，但这个系列从基础神经网路讲起，讲到概率预研模型，降到word2vec，最后讲到RNN模型在NLP领域的应用，我对这个教程评价相当高</p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty</title>
    <link href="/2020/12/28/reference/Netty/"/>
    <url>/2020/12/28/reference/Netty/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>转自<a href="https://mp.weixin.qq.com/s/I9PGsWo7-ykGf2diKklGtA">敖丙肝了一个月的Netty知识点</a></p><h2 id="NIO-基本概念"><a href="#NIO-基本概念" class="headerlink" title="NIO 基本概念"></a>NIO 基本概念</h2><h3 id="阻塞（Block）与非阻塞（Non-Block）"><a href="#阻塞（Block）与非阻塞（Non-Block）" class="headerlink" title="阻塞（Block）与非阻塞（Non-Block）"></a>阻塞（Block）与非阻塞（Non-Block）</h3><p>阻塞和非阻塞是进程在访问数据的时候，数据是否准备就绪的一种处理方式，当数据没有准备的时候。</p><p><strong>阻塞</strong>：往往需要等待缓冲区中的数据准备好过后才处理其他的事情，否则一直等待在那里。</p><p><strong>非阻塞</strong>:当我们的进程访问我们的数据缓冲区的时候，如果数据没有准备好则直接返回，不会等待。如果数据已经准备好，也直接返回。</p><p><strong>阻塞 IO ：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-1.jpg"></p><p><strong>非阻塞 IO ：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-2.jpg"></p><h3 id="同步（Synchronous）与异步（Asynchronous）"><a href="#同步（Synchronous）与异步（Asynchronous）" class="headerlink" title="同步（Synchronous）与异步（Asynchronous）"></a>同步（Synchronous）与异步（Asynchronous）</h3><p>同步和异步都是基于应用程序和操作系统处理 IO 事件所采用的方式。比如</p><p><strong>同步：</strong>是应用程序要直接参与 IO 读写的操作。</p><p><strong>异步：</strong>所有的 IO 读写交给操作系统去处理，应用程序只需要等待通知。</p><p>同步方式在处理 IO 事件的时候，必须阻塞在某个方法上面等待我们的 IO 事件完成（阻塞 IO 事件或者通过轮询 IO事件的方式），对于异步来说，所有的 IO 读写都交给了操作系统。这个时候，我们可以去做其他的事情，并不需要去完成真正的 IO 操作，当操作完成 IO 后，会给我们的应用程序一个通知。</p><p>所以异步相比较于同步带来的直接好处就是在我们处理IO数据的时候，异步的方式我们可以把这部分等待所消耗的资源用于处理其他事务，提升我们服务自身的性能。</p><p><strong>同步 IO ：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-3.jpg"></p><p><strong>异步 IO ：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-4.jpg"></p><h2 id="Java-BIO与NIO对比"><a href="#Java-BIO与NIO对比" class="headerlink" title="Java BIO与NIO对比"></a>Java BIO与NIO对比</h2><h3 id="BIO（传统IO）："><a href="#BIO（传统IO）：" class="headerlink" title="BIO（传统IO）："></a>BIO（传统IO）：</h3><p>BIO是一个同步并阻塞的IO模式，<strong>传统的  java.io 包</strong>，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如<strong>File抽象、输入输出流</strong>等。<strong>交互方式是同步、阻塞的方式</strong>，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。</p><h3 id="NIO（Non-blocking-New-I-O）"><a href="#NIO（Non-blocking-New-I-O）" class="headerlink" title="NIO（Non-blocking/New I/O）"></a>NIO（Non-blocking/New I/O）</h3><p>NIO 是一种同步非阻塞的 I/O 模型，于 Java 1.4 中引入，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。NIO 提供了与传统 BIO 模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</p><h3 id="BIO与NIO的对比"><a href="#BIO与NIO的对比" class="headerlink" title="BIO与NIO的对比"></a>BIO与NIO的对比</h3><table><thead><tr><th align="left">IO模型</th><th align="left">BIO</th><th align="left">NIO</th></tr></thead><tbody><tr><td align="left">通信</td><td align="left">面向流</td><td align="left">面向缓冲</td></tr><tr><td align="left">处理</td><td align="left">阻塞  IO</td><td align="left">非阻塞  IO</td></tr><tr><td align="left">触发</td><td align="left">无</td><td align="left">选择器</td></tr></tbody></table><h4 id="NIO-的-Server-通信的简单模型："><a href="#NIO-的-Server-通信的简单模型：" class="headerlink" title="NIO 的 Server 通信的简单模型："></a>NIO 的 Server 通信的简单模型：</h4><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-5.jpg"></p><h4 id="BIO-的-Server-通信的简单模型："><a href="#BIO-的-Server-通信的简单模型：" class="headerlink" title="BIO 的 Server 通信的简单模型："></a>BIO 的 Server 通信的简单模型：</h4><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-6.jpg"></p><h4 id="NIO的特点："><a href="#NIO的特点：" class="headerlink" title="NIO的特点："></a>NIO的特点：</h4><ol><li>一个线程可以处理多个通道，减少线程创建数量；</li><li>读写非阻塞，节约资源：没有可读／可写数据时，不会发生阻塞导致线程资源的浪费</li></ol><h2 id="Reactor-模型"><a href="#Reactor-模型" class="headerlink" title="Reactor 模型"></a>Reactor 模型</h2><h3 id="单线程的-Reactor-模型"><a href="#单线程的-Reactor-模型" class="headerlink" title="单线程的 Reactor 模型"></a>单线程的 Reactor 模型</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-7.jpg"></p><h3 id="多线程的-Reactor-模型"><a href="#多线程的-Reactor-模型" class="headerlink" title="多线程的 Reactor 模型"></a>多线程的 Reactor 模型</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-8.jpg"></p><h3 id="多线程主从-Reactor-模型"><a href="#多线程主从-Reactor-模型" class="headerlink" title="多线程主从 Reactor 模型"></a>多线程主从 Reactor 模型</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-9.jpg"></p><h2 id="Netty-基础概念"><a href="#Netty-基础概念" class="headerlink" title="Netty  基础概念"></a>Netty  基础概念</h2><h3 id="Netty-简介"><a href="#Netty-简介" class="headerlink" title="Netty 简介"></a>Netty 简介</h3><p>Netty 是一个 NIO 客户端服务器框架，可快速轻松地开发网络应用程序，例如协议服务器和客户端。它极大地简化和简化了网络编程，例如 TCP 和 UDP 套接字服务器。</p><p>“快速简便”并不意味着最终的应用程序将遭受可维护性或性能问题的困扰。Netty 经过精心设计，结合了许多协议（例如FTP，SMTP，HTTP 以及各种基于二进制和文本的旧式协议）的实施经验。结果，Netty 成功地找到了一种无需妥协即可轻松实现开发，性能，稳定性和灵活性的方法。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-10.jpg"></p><h3 id="Netty-执行流程"><a href="#Netty-执行流程" class="headerlink" title="Netty 执行流程"></a>Netty 执行流程</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-11.jpg"></p><h3 id="Netty-核心组件"><a href="#Netty-核心组件" class="headerlink" title="Netty 核心组件"></a>Netty 核心组件</h3><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>Channel是 Java NIO 的一个基本构造。可以看作是传入或传出数据的载体。因此，它可以被打开或关闭，连接或者断开连接。</p><h4 id="EventLoop-与-EventLoopGroup"><a href="#EventLoop-与-EventLoopGroup" class="headerlink" title="EventLoop 与 EventLoopGroup"></a>EventLoop 与 EventLoopGroup</h4><p>EventLoop 定义了Netty的核心抽象，用来处理连接的生命周期中所发生的事件，在内部，将会为每个Channel分配一个EventLoop。</p><p>EventLoopGroup 是一个 EventLoop 池，包含很多的 EventLoop。</p><p>Netty 为每个 Channel 分配了一个 EventLoop，用于处理用户连接请求、对用户请求的处理等所有事件。EventLoop 本身只是一个线程驱动，在其生命周期内只会绑定一个线程，让该线程处理一个 Channel 的所有 IO 事件。</p><p>一个 Channel 一旦与一个 EventLoop 相绑定，那么在 Channel 的整个生命周期内是不能改变的。一个 EventLoop 可以与多个 Channel 绑定。即 Channel 与 EventLoop 的关系是 n:1，而 EventLoop 与线程的关系是 1:1。</p><h4 id="ServerBootstrap-与-Bootstrap"><a href="#ServerBootstrap-与-Bootstrap" class="headerlink" title="ServerBootstrap 与 Bootstrap"></a>ServerBootstrap 与 Bootstrap</h4><p>Bootstarp 和 ServerBootstrap 被称为引导类，指对应用程序进行配置，并使他运行起来的过程。Netty处理引导的方式是使你的应用程序和网络层相隔离。</p><p>Bootstrap 是客户端的引导类，Bootstrap 在调用 bind()（连接UDP）和 connect()（连接TCP）方法时，会新创建一个 Channel，仅创建一个单独的、没有父 Channel 的 Channel 来实现所有的网络交换。</p><p>ServerBootstrap 是服务端的引导类，ServerBootstarp 在调用 bind() 方法时会创建一个 ServerChannel 来接受来自客户端的连接，并且该 ServerChannel 管理了多个子 Channel 用于同客户端之间的通信。</p><h4 id="ChannelHandler-与-ChannelPipeline"><a href="#ChannelHandler-与-ChannelPipeline" class="headerlink" title="ChannelHandler 与 ChannelPipeline"></a>ChannelHandler 与 ChannelPipeline</h4><p>ChannelHandler 是对 Channel 中数据的处理器，这些处理器可以是系统本身定义好的编解码器，也可以是用户自定义的。这些处理器会被统一添加到一个 ChannelPipeline 的对象中，然后按照添加的顺序对 Channel 中的数据进行依次处理。</p><h4 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h4><p>Netty 中所有的 I/O 操作都是异步的，即操作不会立即得到返回结果，所以 Netty 中定义了一个 ChannelFuture 对象作为这个异步操作的“代言人”，表示异步操作本身。如果想获取到该异步操作的返回值，可以通过该异步操作对象的addListener() 方法为该异步操作添加监 NIO 网络编程框架 Netty 听器，为其注册回调：当结果出来后马上调用执行。</p><p>Netty 的异步编程模型都是建立在 Future 与回调概念之上的。</p><h2 id="Netty-源码阅读"><a href="#Netty-源码阅读" class="headerlink" title="Netty 源码阅读"></a>Netty 源码阅读</h2><p>源码阅读，最好可以再 Debug 的情况下进行，这样更容易帮助理解，因此在分析 Netty 前的我准备一个客户端和服务端的代码。</p><h3 id="Netty-Server-代码"><a href="#Netty-Server-代码" class="headerlink" title="Netty - Server 代码"></a>Netty - Server 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        EventLoopGroup parentGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        EventLoopGroup childGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br><br>            ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            bootstrap.group(parentGroup, childGroup)<br>                     .channel(NioServerSocketChannel.class)<br>                     .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>                            ChannelPipeline pipeline = ch.pipeline();<br>                            pipeline.addLast(<span class="hljs-keyword">new</span> StringDecoder());<br>                            pipeline.addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>                            pipeline.addLast(<span class="hljs-keyword">new</span> SomeSocketServerHandler());<br>                         &#125;<br>                    &#125;);<br><br>            ChannelFuture future = bootstrap.bind(<span class="hljs-number">8888</span>).sync();<br>            System.out.println(<span class="hljs-string">&quot;服务器已启动。。。&quot;</span>);<br><br>            future.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            parentGroup.shutdownGracefully();<br>            childGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Server-端-Handler："><a href="#Server-端-Handler：" class="headerlink" title="Server 端 Handler："></a>Server 端 Handler：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoSocketServerHandler</span></span><br><span class="hljs-class">                       <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Client Address ====== &quot;</span> + ctx.channel().remoteAddress());<br>        ctx.channel().writeAndFlush(<span class="hljs-string">&quot;from server:&quot;</span> + UUID.randomUUID());<br>        ctx.fireChannelActive();<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">500</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx,</span></span><br><span class="hljs-function"><span class="hljs-params">                                Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Netty-Client-代码"><a href="#Netty-Client-代码" class="headerlink" title="Netty - Client 代码"></a>Netty - Client 代码</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClient</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        NioEventLoopGroup eventLoopGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>            bootstrap.group(eventLoopGroup)<br>                    .channel(NioSocketChannel.class)<br>                    .<span class="hljs-keyword">handler</span>(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            ChannelPipeline pipeline = ch.pipeline();<br>                            pipeline.addLast(<span class="hljs-keyword">new</span> StringDecoder(CharsetUtil.UTF_8));<br>                            pipeline.addLast(<span class="hljs-keyword">new</span> StringEncoder(CharsetUtil.UTF_8));<br>                            pipeline.addLast(<span class="hljs-keyword">new</span> DemoSocketClientHandler());<br>                        &#125;<br>                    &#125;);<br><br>            ChannelFuture future = bootstrap.connect(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8888</span>).sync();<br>            future.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span>(eventLoopGroup != <span class="hljs-keyword">null</span>) &#123;<br>                eventLoopGroup.shutdownGracefully();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Client-端-Handler-："><a href="#Client-端-Handler-：" class="headerlink" title="Client 端  Handler ："></a>Client 端  Handler ：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoSocketClientHandler</span></span><br><span class="hljs-class">               <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(msg);<br>        ctx.channel().writeAndFlush(<span class="hljs-string">&quot;from client: &quot;</span> + System.currentTimeMillis());<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">5000</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ctx.channel().writeAndFlush(<span class="hljs-string">&quot;from client：begin talking&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx,</span></span><br><span class="hljs-function"><span class="hljs-params">                                Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="NioEventLoopGroup-初始化分析"><a href="#NioEventLoopGroup-初始化分析" class="headerlink" title="NioEventLoopGroup 初始化分析"></a>NioEventLoopGroup 初始化分析</h3><p>首先根据 Server 服务端代码，分析 NioEventLoopGroup 的初始化过程。而在分析 NioEventLoopGroup 之前，有必要简单的说一说 NioEventLoopGroup 与 NioEventLoop ，方便后续源码的理解。</p><h4 id="NioEventLoop-源码分析前了解"><a href="#NioEventLoop-源码分析前了解" class="headerlink" title="NioEventLoop 源码分析前了解"></a>NioEventLoop 源码分析前了解</h4><p><strong>NioEventLoop 的继承体系</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-12.jpg"></p><p>从 NioEventLoop 的继承体系中可以看到，NioEventLoop  本身就是一个 Executor，并且还是一个 单线程的 Executor。Executor  必然拥有一个 <code>execute(Runnable command)</code> 的实现方法，而 NioEventLoop 的 <code>execute()</code> 实现方法在其父类  SingleThreadEventExecutor 中，找到具体代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">execute</span>(<span class="hljs-params">Runnable task</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;task&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">boolean</span> inEventLoop = inEventLoop();<br>    addTask(task);<br>    <span class="hljs-keyword">if</span> (!inEventLoop) &#123;<br>        startThread();<br>        <span class="hljs-keyword">if</span> (isShutdown()) &#123;<br>            <span class="hljs-built_in">boolean</span> reject = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (removeTask(task)) &#123;<br>                    reject = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (UnsupportedOperationException e) &#123;<br>                <span class="hljs-comment">// The task queue does not support removal so the best thing we can do is to just move on and</span><br>                <span class="hljs-comment">// hope we will be able to pick-up the task before its completely terminated.</span><br>                <span class="hljs-comment">// In worst case we will log on termination.</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (reject) &#123;<br>                reject();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;<br>        wakeup(inEventLoop);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里不细说，但是贴出这段代码主要为了引出 <code>startThread();</code> 这句代码，在跟这句代码会发现，它最终调用了 NioEventLoop 的一个成员 Executor 执行了当前成员的 <code>execute()</code> 方法。对应的成员 <code>io.netty.util.concurrent.SingleThreadEventExecutor#executor</code></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-13.jpg"></p><p>而 executor 成员的初始化也是在当前代码执行时创建的匿名 Executor ，也就是执行到即新建并且执行当前 匿名 <code>executr()</code> 方法。</p><p><strong>总结：</strong></p><ol><li>NioEventLoop 本身就是一个 Executor。</li><li>NioEventLoop 内部封装这一个新的线程 Executor 成员。</li><li>NioEventLoop 有两个 <code>execute</code> 方法，除了本身的 <code>execute()</code> 方法对应的还有成员属性 Executor  对应的 <code>execute()</code> 方法。</li></ol><p><strong>备注：</strong> 因为这里出现了四个 Executor，为了区分，我们给其新的名称：</p><blockquote><p>NioEventLoop 本身 Executor：<strong>NioEventLoop</strong></p><p>NioEventLoop 的成员 Executor：<strong>子 Executor</strong></p><p>NioEventLoopGroup 本身 Executor ：<strong>NioEventLoopGroup</strong></p><p>NioEventLoopGroup 的构造参数 Executor ：<strong>总Executor</strong></p></blockquote><p><strong>NioEventLoopGroup 的继承体系</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-14.jpg"></p><p>看到继承体系可以直接知道 NioEventLoopGroup 也是一个 Executor，并且是一个线程池的 Executor，所以他也有 <code>execute()</code> 方法。对应的实现再其父类之中：<code>io.netty.util.concurrent.AbstractEventExecutorGroup#execute</code></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-15.jpg"></p><p>而这里还需要说到的一点是：在 NioEventLoopGroup  的构造中，再其父类 MultithreadEventExecutorGroup 的构造再次引入了一个新的 Executor，</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-16.jpg"></p><p>之所以这里提到这个 Executor，是因为这个 Executor 是对应的 <code>execute()</code> 就是在 NioEventLoop 中的成员 Executor 的 <code>execute()</code> 执行时调用的。也就是下面对应的代码调用。<code>io.netty.util.internal.ThreadExecutorMap#apply(java.util.concurrent.Executor, io.netty.util.concurrent.EventExecutor)</code></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-17.jpg"></p><p>到这如果不明白，没关系，因为只是为了引入 NioEventLoopGroup 和 NioEventLoop 的对应的两个 Executor，和两个 Executor 对应的两个 <code>execute()</code> 方法。这个后面还会有详细分析。</p><p><strong>总结：</strong></p><ol><li>NioEventLoopGroup 是一个线程池线程 Executor。</li><li>NioEventLoopGroup 也封装了一个线程 Executor。</li><li>NioEventLoopGroup 也有两个 <code>execute()</code>方法。</li></ol><h4 id="NioEventLoopGroup-初始化代码分析"><a href="#NioEventLoopGroup-初始化代码分析" class="headerlink" title="NioEventLoopGroup 初始化代码分析"></a>NioEventLoopGroup 初始化代码分析</h4><p>上面说了基本的了解内容，下面具体分析，从 NioEventLoopGroup 的初始化进入源码分析。</p><p>入口我们直接找 NioEventLoopGroup 的无参构造。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioEventLoopGroup</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioEventLoopGroup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;<br>    <span class="hljs-comment">// 第二个参数是这个group所包含的executor</span><br>    <span class="hljs-keyword">this</span>(nThreads, (Executor) <span class="hljs-keyword">null</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioEventLoopGroup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, Executor executor)</span> </span>&#123;<br>    <span class="hljs-comment">// 第三个参数是provider，其用于提供selector及selectable的channel，</span><br>    <span class="hljs-comment">// 这个provider是当前JVM中唯一的一个单例的provider</span><br>    <span class="hljs-keyword">this</span>(nThreads, executor, SelectorProvider.provider());<br>&#125;<br><span class="hljs-keyword">public</span> NioEventLoopGroup(<br>        <span class="hljs-keyword">int</span> nThreads, Executor executor, <span class="hljs-keyword">final</span> SelectorProvider selectorProvider) &#123;<br>    <span class="hljs-comment">// 第四个参数是一个选择策略工厂实例</span><br>    <span class="hljs-keyword">this</span>(nThreads, executor, selectorProvider, DefaultSelectStrategyFactory.INSTANCE);<br>&#125;<br><span class="hljs-keyword">public</span> NioEventLoopGroup(<span class="hljs-keyword">int</span> nThreads, Executor executor, <span class="hljs-keyword">final</span> SelectorProvider selectorProvider,<br>                         <span class="hljs-keyword">final</span> SelectStrategyFactory selectStrategyFactory) &#123;<br>    <span class="hljs-keyword">super</span>(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">MultithreadEventLoopGroup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(nThreads == <span class="hljs-number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">MultithreadEventExecutorGroup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>&#123;<br>    <span class="hljs-comment">// 第三个参数是选择器工厂实例</span><br>    <span class="hljs-keyword">this</span>(nThreads, executor, DefaultEventExecutorChooserFactory.INSTANCE, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>跟到此，可以发现无参构造的基本参数被初始化， <code>nThreads ：DEFAULT_EVENT_LOOP_THREADS//默认当前CPU逻辑核心数的两倍</code>，<code>selectorProvide:SelectorProvider.provider()//当前JVM中唯一的一个单例的provider</code>，<code>SelectStrategyFactory:DefaultSelectStrategyFactory.INSTANCE//默认选择策略工厂实例</code>，<code>chooserFactory:DefaultEventExecutorChooserFactory.INSTANCE//选择器工厂实例</code>。到这里只是基本的初始化参数，重点方法为<code>MultithreadEventExecutorGroup</code> 的构造方法。下面重点分析：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">protected</span> MultithreadEventExecutorGroup(int nThreads, Executor executor,<br>                                        EventExecutorChooserFactory chooserFactory, <span class="hljs-built_in">Object</span>... args) &#123;<br>    <span class="hljs-keyword">if</span> (nThreads &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-built_in">String</span>.format(<span class="hljs-string">&quot;nThreads: %d (expected: &gt; 0)&quot;</span>, nThreads));<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (executor == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 这个executor是group所包含的executor，其将来会为其所包含的每个eventLoop创建一个线程</span><br>        executor = <span class="hljs-keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());<br>    &#125;<br><br>    children = <span class="hljs-keyword">new</span> EventExecutor[nThreads];<br><br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; nThreads; i ++) &#123;<br>        <span class="hljs-built_in">boolean</span> success = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 创建eventLoop</span><br>            children[i] = newChild(executor, args);<br>            success = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;failed to create a child event loop&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 在创建这些eventLoop过程中，只要有一个创建失败，则关闭之前所有已经创建好的eventLoop</span><br>            <span class="hljs-keyword">if</span> (!success) &#123;<br>                <span class="hljs-comment">// 关闭之前所有已经创建好的eventLoop</span><br>                <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; i; j ++) &#123;<br>                    children[j].shutdownGracefully();<br>                &#125;<br><br>                <span class="hljs-comment">// 终止所有eventLoop上所执行的任务</span><br>                <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; i; j ++) &#123;<br>                    EventExecutor e = children[j];<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">while</span> (!e.isTerminated()) &#123;<br>                            e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException interrupted) &#123;<br>                        Thread.currentThread().interrupt();<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建一个选择器</span><br>    chooser = chooserFactory.newChooser(children);<br><br>    final FutureListener&lt;<span class="hljs-built_in">Object</span>&gt; terminationListener = <span class="hljs-keyword">new</span> FutureListener&lt;<span class="hljs-built_in">Object</span>&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> operationComplete(Future&lt;<span class="hljs-built_in">Object</span>&gt; future) throws Exception &#123;<br>            <span class="hljs-keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;<br>                terminationFuture.setSuccess(<span class="hljs-literal">null</span>);<br>            &#125;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">for</span> (EventExecutor e: children) &#123;<br>        e.terminationFuture().addListener(terminationListener);<br>    &#125;<br><br>    <span class="hljs-built_in">Set</span>&lt;EventExecutor&gt; childrenSet = <span class="hljs-keyword">new</span> LinkedHashSet&lt;EventExecutor&gt;(children.length);<br>    Collections.addAll(childrenSet, children);<br>    readonlyChildren = Collections.unmodifiableSet(childrenSet);<br>&#125;<br></code></pre></td></tr></table></figure><p>根据无参构造直接往下跟，可以看到核心部分在最后一个父类的构造里。也就是 <code>io.netty.util.concurrent.MultithreadEventExecutorGroup#MultithreadEventExecutorGroup(int, java.util.concurrent.Executor, io.netty.util.concurrent.EventExecutorChooserFactory, java.lang.Object...)</code>。</p><p>再这里完成整个 NioEventLoopGroup 的实例初始化，这里分析下，然后再画个图回顾下。</p><p>初始化构造参数中的 Executor 参数，当其为空时，将其初始化</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">executor = <span class="hljs-keyword">new</span> <span class="hljs-type">ThreadPerTaskExecutor</span>(<span class="hljs-keyword">new</span><span class="hljs-type">DefaultThreadFactory</span>());<br></code></pre></td></tr></table></figure><p>首先 <code>newDefaultThreadFactory())</code> 创建默认的线程工厂，有兴趣可以跟进去看看。然后再创建<code>ThreadPerTaskExecutor</code>线程 Executor 对象。（PS：这里创建的 Executor 就是 NioEventLoopGroup 内的 Executor 对象，并不是当前 NioEventLoopGroup  自身，可以称其为 <strong>总 Executor</strong>）。</p><p>然后可以看到这里创建了一个 children 数组，根据需要创建的线程数创建对应数量的数组。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">children</span> = new EventExecutor[nThreads]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>因为每个 NioEventLoopGroup 都是 NioEventLoop 的集合，所以这里的 children 数组就是当前 NioEventLoopGroup 的 NioEventLoop。所以 NioEventLoop 的创建的实在 NioEventLoopGroup 初始化的时候。下面看 NioEventLoop 的初始化：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 逐个创建nioEventLoop实例</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nThreads; i ++) &#123;<br>    boolean success = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建eventLoop</span><br>        children<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = <span class="hljs-keyword">new</span><span class="hljs-constructor">Child(<span class="hljs-params">executor</span>, <span class="hljs-params">args</span>)</span>;<br>        success = <span class="hljs-literal">true</span>;<br>    &#125; catch (Exception e) &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Think about if this is a good exception type</span><br>        throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">IllegalStateException(<span class="hljs-string">&quot;failed to create a child event loop&quot;</span>, <span class="hljs-params">e</span>)</span>;<br>    &#125; finally &#123;<br>        <span class="hljs-comment">// 在创建这些eventLoop过程中，只要有一个创建失败，则关闭之前所有已经创建好的eventLoop</span><br>        <span class="hljs-keyword">if</span> (!success) &#123;<br>            <span class="hljs-comment">// 闭之前所有已经创建好的eventLoop</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j ++) &#123;<br>                children<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>.shutdown<span class="hljs-constructor">Gracefully()</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 终止所有eventLoop上所执行的任务</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j ++) &#123;<br>                EventExecutor e = children<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">while</span> (!e.is<span class="hljs-constructor">Terminated()</span>) &#123;<br>                        e.await<span class="hljs-constructor">Termination(Integer.MAX_VALUE, TimeUnit.SECONDS)</span>;<br>                    &#125;<br>                &#125; catch (InterruptedException interrupted) &#123;<br>                    <span class="hljs-comment">// Let the caller handle the interruption.</span><br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.interrupt<span class="hljs-literal">()</span>;<br>                    break;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先整体看这段 NioEventLoop 的创建代码，可以看到整个过程中存在一个成功标志，catch 每个 NioEventLoop 创建完成过程，如果发生异常则将所有已经创建的 NioEventLoop 关闭。重点的代码也就在 NioEventLoop 的创建了。所以我们继续跟：<code>children[i] = newChild(executor, args);</code>往下走，直接找到 <code>io.netty.channel.nio.NioEventLoopGroup#newChild</code> ，因为当前是 NioEventLoopGroup 的创建，所以知道找到子类的 <code>newChild</code> 实现。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override<br>protected EventLoop <span class="hljs-keyword">new</span><span class="hljs-constructor">Child(Executor <span class="hljs-params">executor</span>, Object<span class="hljs-operator">...</span> <span class="hljs-params">args</span>)</span> throws Exception &#123;<br>    return <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoop(<span class="hljs-params">this</span>, <span class="hljs-params">executor</span>, (SelectorProvider)</span> args<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>,<br>            ((SelectStrategyFactory) args<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>).<span class="hljs-keyword">new</span><span class="hljs-constructor">SelectStrategy()</span>, (RejectedExecutionHandler) args<span class="hljs-literal">[<span class="hljs-number">2</span>]</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>又将之前合并的 args 参数强转回来，继续跟进 NioEventLoop 构造：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,<br>             SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) &#123;<br>    <span class="hljs-built_in">super</span>(parent, executor, <span class="hljs-literal">false</span>, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);<br>    <span class="hljs-keyword">if</span> (selectorProvider == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;selectorProvider&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (strategy == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;selectStrategy&quot;</span>);<br>    &#125;<br>    provider = selectorProvider;<br>    <span class="hljs-comment">// 创建一个selector的二元组</span><br>    final SelectorTuple selectorTuple = openSelector();<br>    selector = selectorTuple.selector;<br>    unwrappedSelector = selectorTuple.unwrappedSelector;<br>    selectStrategy = strategy;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们先整体看下，将之前的默认参数初始化到 NioEventLoop 属性中。其中有两处：<code>openSelector()</code> 和 <code>super(parent, executor, false, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler)</code>。这里先看父类构造：</p><p>往下跟，直接就是 SingleThreadEventLoop -&gt; SingleThreadEventExecutor 的初始化，这些也可以在 NioEventLoop 的继承体系可以看到：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// io.netty.channel.SingleThreadEventLoop#SingleThreadEventLoop</span><br><span class="hljs-keyword">protected</span> SingleThreadEventLoop(EventLoopGroup parent, Executor executor,<br>                                <span class="hljs-built_in">boolean</span> addTaskWakesUp, int maxPendingTasks,<br>                                RejectedExecutionHandler rejectedExecutionHandler) &#123;<br>    <span class="hljs-built_in">super</span>(parent, executor, addTaskWakesUp, maxPendingTasks, rejectedExecutionHandler);<br>    <span class="hljs-comment">// 创建一个收尾队列</span><br>    tailTasks = newTaskQueue(maxPendingTasks);<br>&#125;<br><br><span class="hljs-comment">// io.netty.util.concurrent.SingleThreadEventExecutor#SingleThreadEventExecutor</span><br><span class="hljs-keyword">protected</span> SingleThreadEventExecutor(EventExecutorGroup parent, Executor executor,<br>                                    <span class="hljs-built_in">boolean</span> addTaskWakesUp, int maxPendingTasks,<br>                                    RejectedExecutionHandler rejectedHandler) &#123;<br>    <span class="hljs-built_in">super</span>(parent);<br>    <span class="hljs-built_in">this</span>.addTaskWakesUp = addTaskWakesUp;<br>    <span class="hljs-built_in">this</span>.maxPendingTasks = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">16</span>, maxPendingTasks);<br>    <span class="hljs-comment">// 这是当前NioEventLoop所包含的executor</span><br>    <span class="hljs-built_in">this</span>.executor = ThreadExecutorMap.apply(executor, <span class="hljs-built_in">this</span>);<br>    <span class="hljs-comment">// 创建一个任务队列</span><br>    taskQueue = newTaskQueue(<span class="hljs-built_in">this</span>.maxPendingTasks);<br>    rejectedExecutionHandler = ObjectUtil.checkNotNull(rejectedHandler, <span class="hljs-string">&quot;rejectedHandler&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里首先创建的是 SingleThreadEventExecutor ，这里重点需要关注的代码是：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">this</span>.executor = ThreadExecutorMap.apply(executor, <span class="hljs-keyword">this</span>);<br></code></pre></td></tr></table></figure><p>这里<code>this</code> 是 NioEventLoop ，所以<code>this.executor</code>就是前面说的 NioEventLoop 里的 Executor，这里我们先称为 <strong>子 Executor</strong>（子：对应的就是 NioEventLoop ，前面说的 总：对应的是 NioEventLoopGroup ）。</p><p>而这里  <strong>子 Executor</strong> 的初始化是由一个 <code>executor</code> 参数的，这个就是前面 NioEventLoopGroup 构造方法一直带入的 <strong>总 Executor</strong>。那我们继续往下跟，看看这个<strong>子 Executor</strong> 是如何完成的初始化的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Executor <span class="hljs-function"><span class="hljs-title">apply</span>(<span class="hljs-params">final Executor executor, final EventExecutor eventExecutor</span>)</span> &#123;<br>    ObjectUtil.checkNotNull(executor, <span class="hljs-string">&quot;executor&quot;</span>);<br>    ObjectUtil.checkNotNull(eventExecutor, <span class="hljs-string">&quot;eventExecutor&quot;</span>);<br>    <span class="hljs-comment">// 这里创建的executor是子executor</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Executor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-comment">// 这个execute()是子executor的execute()</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">execute</span>(<span class="hljs-params">final Runnable command</span>)</span> &#123;<br>            <span class="hljs-comment">// 这里调用了NioEventLoopGroup所包含的executor的execute()</span><br>            <span class="hljs-comment">// 即调用了“总的executor”的execute()</span><br>            executor.execute(apply(command, eventExecutor));<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码细看就会明白，这里创建的 <strong>子 Executor</strong>的创建也就是一个线程的创建，但是重点却在这个线程 Executor 的 <code>execute()</code>方法实现，只做了一件事情：就是调用 传入的 <strong>总 Executor</strong> 的 <code>execute()</code>方法。所以这里 <strong>子 Executor</strong> 做的事情就是调用 <strong>总 Executor</strong> 的 <code>execute()</code>。不要觉得这里绕，因为这还只是初始化，后面这里执行会更绕。[手动捂脸哭]</p><p>其实这里的 <code>apply(command, eventExecutor)</code>，这里再执行 <strong>总 Executor</strong> 的 <code>execute()</code> 时还是会记录当前正在执行的线程，并且再执行完成时将当前记录值删除。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Runnable <span class="hljs-function"><span class="hljs-title">apply</span>(<span class="hljs-params">final Runnable command, final EventExecutor eventExecutor</span>)</span> &#123;<br>    ObjectUtil.checkNotNull(command, <span class="hljs-string">&quot;command&quot;</span>);<br>    ObjectUtil.checkNotNull(eventExecutor, <span class="hljs-string">&quot;eventExecutor&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Runnable</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>            setCurrentEventExecutor(eventExecutor);<br>            <span class="hljs-keyword">try</span> &#123;<br>                command.run();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                setCurrentEventExecutor(<span class="hljs-literal">null</span>);<br>            &#125;<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里再 NioEventLoop 的属性 Executor 创建完成时，又去创建了一个普通任务队列<code>taskQueue = newTaskQueue(this.maxPendingTasks);</code>并且还创建了一个收尾任务队列<code>tailTasks = newTaskQueue(maxPendingTasks);</code>。这几个队列后面会说到。这里继续跟  NioEventLoop 主流程初始化。</p><p>到这我们再回去看看 <code>openSelector()</code>，这里我们要先知道 SelectorTuple ：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> static <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectorTuple</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Selector unwrappedSelector;  <span class="hljs-comment">// NIO原生selector</span><br>    <span class="hljs-keyword">final</span> Selector selector;  <span class="hljs-comment">// 优化过的selector</span><br><br>    SelectorTuple(Selector unwrappedSelector) &#123;<br>        <span class="hljs-keyword">this</span>.unwrappedSelector = unwrappedSelector;<br>        <span class="hljs-keyword">this</span>.selector = unwrappedSelector;<br>    &#125;<br><br>    SelectorTuple(Selector unwrappedSelector, Selector selector) &#123;<br>        <span class="hljs-keyword">this</span>.unwrappedSelector = unwrappedSelector;<br>        <span class="hljs-keyword">this</span>.selector = selector;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>SelectorTuple 只是一个包含两个 Selector 的内部类，用于封装优化前后的 Selector。而 <code>openSelector()</code> 方法就是为了返回 Selector 并且根据配置判断是否需要优化当前 Selector 。下面看具体代码：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-18.jpg"></p><p>而具体的优化过程有兴趣的可以自己去看看，这里只要知道，若是禁用了优化则 SelectorTuple 的优化后的 Selector 和为优化的 Selector 均为 Nio 原生的 Selector。</p><p>而这<code>io.netty.util.concurrent.MultithreadEventExecutorGroup#MultithreadEventExecutorGroup(int, java.util.concurrent.Executor, io.netty.util.concurrent.EventExecutorChooserFactory, java.lang.Object...)</code>后面还有在 NioEventLoop 数组创建完成后，还有选择器创建和关闭监听器绑定等，感兴趣可以自己看看，这里不再介绍。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-19.jpg"></p><p>到这一个 NioEventLoop 的创建过程的代码也全部看完了。我想如果只看这个肯定还是有点懵，源码这个东西需要自己跟进去去看，debug 一点点的跟，跟着运行的代码去想为何这么实现，不过这里我也画个图，让大家更直观的了解到 NioEventLoopGroup 的创建流程以及主要操作。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-20.jpg"></p><p>我想大家结合这个图，再结合上面的分析过程，最好可以自己找到源码，跟一遍，应该可以理解 NioEvnetLoopGroup 的创建。</p><h3 id="ServerBootstrap与-ServerBootstrap-属性配置分析"><a href="#ServerBootstrap与-ServerBootstrap-属性配置分析" class="headerlink" title="ServerBootstrap与 ServerBootstrap 属性配置分析"></a>ServerBootstrap与 ServerBootstrap 属性配置分析</h3><p>继承体系：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-21.jpg"></p><p>入口代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span><br>ServerBootstrap b = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ServerBootstrap()</span>;<br><span class="hljs-comment">//3.给引导类配置两大线程组,确定了线程模型</span><br>b.group(bossGroup, workerGroup)<br>    <span class="hljs-comment">// (非必备)打印日志</span><br>    .handler(<span class="hljs-keyword">new</span> <span class="hljs-constructor">LoggingHandler(LogLevel.INFO)</span>)<br>    <span class="hljs-comment">// 4.指定 IO 模型</span><br>    .channel(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NioServerSocketChannel</span>.</span></span><span class="hljs-keyword">class</span>)<br>    .child<span class="hljs-constructor">Handler(<span class="hljs-params">new</span> ChannelInitializer&lt;SocketChannel&gt;()</span> &#123;<br>        @Override<br>        public void init<span class="hljs-constructor">Channel(SocketChannel <span class="hljs-params">ch</span>)</span> &#123;<br>            ChannelPipeline p = ch.pipeline<span class="hljs-literal">()</span>;<br>            <span class="hljs-comment">//5.可以自定义客户端消息的业务处理逻辑</span><br>            p.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> HelloServerHandler()</span>);<br>        &#125;<br>    &#125;);<br><br>Bootstrap bootstrap = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Bootstrap()</span>;<br>bootstrap.group(eventLoopGroup)<br>    .channel(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NioSocketChannel</span>.</span></span><span class="hljs-keyword">class</span>)<br>    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;<span class="hljs-literal">()</span> &#123;<br>        @Override<br>        protected void init<span class="hljs-constructor">Channel(SocketChannel <span class="hljs-params">ch</span>)</span> throws Exception &#123;<br>            ChannelPipeline pipeline = ch.pipeline<span class="hljs-literal">()</span>;<br>            pipeline.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> StringDecoder(CharsetUtil.UTF_8)</span>);<br>            pipeline.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> StringEncoder(CharsetUtil.UTF_8)</span>);<br>            pipeline.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> SomeSocketClientHandler()</span>);<br>        &#125;<br>    &#125;);<br></code></pre></td></tr></table></figure><p>ServerBootstrap与 Bootstrap 都是启动配置类，唯一不同的是，ServerBootstrap是服务端的启动配置类，Bootstrap  则是客户端的启动配置类，主要用于绑定我们创建的 EventLoopGroup，指定 Channel 的类型以及绑定 Channel 处理器等操作，主要做的都是给 ServerBootstrap与 Bootstrap  的属性赋值操作，所以称其为配置类。可以进入 <code>group()</code> 方法里看一眼：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> ServerBootstrap <span class="hljs-function"><span class="hljs-title">group</span>(<span class="hljs-params">EventLoopGroup parentGroup, EventLoopGroup childGroup</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>.group(parentGroup);<br>    <span class="hljs-keyword">if</span> (childGroup == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;childGroup&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.childGroup != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;childGroup set already&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.childGroup = childGroup;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其他的方法也是一样，感兴趣可以自己进去看看。这里只是初始化，都是为了后面的操作做准备。</p><h3 id="服务端-bind-方法-ServerBootstrap-bind-源码解析"><a href="#服务端-bind-方法-ServerBootstrap-bind-源码解析" class="headerlink" title="服务端 bind 方法 ServerBootstrap.bind() 源码解析"></a>服务端 bind 方法 ServerBootstrap.bind() 源码解析</h3><p>这里我们从这里进入：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.bind</span>(<span class="hljs-selector-tag">port</span>)<span class="hljs-selector-class">.sync</span>();<br></code></pre></td></tr></table></figure><p>直接从 <code>bind()</code>方法跟进去：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// io.netty.bootstrap.AbstractBootstrap#bind(int)</span><br><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-function"><span class="hljs-title">bind</span>(<span class="hljs-params">int inetPort</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> bind(<span class="hljs-keyword">new</span> InetSocketAddress(inetPort));<br>&#125;<br><br><span class="hljs-comment">// 继续跟进</span><br><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-function"><span class="hljs-title">bind</span>(<span class="hljs-params">SocketAddress localAddress</span>)</span> &#123;<br>    <span class="hljs-comment">// 验证group与channelFactory是否为null</span><br>    validate(); <br>    <span class="hljs-keyword">if</span> (localAddress == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;localAddress&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 这里是一处重点逻辑</span><br>    <span class="hljs-keyword">return</span> doBind(localAddress);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里显示校验了 Bootstrap 的 group 与 channelFactory 是否绑定成功。然后继续跟进 <code>doBind()</code> 方法：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> ChannelFuture <span class="hljs-keyword">do</span><span class="hljs-constructor">Bind(<span class="hljs-params">final</span> SocketAddress <span class="hljs-params">localAddress</span>)</span> &#123;<br>    <span class="hljs-comment">// 创建、初始化channel，并将其注册到selector，返回一个异步结果</span><br>    final ChannelFuture regFuture = init<span class="hljs-constructor">AndRegister()</span>;<br>    <span class="hljs-comment">// 从异步结果中获取channel</span><br>    final Channel channel = regFuture.channel<span class="hljs-literal">()</span>;<br>    <span class="hljs-comment">// 若异步操作执行过程中出现了异常，则直接返回异步对象（直接结束）</span><br>    <span class="hljs-keyword">if</span> (regFuture.cause<span class="hljs-literal">()</span> != null) &#123;<br>        return regFuture;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理异步操作完成的情况（可能是正常结束，或发生异常，或任务取消，这些情况都属于有结果的情况）</span><br>    <span class="hljs-keyword">if</span> (regFuture.is<span class="hljs-constructor">Done()</span>) &#123;<br>        ChannelPromise promise = channel.<span class="hljs-keyword">new</span><span class="hljs-constructor">Promise()</span>;<br>        <span class="hljs-comment">// 绑定指定的端口</span><br>        <span class="hljs-keyword">do</span><span class="hljs-constructor">Bind0(<span class="hljs-params">regFuture</span>, <span class="hljs-params">channel</span>, <span class="hljs-params">localAddress</span>, <span class="hljs-params">promise</span>)</span>;<br>        return promise;<br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 处理异步操作尚未有结果的情况</span><br>        final PendingRegistrationPromise promise = <span class="hljs-keyword">new</span> <span class="hljs-constructor">PendingRegistrationPromise(<span class="hljs-params">channel</span>)</span>;<br>        <span class="hljs-comment">// 为异步操作添加监听</span><br>        regFuture.add<span class="hljs-constructor">Listener(<span class="hljs-params">new</span> ChannelFutureListener()</span> &#123;<br>            <span class="hljs-comment">// 若异步操作具有了结果（即完成），则触发该方法的执行</span><br>            @Override<br>            public void operation<span class="hljs-constructor">Complete(ChannelFuture <span class="hljs-params">future</span>)</span> throws Exception &#123;<br>                Throwable cause = future.cause<span class="hljs-literal">()</span>;<br>                <span class="hljs-keyword">if</span> (cause != null) &#123; <span class="hljs-comment">// 异步操作执行过程中出现了问题</span><br>                    promise.set<span class="hljs-constructor">Failure(<span class="hljs-params">cause</span>)</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 异步操作正常结果</span><br>                    promise.registered<span class="hljs-literal">()</span>;<br>                    <span class="hljs-comment">// 绑定指定的端口</span><br>                    <span class="hljs-keyword">do</span><span class="hljs-constructor">Bind0(<span class="hljs-params">regFuture</span>, <span class="hljs-params">channel</span>, <span class="hljs-params">localAddress</span>, <span class="hljs-params">promise</span>)</span>;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        return promise;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先再这里，我们先把这个方法整体的逻辑搞清楚，然后再再去研究他的每一步具体的操作，画个图，先理解这个方法做了什么：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-22.jpg"></p><p>可以在图中结合代码，找到整个 <code>dobind()</code> 的大局处理思路，然后呢，到这里我们还有很多重点细节需要继续跟进，也就是图中标记的 Tag 1、Tag 2。为了方便后面跟进去代码之后方便回来，这里以此标记，然后下面在具体分析 Tag 标记的源码：</p><blockquote><p><strong>补充 Tag 0 ：</strong></p><p>ChannelPromise 与 ChannelFuture 了解。</p><p><strong>Tag 1 ：</strong></p><p>异步创建、初始化channel，并将其注册到selector</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">final ChannelFuture regFuture</span> = initAndRegister();<br></code></pre></td></tr></table></figure><p><strong>Tag 2 ：</strong></p><p>绑定指定的端口号：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">do</span><span class="hljs-constructor">Bind0(<span class="hljs-params">regFuture</span>, <span class="hljs-params">channel</span>, <span class="hljs-params">localAddress</span>, <span class="hljs-params">promise</span>)</span>;<br></code></pre></td></tr></table></figure></blockquote><h4 id="补充-Tag-0：ChannelPromise-与-ChannelFuture"><a href="#补充-Tag-0：ChannelPromise-与-ChannelFuture" class="headerlink" title="补充 Tag 0：ChannelPromise 与 ChannelFuture"></a>补充 Tag 0：ChannelPromise 与 ChannelFuture</h4><p>ChannelPromise 是一个特殊的 ChannelFuture，是一个可修改的 ChannelFuture。内部提供了修改当前 Future 状态的方法。在 ChannelFuture 的基础上实现了设置最终状态的修改方法。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-23.jpg"></p><p>而 ChannelFuture 只可以查询当前异步操作的结果，不可以修改当前异步结果的 Future 。这里需要知道的就是 ChannelPromise 可以修改当前异步结果的状态，并且在修改状态是会触发监听器。在 <code>doBind</code> 方法中主要用于在处理异步执行一直未结束的的操作，将异步结果存在异常的时，将异常赋值给 ChannelPromise 并返回。</p><h4 id="Tag-1-：initAndRegister-初始化并注册-Channel"><a href="#Tag-1-：initAndRegister-初始化并注册-Channel" class="headerlink" title="Tag 1 ：initAndRegister() 初始化并注册 Channel"></a>Tag 1 ：initAndRegister() 初始化并注册 Channel</h4><p>先找到代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript">final ChannelFuture <span class="hljs-function"><span class="hljs-title">initAndRegister</span>(<span class="hljs-params"></span>)</span> &#123;<br>    Channel channel = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建channel</span><br>        channel = channelFactory.newChannel();<br>        <span class="hljs-comment">// 初始化channel</span><br>        init(channel);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-keyword">if</span> (channel != <span class="hljs-literal">null</span>) &#123;<br>            channel.unsafe().closeForcibly();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultChannelPromise(<span class="hljs-keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);<br>    &#125;<br><br>    <span class="hljs-comment">// 将channel注册到selector</span><br>    ChannelFuture regFuture = config().group().register(channel);<br>    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (channel.isRegistered()) &#123;<br>            channel.close();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            channel.unsafe().closeForcibly();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> regFuture;<br>&#125;<br></code></pre></td></tr></table></figure><p>嗯？！代码意一看，咋就这么点，也就做了三件事，可是这三件事做的每一个都不是一句代码的可以完成的。这里我们一个一个分析，除了这三件事情，其他的也就是异常后的处理逻辑，所以主流程就是下面的三句代码，也为了跟进继续打上标记吧：</p><blockquote><p><strong>Tag 1.1  创建channel</strong>channel = channelFactory.newChannel();</p><p><strong>Tag 1.2 初始化channel</strong>init(channel);</p><p><strong>Tag 1.3  将channel注册到selector</strong>ChannelFuture regFuture = config().group().register(channel);</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-24.jpg"></p><p>针对这三处，还是要一处一处分析。</p><h5 id="Tag-1-1-channelFactory-newChannel-创建-Channel"><a href="#Tag-1-1-channelFactory-newChannel-创建-Channel" class="headerlink" title="Tag 1.1  channelFactory.newChannel()  创建 Channel"></a>Tag 1.1  channelFactory.newChannel()  创建 Channel</h5><p>找到对应的代码：<code>io.netty.channel.ReflectiveChannelFactory#newChannel</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> T <span class="hljs-function"><span class="hljs-title">newChannel</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 调用无参构造器创建channel</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title">constructor</span>.<span class="hljs-title">newInstance</span>(<span class="hljs-params"></span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ChannelException(<span class="hljs-string">&quot;Unable to create Channel from class &quot;</span> + <span class="hljs-title">constructor</span>.<span class="hljs-title">getDeclaringClass</span>(<span class="hljs-params"></span>), <span class="hljs-title">t</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里为什么直接找到 ReflectiveChannelFactory ，需要提一下，在分析 ServerBootstrap与 Bootstrap 启动配置类的时候，设置 channel 的方法，跟进去可以找到针对属性 channelFactory 的赋值代码：</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs monkey"><span class="hljs-keyword">public</span> B channel(<span class="hljs-class"><span class="hljs-keyword">Class</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title">C</span>&gt; <span class="hljs-title">channelClass</span>) &#123;</span><br>    <span class="hljs-keyword">if</span> (channelClass == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;channelClass&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> channelFactory(<span class="hljs-keyword">new</span> ReflectiveChannelFactory&lt;C&gt;(channelClass));<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这里 new 的就是 ReflectiveChannelFactory 工厂类，然后再看 ReflectiveChannelFactory 的构造：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-constructor">ReflectiveChannelFactory(Class&lt;? <span class="hljs-params">extends</span> T&gt; <span class="hljs-params">clazz</span>)</span> &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ObjectUtil</span>.</span></span>check<span class="hljs-constructor">NotNull(<span class="hljs-params">clazz</span>, <span class="hljs-string">&quot;clazz&quot;</span>)</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 将NioServerSocketChannel的无参构造器初始化到constructor</span><br>        this.constructor = clazz.get<span class="hljs-constructor">Constructor()</span>;<br>    &#125; catch (NoSuchMethodException e) &#123;<br>        throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">IllegalArgumentException(<span class="hljs-string">&quot;Class &quot;</span> + StringUtil.<span class="hljs-params">simpleClassName</span>(<span class="hljs-params">clazz</span>)</span> +<br>                                           <span class="hljs-string">&quot; does not have a public non-arg constructor&quot;</span>, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到的是 ReflectiveChannelFactory 在创建时初始化了 constructor 属性，将传入的 channel 类 clazz 中获取构造赋值给了 ReflectiveChannelFactory 反射工厂的 constructor 属性。</p><p>而我们再 Server  端传入的 channel 类为<code>NioServerSocketChannel.class</code> ，所以上面看的 <code>constructor.newInstance();</code> 对应的也就是 NioServerSocketChannel 的无参构造。这样我们就继续跟进 NioServerSocketChannel ：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// NIO中的provider，其用于创建selector与channel。并且是单例的</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider();<br><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">NioServerSocketChannel</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// DEFAULT_SELECTOR_PROVIDER 静态变量</span><br>    <span class="hljs-built_in">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));<br>&#125;<br></code></pre></td></tr></table></figure><p>继续跟进 <code>newSocket()</code> ：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ServerSocketChannel <span class="hljs-function"><span class="hljs-title">newSocket</span>(<span class="hljs-params">SelectorProvider provider</span>)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123; <br>        <span class="hljs-comment">// 创建NIO原生的channel =&gt; ServerSocketChannel</span><br>        <span class="hljs-keyword">return</span> provider.openServerSocketChannel();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ChannelException(<br>            <span class="hljs-string">&quot;Failed to open a server socket.&quot;</span>, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>就是返回了一个 Java NIO 原生的 Channel，最后将 NIO 原生的Channel 包装成 NioServerSocketChannel，继续跟进 <code>this(newSocket(DEFAULT_SELECTOR_PROVIDER))</code> 找到有参构造具体代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">NioServerSocketChannel</span>(<span class="hljs-params">ServerSocketChannel channel</span>)</span> &#123;<br>    <span class="hljs-comment">// 参数1：父channel</span><br>    <span class="hljs-comment">// 参数2：NIO原生channel</span><br>    <span class="hljs-comment">// 参数3：指定当前channel所关注的事件为  接受连接</span><br>    <span class="hljs-built_in">super</span>(<span class="hljs-literal">null</span>, channel, SelectionKey.OP_ACCEPT);<br>    <span class="hljs-comment">// 用于对channel进行配置的属性集合</span><br>    config = <span class="hljs-keyword">new</span> NioServerSocketChannelConfig(<span class="hljs-built_in">this</span>, javaChannel().socket());<br>&#125;<br></code></pre></td></tr></table></figure><p>这里主要做了两件事情，1. 调用父类构造，2. 对 channel 进行配置属性集合。</p><p>这里先说下 new NioServerSocketChannelConfig()，这部操作就是给当前 Channel 的 config 进行赋值，用来保存当前 Channel 的属性配置的集合。好了，这个说了我们继续跟主线：<code>super(null, channel, SelectionKey.OP_ACCEPT)</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// io.netty.channel.nio.AbstractNioMessageChannel#AbstractNioMessageChannel</span><br><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-title">AbstractNioMessageChannel</span>(<span class="hljs-params">Channel parent, SelectableChannel ch, int readInterestOp</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(parent, ch, readInterestOp);<br>&#125;<br><br><span class="hljs-comment">// io.netty.channel.nio.AbstractNioChannel#AbstractNioChannel</span><br><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-title">AbstractNioChannel</span>(<span class="hljs-params">Channel parent, SelectableChannel ch, int readInterestOp</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(parent);<br>    <span class="hljs-comment">// 这里的this.ch为NIO原生channel</span><br>    <span class="hljs-built_in">this</span>.ch = ch;<br>    <span class="hljs-built_in">this</span>.readInterestOp = readInterestOp;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// NIO，非阻塞</span><br>        ch.configureBlocking(<span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ch.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e2) &#123;<br>            <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;<br>                logger.warn(<br>                    <span class="hljs-string">&quot;Failed to close a partially initialized socket.&quot;</span>, e2);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ChannelException(<span class="hljs-string">&quot;Failed to enter non-blocking mode.&quot;</span>, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接找到 AbstractNioChannel 父类构造，这也第一步也是调用父类构造 <code>super(parent);</code> 先记着，先看除了调用父类构造还做了什么事情：</p><blockquote><ol><li>调用父类构造 super(parent);</li><li>将前面创建的原生 Channel 复制给属性保存 this.ch = ch;</li><li>当前 channel 的关注事件属性赋值 this.readInterestOp = readInterestOp;  //  SelectionKey.OP_ACCEPT 接受事件</li><li>将 NIO 原生 Channel 设置为非阻塞 ch.configureBlocking(false);</li></ol></blockquote><p>在 AbstractNioChannel  构造中就做了这么四件事情，主要需要说的还是其调用父类构造又做了什么事情，找到代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// io.netty.channel.AbstractChannel#AbstractChannel(io.netty.channel.Channel)</span><br>protected <span class="hljs-constructor">AbstractChannel(Channel <span class="hljs-params">parent</span>)</span> &#123;<br>    this.parent = parent;<br>    <span class="hljs-comment">// 为channel生成id，由五部分构成</span><br>    id = <span class="hljs-keyword">new</span><span class="hljs-constructor">Id()</span>;<br>    <span class="hljs-comment">// 生成一个底层操作对象unsafe</span><br>    unsafe = <span class="hljs-keyword">new</span><span class="hljs-constructor">Unsafe()</span>;<br>    <span class="hljs-comment">// 创建与这个channel相绑定的channelPipeline</span><br>    pipeline = <span class="hljs-keyword">new</span><span class="hljs-constructor">ChannelPipeline()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 AbstractChannel 构造中主要做了三件事：</p><blockquote><ol><li>为当前 Channel 生成 id  <code>newId()</code>，感兴趣可以跟进去看看。</li><li>生成一个底层操作对象 unsafe，用于 I/O 线程调用传输时使用，用户代码无法调用。<code>newUnsafe()</code></li><li>创建与这个channel相绑定的channelPipeline，这也是一个重点操作，不过在这里先不展开细说，后面会单独细跟 channelPipeline 的代码。</li></ol></blockquote><p>所以到此 <strong>Tag 1 : initAndRegister()  ** 中的 **Tag 1.1 newChannel() ** 创建 Channel 才算跟完。针对 **Tag 1.1 newChannel()</strong> 我们也画图简图整理下思路：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-25.jpg"></p><p>根据图，在结合上面代码的分析，最好自己再可以跟一遍代码，我想这一块的理解还是没什么问题的。到这也只是创建了 Channel。<strong>Tag 1.1 的 Channel 创建</strong>结束，接着跟进 <strong>Tag 1.2 init(channel)</strong>.</p><h5 id="Tag-1-2-init-channel-初始化-Channel"><a href="#Tag-1-2-init-channel-初始化-Channel" class="headerlink" title="Tag 1.2  init(channel)  初始化 Channel"></a>Tag 1.2  init(channel)  初始化 Channel</h5><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-26.jpg"></p><p>这里我们是从 ServerBootstrap 中的doBind 进入的，所以这里直接找到 <code>io.netty.bootstrap.ServerBootstrap#init</code></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Channel channel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// 获取serverBootstrap中的options属性</span><br>    <span class="hljs-keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();<br>    <span class="hljs-comment">// 将options属性设置到channel</span><br>    <span class="hljs-keyword">synchronized</span> (options) &#123;<br>        setChannelOptions(channel, options, logger);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取serverBootstrap中的attrs属性</span><br>    <span class="hljs-keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();<br>    <span class="hljs-keyword">synchronized</span> (attrs) &#123;<br>        <span class="hljs-comment">// 遍历attrs属性</span><br>        <span class="hljs-keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;<br>            <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">&quot;unchecked&quot;</span>)<br>            AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();<br>            <span class="hljs-comment">// 将当前遍历的attr初始化到channel</span><br>            channel.attr(key).set(e.getValue());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取channel的pipeline</span><br>    ChannelPipeline p = channel.pipeline();<br><br>    <span class="hljs-comment">// 将serverBootstrap中所有以child开头的属性写入到局部变量，</span><br>    <span class="hljs-comment">// 然后将它们初始化到childChannel中</span><br>    <span class="hljs-keyword">final</span> EventLoopGroup currentChildGroup = childGroup;<br>    <span class="hljs-keyword">final</span> ChannelHandler currentChildHandler = childHandler;<br>    <span class="hljs-keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;<br>    <span class="hljs-keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;<br>    <span class="hljs-keyword">synchronized</span> (childOptions) &#123;<br>        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(<span class="hljs-number">0</span>));<br>    &#125;<br>    <span class="hljs-keyword">synchronized</span> (childAttrs) &#123;<br>        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(<span class="hljs-number">0</span>));<br>    &#125;<br><br>    p.addLast(<span class="hljs-keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            <span class="hljs-keyword">final</span> ChannelPipeline pipeline = ch.pipeline();<br>            ChannelHandler <span class="hljs-keyword">handler</span> = config.<span class="hljs-keyword">handler</span>();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">handler</span> != <span class="hljs-keyword">null</span>) &#123;<br>                pipeline.addLast(<span class="hljs-keyword">handler</span>);<br>            &#125;<br><br>            ch.eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-comment">// 将ServerBootstrapAcceptor处理器添加到pipeline</span><br>                    <span class="hljs-comment">// ServerBootstrapAcceptor处理器用于接收ServerBootstrap中的属性值，</span><br>                    <span class="hljs-comment">// 我们通常称其为连接处理器</span><br>                    pipeline.addLast(<span class="hljs-keyword">new</span> ServerBootstrapAcceptor(<br>                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里做的事情还是很多的，基本操作我在上面注释上也标注出来，还有一些需要继续跟下去的主要操作，还是先标记 <strong>Tag</strong> 然后继续跟下去。这里说一下这里的 options 与 attrs 属性的赋值，其实就是讲我们 ServerBootstrap 与  Bootstrap 在调用 <code>doBind()</code> 之前通过  <code>option()</code> 与 <code>attr()</code> 设置的参数值，其中 options  属性设置到了 Channel 的 config 属性中，attrs 是直接被设置在了 Channel 上的。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-27.jpg"></p><p>在设置完 options 属性与 attrs 属性时，接着获取了当前 channel 的 pipeline，接下来还是获取我们在 <code>doBind()</code> 之前设置的属性值，以 child 开头的方法 <code>childOption()</code> 与 <code>childAttr()</code> 设置的属性值。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-28.jpg"></p><p>这里使用局部变量记录了所有 Child 相关的值 <code>currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs</code> 主要用于初始化 childChannel 的属性，<code>new ServerBootstrapAcceptor(ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs))</code> 主要是创建 连接处理器。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">p.addLast(<span class="hljs-keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            <span class="hljs-keyword">final</span> ChannelPipeline pipeline = ch.pipeline();<br>            ChannelHandler <span class="hljs-keyword">handler</span> = config.<span class="hljs-keyword">handler</span>();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">handler</span> != <span class="hljs-keyword">null</span>) &#123;<br>                pipeline.addLast(<span class="hljs-keyword">handler</span>);<br>            &#125;<br><br>            ch.eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-comment">// 将ServerBootstrapAcceptor处理器添加到pipeline</span><br>                    <span class="hljs-comment">// ServerBootstrapAcceptor处理器用于接收ServerBootstrap中的属性值，</span><br>                    <span class="hljs-comment">// 我们通常称其为连接处理器</span><br>                    pipeline.addLast(<span class="hljs-keyword">new</span> ServerBootstrapAcceptor(<br>                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;);<br></code></pre></td></tr></table></figure><blockquote><p>首先这里想做的事情是：将当前 channel 的 pipeline 中绑定一个初始化处理器 ChannelInitializer ，因为是抽象类，所以需要匿名实现 initChannel方法。而这些主要的操作是处理 childGroup 里面的 channel 的初始化操作。这里我只想主要讲一下这个连接处理器 ServerBootstrapAcceptor 主要做了什么，其他的具体会在后面的 handler 和 pipeline 的时候细说。</p><p><strong>补充：</strong>这里因为 ServerBootstrap 服务端是对用的有两个 EventLoopGroup，在服务端，parentGroup 是用于接收客户端的连接，在 parentGroup 接收到连接之后是将只是将当前转给了 childGroup去处理后续操作，而 childGroup 是用来专门处理连接后的操作的，不关心 channel 的连接任务。<strong>这个其实就是 Netty-Server 的 Reactor 线程池模型的处理逻辑。</strong></p></blockquote><p>这里主要往下说一下这个连接处理器：ServerBootstrapAcceptor 。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript">ServerBootstrapAcceptor(<br>    final Channel channel, EventLoopGroup childGroup, ChannelHandler childHandler,<br>    Entry&lt;ChannelOption&lt;?&gt;, <span class="hljs-built_in">Object</span>&gt;[] childOptions, Entry&lt;AttributeKey&lt;?&gt;, <span class="hljs-built_in">Object</span>&gt;[] childAttrs) &#123;<br>    <span class="hljs-built_in">this</span>.childGroup = childGroup;<br>    <span class="hljs-built_in">this</span>.childHandler = childHandler;<br>    <span class="hljs-built_in">this</span>.childOptions = childOptions;<br>    <span class="hljs-built_in">this</span>.childAttrs = childAttrs;<br><br>    <span class="hljs-comment">// See https://github.com/netty/netty/issues/1328</span><br>    enableAutoReadTask = <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Runnable</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>            channel.config().setAutoRead(<span class="hljs-literal">true</span>);<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>ServerBootstrapAcceptor  构造只是将 ServerBootstrap 中配置的 Child 属性设置保存下来。而这里一直说这是连接处理器，是因为当客户端连接发送到服务端时，这个处理器会接收客户端的连接并处理。主要是处理方法是 channelRead 中的实现：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void channel<span class="hljs-constructor">Read(ChannelHandlerContext <span class="hljs-params">ctx</span>, Object <span class="hljs-params">msg</span>)</span> &#123;<br>    <span class="hljs-comment">// msg为客户端发送来的数据，其为NioSocketChannel，即子channel，childChannel</span><br>    final Channel child = (Channel) msg;<br><br>    <span class="hljs-comment">// 将来自于ServerBootstrap的child开头属性初始化到childChannel中（childHandler、childOptions、childAttrs）</span><br>    child.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">childHandler</span>)</span>;<br>    set<span class="hljs-constructor">ChannelOptions(<span class="hljs-params">child</span>, <span class="hljs-params">childOptions</span>, <span class="hljs-params">logger</span>)</span>;<br>    <span class="hljs-keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;<br>        child.attr((AttributeKey&lt;Object&gt;) e.get<span class="hljs-constructor">Key()</span>).set(e.get<span class="hljs-constructor">Value()</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 将childChannel注册到selector 需要注意的是，这里的selector与父channel所注册的selector不是同一个</span><br>        childGroup.register(child).add<span class="hljs-constructor">Listener(<span class="hljs-params">new</span> ChannelFutureListener()</span> &#123;<br>            @Override<br>            public void operation<span class="hljs-constructor">Complete(ChannelFuture <span class="hljs-params">future</span>)</span> throws Exception &#123;<br>                <span class="hljs-keyword">if</span> (!future.is<span class="hljs-constructor">Success()</span>) &#123;<br>                    force<span class="hljs-constructor">Close(<span class="hljs-params">child</span>, <span class="hljs-params">future</span>.<span class="hljs-params">cause</span>()</span>);<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125; catch (Throwable t) &#123;<br>        force<span class="hljs-constructor">Close(<span class="hljs-params">child</span>, <span class="hljs-params">t</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里主要就做了两件事情：</p><blockquote><ol><li>初始化 childChannel</li><li>将成功从 client 连接过来的 channel 注册到 selector 上。</li></ol></blockquote><p>这里一直说子channel，就是因为这里注册的是两个 EventLoopGroup，在 Server 端的处理上 netty 线程模型采用“服务端监听线程”和“IO线程”分离的方式。所以这里 <code>channelRead</code> 方法就是在 client 端请求连接到 server 端时，用于将当前连接的 IO 线程绑定到 childChannel 同时注册到 ChildGroup 中的 Selector 中。线程，模型可以参考下面的图：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-29.jpg"></p><p>好了，到这里 **Tag 1.2 initChannel ** 代码也分析完了，有些关于 pipeline 、handler、selector 的部分没有细说因为后面会单独说，在这里没有直接展开。</p><p>这里也画个图：到时候将这些图在整合到一起，现在是的分析过程就像是化整为零，最后在整合到一起化零为整。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-30.jpg"></p><p>这里除了 init(channel) 方法之外，还主要说了下 ServerBootstrapAcceptor 连接处理器。其实主要是 netty-server 的线程模型与代码的结合理解。</p><h5 id="Tag-1-3-config-group-register-channel-将channel注册到selector"><a href="#Tag-1-3-config-group-register-channel-将channel注册到selector" class="headerlink" title="Tag 1.3  config().group().register(channel)  将channel注册到selector"></a>Tag 1.3  config().group().register(channel)  将channel注册到selector</h5><p>channle 注册到 Selector 的代码分析：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// </span><br><span class="hljs-selector-tag">config</span>()<span class="hljs-selector-class">.group</span>()<span class="hljs-selector-class">.register</span>(channel);<br></code></pre></td></tr></table></figure><p>config().group() ：这里就是 Bootstrap 的 EventLoopGroup，而这里是 Server 端的 ServerBootstrap 所以这个其实就是 parentGroup。那这里我们需要找到 register 的方法实现：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-31.jpg"></p><p>这里因为 group 是 NioEventLoopGroup，根据 NioEventLoopGroup 的继承体系就可以直接找到 实现 <code>io.netty.channel.MultithreadEventLoopGroup#register(io.netty.channel.Channel)</code>。因为只有 MultithreadEventLoopGroup 在其继承体系中。所以找到代码我们继续：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">register</span><span class="hljs-params">(Channel channel)</span> </span>&#123;<br>    <span class="hljs-comment">// next() 从eventLoop数组中选择一个eventLoop</span><br>    <span class="hljs-keyword">return</span> next().<span class="hljs-keyword">register</span>(channel);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要了解下 <code>next()</code> 方法，因为我们现在是 eventLoopGroup <code>next()</code> 就是从当前 group 中获取一个 EventLoop，然后这里在继续跟进需要找 EventLoop 继承体系中实现 register 方法的类：<code>SingleThreadEventLoop</code></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-32.jpg"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">register</span><span class="hljs-params">(Channel channel)</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个 ChannelPromise 然后注册</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">register</span>(<span class="hljs-keyword">new</span> DefaultChannelPromise(channel, <span class="hljs-keyword">this</span>));<br>&#125;<br><br><span class="hljs-comment">// ----&gt; 这里继续调用 unsafe 的 register</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">register</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;<br>    ObjectUtil.checkNotNull(promise, <span class="hljs-string">&quot;promise&quot;</span>);<br>    promise.channel().unsafe().<span class="hljs-keyword">register</span>(<span class="hljs-keyword">this</span>, promise);<br>    <span class="hljs-keyword">return</span> promise;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里调用的 unsafe 的 register 方法，在初始化 eventLoop 的时候说过这个 unsafe 的初始化。是我们直接跟进：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs typescript">io.netty.channel.AbstractChannel.AbstractUnsafe#register<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> final <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">register</span>(<span class="hljs-params">EventLoop eventLoop, final ChannelPromise promise</span>)</span> &#123;<br>    <span class="hljs-comment">// 对异常情况的处理</span><br>    <span class="hljs-keyword">if</span> (eventLoop == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;eventLoop&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (isRegistered()) &#123;<br>        promise.setFailure(<span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;registered to an event loop already&quot;</span>));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!isCompatible(eventLoop)) &#123;<br>        promise.setFailure(<br>            <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;incompatible event loop type: &quot;</span> + eventLoop.getClass().getName()));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// channel与eventLoop的绑定就发生在这里，</span><br>    <span class="hljs-comment">// 需要注意，这里的eventLoop还没有绑定线程，因为这个线程还没有创建</span><br>    AbstractChannel.this.eventLoop = eventLoop;<br>    <span class="hljs-comment">// 判断当前线程与eventLoop所绑定线程是否是同一个线程</span><br>    <span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;<br>        register0(promise);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 执行当前线程所绑定的eventLoop的execute(), 这个execute()会将参数任务写入到任务队列，并创建启动新的线程</span><br>            eventLoop.execute(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Runnable</span>(<span class="hljs-params"></span>)</span> &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>                    register0(promise);<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            logger.warn(<br>                <span class="hljs-string">&quot;Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;&quot;</span>,<br>                AbstractChannel.this, t);<br>            closeForcibly();<br>            closeFuture.setClosed();<br>            safeSetFailure(promise, t);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>AbstractUnsafe#register:</p><ol><li>首先判断当前操作是否存在异常情况。</li><li>将 eventLoop 保存到 channel 的 eventLoop 的属性中（channel 与 eventLoop 的绑定），注意：这里的 eventLoop 里面还没有绑定 thread。</li><li>判断 EventLoop 的 thread 是否是当前线程：eventLoop.inEventLoop()。这里断点看一下，初始化的时候这里 eventLoop 中的 thread = null。所以这里返回 false。</li><li>执行当前线程绑定的 eventLoop 的 excute() 方法。执行传入的 runnable ，主要是做的是将参数任务写入到任务队列，并创建启动新的线程</li><li>runnable 中的 run 方法实现：register0(promise);</li></ol><p>这里标记三个 <strong>Tag</strong></p><p><strong>Tag 1.3.1  register0(promise)</strong> 也就是上面的第 5 步。</p><p><strong>Tag 1.3.2  eventLoop.excute() 执行分析</strong> 也就是上面的第 4 步。</p><p><strong>Tag 1.3.3  eventLoop.excute() 的 run 方法执行分析 ** 也就是 **Tag 1.3.2</strong> 最后执行起来的 run 方法</p></blockquote><h6 id="Tag-1-3-1-register0-promise"><a href="#Tag-1-3-1-register0-promise" class="headerlink" title="Tag 1.3.1  register0(promise)"></a><strong>Tag 1.3.1  register0(promise)</strong></h6><p>直接跟进 <code>register0(promise);</code></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void register0(ChannelPromise promise) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (!promise.set<span class="hljs-constructor">Uncancellable()</span><span class="hljs-operator"> || </span>!ensure<span class="hljs-constructor">Open(<span class="hljs-params">promise</span>)</span>) &#123;<br>            return;<br>        &#125;<br>        boolean firstRegistration = neverRegistered;<br>        <span class="hljs-keyword">do</span><span class="hljs-constructor">Register()</span>;  <span class="hljs-comment">// 绑定</span><br>        neverRegistered = <span class="hljs-literal">false</span>;<br>        registered = <span class="hljs-literal">true</span>;<br>        <br>        pipeline.invoke<span class="hljs-constructor">HandlerAddedIfNeeded()</span>;<br><br>        safe<span class="hljs-constructor">SetSuccess(<span class="hljs-params">promise</span>)</span>;<br>        pipeline.fire<span class="hljs-constructor">ChannelRegistered()</span>;<br>        <br>        <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">Active()</span>) &#123;<br>            <span class="hljs-keyword">if</span> (firstRegistration) &#123;<br>                pipeline.fire<span class="hljs-constructor">ChannelActive()</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (config<span class="hljs-literal">()</span>.is<span class="hljs-constructor">AutoRead()</span>) &#123;<br>                <span class="hljs-keyword">begin</span><span class="hljs-constructor">Read()</span>;<br>            &#125;<br>        &#125;<br>    &#125; catch (Throwable t) &#123;<br>        close<span class="hljs-constructor">Forcibly()</span>;<br>        closeFuture.set<span class="hljs-constructor">Closed()</span>;<br>        safe<span class="hljs-constructor">SetFailure(<span class="hljs-params">promise</span>, <span class="hljs-params">t</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里其他操作感兴趣的自己可以进去看看，这边我们主要看 register 流程，直接找 <code>doRegister();</code> 的绑定代码：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-33.jpg"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> doRegister() throws Exception &#123;<br>    <span class="hljs-built_in">boolean</span> selected = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 在这里进行了注册，将NIO原生channel注册到了NIO原生selector</span><br>            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="hljs-number">0</span>, <span class="hljs-built_in">this</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;<br>            <span class="hljs-keyword">if</span> (!selected) &#123;<br>                eventLoop().selectNow();<br>                selected = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">throw</span> e;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里就是 channel 注册 Selector 的代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">selectionKey = java<span class="hljs-constructor">Channel()</span>.register(event<span class="hljs-constructor">Loop()</span>.unwrapped<span class="hljs-constructor">Selector()</span>, <span class="hljs-number">0</span>, this)<br></code></pre></td></tr></table></figure><ol><li>javaChannel()  ：这里获取原生的 Nio Channel，跟进去可以找到这里返回的是  AbstractNioChannel#ch 的 channel。在前面 NioEventGroup 初始化的时候说过这个 NIO Channel 的初始化的过程。</li><li>然后调用  NIO Channel  的 Regsiter 方法</li><li>Regsiter 方法中首先传入的是 unwrappedSelector 前面初始化的 selector 数组。第二个参数 0 ，就是当前监听的的事件， 0  表示不关注任何事件。为什么这里子 Channel 注册的是不关注任何事件？在前面看到的 Channel 注册一个指定的关注事件：<code>SelectionKey.OP_ACCEPT</code> 连接事件，那个 channel 是 Netty 封装的 channel，哪里监听了连接事件之后，只要关注客户端的连接，当 netty 封装的 channel 获取到连接就绪的 channel 的时候就可以拿到当前 channel 需要注册事件了，然后这个时候就可以指定 原生 NIO channel 的需要关注的事件。所以这里默认不关注任何事件就是为后续修改其需要关注指定类型的就绪事件。</li></ol></blockquote><p>到这里 <code>register0</code> 的方法说完。前面还有 EventLoop 的线程 thread 的事情没有说明白，也就是  eventLoop 的 excute() 方法执行过程做了什么，返回去找到代码：<code>io.netty.channel.AbstractChannel.AbstractUnsafe#register</code></p><h6 id="Tag-1-3-2-eventLoop-excute-执行分析"><a href="#Tag-1-3-2-eventLoop-excute-执行分析" class="headerlink" title="Tag 1.3.2  eventLoop.excute() 执行分析"></a>Tag 1.3.2  eventLoop.excute() 执行分析</h6><p>前面还有 EventLoop 的线程 thread 的事情没有说明白，也就是  eventLoop 的 excute() 方法执行过程做了什么，返回去找到代码：<code>io.netty.channel.AbstractChannel.AbstractUnsafe#register</code></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs smali">// 刚刚往里面跟的是 register0 现在再说一下<span class="hljs-built_in"> execute </span><br>eventLoop.execute(new Runnable() &#123;<br>    @Override<br>   <span class="hljs-keyword"> public</span> void run() &#123;<br>        register0(promise);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>往下跟，找到 <code>io.netty.util.concurrent.SingleThreadEventExecutor#execute</code>， eventLoop 的父类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">execute</span>(<span class="hljs-params">Runnable task</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;task&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 判断当前线程与eventLoop所绑定线程是否是同一个</span><br>    <span class="hljs-built_in">boolean</span> inEventLoop = inEventLoop();<br>    <span class="hljs-comment">// 将任务添加到任务队列</span><br>    addTask(task);<br>    <span class="hljs-keyword">if</span> (!inEventLoop) &#123;<br>        <span class="hljs-comment">// 创建并启动一个线程</span><br>        startThread();<br>        <span class="hljs-keyword">if</span> (isShutdown()) &#123;<br>            <span class="hljs-built_in">boolean</span> reject = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (removeTask(task)) &#123;<br>                    reject = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (UnsupportedOperationException e) &#123;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (reject) &#123;<br>                reject();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;<br>        wakeup(inEventLoop);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>首先这个参数：**Runnable task ** 其实就是刚刚我们跟过的方法 <code>register0</code>.</p><ol><li>首先判断当前 inEventLoop();  当前线程是否是 EventLoop 中的 thtrad。这里还是 false。</li><li>将任务添加到任务队列。跟下去可以找到 <code>taskQueue.offer(task)</code> ，这里的 taskQueue 任务队列就在跟创建 eventLoop 时 newChild 中初始化创建的.</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-34.jpg"></p><blockquote><ol><li>inEventLoop = false。首先做的是：<code>startThread</code>.</li></ol></blockquote><p>继续跟进：<code>startThread()</code></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void start<span class="hljs-constructor">Thread()</span> &#123;<br>    <span class="hljs-comment">// 若当前eventLoop所绑定线程尚未启动</span><br>    <span class="hljs-keyword">if</span> (state<span class="hljs-operator"> == </span>ST_NOT_STARTED) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">STATE_UPDATER</span>.</span></span>compare<span class="hljs-constructor">AndSet(<span class="hljs-params">this</span>, ST_NOT_STARTED, ST_STARTED)</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 创建并启动一个线程</span><br>                <span class="hljs-keyword">do</span><span class="hljs-constructor">StartThread()</span>;<br>            &#125; catch (Throwable cause) &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">STATE_UPDATER</span>.</span></span>set(this, ST_NOT_STARTED);<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PlatformDependent</span>.</span></span>throw<span class="hljs-constructor">Exception(<span class="hljs-params">cause</span>)</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先判断当前 eventLoop 所绑定线程尚未启动，然后使用 CAS 修改当前线程的启动状态 ，修改成功则执行 <code>doStartThread()</code>创建并启动一个线程，继续跟：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">doStartThread</span>(<span class="hljs-params"></span>)</span> &#123;<br>    assert thread == <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 调用NioEventLoop所包含的executor的execute()</span><br>    <span class="hljs-comment">// 这个execute()会创建并启动一个线程</span><br>    executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Runnable</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>            thread = Thread.currentThread();<br>            <span class="hljs-keyword">if</span> (interrupted) &#123;<br>                thread.interrupt();<br>            &#125;<br><br>            <span class="hljs-built_in">boolean</span> success = <span class="hljs-literal">false</span>;<br>            updateLastExecutionTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 执行了一个不会停止的for，用于完成任务队列中的任务</span><br>                SingleThreadEventExecutor.this.run();<br>                success = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                logger.warn(<span class="hljs-string">&quot;Unexpected exception from an event executor: &quot;</span>, t);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 省略......</span><br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里调用了 NioEventLoop 所包含的 executor 的 execute() 方法，也就是创建线程的逻辑，后面的具体执行逻辑，下一步部分具体看。传入了一个 Runnable。主要是执行了一个 <code>SingleThreadEventExecutor.this.run();</code> 线程，用于完成任务队列的任务。后面说。这里主要说一下这个 <code>executor.execute()</code>执行的过程。</p><p>这里跟进下面代码可以找到之前 <strong>子 Executor</strong> 的初始化创建的匿名内部类：<code>io.netty.util.internal.ThreadExecutorMap#apply</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Executor <span class="hljs-function"><span class="hljs-title">apply</span>(<span class="hljs-params">final Executor executor, final EventExecutor eventExecutor</span>)</span> &#123;<br>    ObjectUtil.checkNotNull(executor, <span class="hljs-string">&quot;executor&quot;</span>);<br>    ObjectUtil.checkNotNull(eventExecutor, <span class="hljs-string">&quot;eventExecutor&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Executor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">execute</span>(<span class="hljs-params">final Runnable command</span>)</span> &#123;<br>            <span class="hljs-comment">// 这里调用了NioEventLoopGroup所包含的executor的execute()</span><br>            executor.execute(apply(command, eventExecutor));<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以 execute 方法执行的是这里的 <code>execute</code>方法：<code>executor.execute(apply(command, eventExecutor));</code></p><p>而在 ThreadExecutorMap 这里的 executor 之前在 NioEventLoopGroup 初始化的时候说了，这个 executor  是 NioEventLoopGroup 初始化过成功构造方法创建的 <strong>总 executor</strong>。然后 apply 方法又将传入的 runnable 包装成了一个新的 Runnable 。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Runnable <span class="hljs-function"><span class="hljs-title">apply</span>(<span class="hljs-params">final Runnable command, final EventExecutor eventExecutor</span>)</span> &#123;<br>    ObjectUtil.checkNotNull(command, <span class="hljs-string">&quot;command&quot;</span>);<br>    ObjectUtil.checkNotNull(eventExecutor, <span class="hljs-string">&quot;eventExecutor&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Runnable</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>            <span class="hljs-comment">// 做了线程隔离</span><br>            setCurrentEventExecutor(eventExecutor);<br>            <span class="hljs-keyword">try</span> &#123;<br>                command.run();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                setCurrentEventExecutor(<span class="hljs-literal">null</span>);<br>            &#125;<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>只是在执行 command 之前做了异步线程隔离的操作。所以到这里就是  <strong>总 executor</strong> 执行了传入了新包装的 runnable。然后我们继续跟进这里的 <code>executor.execute(apply(command, eventExecutor));</code> execute 方法。这里需要找到实现方法在这里：<code>io.netty.util.concurrent.ThreadPerTaskExecutor#execute</code></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">public void execute(Runnable <span class="hljs-keyword">command</span>) &#123;<br>   <span class="hljs-comment"> // 创建并启动一个线程</span><br>    threadFactory.newThread(<span class="hljs-keyword">command</span>).<span class="hljs-title">start</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>threadFactory 也是之前 NioEventLoopGroup 初始化的线程工厂。这里主要用到这个 <strong>总 executor</strong> 里面的线程工厂来创建线程来着。而这里的 command 就是 apply() 返回的 runnable，也就是包装后的 doStartThread 中的匿名内部类 runnable。所以这里的线程 <code>newThread(command).start()</code> 的 start 就执行了commnnd 的 run 方法。最后就执行到 doStartThread 的里面的 run 方法。</p><p>所以到这里 EventLoop 中的 thread 的创建并且启动就都这里处理完成了。</p><p>这里也画个图说下这个调用过程：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-35.jpg"></p><p>到这里我们的 eventLoop.excute() 中的创建线程并启动的流程看完了，那下面我们要单独说一下这个线程启动之后执行的 run 方法做了什么。主要就是详细说下 <code>threadFactory.newThread(command).start();</code> 这个线程启动执行执行的 run 代码的解析。</p><h6 id="Tag-1-3-3-eventLoop-excute-的-run-方法执行分析"><a href="#Tag-1-3-3-eventLoop-excute-的-run-方法执行分析" class="headerlink" title="Tag 1.3.3  eventLoop.excute() 的 run 方法执行分析"></a>Tag 1.3.3  eventLoop.excute() 的 run 方法执行分析</h6><p>入口还是从 <code>eventLoop.excute()</code> 中进去，也就是 eventLoop 的 run 方法执行分析，找到里面的匿名内部类的 runnable 的实现：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//  对应的代码位置 io.netty.channel.AbstractChannel.AbstractUnsafe#register</span><br>eventLoop.execute(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Runnable</span>(<span class="hljs-params"></span>)</span> &#123;<br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>         register0(promise);<br>     &#125;<br> &#125;);<br></code></pre></td></tr></table></figure><p>跟进 execute() 找到 <code>startThread();</code> 在直接跟进 <code>doStartThread()</code>找到下面代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">doStartThread</span>(<span class="hljs-params"></span>)</span> &#123;<br>       assert thread == <span class="hljs-literal">null</span>;<br>       <span class="hljs-comment">// 调用NioEventLoop所包含的executor的execute() 这个execute()会创建并启动一个线程</span><br>       executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Runnable</span>(<span class="hljs-params"></span>)</span> &#123;<br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>               thread = Thread.currentThread();<br>               <span class="hljs-keyword">if</span> (interrupted) &#123;<br>                   thread.interrupt();<br>               &#125;<br><br>               <span class="hljs-built_in">boolean</span> success = <span class="hljs-literal">false</span>;<br>               updateLastExecutionTime();<br>               <span class="hljs-keyword">try</span> &#123;<br>                   <span class="hljs-comment">// 执行了一个不会停止的for，用于完成任务队列中的任务</span><br>                   SingleThreadEventExecutor.this.run();<br>                   success = <span class="hljs-literal">true</span>;<br>               &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                   logger.warn(<span class="hljs-string">&quot;Unexpected exception from an event executor: &quot;</span>, t);<br>               &#125; <span class="hljs-keyword">finally</span> &#123;<br>              <span class="hljs-comment">// 省略。。。</span><br></code></pre></td></tr></table></figure><p>这段代码上面都跟过，这里就跳过直接找我们要看的代码：<code>SingleThreadEventExecutor.this.run();</code> 这里执行了一个无限循环的代码，用来一直完成任务队列中的任务：这找到实现代码 eventLoop 中的 run() ：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> run() &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 选择就绪的channel</span><br>                <span class="hljs-keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;<br>                    <span class="hljs-keyword">case</span> SelectStrategy.<span class="hljs-attr">CONTINUE:</span>    <span class="hljs-comment">// NioEventLoop不支持</span><br>                        <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-keyword">case</span> SelectStrategy.<span class="hljs-attr">BUSY_WAIT:</span>  <span class="hljs-comment">// NioEventLoop不支持</span><br><br>                    <span class="hljs-keyword">case</span> SelectStrategy.<span class="hljs-attr">SELECT:</span>  <span class="hljs-comment">// SELECT = -1 能走到这里，说明当前任务队列中没有任务</span><br>                        <span class="hljs-comment">// 进行阻塞式选择</span><br>                        select(wakenUp.getAndSet(<span class="hljs-literal">false</span>));<br>                        <span class="hljs-keyword">if</span> (wakenUp.get()) &#123;<br>                            selector.wakeup();<br>                        &#125;<br>                    <span class="hljs-symbol">default:</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                rebuildSelector0();<br>                handleLoopException(e);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            cancelledKeys = <span class="hljs-number">0</span>;<br>            needsToSelectAgain = <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 该变量用于设置“处理就绪channel的IO所使用的时间”与“处理任务队列中任务使用时间”的比例 该值为整型，不大于100</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ioRatio = <span class="hljs-built_in">this</span>.ioRatio;<br>            <span class="hljs-keyword">if</span> (ioRatio == <span class="hljs-number">100</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    processSelectedKeys();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    runAllTasks();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 记录处理就绪channel的IO开始执行的时间点</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioStartTime = System.nanoTime();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 处理就绪channel的IO</span><br>                    processSelectedKeys();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 计算出处理就绪channel的IO所使用的时长</span><br>                    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioTime = System.nanoTime() - ioStartTime;<br>                    <span class="hljs-comment">// 执行任务队列中的任务</span><br>                    runAllTasks(ioTime * (<span class="hljs-number">100</span> - ioRatio) / ioRatio);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 省略。。。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>首先我们整体上看一下这个方法。</p><ol><li>selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())</li><li>switch - case</li><li>processSelectedKeys()</li><li>runAllTasks()</li></ol><p><strong>Tag 1.3.3.1</strong>：selectStrategy.calculateStrategy</p><p><strong>Tag 1.3.3.2</strong> ：switch - case</p><p><strong>Tag 1.3.3.3</strong> ：processSelectedKeys()</p><p><strong>Tag 1.3.3.4</strong> ：runAllTasks()</p></blockquote><h6 id="Tag-1-3-3-1：selectStrategy-calculateStrategy"><a href="#Tag-1-3-3-1：selectStrategy-calculateStrategy" class="headerlink" title="Tag 1.3.3.1：selectStrategy.calculateStrategy"></a><strong>Tag 1.3.3.1</strong>：selectStrategy.calculateStrategy</h6><p>首先找到代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript">selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());<br><br><span class="hljs-comment">// hasTasks  tailTasks 收尾任务队列</span><br><span class="hljs-keyword">protected</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">hasTasks</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.hasTasks() || !tailTasks.isEmpty();<br>&#125;<br><br><span class="hljs-comment">// super.hasTasks()   taskQueue 普通任务队列</span><br><span class="hljs-keyword">protected</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">hasTasks</span>(<span class="hljs-params"></span>)</span> &#123;<br>    assert inEventLoop();<br>    <span class="hljs-keyword">return</span> !taskQueue.isEmpty();<br>&#125;<br></code></pre></td></tr></table></figure><p>首先看到 <code>hasTask</code> : 返回当前任务队列和收尾队列是否有任务。<code>selectNowSupplier</code> : 匿名内部类<code>io.netty.util.IntSupplier</code></p><p>继续跟进：calculateStrategy：<code>io.netty.channel.DefaultSelectStrategy#calculateStrategy</code> 初始化的默认选择器</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// SelectStrategy.<span class="hljs-keyword">SELECT</span> = <span class="hljs-number">-1</span><br><span class="hljs-built_in">public</span> <span class="hljs-type">int</span> calculateStrategy(IntSupplier selectSupplier, <span class="hljs-type">boolean</span> hasTasks) throws <span class="hljs-keyword">Exception</span> &#123;<br>    <span class="hljs-keyword">return</span> hasTasks ? selectSupplier.<span class="hljs-keyword">get</span>() : SelectStrategy.<span class="hljs-keyword">SELECT</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就是如果存在任务则走选择器 <code>selectSupplier.get()</code> 否则直接返回 <code>-1:SELECT</code> 。</p><p>继续跟 get 的任务选择逻辑：selectSupplier : NioEventLoop 中的内部类 IntSupplier</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">selectNow</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">// io.netty.channel.nio.NioEventLoop#selectNow</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">selectNow</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> selector.<span class="hljs-title">selectNow</span><span class="hljs-params">()</span></span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// restore wakeup state if needed</span><br>        <span class="hljs-keyword">if</span> (wakenUp.get()) &#123;<br>            selector.wakeup();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol><li><p>selector.selectNow() : 方法为 NIO 的非阻塞选择，返回就绪的 channel 的数量，可以为 0。</p><p>补充：Selector 的阻塞选择和非阻塞选择的区别就是，非阻塞选则在当前 select 方法执行时判断循环判断所有的 channel 是否就绪并返回所有的就绪数量，而阻塞式选择则是阻塞指定时间直至阻塞时间内获取到就绪 channel 或者阻塞时间超时时立刻返回。</p></li><li><p>wakenUp.get() ：返回当前线程是否被阻塞，没有被阻塞时返回 true，当前线程被阻塞返回 false。</p></li><li><p>selector.wakeup() ：当前线程如果被阻塞，则立刻返回 selector 结果，即唤醒当前线程。</p></li></ol><p>这是 selectNow() 方法执行的结果，是一个必然大于等于 0 的结果。</p></blockquote><p>所以返回 <code>calculateStrategy</code> 方法：如果任务队列存在任务，则通过 Selector 执行非阻塞选择返回就绪的 channel 数量，如果不存在任务，则直接返回 -1。</p><h6 id="Tag-1-3-3-2-：switch-case"><a href="#Tag-1-3-3-2-：switch-case" class="headerlink" title="Tag 1.3.3.2 ：switch - case"></a><strong>Tag 1.3.3.2</strong> ：switch - case</h6><p>现在在返回去看 switch - case 的代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;<br>    <span class="hljs-keyword">case</span> SelectStrategy.CONTINUE:    <span class="hljs-comment">// -2 NioEventLoop不支持 </span><br>        <span class="hljs-keyword">continue</span>;<br><br>    <span class="hljs-keyword">case</span> SelectStrategy.BUSY_WAIT:  <span class="hljs-comment">// -3 NioEventLoop不支持</span><br>   <br>    <span class="hljs-keyword">case</span> SelectStrategy.SELECT:  <span class="hljs-comment">// -1 能走到这里，说明当前任务队列中没有任务</span><br>        <span class="hljs-comment">// 进行阻塞式选择</span><br>        <span class="hljs-keyword">select</span>(wakenUp.getAndSet(<span class="hljs-literal">false</span>));<br>        <span class="hljs-keyword">if</span> (wakenUp.<span class="hljs-keyword">get</span>()) &#123;<br>            selector.wakeup();<br>        &#125;<br>    <span class="hljs-literal">default</span>:<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>因为再 <code>selectStrategy.calculateStrategy</code> 方法中，不可能返回 -2 和 -3。所以 case 的结果只可能走到  SelectStrategy.SELECT 或者直接 default。而只有当所有任务队列中都没有任务的时候才会返回 -1。也就意味着当任务队列中没有任务时也会景行一次阻塞式选择，通过 <code>wakenUp.getAndSet(false)</code> 方法将当前线程设置为阻塞状态。然后就阻塞式 select。</p></blockquote><p>这里我们具体去看看这 select 阻塞选择的逻辑：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void select(boolean oldWakenUp) throws IOException &#123;<br>    Selector selector = this.selector;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 计数器：用于记录空轮询导致CPU占用率飙升，select()提前结束的次数（其值大于1时）</span><br>        <span class="hljs-built_in">int</span> selectCnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 获取当前时间，也就是for循环第一次开始执行的时间点</span><br>        long currentTimeNanos = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>nano<span class="hljs-constructor">Time()</span>;<br>        <span class="hljs-comment">// delayNanos() 表示定时任务队列中第一个定时任务还有多久就到开始执行的时间了</span><br>        long selectDeadLineNanos = currentTimeNanos + delay<span class="hljs-constructor">Nanos(<span class="hljs-params">currentTimeNanos</span>)</span>;<br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">// 处理小于0.5毫秒的任务</span><br>            long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + <span class="hljs-number">500000L</span>)<span class="hljs-operator"> / </span><span class="hljs-number">1000000L</span>;<br>            <span class="hljs-keyword">if</span> (timeoutMillis &lt;= <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 该条件为true，表示具有立即需要执行的定时任务</span><br>                <span class="hljs-keyword">if</span> (selectCnt<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 只有第一次for循环才会执行下面的“非阻塞选择”</span><br>                    selector.select<span class="hljs-constructor">Now()</span>;<br>                    selectCnt = <span class="hljs-number">1</span>;<br>                &#125;<br>                break;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (has<span class="hljs-constructor">Tasks()</span><span class="hljs-operator"> &amp;&amp; </span>wakenUp.compare<span class="hljs-constructor">AndSet(<span class="hljs-params">false</span>, <span class="hljs-params">true</span>)</span>) &#123;<br>                selector.select<span class="hljs-constructor">Now()</span>;<br>                selectCnt = <span class="hljs-number">1</span>;<br>                break;<br>            &#125;<br>            <br>            <span class="hljs-built_in">int</span> selectedKeys = selector.select(timeoutMillis);<br>            selectCnt ++;<br>            <span class="hljs-comment">// 若有就绪的channel了，则直接结束</span><br>            <span class="hljs-keyword">if</span> (selectedKeys != <span class="hljs-number">0</span><span class="hljs-operator"> || </span>oldWakenUp<span class="hljs-operator"> || </span>wakenUp.get<span class="hljs-literal">()</span><span class="hljs-operator"> || </span>has<span class="hljs-constructor">Tasks()</span><span class="hljs-operator"> || </span>has<span class="hljs-constructor">ScheduledTasks()</span>) &#123;<br>                break;<br>            &#125;<br>            <span class="hljs-comment">// 若当前线程被中断</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>interrupted<span class="hljs-literal">()</span>) &#123;<br>                selectCnt = <span class="hljs-number">1</span>;<br>                break;<br>            &#125;<br><br>            <span class="hljs-comment">// 获取当前时间</span><br>            long time = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>nano<span class="hljs-constructor">Time()</span>;<br>            <span class="hljs-comment">// 下面的式子等价于：  time - currentTimeNanos &gt;= timeoutMillis</span><br>            <span class="hljs-comment">// 若下面的条件成立，则说明select()是在指定的阻塞时间过期后才跳出的，即正常结束的</span><br>            <span class="hljs-keyword">if</span> (time - <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TimeUnit</span>.</span><span class="hljs-module"><span class="hljs-identifier">MILLISECONDS</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Nanos(<span class="hljs-params">timeoutMillis</span>)</span> &gt;= currentTimeNanos) &#123;<br>                <span class="hljs-comment">// timeoutMillis elapsed without anything selected.</span><br>                selectCnt = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="hljs-number">0</span> &amp;&amp;<br>                       selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;<br>                selector = select<span class="hljs-constructor">RebuildSelector(<span class="hljs-params">selectCnt</span>)</span>;  <span class="hljs-comment">// 重构selector</span><br>                selectCnt = <span class="hljs-number">1</span>;<br>                break;<br>            &#125;<br>            <span class="hljs-comment">// 本轮for循环结束时间点，同时也是下一轮for循环的开始时间点</span><br>            currentTimeNanos = time;<br>        &#125;  <br>    &#125; catch (CancelledKeyException e) &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法直接画图解释把：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-36.jpg"></p><p>而在 switch-case 唯一的代码逻辑也就是在任务队列中没有任务时执行的阻塞 select，而在其他的任何情况下或者阻塞选择存在就绪 channel 或者任务队列新增任务之后都会跳出 switch - case，执行后续逻辑。</p><h6 id="Tag-1-3-3-3-：processSelectedKeys"><a href="#Tag-1-3-3-3-：processSelectedKeys" class="headerlink" title="Tag 1.3.3.3 ：processSelectedKeys()"></a>Tag 1.3.3.3 ：processSelectedKeys()</h6><p>首先我要说的时这个 <code>processSelectedKeys</code> 方法时处理就绪的 channel 的 IO，而代码逻辑走到这里其实并不一定就有已经就绪的 channel，因为看了上面的逻辑会发现代码任务处理为先，而存在任务就会走到这里逻辑，虽然在走到这里之前也执行了 select 的 channel 但是也都是去查看一遍是否存在就绪 channel，所以这里看下面的逻辑需要先有这个理解，最后我们再具体看 <code>processSelectedKeys</code> 代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">final <span class="hljs-built_in">int</span> ioRatio = this.ioRatio; <span class="hljs-comment">// 默认值 50</span><br><span class="hljs-keyword">if</span> (ioRatio<span class="hljs-operator"> == </span><span class="hljs-number">100</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        process<span class="hljs-constructor">SelectedKeys()</span>;<br>    &#125; finally &#123;<br>        <span class="hljs-comment">// Ensure we always run tasks.</span><br>        run<span class="hljs-constructor">AllTasks()</span>;<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 记录处理就绪channel的IO开始执行的时间点</span><br>    final long ioStartTime = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>nano<span class="hljs-constructor">Time()</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 处理就绪channel的IO</span><br>        process<span class="hljs-constructor">SelectedKeys()</span>;<br>    &#125; finally &#123;<br>        <span class="hljs-comment">// 计算出处理就绪channel的IO所使用的时长</span><br>        final long ioTime = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>nano<span class="hljs-constructor">Time()</span> - ioStartTime;<br>        <span class="hljs-comment">// 执行任务队列中的任务</span><br>        run<span class="hljs-constructor">AllTasks(<span class="hljs-params">ioTime</span> <span class="hljs-operator">*</span> (100 - <span class="hljs-params">ioRatio</span>)</span><span class="hljs-operator"> / </span>ioRatio);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码的整体逻辑再我们看完 runAllTasks 之后再分析，这里存在一个 io 处理与 task 处理的时间分配逻辑。后面再看，这里继续跟进 <code>processSelectedKeys</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">processSelectedKeys</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// 判断channel的selectedKeys是否是优化过的</span><br>    <span class="hljs-keyword">if</span> (selectedKeys != <span class="hljs-literal">null</span>) &#123;<br>        processSelectedKeysOptimized();  <span class="hljs-comment">// 优化处理方式</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        processSelectedKeysPlain(selector.selectedKeys());  <span class="hljs-comment">// 普通处理方式</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里，代码有限判断了当前是否启用的 selectedKey 的优化，再 NioEventLoopGroup 的时候说过，优化就是将selectedKeys 的 set 集合转换成了数组，而再这里也可以得到验证，<code>selectedKeys</code>直接产看这个属性就可以看到，这里不进去看了，感兴趣进去看看。然后针对优化和非优化的处理唯一的区别就是处理的 <code>selectedKeys</code>对象是数组还是集合。这里直接分析 <code>processSelectedKeysOptimized</code> 方法，<code>processSelectedKeysPlain</code> 方法可以自己看，一样的处理。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> processSelectedKeysOptimized() &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; selectedKeys.<span class="hljs-keyword">size</span>; ++i) &#123;<br>        <span class="hljs-comment">// 从数组中取出一个元素</span><br>        <span class="hljs-keyword">final</span> SelectionKey k = selectedKeys.keys[i];<br>     <span class="hljs-comment">// 移除已经取出的 SelectionKey，使 GC 可以处理到已经关闭的 channel</span><br>        selectedKeys.keys[i] = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// 获取selectionKey的附件，该附件中可以存放任意数据，不过这里存放的是NIO原生channel</span><br>        <span class="hljs-keyword">final</span> Object a = k.attachment();<br><br>        <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> AbstractNioChannel) &#123;<br>            processSelectedKey(k, (AbstractNioChannel) a);  <span class="hljs-comment">// 处理就绪事件</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            NioTask&lt;SelectableChannel&gt; <span class="hljs-keyword">task</span> = (NioTask&lt;SelectableChannel&gt;) a;<br>            processSelectedKey(k, <span class="hljs-keyword">task</span>); <span class="hljs-comment">// 这里是测试代码。跟进去可以看到实现方法是测试类</span><br>        &#125;<br><span class="hljs-comment">// 省略......</span><br></code></pre></td></tr></table></figure><p>这里就是直接轮询 selectedKeys 的集合，每取出一个 selectKey 都会在原数组中移除当前元素，就是为了当 channel 关闭后， GC 可以释放当前 channel 占用的内存。</p><p>然后获取 selectKey 中保存的 Nio 原生的 channel，处理就绪后逻辑：<code>processSelectedKey</code> 继续跟进：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processSelectedKey</span>(<span class="hljs-params">SelectionKey k, AbstractNioChannel ch</span>)</span> &#123;<br>    final AbstractNioChannel.NioUnsafe <span class="hljs-keyword">unsafe</span> = ch.<span class="hljs-keyword">unsafe</span>();<br>    <span class="hljs-comment">// 处理selectionKey失效的情况</span><br>    <span class="hljs-keyword">if</span> (!k.isValid()) &#123;<br>        final EventLoop eventLoop;<br>        <span class="hljs-keyword">try</span> &#123;<br>            eventLoop = ch.eventLoop();<br>        &#125; catch (Throwable ignored) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (eventLoop != <span class="hljs-keyword">this</span> || eventLoop == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">unsafe</span>.close(<span class="hljs-keyword">unsafe</span>.voidPromise());<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">int</span> readyOps = k.readyOps();<br>  <span class="hljs-comment">// 判断当前 channnel 就绪的事件类型</span><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 获取当前selectionKey的interestOps</span><br>            <span class="hljs-built_in">int</span> ops = k.interestOps();<br>            <span class="hljs-comment">// 先将SelectionKey.OP_CONNECT按位取或，再与ops进行按位与</span><br>            ops &amp;= ~SelectionKey.OP_CONNECT;<br>            <span class="hljs-comment">// 将修改过的ops再写入到selectionsKey中</span><br>            k.interestOps(ops);<br>            <span class="hljs-comment">// 连接server</span><br>            <span class="hljs-keyword">unsafe</span>.finishConnect();<br>        &#125;<br><br>        <span class="hljs-comment">// 处理写就绪的情况</span><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 强制刷新（将user buffer中的数据写入到网关缓存）</span><br>            ch.<span class="hljs-keyword">unsafe</span>().forceFlush();<br>        &#125;<br>        <span class="hljs-comment">// readyOps为0表示当前没有任何channel就绪</span><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 将网卡缓存中的数据写入到user buffer</span><br>            <span class="hljs-keyword">unsafe</span>.read();<br>        &#125;<br>    &#125; catch (CancelledKeyException ignored) &#123;<br>        <span class="hljs-keyword">unsafe</span>.close(<span class="hljs-keyword">unsafe</span>.voidPromise());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这段逻辑就是处理就绪 channel 的 IO 事件的逻辑。</p><ol><li><p>判断当前 SelectionKey 是否有效。失效结束处理并关闭资源。</p></li><li><p>判断当前 channel 的关注事件，针对处理：获取 SelectionKey 的 readyOps。这里的判断逻辑都是使用高效的位运算。readyOps 为当前 SelectionKey 的就绪的事件类型。</p></li><li><p>(readyOps &amp; SelectionKey.OP_CONNECT) != 0 ：连接就绪事件</p><p>这个事件在 server 端不会关注，只有 client 用来连接 server 时才会关注连接就绪事件。</p><p>连接就绪后，获取当前 SelectionKey 的 interestOps 值，将当前 interestOps 值修改后，调用底层 unsafe 连接server</p></li><li><p>(readyOps &amp; SelectionKey.OP_WRITE) != 0 ：写就绪事件</p><p>当前 channel 关注的是写就绪事件，此时写操作已经就绪，所以直接调用unsafe将数据写入的网卡缓存。</p></li><li><p>(readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0 ：当前channel 关注的是读就绪事件，或者前面因为有新增任务而触发的就绪 channel 处理逻辑，只有因为任务触发的情况下 readyOps  才可能会是 0 ，readyOps  = 0 意味着没有就绪 channel。</p><p>直接调用 unsafe 继续读操作，将网卡缓存的数据读取到用户空间。如果是 readyOps = 0 的情况相当于网卡缓存并没有就绪数据，则时进行的读操作不会读取到数据。</p></li></ol></blockquote><p>这就是完整的 IO 处理逻辑，主要根据当前 channel 关注的事件进行相应的 unsafe 操作。</p><h6 id="Tag-1-3-3-4-：runAllTasks"><a href="#Tag-1-3-3-4-：runAllTasks" class="headerlink" title="Tag 1.3.3.4 ：runAllTasks()"></a><strong>Tag 1.3.3.4</strong> ：runAllTasks()</h6><p>下面我们在看下 <code>runAllTask</code> 方法。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">run<span class="hljs-constructor">AllTasks(<span class="hljs-params">ioTime</span> <span class="hljs-operator">*</span> (100 - <span class="hljs-params">ioRatio</span>)</span><span class="hljs-operator"> / </span>ioRatio);<br><br>protected boolean run<span class="hljs-constructor">AllTasks(<span class="hljs-params">long</span> <span class="hljs-params">timeoutNanos</span>)</span> &#123;<br>    <span class="hljs-comment">// 从定时任务队列中取出所有当前马上就要到期的定时任务放入到任务队列</span><br>    fetch<span class="hljs-constructor">FromScheduledTaskQueue()</span>;<br>    <span class="hljs-comment">// 从任务队列中取出一个任务</span><br>    Runnable task = poll<span class="hljs-constructor">Task()</span>;<br>    <span class="hljs-comment">// 若该任务为空，则说明任务队列中已经没有任务了，此时就可以执行收尾任务了</span><br>    <span class="hljs-keyword">if</span> (task<span class="hljs-operator"> == </span>null) &#123;<br>        <span class="hljs-comment">// 执行收尾队列中的收尾任务</span><br>        after<span class="hljs-constructor">RunningAllTasks()</span>;<br>        return <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    final long deadline = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ScheduledFutureTask</span>.</span></span>nano<span class="hljs-constructor">Time()</span> + timeoutNanos;<br>    <span class="hljs-comment">// 计数器</span><br>    long runTasks = <span class="hljs-number">0</span>;<br>    long lastExecutionTime;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 执行任务</span><br>        safe<span class="hljs-constructor">Execute(<span class="hljs-params">task</span>)</span>;<br>        runTasks ++;<br>        <span class="hljs-comment">// 每64个任务查看一次超时</span><br>        <span class="hljs-keyword">if</span> ((runTasks &amp; <span class="hljs-number">0x3F</span>)<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) &#123;<br>            lastExecutionTime = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ScheduledFutureTask</span>.</span></span>nano<span class="hljs-constructor">Time()</span>;<br>            <span class="hljs-keyword">if</span> (lastExecutionTime &gt;= deadline) &#123;<br>                break;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 从任务队列中再取出一个任务</span><br>        task = poll<span class="hljs-constructor">Task()</span>;<br>        <span class="hljs-keyword">if</span> (task<span class="hljs-operator"> == </span>null) &#123;<br>            lastExecutionTime = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ScheduledFutureTask</span>.</span></span>nano<span class="hljs-constructor">Time()</span>;<br>            break;<br>        &#125;<br>    &#125; <span class="hljs-comment">// end-for</span><br><br>    <span class="hljs-comment">// 处理收尾队列中的任务</span><br>    after<span class="hljs-constructor">RunningAllTasks()</span>;<br>    this.lastExecutionTime = lastExecutionTime;<br>    return <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>画图理解一下这个方法：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-37.jpg"></p><p>这里面有几个方法大家感兴趣可以进去看看：这部分逻辑不复杂，大家可以自己研究下。</p><blockquote><ol><li><p>fetchFromScheduledTaskQueue()</p><p>io.netty.util.concurrent.SingleThreadEventExecutor#fetchFromScheduledTaskQueue</p><p>从定时任务队列中取出所有当前马上就要到期的定时任务放入到任务队列</p></li><li><p>pollTask()</p><p>io.netty.util.concurrent.SingleThreadEventExecutor#pollTask</p><p>从任务队列中取出一个任务</p></li><li><p>afterRunningAllTasks()</p><p>io.netty.util.concurrent.SingleThreadEventExecutor#afterRunningAllTasks</p><p>执行收尾任务队列中的所有收尾任务</p></li><li><p>safeExecute(task)</p><p>io.netty.util.concurrent.AbstractEventExecutor#safeExecute</p><p>执行任务</p></li></ol></blockquote><p>到此我们的 channel 的 initAndRegister 介绍完成，并且介绍了 channel 就绪后的执行方法 eventLoop 的 execute 调用的 run 方法的逻辑。其实 run 方法不是说注册初始化的时候就调用的，而是通过任务或者就绪 channel 触发的，只是注册时候说到这个代码就直接跟完这个逻辑，让大家也好理解一点。</p><h4 id="Tag-2-doBind0-绑定端口号"><a href="#Tag-2-doBind0-绑定端口号" class="headerlink" title="Tag 2  doBind0()  绑定端口号"></a>Tag 2  doBind0()  绑定端口号</h4><p>先看一下面需要跟踪的代码在哪里，上面饶了一个圈，现在回来先看看回到哪里，不然都不知道自己是谁，自己在哪。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-38.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-39.jpg"></p><p>找到 <code>doBind0</code>方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> doBind0(<br>    final ChannelFuture regFuture, final Channel channel,<br>    final SocketAddress localAddress, final ChannelPromise promise) &#123;<br>    channel.eventLoop().execute(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Runnable</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>            <span class="hljs-keyword">if</span> (regFuture.isSuccess()) &#123;  <span class="hljs-comment">// 只有当channel初始化注册成功后，才会进行绑定</span><br>                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                promise.setFailure(regFuture.cause());<br>            &#125;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果初始化失败，则直接返回失败，我们这里跟正确逻辑，直接跟 <code>channel.bind</code>方法：</p><figure class="highlight irpf90"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs irpf90"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-keyword">bind</span>(SocketAddress localAddress, ChannelPromise promise) &#123;<br>    <span class="hljs-keyword">return</span> pipeline.<span class="hljs-keyword">bind</span>(localAddress, promise);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里不多少直接进去，继续探索：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function">ChannelFuture <span class="hljs-title">bind</span><span class="hljs-params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> tail.<span class="hljs-title">bind</span><span class="hljs-params">(localAddress, promise)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一样。继续探索：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-function"><span class="hljs-title">bind</span>(<span class="hljs-params">final SocketAddress localAddress, final ChannelPromise promise</span>)</span> &#123;<br>    。。。。<br>    final AbstractChannelHandlerContext next = findContextOutbound(MASK_BIND);<br>    EventExecutor executor = next.executor();<br>    <span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;<br>        next.invokeBind(localAddress, promise);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        safeExecute(executor, <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Runnable</span>(<span class="hljs-params"></span>)</span> &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>                next.invokeBind(localAddress, promise);<br>            &#125;<br>        &#125;, promise, <span class="hljs-literal">null</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> promise;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里涉及到 pipeline 的逻辑后面细说，这里我们直接去看看一下 bind 的代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void invoke<span class="hljs-constructor">Bind(SocketAddress <span class="hljs-params">localAddress</span>, ChannelPromise <span class="hljs-params">promise</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (invoke<span class="hljs-constructor">Handler()</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ((ChannelOutboundHandler) handler<span class="hljs-literal">()</span>).bind(this, localAddress, promise);<br>        &#125; catch (Throwable t) &#123;<br>            notify<span class="hljs-constructor">OutboundHandlerException(<span class="hljs-params">t</span>, <span class="hljs-params">promise</span>)</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        bind(localAddress, promise);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里找到 bind 实现：<code>io.netty.channel.DefaultChannelPipeline.HeadContext#bind</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> bind(<br>    ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) &#123;<br>    unsafe.bind(localAddress, promise);<br>&#125;<br></code></pre></td></tr></table></figure><p>继续跟进：<code>unsafe.bind</code> : <code>io.netty.channel.AbstractChannel.AbstractUnsafe#bind</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> final <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">bind</span>(<span class="hljs-params">final SocketAddress localAddress, final ChannelPromise promise</span>)</span> &#123;<br>    <span class="hljs-comment">// 省略。。。</span><br><br>    <span class="hljs-comment">// 获取当前channel是否被激活。注意，现在还没有被激活，所以其值为false</span><br>    <span class="hljs-built_in">boolean</span> wasActive = isActive();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 绑定</span><br>        doBind(localAddress);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        safeSetFailure(promise, t);<br>        closeIfClosed();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;<br>        invokeLater(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Runnable</span>(<span class="hljs-params"></span>)</span> &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>                pipeline.fireChannelActive();  <span class="hljs-comment">// 触发重写的channelActivate方法的执行</span><br>            &#125;<br>        &#125;);<br>    &#125;<br>    safeSetSuccess(promise);<br>&#125;<br></code></pre></td></tr></table></figure><p>最终找到 AbstractUnsafe 中找到最终调用的 doBind 方法，在调用前又获取了当前 channel 是否被激活，若已经激活则触发 pipeline 的 <code>fireChannelActive</code> 方法执行。这个都在 pipeline 再具体细说。当 channel 没有被激活时才去调用 NIO 原生的channel 进行绑定。代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">protected void <span class="hljs-keyword">do</span><span class="hljs-constructor">Bind(SocketAddress <span class="hljs-params">localAddress</span>)</span> throws Exception &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PlatformDependent</span>.</span></span>java<span class="hljs-constructor">Version()</span> &gt;= <span class="hljs-number">7</span>) &#123;<br>        java<span class="hljs-constructor">Channel()</span>.bind(localAddress, config.get<span class="hljs-constructor">Backlog()</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        java<span class="hljs-constructor">Channel()</span>.socket<span class="hljs-literal">()</span>.bind(localAddress, config.get<span class="hljs-constructor">Backlog()</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>javaChannel()</code> 即获取 NIO 原生 channel 的方法，再获取到 NIO 原生 channel 之后调用 bind 方法完成绑定。</p><p>绑定 <code>bind</code> 方法我们就先初步了解最终怎么完成绑定的，要清楚到最后完成 bind 的依然是 NIO 的 channel。关于 pipeline 也是 netty 的一块重点，后面我们再细说。</p><p>这边完整的 server 启动初始化到启动的代码我们跟完了，现在可以类比这再把 client 的代码跟一遍，不过现在再看 client 的代码，会有很多不同的理解出来也应该会有很多原来如此的理解吧。</p><h3 id="Client-端启动分析"><a href="#Client-端启动分析" class="headerlink" title="Client 端启动分析"></a>Client 端启动分析</h3><p>上面我们跟完了 Server 端的代码初始化到启动分析，下面我们在跟下 Client 端的代码，这两部分有重复代码有相同的逻辑也有不同的地方。从启动类就可以看到他们是有区别的，但是上面理解了在看下面这个会容易很多。第一步找到代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">NioEventLoopGroup eventLoopGroup = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup()</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    Bootstrap bootstrap = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Bootstrap()</span>;<br>    bootstrap.group(eventLoopGroup)<br>        .channel(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NioSocketChannel</span>.</span></span><span class="hljs-keyword">class</span>)<br>        .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;<span class="hljs-literal">()</span> &#123;<br>            @Override<br>            protected void init<span class="hljs-constructor">Channel(SocketChannel <span class="hljs-params">ch</span>)</span> throws Exception &#123;<br>                ChannelPipeline pipeline = ch.pipeline<span class="hljs-literal">()</span>;<br>                pipeline.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> StringDecoder(CharsetUtil.UTF_8)</span>);<br>                pipeline.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> StringEncoder(CharsetUtil.UTF_8)</span>);<br>                pipeline.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> SomeSocketClientHandler()</span>);<br>            &#125;<br>        &#125;);<br><br>    ChannelFuture future = bootstrap.connect(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8888</span>).sync<span class="hljs-literal">()</span>;<br>    future.channel<span class="hljs-literal">()</span>.close<span class="hljs-constructor">Future()</span>.sync<span class="hljs-literal">()</span>;<br>&#125; finally &#123;<br>    <span class="hljs-keyword">if</span>(eventLoopGroup != null) &#123;<br>        eventLoopGroup.shutdown<span class="hljs-constructor">Gracefully()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol><li>创建  NioEventLoopGroup，这个因为和 Server 端是一样的，所以这里不在分析。</li><li>初始化 Bootstrap 启动配置类，配置启动参数，这个在上面 Server 端的 Bind 方法分析的时候，也有看到都是在哪里使用这个配置的属性的。这里也不细说。</li><li>客户端启动，也就是：<code>bootstrap.connect</code>，这里就是与 Server 端的主要区别。在 Server 端是启动一个服务端服务，使用的是 bind 绑定当前机器的端口，对外暴露服务，而在 Client 端就是主动去连接 Server 端，与服务器建立连接。所以这里是 connect。这里我们主要跟进去看看这个方法</li></ol></blockquote><h4 id="Bootstrap-connect-分析："><a href="#Bootstrap-connect-分析：" class="headerlink" title="Bootstrap.connect() 分析："></a>Bootstrap.connect() 分析：</h4><p>先找到 Bootstrap 的代码，跟进去：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-function"><span class="hljs-title">connect</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> inetHost, int inetPort</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> connect(InetSocketAddress.createUnresolved(inetHost, inetPort));<br>&#125;<br><br><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-function"><span class="hljs-title">connect</span>(<span class="hljs-params">SocketAddress remoteAddress</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (remoteAddress == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;remoteAddress&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 验证bootstrap的group、channelFactory与handler是否为空</span><br>    validate();<br>    <span class="hljs-comment">// 解析并连接地址</span><br>    <span class="hljs-keyword">return</span> doResolveAndConnect(remoteAddress, config.localAddress());<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>InetSocketAddress.createUnresolved</code> 将输入的连接地址和端口号保存创建创建 InetSocketAddress 对象返回。</p><p><code>validate()</code> 方法主要校验 bootstrap 的必须配置是否为空：group、channelFactory与handler是否为空。</p><p>然后调用 <code>doResolveAndConnect</code> 方法建立连接</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> ChannelFuture <span class="hljs-keyword">do</span><span class="hljs-constructor">ResolveAndConnect(<span class="hljs-params">final</span> SocketAddress <span class="hljs-params">remoteAddress</span>, <span class="hljs-params">final</span> SocketAddress <span class="hljs-params">localAddress</span>)</span> &#123;<br>    <span class="hljs-comment">// 创建、初始化并注册channel</span><br>    final ChannelFuture regFuture = init<span class="hljs-constructor">AndRegister()</span>;<br>    final Channel channel = regFuture.channel<span class="hljs-literal">()</span>;<br>    <span class="hljs-comment">// 若channel注册完毕</span><br>    <span class="hljs-keyword">if</span> (regFuture.is<span class="hljs-constructor">Done()</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!regFuture.is<span class="hljs-constructor">Success()</span>) &#123;<br>            return regFuture;<br>        &#125;<br>        <span class="hljs-comment">// 解析并连接server端地址</span><br>        return <span class="hljs-keyword">do</span><span class="hljs-constructor">ResolveAndConnect0(<span class="hljs-params">channel</span>, <span class="hljs-params">remoteAddress</span>, <span class="hljs-params">localAddress</span>, <span class="hljs-params">channel</span>.<span class="hljs-params">newPromise</span>()</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        final PendingRegistrationPromise promise = <span class="hljs-keyword">new</span> <span class="hljs-constructor">PendingRegistrationPromise(<span class="hljs-params">channel</span>)</span>;<br>        regFuture.add<span class="hljs-constructor">Listener(<span class="hljs-params">new</span> ChannelFutureListener()</span> &#123;<br>            @Override<br>            public void operation<span class="hljs-constructor">Complete(ChannelFuture <span class="hljs-params">future</span>)</span> throws Exception &#123;<br>                Throwable cause = future.cause<span class="hljs-literal">()</span>;<br>                <span class="hljs-keyword">if</span> (cause != null) &#123;<br>                    promise.set<span class="hljs-constructor">Failure(<span class="hljs-params">cause</span>)</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    promise.registered<span class="hljs-literal">()</span>;<br>                    <span class="hljs-keyword">do</span><span class="hljs-constructor">ResolveAndConnect0(<span class="hljs-params">channel</span>, <span class="hljs-params">remoteAddress</span>, <span class="hljs-params">localAddress</span>, <span class="hljs-params">promise</span>)</span>;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        return promise;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这段代码我想你看到之后应该很眼熟，这里如果抛开 <code>doResolveAndConnect0</code> 方法不看，其他的逻辑可以说是与 Server 端的 bind 方法跟进去看到的是一样的。首先通过异步的方式初始化并注册 channel，然后获取异步结果，判断是否异常，处理异常情况。没有异常，判断当前异步方法是否结束，如果结束根据结束的状态处理结束的逻辑，因为结束可以是正常也可以是异常结束。如果是异步结果一直没有结果，那就建立监听，监听异步结果返回时，触发最终逻辑。</p><p>这里我们也会将当前方法跟进去说一遍，但是只会细说与 Server 端不同的地方。</p><p>按照 Server 端的介绍模式，这里分成三段详细介绍</p><p><strong>Tag 1：initAndRegister();</strong></p><p><strong>Tag 2：doResolveAndConnect0(channel, remoteAddress, localAddress, promise);</strong></p></blockquote><h5 id="Tag-1：initAndRegister-分析"><a href="#Tag-1：initAndRegister-分析" class="headerlink" title="Tag 1：initAndRegister() 分析"></a>Tag 1：initAndRegister() 分析</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript">final ChannelFuture <span class="hljs-function"><span class="hljs-title">initAndRegister</span>(<span class="hljs-params"></span>)</span> &#123;<br>    Channel channel = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建channel</span><br>        channel = channelFactory.newChannel();<br>        <span class="hljs-comment">// 初始化channel</span><br>        init(channel);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-keyword">if</span> (channel != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))</span><br>            channel.unsafe().closeForcibly();<br>            <span class="hljs-comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);<br>        &#125;<br>        <span class="hljs-comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultChannelPromise(<span class="hljs-keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);<br>    &#125;<br><br>    <span class="hljs-comment">// 将channel注册到selector</span><br>    ChannelFuture regFuture = config().group().register(channel);<br>    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (channel.isRegistered()) &#123;<br>            channel.close();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            channel.unsafe().closeForcibly();<br>        &#125;<br>    &#125;<br>        <span class="hljs-keyword">return</span> regFuture;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里调用的 <code>io.netty.bootstrap.AbstractBootstrap#initAndRegister</code> 的方法与 Server 端调用的完全一样。我们h还是把当前方法分成三部分然后一个一个细说：</p><p><strong>Tag 1.1：channelFactory.newChannel();</strong></p><p><strong>Tag 1.2：init(channel);</strong></p><p><strong>Tag 1.3：config().group().register(channel);</strong></p></blockquote><h6 id="Tag-1-1-newChannel-分析"><a href="#Tag-1-1-newChannel-分析" class="headerlink" title="Tag 1.1 newChannel() 分析"></a>Tag 1.1 newChannel() 分析</h6><blockquote><p>首先在这里不一样的是 Bootstrap 的启动配置类传入的 channel  是 <code>.channel(NioSocketChannel.class)</code>。而在 Server 端传入的 <code>NioServerSoucketChannel</code> 。</p><p>所以在 Client 端 channelFactory 调用的则是 NioSocketChannel 的无参构造来初始化创建 channel。所以这里直接找到 NioSocketChannel 的构造方法：</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">NioSocketChannel</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// DEFAULT_SELECTOR_PROVIDER：全局唯一的provider，通过它可以创建出selector与channel</span><br>    <span class="hljs-built_in">this</span>(DEFAULT_SELECTOR_PROVIDER);<br>&#125;<br><br><span class="hljs-comment">// 继续跟进 this</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">NioSocketChannel</span>(<span class="hljs-params">SelectorProvider provider</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>(newSocket(provider));<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>到这里调用了 newSocket(provider) 方法。主要是创建了原生的 SocketChannel ，<code>provider.openSocketChannel()</code> 。初始化 Nio 原生的 channel 之后，就是创建 Netty 包装的 channel 的过程了。</p></blockquote><p>继续往后跟：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-constructor">NioSocketChannel(Channel <span class="hljs-params">parent</span>, SocketChannel <span class="hljs-params">socket</span>)</span> &#123;<br>    super(parent, socket);<br>    config = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioSocketChannelConfig(<span class="hljs-params">this</span>, <span class="hljs-params">socket</span>.<span class="hljs-params">socket</span>()</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 <code>new NioSocketChannelConfig(this, socket.socket())</code> 与 Server 端一样，此处就不再跟。我们直接跟 super(parent, socket) ：点击去找到 <code>io.netty.channel.nio.AbstractNioByteChannel#AbstractNioByteChannel</code>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-title">AbstractNioByteChannel</span>(<span class="hljs-params">Channel parent, SelectableChannel ch</span>)</span> &#123;<br>    <span class="hljs-comment">// 第三个参数： 指定关注事件为读事件 OP_READ</span><br>    <span class="hljs-built_in">super</span>(parent, ch, SelectionKey.OP_READ);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就出现了与 Server 端不一样的地方了。不知道大家还记得在 Server 端创建 channel 的时候，指定的关注事件是什么，直接贴上代码：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-40.jpg"></p><p>当时跟 Server 端注册 channel 时关注就的是 OP_ACCEPT，而在 Client 端创建的 channel 变成了关注的事件为 OP_READ 事件，因为当 Client 连接 Server 完成时，会由 Server 端通知 Client 端连接成功，所以此时 Client 直接注册 OP_READ 使事件来监听来自 Server 的返回。</p><p>然后下面的 super 的代码与 server 端的是同一个父类 <code>io.netty.channel.nio.AbstractNioChannel#AbstractNioChannel</code> 。所以后面的代码是与 Server 端一样。如果忘了可以往上翻翻，找到 Server 端的 newChannel 方法就可以看到。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-41.jpg"></p><h5 id="Tag-1-2-init-channel-分析"><a href="#Tag-1-2-init-channel-分析" class="headerlink" title="Tag 1.2  init(channel) 分析"></a>Tag 1.2  init(channel) 分析</h5><p>上面跟完了 client 端的 channel  创建，接着就是看 channel 的初始化。同样是先找到代码：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-42.jpg"></p><p>因为这是 Client，启动类是 Bootstrap。所以找到对应方法：这也是与 Server 端的区别。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">void</span> init(Channel channel) throws <span class="hljs-built_in">Exception</span> &#123;<br>    ChannelPipeline p = channel.pipeline();<br>    <span class="hljs-comment">// 将bootstrap中创建的ChannelInitializer处理器添加到pipeline</span><br>    p.addLast(config.handler());<br><br>    <span class="hljs-comment">// 将bootstrap中的options初始化到channel</span><br>    <span class="hljs-keyword">final</span> Map&lt;ChannelOption<span class="hljs-meta">&lt;?</span>&gt;, <span class="hljs-keyword">Object</span>&gt; options = options0();<br>    synchronized (options) &#123;<br>        setChannelOptions(channel, options, logger);<br>    &#125;<br><br>    <span class="hljs-comment">// 将bootstrap中的attrs初始化到channel</span><br>    <span class="hljs-keyword">final</span> Map&lt;AttributeKey<span class="hljs-meta">&lt;?</span>&gt;, <span class="hljs-keyword">Object</span>&gt; attrs = attrs0();<br>    synchronized (attrs) &#123;<br>        <span class="hljs-keyword">for</span> (Entry&lt;AttributeKey<span class="hljs-meta">&lt;?</span>&gt;, <span class="hljs-keyword">Object</span>&gt; e: attrs.entrySet()) &#123;<br>            channel.attr((AttributeKey&lt;<span class="hljs-keyword">Object</span>&gt;) e.getKey()).set(e.getValue());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里可以明显看到与 Server 端的 init 方法相比，做的事情要少很多。首先将 Bootstrap 配置传入的 handler  添加到 channel 的 pipeline 中 <code>p.addLast(config.handler());</code>。然后将 bootstrap 中配置的 attr 和 options 的属性值初始化到 channel 中。</p></blockquote><p>这里稍微比较下 Client 端和 Server 端的 init 方法区别：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-43.jpg"></p><p>可以看到当时再 Server 端我们不仅处理了 ParentGroup 的属性初始化，还初始化了以 Child 开头的 ChildGroup 的属性初始化，而再 Server 端是获取 pipeline 将传入的 childHandler 再次注册成一个新的 hanndler 然后添加到当前的 pipeline 中。再 Clinet 端则是直接将配置类传入的 handler 添加到 pipeline。这就是两边主要的区别，也就是因为 Server 传入的是两个 NioEventLoopGrou 才有的处理逻辑上的区别。也就是Server 端使用的是 Reactor 线程池模型，而Client 使用的 Reactor 模型。</p><p>Netty-Client 端的 Reactor 模型：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-44.jpg"></p><p>所以因为选择模型的区别，再处理逻辑上也有区别。</p><h5 id="Tag-1-3-register-channel-分析"><a href="#Tag-1-3-register-channel-分析" class="headerlink" title="Tag 1.3  register(channel)  分析"></a>Tag 1.3  register(channel)  分析</h5><p>这部分就完全与 Server 端一致，所以这里也不再啰嗦。不明白的可以直接翻到前面就可以看到。不在赘述。</p><h4 id="Tag-2：doResolveAndConnect0-分析"><a href="#Tag-2：doResolveAndConnect0-分析" class="headerlink" title="Tag 2：doResolveAndConnect0 分析"></a>Tag 2：doResolveAndConnect0 分析</h4><p>上面 Client 端的 channel 初始化与注册也看了一遍。下面我们继续看 <code>doResolveAndConnect0</code> 方法：<code>io.netty.bootstrap.Bootstrap#doResolveAndConnect0</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">private</span> ChannelFuture <span class="hljs-title">doResolveAndConnect0</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Channel channel, SocketAddress remoteAddress,</span></span><br><span class="hljs-function"><span class="hljs-params">                                           <span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">final</span> EventLoop eventLoop = channel.eventLoop();<br>        <span class="hljs-comment">// 创建一个地址解析器，其中包含一个地址格式匹配器</span><br>        <span class="hljs-keyword">final</span> AddressResolver&lt;SocketAddress&gt; resolver = <span class="hljs-keyword">this</span>.resolver.getResolver(eventLoop);<br><br>        <span class="hljs-comment">// 若解析器不支持该地址 或 该地址已经解析过了，则直接对该地址进行连接，</span><br>        <span class="hljs-comment">// 返回可修改的promise，即成功了就成功，失败了则promise中有失败信息</span><br>        <span class="hljs-keyword">if</span> (!resolver.isSupported(remoteAddress) || resolver.isResolved(remoteAddress)) &#123;<br>            doConnect(remoteAddress, localAddress, promise);<br>            <span class="hljs-keyword">return</span> promise;<br>        &#125;<br>        <span class="hljs-comment">// 以异步方式解析server地址</span><br>        <span class="hljs-keyword">final</span> Future&lt;SocketAddress&gt; resolveFuture = resolver.resolve(remoteAddress);<br><br>        <span class="hljs-keyword">if</span> (resolveFuture.isDone()) &#123;  <span class="hljs-comment">// 处理解析完成的情况（成功或异常）</span><br>            <span class="hljs-keyword">final</span> Throwable resolveFailureCause = resolveFuture.cause();<br><br>            <span class="hljs-keyword">if</span> (resolveFailureCause != null) &#123;  <span class="hljs-comment">// 若异步解析中出现了问题，则直接关闭channel</span><br>                channel.<span class="hljs-built_in">close</span>();<br>                promise.setFailure(resolveFailureCause);<br>            &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 处理异步解析成功的情况</span><br>                <span class="hljs-comment">// resolveFuture.getNow() 从异步对象中获取解析结果，即解析过的地址</span><br>                doConnect(resolveFuture.getNow(), localAddress, promise);<br>            &#125;<br>            <span class="hljs-keyword">return</span> promise;<br>        &#125;<br><br>        resolveFuture.addListener(<span class="hljs-keyword">new</span> FutureListener&lt;SocketAddress&gt;() &#123;<br>            @Override<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> operationComplete(Future&lt;SocketAddress&gt; <span class="hljs-built_in">future</span>) throws Exception &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">future</span>.cause() != null) &#123;<br>                    channel.<span class="hljs-built_in">close</span>();<br>                    promise.setFailure(<span class="hljs-built_in">future</span>.cause());<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    doConnect(<span class="hljs-built_in">future</span>.getNow(), localAddress, promise);<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable cause) &#123;<br>        promise.tryFailure(cause);<br>    &#125;<br>    <span class="hljs-keyword">return</span> promise;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>doResolveAndConnect0</code> 方法我们直接画个图看下逻辑流程，具体的需要我们细看的时 <code>doConnect</code> 的连接方法。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-45.jpg"></p><p>下面我们继续跟 doConnect 方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> doConnect(<br>    final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise connectPromise) &#123;<br><br>    final Channel channel = connectPromise.channel();<br>    channel.eventLoop().execute(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Runnable</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>            <span class="hljs-keyword">if</span> (localAddress == <span class="hljs-literal">null</span>) &#123;<br>                channel.connect(remoteAddress, connectPromise);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                channel.connect(remoteAddress, localAddress, connectPromise);<br>            &#125;<br>            <span class="hljs-comment">// 为promise添加一个异常监听器。连接过程发生异常，则关闭channel</span><br>            connectPromise.addListener(ChannelFutureListener.CLOSE_ON_FAILURE);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里获取 channel 中绑定的 EventLoop 调用 execute 方法，上面关于 channel 的注册绑定流程大家还有印象没？这里调用的代码就是下面这段：<code>SingleThreadEventExecutor#execute</code></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-46.jpg"></p><p>做的事情就是添加任务，因为当前的线程就是 eventLoop ，所以 !inEventLoop == false。在这里的逻辑只是添加任务。上面在介绍的 channel 绑定注册时候走的逻辑还有启动线程，在这里连接的时候相当于线程已经启动，这里只是添加任务，最后任务会在前面介绍的 run 方法里面执行（<strong>Tag 1.3.3  eventLoop.excute() 的 run 方法执行分析</strong>）。</p><p>这里就直接看这个匿名内部内的方法，继续跟 connect 方法：<code>io.netty.channel.AbstractChannel#connect(java.net.SocketAddress, java.net.SocketAddress, io.netty.channel.ChannelPromise)</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> pipeline.<span class="hljs-built_in">connect</span>(remoteAddress, localAddress, promise);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 pipeline 进行连接：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> tail.<span class="hljs-built_in">connect</span>(remoteAddress, localAddress, promise);<br>&#125;<br></code></pre></td></tr></table></figure><p>pipeline 获取为节点进行调用连接：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> ChannelFuture connect(<br>    final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) &#123;<br><br>    <span class="hljs-keyword">if</span> (remoteAddress == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;remoteAddress&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (isNotValidPromise(promise, <span class="hljs-literal">false</span>)) &#123;<br>        <span class="hljs-comment">// cancelled</span><br>        <span class="hljs-keyword">return</span> promise;<br>    &#125;<br><br>    <span class="hljs-comment">// 查找要处理该请求的处理器节点</span><br>    final AbstractChannelHandlerContext next = findContextOutbound(MASK_CONNECT);<br>    <span class="hljs-comment">// 获取处理器节点的executor</span><br>    EventExecutor executor = next.executor();<br>    <span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;<br>        next.invokeConnect(remoteAddress, localAddress, promise);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        safeExecute(executor, <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Runnable</span>(<span class="hljs-params"></span>)</span> &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>                next.invokeConnect(remoteAddress, localAddress, promise);<br>            &#125;<br>        &#125;, promise, <span class="hljs-literal">null</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> promise;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里首先 <code>findContextOutbound</code> 找到处理器节点，后面说。然后获取处理器的 EventExecutor。执行 invokeConnect。这里主要看 <code>invokeConnect</code> 连接处理：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void invoke<span class="hljs-constructor">Connect(SocketAddress <span class="hljs-params">remoteAddress</span>, SocketAddress <span class="hljs-params">localAddress</span>, ChannelPromise <span class="hljs-params">promise</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (invoke<span class="hljs-constructor">Handler()</span>) &#123;  <span class="hljs-comment">// 判断该处理器节点中对应的处理器是否已经添加</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            ((ChannelOutboundHandler) handler<span class="hljs-literal">()</span>).connect(this, remoteAddress, localAddress, promise);<br>        &#125; catch (Throwable t) &#123;<br>            notify<span class="hljs-constructor">OutboundHandlerException(<span class="hljs-params">t</span>, <span class="hljs-params">promise</span>)</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        connect(remoteAddress, localAddress, promise);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接继续跟<code>connect</code> 方法，这里找到的是匿名内部内 HeadContext：<code>io.netty.channel.DefaultChannelPipeline.HeadContext#connect</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    ChannelHandlerContext ctx,</span></span><br><span class="hljs-function"><span class="hljs-params">    SocketAddress remoteAddress, SocketAddress localAddress,</span></span><br><span class="hljs-function"><span class="hljs-params">    ChannelPromise promise)</span> </span>&#123;<br>    <span class="hljs-comment">// 连接</span><br>    unsafe.<span class="hljs-built_in">connect</span>(remoteAddress, localAddress, promise);<br>&#125;<br></code></pre></td></tr></table></figure><p>获取到底层 unsafe 对象进行连接：<code>io.netty.channel.nio.AbstractNioChannel.AbstractNioUnsafe#connect</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> final <span class="hljs-built_in">void</span> connect(<br>    final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) &#123;<br>    <span class="hljs-keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (connectPromise != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// Already a connect in process.</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConnectionPendingException();<br>        &#125;<br><br>        <span class="hljs-built_in">boolean</span> wasActive = isActive();<br>        <span class="hljs-keyword">if</span> (doConnect(remoteAddress, localAddress)) &#123;  <span class="hljs-comment">// 连接            </span><br>            <span class="hljs-comment">// 省略+......</span><br></code></pre></td></tr></table></figure><p>这里进行连接，找到 <code>doConnect</code> 连接方法：<code>io.netty.channel.socket.nio.NioSocketChannel#doConnect</code></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">protected boolean <span class="hljs-keyword">do</span><span class="hljs-constructor">Connect(SocketAddress <span class="hljs-params">remoteAddress</span>, SocketAddress <span class="hljs-params">localAddress</span>)</span> throws Exception &#123;<br>    <span class="hljs-keyword">if</span> (localAddress != null) &#123;<br>        <span class="hljs-keyword">do</span><span class="hljs-constructor">Bind0(<span class="hljs-params">localAddress</span>)</span>;  <span class="hljs-comment">// 将localAddress绑定到channel</span><br>    &#125;<br><br>    boolean success = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 连接server地址，若本次连接成功，则成功；若不成功，则当前channel的连接就绪</span><br>        boolean connected = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SocketUtils</span>.</span></span>connect(java<span class="hljs-constructor">Channel()</span>, remoteAddress);<br>        <span class="hljs-keyword">if</span> (!connected) &#123;<br>            <span class="hljs-comment">// 指定其关注的事件为  连接就绪</span><br>            selection<span class="hljs-constructor">Key()</span>.interest<span class="hljs-constructor">Ops(SelectionKey.OP_CONNECT)</span>;<br>        &#125;<br>        success = <span class="hljs-literal">true</span>;<br>        return connected;<br>    &#125; finally &#123;<br>        <span class="hljs-keyword">if</span> (!success) &#123;<br>            <span class="hljs-keyword">do</span><span class="hljs-constructor">Close()</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>doBind0(localAddress)</code> 将Client 端指定的端口号绑定到 channel，localAddress 为配置类设置的 Client 端口号。</p><p>然后进行连接，这里首先在执行时直接进行连接，如果第一次连接成功则直接返回成功，如果失败，注册 Selector 事件 OP_CONNECT ，即将当前 channel 修改为连接就绪，后续执行到 run 方法时就会再次执行连接，直到连接成功，结束当前连接就绪。</p><p>到这就是整个 Client 的启动。整体看下来可以类比 Server 端，大体流程还是差不多的。学就完了。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-47.jpg"></p><h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><p>前面说了那么学完，大家对于 Netty 执行流程，Server 端和 Client 端的启动，大家都有了很深的认识，前面也留了很大一块关于 Netty 服务启动之后的处理过程，这部分也就是前面没有说的 Pipeline 的部分知识点。下面我们就重点说说 Pipeline 。</p><h4 id="Pipeline-的创建"><a href="#Pipeline-的创建" class="headerlink" title="Pipeline 的创建"></a>Pipeline 的创建</h4><p>先找到代码，Pipeline 的创建其实在前面也有看到，这个入口就在Server 端和 Client 端启动的时创建 Channel 的时候。找到代码：<code>io.netty.channel.AbstractChannel#AbstractChannel(io.netty.channel.Channel)</code></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">protected <span class="hljs-constructor">AbstractChannel(Channel <span class="hljs-params">parent</span>)</span> &#123;<br>    this.parent = parent;<br>    <span class="hljs-comment">// 为channel生成id，由五部分构成</span><br>    id = <span class="hljs-keyword">new</span><span class="hljs-constructor">Id()</span>;<br>    <span class="hljs-comment">// 生成一个底层操作对象unsafe</span><br>    unsafe = <span class="hljs-keyword">new</span><span class="hljs-constructor">Unsafe()</span>;<br>    <span class="hljs-comment">// 创建与这个channel相绑定的channelPipeline</span><br>    pipeline = <span class="hljs-keyword">new</span><span class="hljs-constructor">ChannelPipeline()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>newChannelPipeline()</code> 这个就是 Pipeline 的创建入口，跟进去：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe">protected DefaultChannelPipeline <span class="hljs-keyword">new</span><span class="hljs-type">ChannelPipeline</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">DefaultChannelPipeline</span>(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这里是直接创建了 <code>DefaultChannelPipeline</code>。直接找到构造方法：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">protected <span class="hljs-constructor">DefaultChannelPipeline(Channel <span class="hljs-params">channel</span>)</span> &#123;<br>    this.channel = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ObjectUtil</span>.</span></span>check<span class="hljs-constructor">NotNull(<span class="hljs-params">channel</span>, <span class="hljs-string">&quot;channel&quot;</span>)</span>;<br>    succeededFuture = <span class="hljs-keyword">new</span> <span class="hljs-constructor">SucceededChannelFuture(<span class="hljs-params">channel</span>, <span class="hljs-params">null</span>)</span>;<br>    voidPromise =  <span class="hljs-keyword">new</span> <span class="hljs-constructor">VoidChannelPromise(<span class="hljs-params">channel</span>, <span class="hljs-params">true</span>)</span>;<br><br>    <span class="hljs-comment">// 创建尾节点</span><br>    tail = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TailContext(<span class="hljs-params">this</span>)</span>;<br>    <span class="hljs-comment">// 创建头节点</span><br>    head = <span class="hljs-keyword">new</span> <span class="hljs-constructor">HeadContext(<span class="hljs-params">this</span>)</span>;<br><br>    <span class="hljs-comment">// 将头尾节点连接</span><br>    head.next = tail;<br>    tail.prev = head;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol><li>创建一个记录成功的 succeededFuture 。</li><li>创建一个记录异常的 voidPromise，在 <code>VoidChannelPromise</code> 方法中创建了一个异常监听器，触发重写的 <code>fireExceptionCaught(cause)</code> 的方法执行。</li><li>创建一个尾节点。</li><li>创建一个头节点。</li><li>将收尾节点关联起来。</li></ol></blockquote><p>这里我们去看看两个 TailContext 和 HeadContext。两个差不多，先看 <code>new TailContext(this);</code>.这里 TailContext 是一个内部类：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-48.jpg"></p><p>实现了 ChannelInboundHandler 处理器，是一个 InboundHandler。关于 InboundHandler 和 OutboundHandler 处理器下面单独说，这里不展开。只要知道 InboundHandler 的方法都是处理回调的方法。</p><p>这里还是看 TailContext 的构造方法。第一步调用了父类构造，然后修改节点的处理器状态，先进去看看修改节点处理器状态的方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript">final <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">setAddComplete</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        int oldState = handlerState; <span class="hljs-comment">// 获取处理器状态</span><br>        <span class="hljs-keyword">if</span> (oldState == REMOVE_COMPLETE) &#123; <span class="hljs-comment">// 处理器状态为移除状态</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 通过CAS方式将处理器状态修改为 添加完毕</span><br>        <span class="hljs-keyword">if</span> (HANDLER_STATE_UPDATER.compareAndSet(<span class="hljs-built_in">this</span>, oldState, ADD_COMPLETE)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>就是通过 CAS 的方式将当前节点的处理器状态修改为添加完毕。然后我们再回去跟父类构造：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript">AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor,<br>                              <span class="hljs-built_in">String</span> name, Class&lt;? <span class="hljs-keyword">extends</span> ChannelHandler&gt; handlerClass) &#123;<br>    <span class="hljs-built_in">this</span>.name = ObjectUtil.checkNotNull(name, <span class="hljs-string">&quot;name&quot;</span>);<br>    <span class="hljs-built_in">this</span>.pipeline = pipeline;<br>    <span class="hljs-comment">// 每个处理器节点都会绑定一个executor</span><br>    <span class="hljs-built_in">this</span>.executor = executor;<br>    <span class="hljs-comment">// 执行标记</span><br>    <span class="hljs-built_in">this</span>.executionMask = mask(handlerClass);<br>    ordered = executor == <span class="hljs-literal">null</span> || executor <span class="hljs-keyword">instanceof</span> OrderedEventExecutor;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里先是绑定 pipeline 和 executor，不过这里的 executor 传入是 null，每个处理器节点都会绑定一个 Ececutor ，如果当前处理器的 executor 为空则直接使用 channel 的 Executor 来执行当前处理器节点里的处理器方法。</p><p>这里我们跟进去看下 <code>mask(handlerClass)</code> 方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">static</span> int <span class="hljs-function"><span class="hljs-title">mask</span>(<span class="hljs-params">Class&lt;? <span class="hljs-keyword">extends</span> ChannelHandler&gt; clazz</span>)</span> &#123;<br>    <span class="hljs-comment">// 从缓存中尝试着获取标记</span><br>    <span class="hljs-built_in">Map</span>&lt;Class&lt;? <span class="hljs-keyword">extends</span> ChannelHandler&gt;, Integer&gt; cache = MASKS.get();<br>    Integer mask = cache.get(clazz);<br>    <span class="hljs-keyword">if</span> (mask == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 创建一个标记</span><br>        mask = mask0(clazz);<br>        cache.put(clazz, mask);<br>    &#125;<br>    <span class="hljs-keyword">return</span> mask;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这个方法是一个静态的，首先从缓存中获取标记数据，获取不到为当前处理器类创建缓存标记：<code>mask0(clazz)</code>:</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-49.jpg"></p><p>这是充分使用了<strong>二进制的开关的性质</strong>，这里方法的作用就是将所有的 InboundHandler 处理器和 OutboundHandler 处理器中定义的方法进行标记，如果其中的方法被实现了，并且方法中没有 <code>@Skip</code> 注解，则当前方法对应的二进制位的值是 1，当当前标记位等于 1 时，则标记当前方法时需要执行的。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-50.jpg"></p><p>其实这里在 TailContext 和 HeadContext 中所有的标记位都是 1，因为 TailContext 和 HeadContext 分别都实现了 InboundHandler  和 OutboundHandler 接口中的接口。这里说这个主要因为这里在我们自定义的处理器时就会使用到。扎到一个自定义的处理器：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-51.jpg"></p><p>我们没有直接实现自 InboundHandler，而是直接继承了 ChannelInboundHandlerAdapter ，大家可以进去看看，在 ChannelInboundHandlerAdapter 中每一个实现方法上都有一个  <code>@Skip</code> 注解，而且它默认实现了所有的 InboundHandler 接口的方法，就是为了我们在定义自定义处理器减少一些默认实现的处理，而且为了性能在初始化时将所有的方法打上标记，保证只执行我们自己实现的方法，这就是这个标记的用处。这里 <code>mask</code> 处理的都是 InboundHandler  和 OutboundHandler 处理器中的接口方法。</p><p>好了到这里 TailContext 节点创建完成，我们接着看 HeadContext 节点：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 头节点既是inbound处理器，也是outbound处理器</span><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeadContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractChannelHandlerContext</span></span><br><span class="hljs-class">            <span class="hljs-title">implements</span> <span class="hljs-title">ChannelOutboundHandler</span>, <span class="hljs-title">ChannelInboundHandler</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Unsafe</span> unsafe;<br><br>        <span class="hljs-type">HeadContext</span>(<span class="hljs-type">DefaultChannelPipeline</span> pipeline) &#123;<br>            <span class="hljs-keyword">super</span>(pipeline, <span class="hljs-literal">null</span>, <span class="hljs-type">HEAD_NAME</span>, <span class="hljs-type">HeadContext</span>.<span class="hljs-keyword">class</span>);<br>            unsafe = pipeline.channel().unsafe();<br>            setAddComplete();<br>        &#125;<br>        <span class="hljs-comment">// 。。。。</span><br></code></pre></td></tr></table></figure><p>HeadContext  也是内部类，这里与 TailContext 不同的是，HeadContext  同时实现了 InboundHandler  和 OutboundHandler。并且创建了一个用于底层 IO 处理的 unsafe 对象。到这里 Pipeline 的初始化创建看完了，可以看到 Pipeline 在 Channel 的创建的时初始化创建的。</p><p>下面说一下一个特殊的处理器，前面也是一直看到：<code>ChannelInitializer</code>处理器。</p><h4 id="ChannelInitializer-处理器节点"><a href="#ChannelInitializer-处理器节点" class="headerlink" title="ChannelInitializer 处理器节点"></a>ChannelInitializer 处理器节点</h4><p>先看下类图：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-52.jpg"></p><p>ChannelInitializer 继承于 ChannelInboundHandler 接口，是一个抽象类，定义了一个抽象方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(C ch)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br></code></pre></td></tr></table></figure><p>以 Server 端为例，我们在使用 ChannelInitializer 时都需要实现 <code>initChannel</code> 方法：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-53.jpg"></p><p>在 ServerBootstrap 中 <code>io.netty.bootstrap.ServerBootstrap#init</code> 方法中可以找到代码：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">p.addLast(<span class="hljs-keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">final</span> ChannelPipeline pipeline = ch.pipeline();<br>        ChannelHandler <span class="hljs-keyword">handler</span> = config.<span class="hljs-keyword">handler</span>();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">handler</span> != <span class="hljs-keyword">null</span>) &#123;<br>            pipeline.addLast(<span class="hljs-keyword">handler</span>);<br>        &#125;<br><br>        ch.eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                pipeline.addLast(<span class="hljs-keyword">new</span> ServerBootstrapAcceptor(<br>                    ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>负责在 accept 新连接的 Channel 的 pipeline 被添加了一个 ChannelInitializer，由于此时这个 Channel 还没有被注册到EventLoop，于是在 addLast 方法的调用链中，会给 pipeline 添加一个 <code>PendingHandlerAddedTask</code> ，其目的是在 Channel被注册到 EventLoop 的时候，触发一个回调事件然后在 <code>AbstractBootstrap.initAndRegister()</code> 方法中，这个Channel会被注册到 ParentEventLoopGoup，接着会被注册到 ParentEventLoopGoup 中的某一个具体的 EventLoop 然后在AbstractChannel.register0() 方法中，之前注册的 PendingHandlerAddedTask 会被调用，经过一系列调用之后，最终 <code>ChannelInitializer.handleAdded()</code> 方法会被触发。所以我们进去看 <code>ChannelInitializer.handleAdded()</code> 方法:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 当前处理器所封装的处理器节点被添加到pipeline后就会触发该方法的执行</span><br>public void handler<span class="hljs-constructor">Added(ChannelHandlerContext <span class="hljs-params">ctx</span>)</span> throws Exception &#123;<br>    <span class="hljs-keyword">if</span> (ctx.channel<span class="hljs-literal">()</span>.is<span class="hljs-constructor">Registered()</span>) &#123;  <span class="hljs-comment">// 若channel已经完成了注册</span><br>        <span class="hljs-keyword">if</span> (init<span class="hljs-constructor">Channel(<span class="hljs-params">ctx</span>)</span>) &#123;<br>            <span class="hljs-comment">// 将当前处理器节点从initMap集合中删除</span><br>            remove<span class="hljs-constructor">State(<span class="hljs-params">ctx</span>)</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 ChannelInitializer 的方法触发时必须在 Channel 注册完成之后，然后开始执行 initChannel 方法，在初始化操作完成之后又将当前处理器节点从 initMap 集合中移除。现在先看看 initChannel 方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> boolean initChannel(ChannelHandlerContext ctx) throws Exception &#123;<br>    <span class="hljs-comment">// 将当前处理器节点添加到initMap集合中</span><br>    <span class="hljs-keyword">if</span> (initMap.add(ctx)) &#123; <span class="hljs-comment">// Guard against re-entrance.</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 调用重写的initChannel()</span><br>            initChannel((C) ctx.channel());<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable cause) &#123;<br>            exceptionCaught(ctx, cause);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 立即将该处理器节点从pipeline上删除</span><br>            ChannelPipeline pipeline = ctx.pipeline();<br>            <span class="hljs-comment">// 查找在pipeline中是否存在当前处理器</span><br>            <span class="hljs-keyword">if</span> (pipeline.context(<span class="hljs-keyword">this</span>) != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 将当前处理器节点从pipeline中删除</span><br>                pipeline.remove(<span class="hljs-keyword">this</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>initChannel</code> 方法中，先将当前处理器节点添加到 initMap 中，然后调用抽象方法 <code>initChannel</code> ，由此调用到抽象类的实现方法，也就是在前面 Server 端代码中我们初始化 childHandler 时添加的实现方法，不过 ChannelInitializer 在 Netty 自己的代码中也有多处使用，上面说的 Server 端启动初始化的时候在 init 方法中也就有使用。不过我们自己定义的可以回顾一下：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-54.jpg"></p><p>在 Server 端 ServerBootstrap 中我们使用 ChannelInitializer 给 pipeline 中添加处理器节点。</p><p>再回到 <code>initChannel</code> 方法。继续看再其执行完重新的 <code>initChannel</code> 方法之后必然执行 finally 的代码，首先获取当前Pipeline，<code>pipeline.context(this)</code> 从 Pieline 查找但其处理器节点是否存在。存在然后 <code>pipeline.remove(this)</code> 将其从当前 Pipeline 中移除。</p><p>感兴趣可以看下，<code>pipeline.context</code> 方法和 <code>pipeline.remove</code> 方法，因为 Pipeline 中的处理器节点 时链表形式保存的，所以在这两个方法方法的处理就是链表的查找和删除。</p><p>看到这里可以发现 ChannelInitializer 的主要目的是为程序员提供了一个简单的工具，用于在某个 Channel 注册到EventLoop 后，对这个 Channel 执行一些初始化操作。ChannelInitializer 虽然会在一开始会被注册到 Channel 相关的pipeline 里，但是在初始化完成之后，ChannelInitializer 会将自己从pipeline中移除，不会影响后续的操作。刚刚看到的 <code>pipeline.remove</code> 就是将当前处理器节点从 pipeline 移除的方法，而在执行完 <code>initChannel</code> 方法后，在 <code>handlerAdded</code> 方法中又将添加到 <code>initMap</code> 中的处理器节点也移除了。</p><h4 id="Hanndler-添加到-Pipeline"><a href="#Hanndler-添加到-Pipeline" class="headerlink" title="Hanndler 添加到 Pipeline"></a>Hanndler 添加到 Pipeline</h4><p>上面说了 ChannelInitializer  处理器节点，看到我们在重写 initChannel 方法时调用的都有 pipeline 新增处理器方法，也就是 <code>addLast</code> 方法，这里我们详细看看 addLast 怎么将处理器添加到 pipeline 的：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">io.netty.channel.DefaultChannelPipeline#add<span class="hljs-constructor">Last(<span class="hljs-params">io</span>.<span class="hljs-params">netty</span>.<span class="hljs-params">channel</span>.ChannelHandler<span class="hljs-operator">...</span>)</span><br>public final ChannelPipeline add<span class="hljs-constructor">Last(ChannelHandler<span class="hljs-operator">...</span> <span class="hljs-params">handlers</span>)</span> &#123;<br>    <span class="hljs-comment">// 第一个参数为group，其值默认为null</span><br>    return add<span class="hljs-constructor">Last(<span class="hljs-params">null</span>, <span class="hljs-params">handlers</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>前面说过，每个 Pipeline 都有一个 EventLoop 绑定，这里添加方法默认传入一个 EventLoopGroup 参数，不过这里传了空；继续往下跟：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> final ChannelPipeline <span class="hljs-function"><span class="hljs-title">addLast</span>(<span class="hljs-params">EventExecutorGroup executor, ChannelHandler... handlers</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (handlers == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;handlers&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 遍历所有handlers，逐个添加到pipeline</span><br>    <span class="hljs-keyword">for</span> (ChannelHandler h: handlers) &#123;<br>        <span class="hljs-keyword">if</span> (h == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        addLast(executor, <span class="hljs-literal">null</span>, h);<span class="hljs-comment">// 这里第二个参数是处理器name</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>遍历传入参数，将 Handler 循环添加到 Pipeline 中：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> final ChannelPipeline addLast(EventExecutorGroup group, <span class="hljs-keyword">String</span> name, ChannelHandler handler) &#123;<br>    final AbstractChannelHandlerContext <span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>;<br>    synchronized (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-comment">// 检测处理器是否被多次添加</span><br>        checkMultiplicity(handler);<br><br>        <span class="hljs-comment">// 将处理器包装为一个节点 filterName() 获取到节点的名称</span><br>        <span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span> = <span class="hljs-keyword">new</span><span class="hljs-type">Context</span>(group, filterName(name, handler), handler);<br><br>        <span class="hljs-comment">// 将新的节点添加到pipeline</span><br>        addLast0(<span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>);<br>        <br>        <span class="hljs-keyword">if</span> (!registered) &#123;<br>            <span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>.setAddPending();<br>            callHandlerCallbackLater(<span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>, <span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 获取新建节点绑定的eventLoop</span><br>        EventExecutor executor = <span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>.executor();<br>        <span class="hljs-comment">// 若该eventLoop绑定的线程与当前线程不是同一个，则执行下面的代码</span><br>        <span class="hljs-keyword">if</span> (!executor.inEventLoop()) &#123;<br>            callHandlerAddedInEventLoop(<span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>, executor);<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 若该eventLoop绑定的线程与当前线程是同一个线程，</span><br>    <span class="hljs-comment">// 则调用重写的handlerAdded()方法</span><br>    callHandlerAdded0(<span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol><li>校验当前处理器是否被多次添加，没有被 @Sharable 注解标注的处理器只可以被添加一次。</li><li>将处理器包装一个新的节点 <code>newContext(group, filterName(name, handler), handler)</code></li><li>将新的节点添加到 Pipeline 中。<code>addLast0(newCtx)</code></li><li>判断 channel 没有注册，处理异常情况。<code>callHandlerCallbackLater(newCtx, true)</code></li><li>获取新节点的 EventLoop ，判断是否是当前线程，如果不是当前线程执行 <code>callHandlerAddedInEventLoop(newCtx, executor)</code></li><li>新节点的 EventLoop 是当前线程执行 <code>callHandlerAdded0(newCtx)</code></li></ol><p>这里我们标记几个需要往下细跟的代码：</p><p><strong>Tag Handler 1 ：newContext</strong></p><p><strong>Tag Handler 2 ：addLast0</strong></p><p><strong>Tag Handler 3  callHandlerCallbackLater/callHandlerAdded0</strong></p></blockquote><h5 id="Tag-Handler-1-：newContext"><a href="#Tag-Handler-1-：newContext" class="headerlink" title="Tag Handler 1 ：newContext"></a>Tag Handler 1 ：newContext</h5><p>这里处理还是比较复杂，我们具体进去看：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> AbstractChannelHandlerContext <span class="hljs-keyword">new</span><span class="hljs-constructor">Context(EventExecutorGroup <span class="hljs-params">group</span>, String <span class="hljs-params">name</span>, ChannelHandler <span class="hljs-params">handler</span>)</span> &#123;<br>    <span class="hljs-comment">// childExecutor() 获取与当前处理器节点相绑定的eventLoop</span><br>    return <span class="hljs-keyword">new</span> <span class="hljs-constructor">DefaultChannelHandlerContext(<span class="hljs-params">this</span>, <span class="hljs-params">childExecutor</span>(<span class="hljs-params">group</span>)</span>, name, handler);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先这里我们传入的 group 是 null ，前面一直没有传，这里调用 <code>childExecutor(group)</code> 直接跟进去：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">private</span> EventExecutor childExecutor(EventExecutorGroup <span class="hljs-keyword">group</span>) &#123;<br>    <span class="hljs-comment">// 若group为null，则与该节点绑定的eventLoop为null</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">group</span> == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">Boolean</span> pinEventExecutor = channel.config().getOption(ChannelOption.SINGLE_EVENTEXECUTOR_PER_GROUP);<br>    <span class="hljs-keyword">if</span> (pinEventExecutor != <span class="hljs-keyword">null</span> &amp;&amp; !pinEventExecutor) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">group</span>.<span class="hljs-keyword">next</span>();<br>    &#125;<br><br>    Map&lt;EventExecutorGroup, EventExecutor&gt; childExecutors = <span class="hljs-keyword">this</span>.childExecutors;<br>    <span class="hljs-keyword">if</span> (childExecutors == <span class="hljs-keyword">null</span>) &#123;<br>        childExecutors = <span class="hljs-keyword">this</span>.childExecutors = <span class="hljs-keyword">new</span> IdentityHashMap&lt;EventExecutorGroup, EventExecutor&gt;(<span class="hljs-number">4</span>);<br>    &#125;<br>    EventExecutor childExecutor = childExecutors.get(<span class="hljs-keyword">group</span>);<br>    <span class="hljs-keyword">if</span> (childExecutor == <span class="hljs-keyword">null</span>) &#123;<br>        childExecutor = <span class="hljs-keyword">group</span>.<span class="hljs-keyword">next</span>();<br>        childExecutors.put(<span class="hljs-keyword">group</span>, childExecutor);<br>    &#125;<br>    <span class="hljs-keyword">return</span> childExecutor;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实在我们没有指定 Group 的时候，这里代码是被直接返回了出去，下面执行逻辑就没有执行，而此时节点的 EventLoop 是在 <code>EventExecutor executor = newCtx.executor();</code> 中绑定的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> EventExecutor <span class="hljs-function"><span class="hljs-title">executor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (executor == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> channel().eventLoop();  <span class="hljs-comment">// 获取到channel所绑定的eventLoop</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> executor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在新节点获取当前节点绑定的 Executor 时如果未绑定，则直接获取当前 Channle 的 eventLoop 。这里再回去看 <code>childExecutor</code> 方法，如果要走到下面逻辑则需要到添加 Handler 时传入一个 EventLoopGroup：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-55.jpg"></p><p>好了，这样我们的 Group 就不为 null。继续看 childExecutor 下面的逻辑：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">private</span> EventExecutor childExecutor(EventExecutorGroup <span class="hljs-keyword">group</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">group</span> == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">Boolean</span> pinEventExecutor = channel.config().getOption(ChannelOption.SINGLE_EVENTEXECUTOR_PER_GROUP);<br>    <span class="hljs-keyword">if</span> (pinEventExecutor != <span class="hljs-keyword">null</span> &amp;&amp; !pinEventExecutor) &#123;<br>        <span class="hljs-comment">// 轮询获取 eventLoop</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">group</span>.<span class="hljs-keyword">next</span>();<br>    &#125;<br><br>    Map&lt;EventExecutorGroup, EventExecutor&gt; childExecutors = <span class="hljs-keyword">this</span>.childExecutors;<br>    <span class="hljs-keyword">if</span> (childExecutors == <span class="hljs-keyword">null</span>) &#123;<br>        childExecutors = <span class="hljs-keyword">this</span>.childExecutors = <span class="hljs-keyword">new</span> IdentityHashMap&lt;EventExecutorGroup, EventExecutor&gt;(<span class="hljs-number">4</span>);<br>    &#125;<br><br>    EventExecutor childExecutor = childExecutors.get(<span class="hljs-keyword">group</span>);<br>    <span class="hljs-keyword">if</span> (childExecutor == <span class="hljs-keyword">null</span>) &#123;<br>        childExecutor = <span class="hljs-keyword">group</span>.<span class="hljs-keyword">next</span>();<br>        childExecutors.put(<span class="hljs-keyword">group</span>, childExecutor);<br>    &#125;<br>    <span class="hljs-keyword">return</span> childExecutor;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol><li>获取 channel 的 option 配置的 <code>SINGLE_EVENTEXECUTOR_PER_GROUP</code> 值。用来配置当前处理器节点是否绑定使用同一个 EventLoop。不为空并且是 False : 则表示一个group中的每一个处理器都会分配一个 eventLoop，调用 EventLoopGroup 的 <code>next</code> 方法，而 <code>next</code> 是轮询的方式从 Group 中选取 EventLoop。</li><li>没有配置使用同一个 eventLoop 则先获取缓存中保存的 EventLoopGroup 对应的 eventLoop，如果缓存中存在则直接返回，如果缓存中不存在则从 EventLoopGroup 获取一个 eventLoop，保存到缓存中并返回。</li></ol></blockquote><p>这就是创建处理器节点中绑定 EventLoop 的方法。所以到这可以看到处理器节点的 EventLoop 可以指定，不指定则直接使用当前 channel 的 EventLoop 。拿到 EventLoop  之后则直接创建处理器节点 <code>new DefaultChannelHandlerContext</code></p><h5 id="Tag-Handler-2-：addLast0"><a href="#Tag-Handler-2-：addLast0" class="headerlink" title="Tag Handler 2 ：addLast0."></a>Tag Handler 2 ：addLast0.</h5><p>这里直接找到代码跟进去：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">private</span> void addLast0(AbstractChannelHandlerContext <span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>) &#123;<br>    AbstractChannelHandlerContext prev = tail.prev;<br>    <span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>.prev = prev;<br>    <span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>.next = tail;<br>    prev.next = <span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>;<br>    tail.prev = <span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是一个链表操作，先获取到当前 Pipeline 的 TailContext 节点，因为这里是我们从 <code>addLast</code> 方法跟进来的，所以这里是添加在尾节点前，也就是末尾添加。同样类比其他的 Handler 添加方法 <code>addBefore</code>。这里获取到 Tail 节点，将链表收尾关联到新的节点上，完成链表的新增即完成新节点添加。</p><h5 id="Tag-Handler-3-callHandlerCallbackLater-callHandlerAdded0"><a href="#Tag-Handler-3-callHandlerCallbackLater-callHandlerAdded0" class="headerlink" title="Tag Handler 3  callHandlerCallbackLater/callHandlerAdded0"></a>Tag Handler 3  callHandlerCallbackLater/callHandlerAdded0</h5><p>直接跟 <code>callHandlerCallbackLater</code>方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">callHandlerAddedInEventLoop</span>(<span class="hljs-params">final AbstractChannelHandlerContext newCtx, EventExecutor executor</span>)</span> &#123;<br>    newCtx.setAddPending(); <span class="hljs-comment">// 将当前节点状态设置成处理中，等待 callHandlerAdded0 执行完成</span><br>    executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Runnable</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>            callHandlerAdded0(newCtx);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这个方法也是调用的 <code>callHandlerAdded0</code> 方法，只不过因为当前节点绑定的 EventLoop 不是当前执行线程，所以需要通过 EventLoop 创建一个新的任务，由任务来完成 <code>callHandlerAdded0</code> 方法的执行，而是当前线程则直接执行 <code>callHandlerAdded0</code> 方法。继续看 <code>callHandlerAdded0</code> 方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">callHandlerAdded0</span>(<span class="hljs-params">final AbstractChannelHandlerContext ctx</span>)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        ctx.callHandlerAdded();<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-built_in">boolean</span> removed = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            remove0(ctx);<br>            ctx.callHandlerRemoved();<br>            removed = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t2) &#123;<br>            <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;<br>                logger.warn(<span class="hljs-string">&quot;Failed to remove a handler: &quot;</span> + ctx.name(), t2);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (removed) &#123;<br>            fireExceptionCaught(<span class="hljs-keyword">new</span> ChannelPipelineException(<br>                ctx.handler().getClass().getName() +<br>                <span class="hljs-string">&quot;.handlerAdded() has thrown an exception; removed.&quot;</span>, t));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            fireExceptionCaught(<span class="hljs-keyword">new</span> ChannelPipelineException(<br>                ctx.handler().getClass().getName() +<br>                <span class="hljs-string">&quot;.handlerAdded() has thrown an exception; also failed to remove.&quot;</span>, t));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里直接调用当前处理器的 <code>callHandlerAdded</code> 方法，如果异常则将资源移除。进到 <code>callHandlerAdded</code> 方法中：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">callHandlerAdded</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">if</span> (setAddComplete()) &#123; <span class="hljs-comment">// CAS 方式将处理器状态修改为 添加完毕 ADD_COMPLETE</span><br>        <span class="hljs-keyword">handler</span>().handlerAdded(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先通过 CAS 修改处理器状态为添加完成，状态修改成功则调用处理器的添加方法完成处理器添加。</p><p>到这里处理器的添加完成。添加处理器方法画个图再回顾一下：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-56.jpg"></p><p>说到这里，pipeline 的初始化到 Pipeline 中添加 Handler 。那到这里我们在整体的理解下 Pipeline：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-57.jpg"></p><p>现在在结合这个图去理解一下 Pipeline 的创建和添加的过程应该心里面会有点不一样认知。当然说到这里还是没有说到 Pipeline 的执行顺序，下面我们从 InboundHandler 处理器和 OutboundHandler 处理器来说 Pipeline 的执行过程。</p><h3 id="Pipeline-中消息的传递与处理"><a href="#Pipeline-中消息的传递与处理" class="headerlink" title="Pipeline 中消息的传递与处理"></a>Pipeline 中消息的传递与处理</h3><p>要说 Pipeline 的中的消息处理，首先还是先说下我们的 Handler，因为 Pipeline 中的消息都是由每一个处理器来完成处理的。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-58.jpg"></p><p>ChannelHandler 是 handler 的顶级接口，我们所有的处理器都实现自该接口，当前接口只定义了两个方法：<code>hanndlerAdded</code> 和 <code>handlerRemoved</code>，用于当前处理器被从 Pipeline 中添加或移除时调用的方法，还有一个过时的处理异常的方法：<code>exceptionCaught</code>。</p><p>再说 ChannelHandler  两个子类接口：<code>ChannelInboundHandler</code> 和 <code>ChannelOutboundHandler</code> 这两个接口将处理器方法定义成了两类，<code>ChannelInboundHandler</code> 定义了所有的用于处理回调的方法，都是需要出动触发的方法。<code>ChannelOutboundHandler</code> 定义的所有的用于主动调用的处理器方法，需要主动调用。</p><p>而 <code>ChannelHandlerAdapter</code> 则是处理器适配器顶级抽象类，用于定义处理器适配器的规范。</p><p><code>ChannelInboundHandlerAdapter</code> 和 <code>ChannelOutboundHandlerAdapter</code> 处理器适配器中它帮我们默认实现了所有的 handler 的方法，并且每个方法上面都标记了 <code>@Skip</code> 注解，在前面也看到，被标记 <code>@Skip</code> 注解的 Handler 方法会被标记，不会被 Handler 执行，这让我们再使用适配器之定义处理器时只要重写我们关心方法即可，重写的方法不会标记 <code>@Skip</code> 。</p><p>还有一个重要的类需要说下：<code>ChannelHandlerContext</code>，上下文对象，每个 Handler 每个方法都需要传递上下文对象，再 Pipeline 中处理器的调用就是通过 <code>ChannelHandlerContext</code> 上下文对象完成执行链的调用，也可以用来保存上下文数据。</p><p>下面就说重点，Pipeline 中 handler 的执行过程。先定义一个处理器：</p><blockquote><ol><li>InboundHandler1</li></ol><p>只实现 <code>channelRead</code> 方法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override<br>public void channel<span class="hljs-constructor">Read(ChannelHandlerContext <span class="hljs-params">ctx</span>, Object <span class="hljs-params">msg</span>)</span><br>    throws Exception &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;InboundHandler1 进入 &quot;</span> + msg);<br>    ctx.fire<span class="hljs-constructor">ChannelRead(<span class="hljs-params">msg</span>)</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;InboundHandler1 退出 &quot;</span> + msg);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>InboundHandler2</li></ol><p>只实现 <code>channelRead</code> 方法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override<br>public void channel<span class="hljs-constructor">Read(ChannelHandlerContext <span class="hljs-params">ctx</span>, Object <span class="hljs-params">msg</span>)</span><br>    throws Exception &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;InboundHandler2 进入 &quot;</span> + msg);<br>    ctx.fire<span class="hljs-constructor">ChannelRead(<span class="hljs-params">msg</span>)</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;InboundHandler2 退出 &quot;</span> + msg);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>InboundHandler3</li></ol><p>只实现 <code>channelRead</code> 方法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override<br>public void channel<span class="hljs-constructor">Read(ChannelHandlerContext <span class="hljs-params">ctx</span>, Object <span class="hljs-params">msg</span>)</span><br>    throws Exception &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;InboundHandler3 进入 &quot;</span> + msg);<br>    ctx.fire<span class="hljs-constructor">ChannelRead(<span class="hljs-params">msg</span>)</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;InboundHandler3 退出 &quot;</span> + msg);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>OutboundHandler1</li></ol><p>只实现 <code>write</code> 方法</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">@Override<br><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> <span class="hljs-keyword">write</span>(ChannelHandlerContext ctx, <span class="hljs-keyword">Object</span> msg, ChannelPromise promise)<br>        throws <span class="hljs-keyword">Exception</span> &#123;<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;OutboundHandler1 进入 &quot; + msg);<br>    ctx.<span class="hljs-keyword">write</span>(msg, promise);<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;OutboundHandler1 退出 &quot; + msg);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>OutboundHandler2</li></ol><p>只实现 <code>write</code> 方法</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">@Override<br><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> <span class="hljs-keyword">write</span>(ChannelHandlerContext ctx, <span class="hljs-keyword">Object</span> msg, ChannelPromise promise)<br>        throws <span class="hljs-keyword">Exception</span> &#123;<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;OutboundHandler2 进入 &quot; + msg);<br>    ctx.<span class="hljs-keyword">write</span>(msg, promise);<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;OutboundHandler2 退出 &quot; + msg);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>OutboundHandler3</li></ol><p>只实现 <code>write</code> 方法</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">@Override<br><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> <span class="hljs-keyword">write</span>(ChannelHandlerContext ctx, <span class="hljs-keyword">Object</span> msg, ChannelPromise promise)<br>        throws <span class="hljs-keyword">Exception</span> &#123;<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;OutboundHandler3 进入 &quot; + msg);<br>    ctx.<span class="hljs-keyword">write</span>(msg, promise);<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;OutboundHandler3 退出 &quot; + msg);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="InboundHandler-执行流程"><a href="#InboundHandler-执行流程" class="headerlink" title="InboundHandler 执行流程"></a>InboundHandler 执行流程</h4><p>添加三个 <code>InboundHandler</code>处理器，添加顺序为：</p><p><strong>InboundHandler1  -&gt;  InboundHandler2 -&gt;  InboundHandler3</strong></p><p>添加完成后 Pipeline 如图：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-59.jpg"></p><p>此时请求过，Handler 在 Pipeline 的执行流程：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-60.jpg"></p><p>当 client 请求到 Server 并写入数据时，触发 Server 端 Head 节点的 <code>channelRead</code> 方法，此时调用链开始执行，Head 节点执行 <code>channelRead</code> 方法调用 <code>fireChannelRead</code> 触发 next 节点的 <code>channelRead</code> 方法执行，不过这里会先判断 next 节点的方法标记也就是 mask 是否标记当前 Handler  是否需要执行 <code>channelRead</code> 方法，如果重写则调用，否则继续找 next 的 next 节点。举个栗子：如果 handler2 没有重写 <code>channelRead</code> 方法，则调用会变成这样：</p><p><strong>Head -&gt; handler1 -&gt; handler3 -&gt; Tail</strong>。</p><p>所以 Pipeline 的处理器执行是由 Head 节点开始，由 Head 触发 Inbound 方法，完成调用链执行。</p><p>这里我们可以找到执行调用的代码，先看 Head 节点的 channelRead 方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">channelRead</span>(<span class="hljs-params">ChannelHandlerContext ctx, <span class="hljs-built_in">Object</span> msg</span>)</span> &#123;<br>    ctx.fireChannelRead(msg);  <span class="hljs-comment">// 准备调用其下一个节点的channelRead()</span><br>&#125;<br>ctx.fireChannelRead(msg)<span class="hljs-string">` 进去看看如果调用下一个节点：`</span>io.netty.channel.AbstractChannelHandlerContext#fireChannelRead<br><span class="hljs-keyword">public</span> ChannelHandlerContext <span class="hljs-function"><span class="hljs-title">fireChannelRead</span>(<span class="hljs-params">final <span class="hljs-built_in">Object</span> msg</span>)</span> &#123;<br>    invokeChannelRead(findContextInbound(MASK_CHANNEL_READ), msg);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里通过 findContextInbound 方法获取下一个节点，传入的参数 <code>MASK_CHANNEL_READ</code> 用来判断当前处理器的 <code>channelRead</code> 方法是否被标记需要执行。进入 findContextInbound 方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> AbstractChannelHandlerContext <span class="hljs-function"><span class="hljs-title">findContextInbound</span>(<span class="hljs-params">int mask</span>)</span> &#123;<br>    AbstractChannelHandlerContext ctx = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>        ctx = ctx.next;<br>    &#125; <span class="hljs-keyword">while</span> ((ctx.executionMask &amp; mask) == <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> ctx;<br>&#125;<br></code></pre></td></tr></table></figure><p>获取当前节点的 Next 节点，判断 Next 节点的 channelRead 方法是否需要执行，不需要则继续获取下一个，知道获取到 Tail 节点，因为 Tail 实现了所有的 InboundHandler 处理器方法。</p><p>然后执行 invokeChannelRead 方法，触发 Next 节点的 channelRead 的执行：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static void invoke<span class="hljs-constructor">ChannelRead(<span class="hljs-params">final</span> AbstractChannelHandlerContext <span class="hljs-params">next</span>, Object <span class="hljs-params">msg</span>)</span> &#123;<br>    final Object m = next.pipeline.touch(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ObjectUtil</span>.</span></span>check<span class="hljs-constructor">NotNull(<span class="hljs-params">msg</span>, <span class="hljs-string">&quot;msg&quot;</span>)</span>, next);<br>    EventExecutor executor = next.executor<span class="hljs-literal">()</span>;<br>    <span class="hljs-keyword">if</span> (executor.<span class="hljs-keyword">in</span><span class="hljs-constructor">EventLoop()</span>) &#123;<br>        next.invoke<span class="hljs-constructor">ChannelRead(<span class="hljs-params">m</span>)</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Runnable()</span> &#123;<br>            @Override<br>            public void run<span class="hljs-literal">()</span> &#123;<br>                next.invoke<span class="hljs-constructor">ChannelRead(<span class="hljs-params">m</span>)</span>;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接找到  invokeChannelRead 方法：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void invoke<span class="hljs-constructor">ChannelRead(Object <span class="hljs-params">msg</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (invoke<span class="hljs-constructor">Handler()</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ((ChannelInboundHandler) handler<span class="hljs-literal">()</span>).channel<span class="hljs-constructor">Read(<span class="hljs-params">this</span>, <span class="hljs-params">msg</span>)</span>;<br>        &#125; catch (Throwable t) &#123;<br>            notify<span class="hljs-constructor">HandlerException(<span class="hljs-params">t</span>)</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fire<span class="hljs-constructor">ChannelRead(<span class="hljs-params">msg</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>invokeHandler()</code> 方法判断当前处理器状态是否完成，然后调用下一个节点的 channelRead 方法。</p><p>Inbound 执行过程的代码以 channelRead 为例就说到这，然后现在看着代码再结合上面的图大家应该很清楚整个执行的流程。</p><h4 id="OutboundHandler-执行流程"><a href="#OutboundHandler-执行流程" class="headerlink" title="OutboundHandler 执行流程"></a>OutboundHandler 执行流程</h4><p>OutboundHandler  与 InboundHandler 不一样，因为 OutboundHandler  的方法是需要我们自己调用，而不像 InboundHandler  处理器的方法是触发调用。所以在这种情况下，如果我们只添加 OutboundHandler  处理器的话，当 Client 发起请求也不会触发 OutboundHandler  的方法执行。因此我们加一个 InboundHandler 方法，用来触发 OutboundHandler 的执行。</p><p>定义 WriteInboundHandler ：重写 <code>channelRead</code> 方法</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">@Override<br><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> channelRead(ChannelHandlerContext ctx, <span class="hljs-keyword">Object</span> msg)<br>    throws <span class="hljs-keyword">Exception</span> &#123;<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;WriteInboundHandler  进入 &quot; + msg);<br>    ctx.channel().<span class="hljs-keyword">write</span>(&quot;我是 Server。&quot;);<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;InboundHWriteInboundHandler andler3 退出 &quot; + msg);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里在 WriteInboundHandler 中我们获取到 Channel，然后通过 Channel 将消息写回 Clinet 端。</p><p>Hanndler 添加顺序：<strong>WriteInboundHandler  -&gt; OutboundHandler1 -&gt; OutboundHandler2 -&gt; OutboundHandler3</strong></p><p>添加完成后 Pipeline 如图：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-61.jpg"></p><p>而此时 client 请求到 Server 并写入数据时，一样是先触发 Head 节点的 channelRead 方法。执行流程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-62.jpg"></p><p>Outbound 的处理流程与 Inbound 的流程是相反的，在 Inbound 中处理是获取 next 节点执行，而在 Outbound 节点中获取的确是 prev 节点的重写方法执行。所以这里的执行顺序会变成跟添加顺序相反的顺序执行。</p><blockquote><p>这里首先请求进入 Server 触发 Head 节点的 channelRead 方法执行，然后再获取下一个重写了 channelRead 方法的 Inbound 处理器，找到 WirteHandler 处理器，在 WirteHandler 处理器中掉用 Channel 的 writeAndFlush 方法，找到Tail 节点实现方法，调用了 Write 方法，然后获取 Prev 节点中重写了 write 方法的处理器，找到 Outbound3，然后依次调用 Outbound2 的 write 方法和 Outbound1 的 write 方法，执行完成依次返回。</p></blockquote><p>这里我们可以找到执行调用的代码：</p><p>先看 Inbound 处理器执行调用的触发过程，从 <code>ctx.channel().write</code> 的方法进入，找到 <code>io.netty.channel.DefaultChannelPipeline#write(java.lang.Object)</code>：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function">ChannelFuture <span class="hljs-title">write</span><span class="hljs-params">(Object msg)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> tail.<span class="hljs-title">write</span><span class="hljs-params">(msg)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到在 Channel 中的 Write 方法直接找到 Tail 调用其重写的 Write 方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-function"><span class="hljs-title">write</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> msg</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> write(msg, newPromise());<br>&#125;<br></code></pre></td></tr></table></figure><p>往下跟 write 方法：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">write</span>(Object msg, <span class="hljs-keyword">boolean</span> flush, ChannelPromise promise) &#123;<br>        ObjectUtil.checkNotNull(msg, <span class="hljs-string">&quot;msg&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (isNotValidPromise(promise, <span class="hljs-keyword">true</span>)) &#123;<br>                ReferenceCountUtil.release(msg);<br>                <span class="hljs-comment">// cancelled</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;<br>            ReferenceCountUtil.release(msg);<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125;<br>        <span class="hljs-comment">// 查找下一个节点(prev)</span><br>        <span class="hljs-keyword">final</span> AbstractChannelHandlerContext <span class="hljs-keyword">next</span> = findContextOutbound(flush ?<br>                (MASK_WRITE | MASK_FLUSH) : MASK_WRITE);<br>        <span class="hljs-keyword">final</span> Object m = pipeline.touch(msg, <span class="hljs-keyword">next</span>);<br>        EventExecutor executor = <span class="hljs-keyword">next</span>.executor();<br>        <span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;<br>            <span class="hljs-keyword">if</span> (flush) &#123;<br>                <span class="hljs-keyword">next</span>.invokeWriteAndFlush(m, promise);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">next</span>.invokeWrite(m, promise);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">final</span> AbstractWriteTask <span class="hljs-keyword">task</span>;<br>            <span class="hljs-keyword">if</span> (flush) &#123;<br>                <span class="hljs-keyword">task</span> = WriteAndFlushTask.newInstance(<span class="hljs-keyword">next</span>, m, promise);<br>            &#125;  <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">task</span> = WriteTask.newInstance(<span class="hljs-keyword">next</span>, m, promise);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!safeExecute(executor, <span class="hljs-keyword">task</span>, promise, m)) &#123;<br>                <span class="hljs-keyword">task</span>.cancel();<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>可以看到这里先通过 <code>findContextOutbound</code> 方法获取下一个节点：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> AbstractChannelHandlerContext <span class="hljs-function"><span class="hljs-title">findContextOutbound</span>(<span class="hljs-params">int mask</span>)</span> &#123;<br>    AbstractChannelHandlerContext ctx = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>        ctx = ctx.prev;<br>    &#125; <span class="hljs-keyword">while</span> ((ctx.executionMask &amp; mask) == <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> ctx;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里我们可以看到，Outbound 的获取顺序是获取的 prev ，并且判断该 handler 中当前方法是否标记需要执行。</p><p>获取到下一个节点之后在 wirte 方法中通过 <code>next.invokeWrite</code> 方法完成执行器链调用。当然如果我们一个 OutboundHandler 都没有定义的话，<code>findContextOutbound</code> 方法最终会获取到 Head 节点，然后执行 Head 节点 write 方法，因为我们在前面看到 HeadContext 节点同时实现了 Inboundhandler 和 OutboundHandler。这里我们去看一下 Head 节点：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">write</span>(<span class="hljs-params">ChannelHandlerContext ctx, <span class="hljs-built_in">Object</span> msg, ChannelPromise promise</span>)</span> &#123;<br>    unsafe.write(msg, promise);<br>&#125;<br></code></pre></td></tr></table></figure><p>最终在 HeadContext 中完成底层 unsafe 的 write 操作。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>至此整个 Netty 的源码应该了解的都差不多了，大家没事就可以拿出来读一下巩固一遍，脑海里再过一遍，这整个体系就在脑海中建立起来了，基本上稳了。</p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty,转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构篇-B树B+树B*树</title>
    <link href="/2020/12/27/datastructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87-B%E6%A0%91B%E5%8A%A0%E6%A0%91B%E5%BF%83%E6%A0%91/"/>
    <url>/2020/12/27/datastructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87-B%E6%A0%91B%E5%8A%A0%E6%A0%91B%E5%BF%83%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h1><blockquote><p>B树又称为多路平衡查找树，是一种组织和维护外存文件系统非常有效的数据结构。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/b-tree.png" alt="B-TREE"></p><p class="note note-primary">一棵m阶B树或者是一棵空树，或者是满足要求的m叉树：</p><blockquote><p>1.树中每个结点至多有m个孩子结点（即至多有m-1个关键字）;<code>最多关键字个数Max=m-1</code></p></blockquote><blockquote><p>2.除根结点外，其他非叶子节子点至少有[m/2]个孩子结点(即至少有[m/2]-1=[(m-1)/2]个关键字)<code>最少关键字个数Min=[m/2]-1</code></p></blockquote><blockquote><p>3.若根结点不是叶子结点，则根结点至少有两个孩子结点；</p></blockquote><blockquote><p>4.每个结点的结构如下，结点中按关键字大小顺序排列：n    p0    k1    p1    k2    p2    …    kn    pn</p></blockquote><blockquote><p>5.所有外部结点都在同一层上。B树是所有结点的平衡因子均等于0的多路查找树。在计算B树的高度时，需要计入最底层的外部结点</p></blockquote><blockquote><p>6.外部结点就是失败结点，指向它的指针为空，不含有任何信息，是虚设的。一棵B树中总有n个关键字，则外部结点个数为n+1。</p></blockquote><p class="note note-primary">    代码结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cgo">#define MAXM 10&#x2F;&#x2F;定义B树的最大的阶数<br>typedef   int KeyType;       &#x2F;&#x2F;KeyType为关键字类型<br>typedef struct node <br>&#123;      int keynum;           &#x2F;&#x2F;结点当前拥有的关键字的个数<br>       KeyType key[MAXM];      &#x2F;&#x2F;[1..keynum]存放关键字<br>       struct node *parent;   &#x2F;&#x2F;双亲结点指针<br>       struct node *ptr[MAXM]; &#x2F;&#x2F;孩子结点指针数组[0..keynum]<br>&#125;  BTNode;<br></code></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><blockquote><p>将k与根结点中的key[i]进行比较：<br>1.若k=key[i]，则查找成功；<br>2.若k＜key[1]，则沿着指针ptr[0]所指的子树继续查找；<br>3.若key[i]＜k＜key[i+1]，则沿着指针ptr[i]所指的子树继续查找；<br>4.若k＞key[n]，则沿着指针ptr[n]所指的子树继续查找。</p></blockquote><p class="note note-danger">    说明：当查找到某个叶结点时，若相应的指针为空，落入一个外部结点，表示查找失败。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p class="note note-primary">    插入流程</p><blockquote><p>1.查找该关键字的插入结点（注意B树的插入结点一定是叶子结点层的结点）。 </p></blockquote><blockquote><p>2.插入关键字。</p></blockquote><p>1.插入结点有空位置，即关键字个数n＜m-1：直接把关键字k有序插入到该结点的合适位置上。</p><p>2.插入结点没有空位置，即原关键字个数n=m-1  -&gt; 分裂。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/fenlie.png"></p><blockquote><p>如果没有双亲结点，新建一个双亲结点，树的高度增加一层。<br>如果有双亲结点，将ki插入到双亲结点中。</p></blockquote><p class="note note-primary">    例子  关键字序列为：(1，2，6，7，11，4，8，13，10，5，17，9，16，20，3，12，14，18，19，15)。创建一棵5阶B树。</p><blockquote><p><code>注意</code>：最多的关键字个数 Max = m-1 = 4</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/b-tree-demo.png"></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除过程</p><p>（1）查找关键字k所在的结点。<br>（2）删除关键字k。</p><p>删除关键字k分两种情况：</p><ul><li><p>在叶子结点层上删除关键字k。</p></li><li><p>在非叶子结点层上删除关键字k。</p></li></ul><p><code>注意</code>：非根、非叶子结点的关键字最少个数Min=m/2-1</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/b-tree-delete-demo.png"></p><p>在B树的叶子结点b上删除关键字共有以下3种情况：</p><ul><li>假如b结点的关键字个数大于Min，说明删去该关键字后该结点仍满足B树的定义，则可直接删去该关键字。     </li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/b-tree-delete-demo-1.png"></p><ul><li>假如b结点的关键字个数等于Min，说明删去关键字后该结点将不满足B树的定义。若可以从兄弟结点借。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/b-tree-delete-demo-2.png"></p><ul><li>假如b结点的关键字个数等于Min，说明删去关键字后该结点将不满足B树的定义。若不能从兄弟结点借。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/b-tree-delete-demo-3.png"></p><p class="note note-primary">    对于前例生成的B树，给出删除8，16，15，4等4个关键字的过程。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/b-tree-delete-demo-4.png"></p><h1 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h1><blockquote><p>B+树是B树的一些变形。一棵4阶的B+树示例：　</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/b+-tree.png"></p><p class="note note-primary">    B+树的定义　一棵m阶B+树满足下列要求：</p><blockquote><p>每个分支结点至多有m棵子树（这里m=4）。</p></blockquote><blockquote><p>根结点或者没有子树，或者至少有两棵子树。</p></blockquote><blockquote><p>除根结点外，其他每个分支结点至少有 m/2 棵子树。</p></blockquote><blockquote><p>有n棵子树的结点恰好有n个关键字</p></blockquote><blockquote><p>所有叶子结点包含全部关键字及指向相应记录的指针，而且叶子结点按关键字大小顺序链接。并将所有叶子结点链接起来。</p></blockquote><blockquote><p>所有分支结点（可看成是索引的索引）中仅包含它的各个子结点（即下级索引的索引块）中最大关键字及指向子结点的指针。</p></blockquote><p class="note note-primary">    m阶的B+树和m阶的B树的主要的差异</p><h1 id="B-Tree-2"><a href="#B-Tree-2" class="headerlink" title="B*Tree"></a>B*Tree</h1><blockquote><p>B<em>Tree是B+Tree的变体，在B+树的非根和非叶子节点再增加指向兄弟的指针；B</em>树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3 （代替B+树的1/2）。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/b++-tree.png"></p><p class="note note-danger">    B*树分配新结点的概率比B+树要低，空间使用率更高；</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/weixin_43778491/article/details/84893581?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">浅谈mysql中的Btree,b+-tree,b*tree</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>B树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构篇-二叉排序树</title>
    <link href="/2020/12/27/datastructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/"/>
    <url>/2020/12/27/datastructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote><p>二茬排序树(二叉搜索树)满足以下性质的二叉树<br> 1.若根结点的左子树非空，则左子树上的所有结点关键字均小于根结点关键字。<br> 2.若根结点的右子树非空，则右子树上的所有结点关键字均大于根结点关键字。<br> 3.根结点的左右子树本身又是一颗二叉排序树。</p></blockquote><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><blockquote><p>中序遍历得到一个递增序列，平均查找时间O(logN)</p></blockquote><h1 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cgo">BSTNode *CreateBST(KeyType A[],int n)&#x2F;&#x2F;创建二叉排序树<br>&#x2F;&#x2F;返回BST树根结点指针<br>&#123;BSTNode *bt&#x3D;NULL;&#x2F;&#x2F;初始时bt为空树<br>int i&#x3D;0;<br>while (i&lt;n)<br>&#123;InsertBST(bt,A[i]);&#x2F;&#x2F;将关键字A[i]插入二叉排序树bt中<br>i++;<br>&#125;<br>return bt;&#x2F;&#x2F;返回建立的二叉排序树的根指针<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cgo">bool InsertBST(BSTNode *&amp;bt,KeyType k)<br>&#x2F;&#x2F;在二叉排序树bt中插入一个关键字为k的结点。插入成功返回真，否则返回假<br>&#123;if (bt&#x3D;&#x3D;NULL)&#x2F;&#x2F;原树为空，新插入的结点为根结点<br>&#123;bt&#x3D;(BSTNode *)malloc(sizeof(BSTNode));<br>bt-&gt;key&#x3D;k; bt-&gt;lchild&#x3D;bt-&gt;rchild&#x3D;NULL;<br>return true;<br>&#125;<br>else if (k&#x3D;&#x3D;bt-&gt;key) &#x2F;&#x2F;树中存在相同关键字的结点，返回假<br>return false;<br>else if (k&lt;bt-&gt;key) <br>return InsertBST(bt-&gt;lchild,k);&#x2F;&#x2F;插入到左子树中<br>else<br>return InsertBST(bt-&gt;rchild,k);&#x2F;&#x2F;插入到右子树中<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cgo">BSTNode *SearchBST(BSTNode *bt,KeyType k)<br>&#123; <br>    if (bt&#x3D;&#x3D;NULL || bt-&gt;key&#x3D;&#x3D;k)      &#x2F;&#x2F;递归终结条件<br>return bt;<br>if (k&lt;bt-&gt;key)<br>       return SearchBST(bt-&gt;lchild,k);  &#x2F;&#x2F;在左子树中递归查找<br>    else<br>     return SearchBST(bt-&gt;rchild,k);  &#x2F;&#x2F;在右子树中递归查找<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cgo">void Delete1(BSTNode *p,BSTNode *&amp;r)  &#x2F;&#x2F;当被删p结点有左右子树时的删除过程<br>&#123;<br>BSTNode *q;<br>if (r-&gt;rchild!&#x3D;NULL)<br>Delete1(p,r-&gt;rchild);&#x2F;&#x2F;递归找最右下结点r<br>else&#x2F;&#x2F;找到了最右下结点r<br>&#123;p-&gt;key&#x3D;r-&gt;key;&#x2F;&#x2F;将*结点的值赋给结点p<br>q&#x3D;r;<br>r&#x3D;r-&gt;lchild;&#x2F;&#x2F;直接将其左子树的根结点放在被删结点的位置上<br>free(q);&#x2F;&#x2F;释放原结点r的空间<br>&#125;<br>&#125;<br>void Delete(BSTNode *&amp;p)&#x2F;&#x2F;从二叉排序树中删除p结点<br>&#123;<br>BSTNode *q;<br>if (p-&gt;rchild&#x3D;&#x3D;NULL)&#x2F;&#x2F;p结点没有右子树的情况<br>&#123;<br>q&#x3D;p;<br>p&#x3D;p-&gt;lchild;&#x2F;&#x2F;直接将其右子树的根结点放在被删结点的位置上<br>free(q);  <br>&#125;<br>else if (p-&gt;lchild&#x3D;&#x3D;NULL)&#x2F;&#x2F;p结点没有左子树的情况<br>&#123;<br>q&#x3D;p;<br>p&#x3D;p-&gt;rchild;&#x2F;&#x2F;将p结点的右子树作为双亲结点的相应子树<br>free(q);  <br>&#125;<br>else Delete1(p,p-&gt;lchild);&#x2F;&#x2F;p结点既没有左子树又没有右子树的情况<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><code class="hljs cgo">&#x2F;&#x2F;二叉排序树算法<br>#include &lt;stdio.h&gt;<br>#include &lt;malloc.h&gt;<br>typedef int KeyType;<br>typedef char InfoType[10];<br>typedef struct node<br>&#123;<br>KeyType key;              &#x2F;&#x2F;关键字项<br>InfoType data;             &#x2F;&#x2F;其他数据域<br>struct node *lchild,*rchild;&#x2F;&#x2F;左右孩子指针<br>&#125; BSTNode;           &#x2F;&#x2F;二叉排序树结点类型<br>bool InsertBST(BSTNode *&amp;bt,KeyType k)<br>&#x2F;&#x2F;在二叉排序树bt中插入一个关键字为k的结点。插入成功返回真，否则返回假<br>&#123;if (bt&#x3D;&#x3D;NULL)&#x2F;&#x2F;原树为空，新插入的结点为根结点<br>&#123;bt&#x3D;(BSTNode *)malloc(sizeof(BSTNode));<br>bt-&gt;key&#x3D;k; bt-&gt;lchild&#x3D;bt-&gt;rchild&#x3D;NULL;<br>return true;<br>&#125;<br>else if (k&#x3D;&#x3D;bt-&gt;key) &#x2F;&#x2F;树中存在相同关键字的结点，返回假<br>return false;<br>else if (k&lt;bt-&gt;key) <br>return InsertBST(bt-&gt;lchild,k);&#x2F;&#x2F;插入到左子树中<br>else<br>return InsertBST(bt-&gt;rchild,k);&#x2F;&#x2F;插入到右子树中<br>&#125;<br><br>BSTNode *CreateBST(KeyType A[],int n)&#x2F;&#x2F;创建二叉排序树<br>&#x2F;&#x2F;返回BST树根结点指针<br>&#123;BSTNode *bt&#x3D;NULL;&#x2F;&#x2F;初始时bt为空树<br>int i&#x3D;0;<br>while (i&lt;n)<br>&#123;InsertBST(bt,A[i]);&#x2F;&#x2F;将关键字A[i]插入二叉排序树bt中<br>i++;<br>&#125;<br>return bt;&#x2F;&#x2F;返回建立的二叉排序树的根指针<br>&#125;<br><br>void DispBST(BSTNode *bt)&#x2F;&#x2F;输出一棵排序二叉树<br>&#123;<br>if (bt!&#x3D;NULL)<br>&#123;printf(&quot;%d&quot;,bt-&gt;key);<br>if (bt-&gt;lchild!&#x3D;NULL || bt-&gt;rchild!&#x3D;NULL)<br>&#123;printf(&quot;(&quot;);&#x2F;&#x2F;有孩子结点时才输出(<br>DispBST(bt-&gt;lchild);&#x2F;&#x2F;递归处理左子树<br>if (bt-&gt;rchild!&#x3D;NULL) printf(&quot;,&quot;);&#x2F;&#x2F;有右孩子结点时才输出,<br>DispBST(bt-&gt;rchild);&#x2F;&#x2F;递归处理右子树<br>printf(&quot;)&quot;);&#x2F;&#x2F;有孩子结点时才输出)<br>&#125;<br>&#125;<br>&#125;<br>BSTNode *SearchBST(BSTNode *bt,KeyType k)<br>&#123; <br>    if (bt&#x3D;&#x3D;NULL || bt-&gt;key&#x3D;&#x3D;k)      &#x2F;&#x2F;递归终结条件<br>return bt;<br>if (k&lt;bt-&gt;key)<br>       return SearchBST(bt-&gt;lchild,k);  &#x2F;&#x2F;在左子树中递归查找<br>    else<br>     return SearchBST(bt-&gt;rchild,k);  &#x2F;&#x2F;在右子树中递归查找<br>&#125;<br>BSTNode *SearchBST1(BSTNode *bt,KeyType k,BSTNode *f1,BSTNode *&amp;f)<br>&#x2F;*在bt中查找关键字为k的结点,若查找成功,该函数返回该结点的指针,<br>f返回其双亲结点;否则,该函数返回NULL。<br>其调用方法如下:<br>         SearchBST(bt,x,NULL,f);<br>这里的第3个参数f1仅作中间参数,用于求f,初始设为NULL*&#x2F;<br>&#123; <br>if (bt&#x3D;&#x3D;NULL)<br>&#123;<br>f&#x3D;NULL;<br>return(NULL);<br>&#125;<br>else if (k&#x3D;&#x3D;bt-&gt;key) <br>&#123;<br>f&#x3D;f1;<br>return(bt);<br>&#125;<br>else if (k&lt;bt-&gt;key)<br>       return SearchBST1(bt-&gt;lchild,k,bt,f);  &#x2F;&#x2F;在左子树中递归查找<br>    else<br>     return SearchBST1(bt-&gt;rchild,k,bt,f);  &#x2F;&#x2F;在右子树中递归查找<br>&#125;<br><br>void Delete1(BSTNode *p,BSTNode *&amp;r)  &#x2F;&#x2F;当被删p结点有左右子树时的删除过程<br>&#123;<br>BSTNode *q;<br>if (r-&gt;rchild!&#x3D;NULL)<br>Delete1(p,r-&gt;rchild);&#x2F;&#x2F;递归找最右下结点r<br>else&#x2F;&#x2F;找到了最右下结点r<br>&#123;p-&gt;key&#x3D;r-&gt;key;&#x2F;&#x2F;将*结点的值赋给结点p<br>q&#x3D;r;<br>r&#x3D;r-&gt;lchild;&#x2F;&#x2F;直接将其左子树的根结点放在被删结点的位置上<br>free(q);&#x2F;&#x2F;释放原结点r的空间<br>&#125;<br>&#125;<br>void Delete(BSTNode *&amp;p)&#x2F;&#x2F;从二叉排序树中删除p结点<br>&#123;<br>BSTNode *q;<br>if (p-&gt;rchild&#x3D;&#x3D;NULL)&#x2F;&#x2F;p结点没有右子树的情况<br>&#123;<br>q&#x3D;p;<br>p&#x3D;p-&gt;lchild;&#x2F;&#x2F;直接将其右子树的根结点放在被删结点的位置上<br>free(q);  <br>&#125;<br>else if (p-&gt;lchild&#x3D;&#x3D;NULL)&#x2F;&#x2F;p结点没有左子树的情况<br>&#123;<br>q&#x3D;p;<br>p&#x3D;p-&gt;rchild;&#x2F;&#x2F;将p结点的右子树作为双亲结点的相应子树<br>free(q);  <br>&#125;<br>else Delete1(p,p-&gt;lchild);&#x2F;&#x2F;p结点既没有左子树又没有右子树的情况<br>&#125;<br>int DeleteBST(BSTNode *&amp;bt,KeyType k)&#x2F;&#x2F;在bt中删除关键字为k的结点<br>&#123;<br>if (bt&#x3D;&#x3D;NULL) <br>return 0;&#x2F;&#x2F;空树删除失败<br>else <br>&#123;<br>if (k&lt;bt-&gt;key) <br>return DeleteBST(bt-&gt;lchild,k);&#x2F;&#x2F;递归在左子树中删除为k的结点<br>else if (k&gt;bt-&gt;key) <br>return DeleteBST(bt-&gt;rchild,k);&#x2F;&#x2F;递归在右子树中删除为k的结点<br>else <br>&#123;<br>Delete(bt);&#x2F;&#x2F;调用Delete(bt)函数删除*bt结点<br>return 1;<br>&#125;<br>&#125;<br>&#125;<br>void DestroyBST(BSTNode *&amp;bt)&#x2F;&#x2F;销毁二叉排序树bt<br>&#123;<br>if (bt!&#x3D;NULL)<br>&#123;<br>DestroyBST(bt-&gt;lchild);<br>DestroyBST(bt-&gt;rchild);<br>free(bt);<br>&#125;<br>&#125;<br>&#x2F;*<br>int main()<br>&#123;<br>BSTNode *bt,*p,*f;<br>int n&#x3D;12,x&#x3D;46;<br>KeyType a[]&#x3D;&#123;25,18,46,2,53,39,32,4,74,67,60,11&#125;;<br>bt&#x3D;CreateBST(a,n);<br>printf(&quot;BST:&quot;);DispBST(bt);printf(&quot;\n&quot;);<br>printf(&quot;删除%d结点\n&quot;,x);<br>if (SearchBST(bt,x)!&#x3D;NULL)<br>&#123;<br>DeleteBST(bt,x);<br>printf(&quot;BST:&quot;);DispBST(bt);printf(&quot;\n&quot;);<br>&#125;<br>x&#x3D;18;<br>p&#x3D;SearchBST1(bt,x,NULL,f);<br>if (f!&#x3D;NULL)<br>printf(&quot;%d的双亲是%d\n&quot;,x,f-&gt;key);<br>DestroyBST(bt);<br>return 1;<br>&#125;<br>*&#x2F;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉排序树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构篇-平衡二叉树(AVL树)</title>
    <link href="/2020/12/23/datastructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/12/23/datastructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="平衡二叉树定义"><a href="#平衡二叉树定义" class="headerlink" title="平衡二叉树定义"></a>平衡二叉树定义</h1><blockquote><p>任意节点的子树的高度差都小于等于1,并且左右两个子树都是一棵平衡二叉树</p></blockquote><ul><li>B树（多路平衡搜索树)</li><li>AVL树（二叉平衡搜索树)</li></ul><blockquote><p>时间复杂度:平均O(logN),最坏O(N)</p></blockquote><h1 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h1><p>总是作为叶子节点插入，当破坏平衡性，首先从该新节点向根节点查找第一个失去平衡的节点，然后<strong>以该失衡节点和它相邻的刚查找过的两个节点</strong>构成调整子树，使之成为新的平衡子树。当失衡的最小子树被调整为平衡子树后，整棵树恢复平衡。</p><blockquote><p>失衡的最小子树是指以离插入节点<code>最近</code>,且平衡因子绝对值大于1的结点作为根的子树。假设用A表示失衡的最小子树的根结点，则调整该子树的操作可归纳为下列四种情况</p></blockquote><p>平衡因子：该节点左子树高度-该右子树高度（或者该右子树高度-该节点左子树高度）,当为0,1,-1时为平衡二叉树</p><ul><li>LL型调整</li></ul><blockquote><p>这是因在A节点的左子树(设为B结点)的右子树上插入结点，使得A结点的 平衡因子由1变为2而引起的不平衡。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20201226132145939.png" alt="LL型调整"></p><blockquote><p>调整方法：将B结点向上升替代A结点成为根节点，A结点作为B结点的右子树，B结点的原右子树b作为A结点左子树。</p></blockquote><ul><li>RR型调整</li></ul><blockquote><p>这是因在A节点的右子树(设为B结点)的右子树上插入结点，使得A结点的 平衡因子由-1变为-2而引起的不平衡。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20201226153538053.png" alt="RR型调整"></p><blockquote><p>调整方法：将B结点向上升替代A结点成为根节点，A结点作为B结点的左子树，B结点的原左子树b作为A结点右子树。</p></blockquote><ul><li>LR型调整</li></ul><blockquote><p>这是因在A节点的左子树(设为B结点)的右子树上插入结点，使得A结点的 平衡因子由1变为2而引起的不平衡。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20201226163744943.png" alt="LR型调整"></p><blockquote><p>调整方法：将C结点向上升替代A结点成为根节点，B结点作为C结点的左子树，A结点作为C结点的右子树，C结点的原左子树b作为B结点右子树，C结点的原右子树y作为A结点左子树。</p></blockquote><ul><li>RL型调整</li></ul><blockquote><p>这是因在A节点的右子树(设为B结点)的左子树上插入结点，使得A结点的 平衡因子由-1变为-2而引起的不平衡。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20201226165948271.png" alt="RL型调整"></p><blockquote><p>调整方法：将C结点向上升替代A结点成为根节点，A结点作为C结点的左子树，B结点作为C结点的右子树，C结点的原左子树b作为A结点右子树，C结点的原右子树y作为B结点左子树。</p></blockquote><h1 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h1><blockquote><p>平衡二叉树删除一个结点与二叉排序树类似，只是增加调整步骤。</p></blockquote><p>删除过程</p><blockquote><p>1.查找。先在平衡二叉树中查找关键字为k的结点p。</p><p>2.删除。删除分为以下几种情况。</p><p>​    2.1 叶子节点：直接删除该结点。</p><p>​    2.2 单分支节点：用p结点的左或右孩子结点替代p结点（结点替换）。</p><p>​    2.3 双分支节点：用p结点的中序前驱（或者中序后继）结点q的值替换p结点的值，再删除结点q。</p><p>3.调整。若被删除的是结点q，则从结点q向根结点方向查找第一个失去平衡的结点</p><p>​    3.1 若所有节点都是平衡的，则不需调整。</p><p>​    3.2 假设找到某个结点的平衡因子=-2：其左孩子的平衡因子=-1，则作RR型调整。其右孩子的平衡因子=1，则做RL型调整。其右孩子平衡因子=0，在作RR或者RL型调整均可。</p><p>​    3.3 假设找到某个结点的平衡因子=2：其左孩子的平衡因子=-1，则作LR型调整。其右孩子的平衡因子=1，则做LL型调整。其右孩子平衡因子=0，在作LR或者LL型调整均可。</p></blockquote><p>参考例子</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20201227094844136.png" alt="删除过程"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//AVL算法</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;malloc.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> KeyType;<span class="hljs-comment">//关键字类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span> InfoType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>               //记录类型</span><br><span class="hljs-class">&#123;</span><br>KeyType key;                  <span class="hljs-comment">//关键字项</span><br>    <span class="hljs-keyword">int</span> bf;<span class="hljs-comment">//平衡因子</span><br>    InfoType data;               <span class="hljs-comment">//其他数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span><span class="hljs-comment">//左右孩子指针</span><br>&#125; BSTNode;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LeftProcess</span><span class="hljs-params">(BSTNode *&amp;p,<span class="hljs-keyword">int</span> &amp;taller)</span></span><br><span class="hljs-function"><span class="hljs-comment">//对以指针p所指结点为根的二叉树作左平衡旋转处理,本算法结束时,指针p指向新的根结点</span></span><br><span class="hljs-function"></span>&#123;<br>BSTNode *p1,*p2;<br><span class="hljs-keyword">if</span> (p-&gt;bf==<span class="hljs-number">0</span>)<span class="hljs-comment">//原本左、右子树等高,现因左子树增高而使树增高</span><br>&#123;<br>p-&gt;bf=<span class="hljs-number">1</span>;<br>taller=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p-&gt;bf==<span class="hljs-number">-1</span>)<span class="hljs-comment">//原本右子树比左子树高,现左、右子树等高 </span><br>&#123;<br>p-&gt;bf=<span class="hljs-number">0</span>;<br>taller=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//原本左子树比右子树高,需作左子树的平衡处理</span><br>&#123;<br>p1=p-&gt;lchild;<span class="hljs-comment">//p1指向结点p的左孩子</span><br><span class="hljs-keyword">if</span> (p1-&gt;bf==<span class="hljs-number">1</span>)<span class="hljs-comment">//新结点插入在结点b的左孩子的左子树上,要作LL调整</span><br>&#123;<br>p-&gt;lchild=p1-&gt;rchild;<br>p1-&gt;rchild=p;<br>p-&gt;bf=p1-&gt;bf=<span class="hljs-number">0</span>;<br>p=p1;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p1-&gt;bf==<span class="hljs-number">-1</span>)<span class="hljs-comment">//新结点插入在结点b的左孩子的右子树上,要作LR调整</span><br>&#123;<br>p2=p1-&gt;rchild;<br>p1-&gt;rchild=p2-&gt;lchild;<br>p2-&gt;lchild=p1;<br>p-&gt;lchild=p2-&gt;rchild;<br>p2-&gt;rchild=p;<br><span class="hljs-keyword">if</span> (p2-&gt;bf==<span class="hljs-number">0</span>)<span class="hljs-comment">//新结点插在p2处作为叶子结点的情况</span><br>p-&gt;bf=p1-&gt;bf=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p2-&gt;bf==<span class="hljs-number">1</span>)<span class="hljs-comment">//新结点插在p2的左子树上的情况</span><br>&#123;<br>p1-&gt;bf=<span class="hljs-number">0</span>;p-&gt;bf=<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//新结点插在p2的右子树上的情况</span><br>&#123;<br>p1-&gt;bf=<span class="hljs-number">1</span>;p-&gt;bf=<span class="hljs-number">0</span>;<br>&#125;<br>p=p2;p-&gt;bf=<span class="hljs-number">0</span>;<span class="hljs-comment">//仍将p指向新的根结点,并置其bf值为0</span><br>&#125;<br>taller=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RightProcess</span><span class="hljs-params">(BSTNode *&amp;p,<span class="hljs-keyword">int</span> &amp;taller)</span></span><br><span class="hljs-function"><span class="hljs-comment">//对以指针p所指结点为根的二叉树作右平衡旋转处理,本算法结束时,指针p指向新的根结点</span></span><br><span class="hljs-function"></span>&#123;<br>BSTNode *p1,*p2;<br><span class="hljs-keyword">if</span> (p-&gt;bf==<span class="hljs-number">0</span>)<span class="hljs-comment">//原本左、右子树等高,现因右子树增高而使树增高</span><br>&#123;<br>p-&gt;bf=<span class="hljs-number">-1</span>;<br>taller=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p-&gt;bf==<span class="hljs-number">1</span>)<span class="hljs-comment">//原本左子树比右子树高,现左、右子树等高</span><br>&#123;<br>p-&gt;bf=<span class="hljs-number">0</span>;<br>taller=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//原本右子树比左子树高,需作右子树的平衡处理</span><br>&#123;<br>p1=p-&gt;rchild;<span class="hljs-comment">//p1指向结点p的右子树根结点</span><br><span class="hljs-keyword">if</span> (p1-&gt;bf==<span class="hljs-number">-1</span>)<span class="hljs-comment">//新结点插入在结点b的右孩子的右子树上,要作RR调整</span><br>&#123;<br>p-&gt;rchild=p1-&gt;lchild;<br>p1-&gt;lchild=p;<br>p-&gt;bf=p1-&gt;bf=<span class="hljs-number">0</span>;<br>p=p1;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p1-&gt;bf==<span class="hljs-number">1</span>)<span class="hljs-comment">//新结点插入在结点p的右孩子的左子树上,要作RL调整</span><br>&#123;<br>p2=p1-&gt;lchild;<br>p1-&gt;lchild=p2-&gt;rchild;<br>p2-&gt;rchild=p1;<br>p-&gt;rchild=p2-&gt;lchild;<br>p2-&gt;lchild=p;<br><span class="hljs-keyword">if</span> (p2-&gt;bf==<span class="hljs-number">0</span>)<span class="hljs-comment">//新结点插在p2处作为叶子结点的情况</span><br>p-&gt;bf=p1-&gt;bf=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p2-&gt;bf==<span class="hljs-number">-1</span>)<span class="hljs-comment">//新结点插在p2的右子树上的情况</span><br>&#123;<br>p1-&gt;bf=<span class="hljs-number">0</span>;p-&gt;bf=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//新结点插在p2的左子树上的情况</span><br>&#123;<br>p1-&gt;bf=<span class="hljs-number">-1</span>;p-&gt;bf=<span class="hljs-number">0</span>;<br>&#125;<br>p=p2;p-&gt;bf=<span class="hljs-number">0</span>;<span class="hljs-comment">//仍将p指向新的根结点,并置其bf值为0</span><br>&#125;<br>taller=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InsertAVL</span><span class="hljs-params">(BSTNode *&amp;b,KeyType e,<span class="hljs-keyword">int</span> &amp;taller)</span></span><br><span class="hljs-function"><span class="hljs-comment">/*若在平衡的二叉排序树b中不存在和e有相同关键字的结点,则插入一个</span></span><br><span class="hljs-function"><span class="hljs-comment">  数据元素为e的新结点,并返回1,否则返回0。若因插入而使二叉排序树</span></span><br><span class="hljs-function"><span class="hljs-comment">  失去平衡,则作平衡旋转处理,布尔变量taller反映b长高与否*/</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(b==<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//原为空树,插入新结点,树“长高”,置taller为1</span><br>&#123; <br>b=(BSTNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BSTNode));<br>b-&gt;key=e;<br>b-&gt;lchild=b-&gt;rchild=<span class="hljs-literal">NULL</span>;<br>b-&gt;bf=<span class="hljs-number">0</span>;<br>taller=<span class="hljs-number">1</span>;<br>&#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br><span class="hljs-keyword">if</span> (e==b-&gt;key)<span class="hljs-comment">//树中已存在和e有相同关键字的结点则不再插入</span><br>&#123; <br>taller=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (e&lt;b-&gt;key)<span class="hljs-comment">//应继续在结点b的左子树中进行搜索</span><br>&#123; <br><span class="hljs-keyword">if</span> ((InsertAVL(b-&gt;lchild,e,taller))==<span class="hljs-number">0</span>) <span class="hljs-comment">//未插入</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (taller==<span class="hljs-number">1</span>)<span class="hljs-comment">//已插入到结点b的左子树中且左子树“长高”</span><br>LeftProcess(b,taller);<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//应继续在结点b的右子树中进行搜索</span><br>&#123; <br><span class="hljs-keyword">if</span> ((InsertAVL(b-&gt;rchild,e,taller))==<span class="hljs-number">0</span>) <span class="hljs-comment">//未插入</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (taller==<span class="hljs-number">1</span>)<span class="hljs-comment">//已插入到b的右子树且右子树“长高”</span><br>RightProcess(b,taller);<br>&#125;<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DispBSTree</span><span class="hljs-params">(BSTNode *b)</span><span class="hljs-comment">//以括号表示法输出AVL</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (b!=<span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,b-&gt;key);<br><span class="hljs-keyword">if</span> (b-&gt;lchild!=<span class="hljs-literal">NULL</span> || b-&gt;rchild!=<span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(&quot;</span>);<br>DispBSTree(b-&gt;lchild);<br><span class="hljs-keyword">if</span> (b-&gt;rchild!=<span class="hljs-literal">NULL</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;,&quot;</span>);<br>DispBSTree(b-&gt;rchild);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;)&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DestroyAVL</span><span class="hljs-params">(BSTNode *&amp;b)</span><span class="hljs-comment">//销毁AVL</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (b!=<span class="hljs-literal">NULL</span>)<br>&#123;<br>DestroyAVL(b-&gt;lchild);<br>DestroyAVL(b-&gt;rchild);<br><span class="hljs-built_in">free</span>(b);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LeftProcess1</span><span class="hljs-params">(BSTNode *&amp;p,<span class="hljs-keyword">int</span> &amp;taller)</span><span class="hljs-comment">//在删除结点时进行左处理</span></span><br><span class="hljs-function"></span>&#123;<br>BSTNode *p1,*p2;<br><span class="hljs-keyword">if</span> (p-&gt;bf==<span class="hljs-number">1</span>)<br>&#123;<br>p-&gt;bf=<span class="hljs-number">0</span>;<br>taller=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p-&gt;bf==<span class="hljs-number">0</span>)<br>&#123;<br>p-&gt;bf=<span class="hljs-number">-1</span>;<br>taller=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//p-&gt;bf=-1</span><br>&#123;<br>p1=p-&gt;rchild;<br><span class="hljs-keyword">if</span> (p1-&gt;bf==<span class="hljs-number">0</span>)<span class="hljs-comment">//需作RR调整</span><br>&#123;<br>p-&gt;rchild=p1-&gt;lchild;<br>p1-&gt;lchild=p;<br>p1-&gt;bf=<span class="hljs-number">1</span>;p-&gt;bf=<span class="hljs-number">-1</span>;<br>p=p1;<br>taller=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p1-&gt;bf==<span class="hljs-number">-1</span>)<span class="hljs-comment">//需作RL调整</span><br>&#123;<br>p-&gt;rchild=p1-&gt;lchild;<br>p1-&gt;lchild=p;<br>p-&gt;bf=p1-&gt;bf=<span class="hljs-number">0</span>;<br>p=p1;<br>taller=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//需作RL调整</span><br>&#123;<br>p2=p1-&gt;lchild;<br>p1-&gt;lchild=p2-&gt;rchild;<br>p2-&gt;rchild=p1;<br>p-&gt;rchild=p2-&gt;lchild;<br>p2-&gt;lchild=p;<br><span class="hljs-keyword">if</span> (p2-&gt;bf==<span class="hljs-number">0</span>)<br>&#123;<br>p-&gt;bf=<span class="hljs-number">0</span>;p1-&gt;bf=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p2-&gt;bf==<span class="hljs-number">-1</span>)<br>&#123;<br>p-&gt;bf=<span class="hljs-number">1</span>;p1-&gt;bf=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>p-&gt;bf=<span class="hljs-number">0</span>;p1-&gt;bf=<span class="hljs-number">-1</span>;<br>&#125;<br>p2-&gt;bf=<span class="hljs-number">0</span>;<br>p=p2;<br>taller=<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RightProcess1</span><span class="hljs-params">(BSTNode *&amp;p,<span class="hljs-keyword">int</span> &amp;taller)</span> <span class="hljs-comment">//在删除结点时进行右处理</span></span><br><span class="hljs-function"></span>&#123;<br>BSTNode *p1,*p2;<br><span class="hljs-keyword">if</span> (p-&gt;bf==<span class="hljs-number">-1</span>)<br>&#123;<br>p-&gt;bf=<span class="hljs-number">0</span>;<br>taller=<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p-&gt;bf==<span class="hljs-number">0</span>)<br>&#123;<br>p-&gt;bf=<span class="hljs-number">1</span>;<br>taller=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//p-&gt;bf=1</span><br>&#123;<br>p1=p-&gt;lchild;<br><span class="hljs-keyword">if</span> (p1-&gt;bf==<span class="hljs-number">0</span>)<span class="hljs-comment">//需作LL调整</span><br>&#123;<br>p-&gt;lchild=p1-&gt;rchild;<br>p1-&gt;rchild=p;<br>p1-&gt;bf=<span class="hljs-number">-1</span>;p-&gt;bf=<span class="hljs-number">1</span>;<br>p=p1;<br>taller=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p1-&gt;bf==<span class="hljs-number">1</span>)<span class="hljs-comment">//需作RL调整</span><br>&#123;<br>p-&gt;lchild=p1-&gt;rchild;<br>p1-&gt;rchild=p;<br>p-&gt;bf=p1-&gt;bf=<span class="hljs-number">0</span>;<br>p=p1;<br>taller=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//需作LR调整</span><br>&#123;<br>p2=p1-&gt;rchild;<br>p1-&gt;rchild=p2-&gt;lchild;<br>p2-&gt;lchild=p1;<br>p-&gt;lchild=p2-&gt;rchild;<br>p2-&gt;rchild=p;<br><span class="hljs-keyword">if</span> (p2-&gt;bf==<span class="hljs-number">0</span>)<br>&#123;<br>p-&gt;bf=<span class="hljs-number">0</span>;p1-&gt;bf=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p2-&gt;bf==<span class="hljs-number">1</span>)<br>&#123;<br>p-&gt;bf=<span class="hljs-number">-1</span>;p1-&gt;bf=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>p-&gt;bf=<span class="hljs-number">0</span>;p1-&gt;bf=<span class="hljs-number">1</span>;<br>&#125;<br>p2-&gt;bf=<span class="hljs-number">0</span>;<br>p=p2;<br>taller=<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delete2</span><span class="hljs-params">(BSTNode *q,BSTNode *&amp;r,<span class="hljs-keyword">int</span> &amp;taller)</span>  </span><br><span class="hljs-function"><span class="hljs-comment">//由DeleteAVL()调用,用于处理被删结点左右子树均不空的情况</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (r-&gt;rchild==<span class="hljs-literal">NULL</span>)<br>&#123;<br>q-&gt;key=r-&gt;key;<br>q=r;<br>r=r-&gt;lchild;<br><span class="hljs-built_in">free</span>(q);<br>taller=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>Delete2(q,r-&gt;rchild,taller);<br><span class="hljs-keyword">if</span> (taller==<span class="hljs-number">1</span>) <br>RightProcess1(r,taller);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DeleteAVL</span><span class="hljs-params">(BSTNode *&amp;p,KeyType x,<span class="hljs-keyword">int</span> &amp;taller)</span> <span class="hljs-comment">//在AVL树p中删除关键字为x的结点</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> k;<br>BSTNode *q;<br><span class="hljs-keyword">if</span> (p==<span class="hljs-literal">NULL</span>) <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x&lt;p-&gt;key)<br>&#123;<br>k=DeleteAVL(p-&gt;lchild,x,taller);<br><span class="hljs-keyword">if</span> (taller==<span class="hljs-number">1</span>) <br>LeftProcess1(p,taller);<br><span class="hljs-keyword">return</span> k;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x&gt;p-&gt;key)<br>&#123;<br>k=DeleteAVL(p-&gt;rchild,x,taller);<br><span class="hljs-keyword">if</span> (taller==<span class="hljs-number">1</span>) <br>RightProcess1(p,taller);<br><span class="hljs-keyword">return</span> k;<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//找到了关键字为x的结点,由p指向它</span><br>&#123;<br>q=p;<br><span class="hljs-keyword">if</span> (p-&gt;rchild==<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//被删结点右子树为空</span><br>&#123;<br>p=p-&gt;lchild;<br><span class="hljs-built_in">free</span>(q);<br>taller=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p-&gt;lchild==<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//被删结点左子树为空</span><br>&#123;<br>p=p-&gt;rchild;<br><span class="hljs-built_in">free</span>(q);<br>taller=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//被删结点左右子树均不空</span><br>&#123;<br>Delete2(q,q-&gt;lchild,taller);<br><span class="hljs-keyword">if</span> (taller==<span class="hljs-number">1</span>) <br>LeftProcess1(q,taller);<br>p=q;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>BSTNode *b=<span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">int</span> i,j,k;<br>KeyType a[]=&#123;<span class="hljs-number">16</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">9</span>,<span class="hljs-number">26</span>,<span class="hljs-number">18</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>&#125;,n=<span class="hljs-number">9</span>;  <span class="hljs-comment">//例9.5</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; 创建一棵AVL树:\n&quot;</span>);<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   第%d步,插入%d元素:&quot;</span>,i+<span class="hljs-number">1</span>,a[i]);<br>InsertAVL(b,a[i],j);<br>DispBSTree(b);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>); <br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   AVL:&quot;</span>);DispBSTree(b);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; 删除操作:\n&quot;</span>);<span class="hljs-comment">//例9.6</span><br>k=<span class="hljs-number">11</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   删除关键字%d:&quot;</span>,k);<br>DeleteAVL(b,k,j);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   AVL:&quot;</span>);DispBSTree(b);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>k=<span class="hljs-number">9</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   删除关键字%d:&quot;</span>,k);<br>DeleteAVL(b,k,j);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   AVL:&quot;</span>);DispBSTree(b);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>k=<span class="hljs-number">15</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   删除关键字%d:&quot;</span>,k);<br>DeleteAVL(b,k,j);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   AVL:&quot;</span>);DispBSTree(b);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n\n&quot;</span>);<br>DestroyAVL(b);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/ppt/avl.pptx">平衡二叉树-PPT</a></p><p><a href="https://www.cnblogs.com/zhangbaochong/p/5164994.html">平衡二叉树详解</a><br><a href="https://blog.csdn.net/wxbmelisky/article/details/47755753">平衡二叉树的实现原理</a><br><a href="https://blog.csdn.net/wxbmelisky/article/details/47787963?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.control">平衡二叉树实现的实例</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>平衡二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS篇-微机原理学习总结</title>
    <link href="/2020/12/22/os/OS%E7%AF%87-%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2020/12/22/os/OS%E7%AF%87-%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="第1章-计算机基本知识-（1）"><a href="#第1章-计算机基本知识-（1）" class="headerlink" title="第1章 计算机基本知识 （1）"></a>第1章 计算机基本知识 （1）</h1><p>1.1 微型计算机组成 （1）<br>1.2 微型计算机中信息的表示及运算基础 （2）<br>1.2.1 二进制数的表示与运算 （3）<br>1.2.2 二-十进制（BCD）数的表示与运算 （5）<br>1.2.3 十六进制数的表示与运算 （6）<br>1.2.4 带符号二进制数的表示和运算 （7）<br>1.3.6 字符的编码表示 （9）<br>1.3 几种进制之间的相互转换 （10）<br>1.3.1 十进制整数到任意进制整数的转换 （10）<br>1.3.2 任意进制整数到十进制整数之间的转换 （11）<br>1.3.3 二进制数和十六进制数之间的相互转换 （12）<br>1.3.4 带符号二进制整数到十进制整数之间的转换 （12）</p><h1 id="第2章-8086系统结构-（14）"><a href="#第2章-8086系统结构-（14）" class="headerlink" title="第2章 8086系统结构 （14）"></a>第2章 8086系统结构 （14）</h1><p>2.1 8086 CPU结构 （15）<br>2.1.1 8086 CPU的内部结构 （15）<br>2.1.2 8086 CPU的寄存器结构 （16）<br>2.1.3 8086 CPU的引脚及功能 （20）<br>2.2 8086系统的结构和配置 （23）<br>2.2.1 8086存储器结构 （23）<br>2.2.2 8086输入/输出结构 （27）<br>2.2.3 8086的最小模式和最大模式系统 （28）<br>2.3 8086 CPU内部时序 （30）</p><h1 id="第3章-8086的指令系统-（35）"><a href="#第3章-8086的指令系统-（35）" class="headerlink" title="第3章 8086的指令系统 （35）"></a>第3章 8086的指令系统 （35）</h1><p>3.1 8086 指令的特点 （35）<br>3.2 8086的寻址方式 （36）<br>3.2.1 8086寻址方式的说明 （36）<br>3.2.2 寻址方式介绍 （37）<br>3.3 8086的指令格式及数据类型 （40）<br>3.4 8086的指令集 （42）<br>3.4.1 数据传送指令 （42）<br>3.4.2 算术运算指令 （46）<br>3.4.3 位操作指令 （53）<br>3.4.4 串处理指令 （57）<br>3.4.5 程序控制转移指令 （59）<br>3.4.6 处理器控制指令 （65）</p><h1 id="第4章-8086汇编语言程序设计-（70）"><a href="#第4章-8086汇编语言程序设计-（70）" class="headerlink" title="第4章 8086汇编语言程序设计 （70）"></a>第4章 8086汇编语言程序设计 （70）</h1><p>4.1 8086汇编语言的语句 （70）<br>4.2 8086汇编语言中的伪指令 （72）<br>4.2.1 符号定义语句 （72）<br>4.2.2 变量定义语句 （72）<br>4.2.3 段定义语句 （74）<br>4.2.4 过程定义语句 （76）<br>4.2.5 结束语句 （77）<br>4.3 8086汇编语言中的运算符 （77）<br>4.3.1 常用运算符和操作符 （77）<br>4.3.2 运算符的优先级别 （80）<br>4.4 汇编语言程序设计 （80）<br>4.4.1 汇编语言程序设计基本步骤 （80）<br>4.4.2 汇编语言程序的基本结构 （81）<br>4.5 宏定义与宏调用 （87）<br>4.6 汇编语言程序设计与上机调试 （89）<br>4.6.1 汇编语言程序设计实例 （89）<br>4.6.2 DOS功能调用与子程序设计 （98）<br>4.6.3 汇编语言程序上机调试 （102）</p><h1 id="第5章-存储器原理与接口-（103）"><a href="#第5章-存储器原理与接口-（103）" class="headerlink" title="第5章 存储器原理与接口 （103）"></a>第5章 存储器原理与接口 （103）</h1><p>5.1 存储器分类 （103）<br>5.2 多层存储结构概念 （105）<br>5.3 主存储器及存储控制 （107）<br>5.3.1 主存储器 （107）<br>5.3.2 主存储器的基本组成 （108）<br>5.4 8086系统的存储器组织 （111）<br>5.4.1 8086 CPU的存储器接口 （111）<br>5.4.2 存储器接口举例 （113）<br>5.5 现代内存芯片技术 （118）</p><h1 id="第6章-微型计算机的输入-输出-（120）"><a href="#第6章-微型计算机的输入-输出-（120）" class="headerlink" title="第6章 微型计算机的输入/输出 （120）"></a>第6章 微型计算机的输入/输出 （120）</h1><p>6.1 CPU与外设通信的特点 （120）<br>6.1.1 I/O端口的寻址方式 （121）<br>6.1.2 I/O端口地址的形成 （121）<br>6.2 输入/输出方式 （122）<br>6.3 CPU与外设通信的接口 （123）<br>6.3.1 同步传输方式与接口 （123）<br>6.3.2 异步查询方式与接口 （124）<br>6.4 8086 CPU的输入/输出 （127）</p><h1 id="第7章-可编程接口芯片-（129）"><a href="#第7章-可编程接口芯片-（129）" class="headerlink" title="第7章 可编程接口芯片 （129）"></a>第7章 可编程接口芯片 （129）</h1><p>7.1 可编程并行接口芯片8255A （130）<br>7.1.1 8255A的内部结构 （130）<br>7.1.2 8255A的引脚分配 （131）<br>7.1.3 8255A的工作方式及编程 （132）<br>7.1.4 8255A工作方式的功能 （135）<br>7.1.5 8255A应用举例 （141）<br>7.2 可编程定时/计数器接口芯片8253 （148）<br>7.2.1 8253的内部结构 （149）<br>7.2.2 8253的引脚分配 （150）<br>7.2.3 8253的编程 （151）<br>7.2.4 8253的工作方式 （153）<br>7.2.5 8253的工作方式小结 （160）<br>7.2.6 8253应用举例 （161）</p><h1 id="第8章-串行输入-输出接口-（165）"><a href="#第8章-串行输入-输出接口-（165）" class="headerlink" title="第8章 串行输入/输出接口 （165）"></a>第8章 串行输入/输出接口 （165）</h1><p>8.1 串行通信接口 （166）<br>8.1.1 串行通信的实现 （166）<br>8.1.2 串行通信的基本概念 （171）<br>8.1.3 可编程串行通信接口芯片8251A简介 （174）<br>8.1.4 串行通信接口RS-232C （182）<br>8.2 USB总线简介 （188）<br>8.2.1 什么是USB （188）<br>8.2.2 USB工作原理 （192）<br>8.2.3 USB传输方式 （193）<br>8.2.4 USB设备列举 （194）<br>8.3 USB总线转接芯片——CH341简介 （195）</p><h1 id="第9章-中断与中断管理-（199）"><a href="#第9章-中断与中断管理-（199）" class="headerlink" title="第9章 中断与中断管理 （199）"></a>第9章 中断与中断管理 （199）</h1><p>9.1 中断原理 （199）<br>9.1.1 从无条件传输、条件传输到中断传输 （200）<br>9.1.2 中断概念 （201）<br>9.1.3 中断应用 （201）<br>9.2 中断系统组成及其功能 （202）<br>9.2.1 与中断有关的触发器 （202）<br>9.2.2 中断条件 （203）<br>9.2.3 中断响应过程 （204）<br>9.3 中断源识别及中断优先权 （205）<br>9.3.1 中断源识别 （205）<br>9.3.2 中断优先权 （208）<br>9.4 8086中断系统 （209）<br>9.4.1 不可屏蔽中断 （210）<br>9.4.2 可屏蔽中断 （210）<br>9.4.3 软件中断 （211）<br>9.4.4 中断概念的再讨论 （213）<br>9.5 8086 CPU的中断管理 （213）<br>9.5.1 8086 CPU的中断处理顺序 （213）<br>9.5.2 8086 CPU的中断服务入口地址表 （213）<br>9.5.3 中断入口地址设置 （215）<br>9.6 可编程中断控制器8259A简介 （217）<br>9.6.1 8259A的内部结构及引脚分配 （217）<br>9.6.2 8259A的中断管理方式 （219）<br>9.6.3 8259A的编程与应用 （221）<br>9.7 IBM PC硬件中断 （226）<br>9.7.1 中断设置 （226）<br>9.7.2 计算机中断资源的使用 （226）<br>9.7.3 中断举例 （227）</p><h1 id="第10章-D-A转换与A-D转换接口及其应用-（230）"><a href="#第10章-D-A转换与A-D转换接口及其应用-（230）" class="headerlink" title="第10章 D/A转换与A/D转换接口及其应用 （230）"></a>第10章 D/A转换与A/D转换接口及其应用 （230）</h1><p>10.1 从物理信号到电信号的转换 （231）<br>10.2 D/A转换器及其接口技术 （234）<br>10.2.1 D/A转换器及其接口概述 （234）<br>10.2.2 并行8位D/A转换芯片AD558及其接口 （235）<br>10.2.3 串行8位D/A转换器TLC5620 （236）<br>10.2.4 12位D/A转换器及接口 （239）<br>10.3 A/D转换器及其接口技术 （240）<br>10.3.1 A/D转换原理 （240）<br>10.3.2 A/D转换与微机接口技术的一般原理 （241）<br>10.3.3 A/D转换与微机接口电路 （241）<br>10.3.4 A/D转换芯片ADC0809 （244）<br>10.3.5 串行8位A/D转换器TLC0831 （247）<br>10.4 微机应用实例 （249）</p><h1 id="第11章-80286微处理器-（253）"><a href="#第11章-80286微处理器-（253）" class="headerlink" title="第11章 80286微处理器 （253）"></a>第11章 80286微处理器 （253）</h1><p>11.1 80286微处理器基本原理概述 （254）<br>11.1.1 80286内部结构简介 （254）<br>11.1.2 80286芯片引脚功能 （257）<br>11.1.3 80286支持的数据类型 （258）<br>11.1.4 80286指令系统 （258）<br>11.1.5 80286的存储器管理 （260）<br>11.1.6 保护虚地址方式下存储器管理 （261）<br>11.2 80286的系统配置 （266）</p><h1 id="第12章-80386微处理器-（268）"><a href="#第12章-80386微处理器-（268）" class="headerlink" title="第12章 80386微处理器 （268）"></a>第12章 80386微处理器 （268）</h1><p>12.1 80386系统结构 （268）<br>12.1.1 80386微处理器基本结构 （268）<br>12.1.2 80386的寄存器组成 （271）<br>12.1.3 80386的存储器管理 （273）<br>12.1.4 80386的保护机制 （278）<br>12.1.5 80386系统组成 （278）<br>12.2 80386的指令系统 （280）<br>12.2.1 80386的寻址方式 （280）<br>12.2.2 80386的指令系统 （280）<br>12.3 80386的存储器扩展 （283）<br>12.3.1 基本的存储器接口控制线 （284）<br>12.3.2 基本的存储器接口 （285）<br>12.3.3 高速缓冲存储器 （287）<br>12.3.4 Intel 82385高速缓存控制器 （291）<br>12.4 80386的输入/输出接口 （292）<br>12.4.1 8038的I/O系统 （292）<br>12.4.2 多功能接口芯片82380 （294）<br>12.5 80386的异常和中断及其处理 （297）<br>12.5.1 实模式下异常和中断的处理过程 （298）<br>12.5.2 保护虚地址方式下异常和中断的处理过程 （298）<br>12.6 精简指令集计算机（RISC）简介 （301）<br>12.6.1 RISC的基本原理 （301）<br>12.6.2 RISC的特色及其难点所在 （303）<br>12.6.3 RISC的关键技术 （304）<br>12.7 80x86典型微处理机介绍 （307）<br>12.7.1 80486 CPU （307）<br>12.7.2 Pentium系列微处理机 （312）</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF.ppt">微机原理与接口技术</a></p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微机原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理学习总结</title>
    <link href="/2020/12/22/note/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2020/12/22/note/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="1-1什么是编译"><a href="#1-1什么是编译" class="headerlink" title="1-1什么是编译"></a>1-1什么是编译</h2><h2 id="1-2编译系统的结构"><a href="#1-2编译系统的结构" class="headerlink" title="1-2编译系统的结构"></a>1-2编译系统的结构</h2><h2 id="1-3词法分析"><a href="#1-3词法分析" class="headerlink" title="1-3词法分析"></a>1-3词法分析</h2><h2 id="1-4语法分析概述"><a href="#1-4语法分析概述" class="headerlink" title="1-4语法分析概述"></a>1-4语法分析概述</h2><h2 id="1-5语义分析概述"><a href="#1-5语义分析概述" class="headerlink" title="1-5语义分析概述"></a>1-5语义分析概述</h2><h2 id="1-6中间代码生成和编译器后端"><a href="#1-6中间代码生成和编译器后端" class="headerlink" title="1-6中间代码生成和编译器后端"></a>1-6中间代码生成和编译器后端</h2><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="2-1词法语法分析基本概念"><a href="#2-1词法语法分析基本概念" class="headerlink" title="2-1词法语法分析基本概念"></a>2-1词法语法分析基本概念</h2><h2 id="2-2文法定义"><a href="#2-2文法定义" class="headerlink" title="2-2文法定义"></a>2-2文法定义</h2><h2 id="2-3语言的定义"><a href="#2-3语言的定义" class="headerlink" title="2-3语言的定义"></a>2-3语言的定义</h2><h2 id="2-4文法的分类"><a href="#2-4文法的分类" class="headerlink" title="2-4文法的分类"></a>2-4文法的分类</h2><h2 id="2-5CFG的分析树"><a href="#2-5CFG的分析树" class="headerlink" title="2-5CFG的分析树"></a>2-5CFG的分析树</h2><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><h2 id="3-1正则表达式"><a href="#3-1正则表达式" class="headerlink" title="3-1正则表达式"></a>3-1正则表达式</h2><h2 id="3-2正则定义"><a href="#3-2正则定义" class="headerlink" title="3-2正则定义"></a>3-2正则定义</h2><h2 id="3-3有求自动机"><a href="#3-3有求自动机" class="headerlink" title="3-3有求自动机"></a>3-3有求自动机</h2><h2 id="3-4有穷自动机的分类"><a href="#3-4有穷自动机的分类" class="headerlink" title="3-4有穷自动机的分类"></a>3-4有穷自动机的分类</h2><h2 id="3-5从正则表达式到有穷自动机"><a href="#3-5从正则表达式到有穷自动机" class="headerlink" title="3-5从正则表达式到有穷自动机"></a>3-5从正则表达式到有穷自动机</h2><h2 id="3-6从NFA到DFA的转换"><a href="#3-6从NFA到DFA的转换" class="headerlink" title="3-6从NFA到DFA的转换"></a>3-6从NFA到DFA的转换</h2><h2 id="3-7识别单词的DFA"><a href="#3-7识别单词的DFA" class="headerlink" title="3-7识别单词的DFA"></a>3-7识别单词的DFA</h2><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><h2 id="4-1自顶向下分析概述"><a href="#4-1自顶向下分析概述" class="headerlink" title="4-1自顶向下分析概述"></a>4-1自顶向下分析概述</h2><h2 id="4-2文法转换"><a href="#4-2文法转换" class="headerlink" title="4-2文法转换"></a>4-2文法转换</h2><h2 id="4-3LL1文法"><a href="#4-3LL1文法" class="headerlink" title="4-3LL1文法"></a>4-3LL1文法</h2><h2 id="4-4FIRST集和FOLLOW集"><a href="#4-4FIRST集和FOLLOW集" class="headerlink" title="4-4FIRST集和FOLLOW集"></a>4-4FIRST集和FOLLOW集</h2><h2 id="4-5递归的预测分析法"><a href="#4-5递归的预测分析法" class="headerlink" title="4-5递归的预测分析法"></a>4-5递归的预测分析法</h2><h2 id="4-6非递归的预测分析法"><a href="#4-6非递归的预测分析法" class="headerlink" title="4-6非递归的预测分析法"></a>4-6非递归的预测分析法</h2><h2 id="4-7预测分析法中的错误处理"><a href="#4-7预测分析法中的错误处理" class="headerlink" title="4-7预测分析法中的错误处理"></a>4-7预测分析法中的错误处理</h2><h2 id="4-8自底向上的分析概述"><a href="#4-8自底向上的分析概述" class="headerlink" title="4-8自底向上的分析概述"></a>4-8自底向上的分析概述</h2><h2 id="4-9LR分析法概述"><a href="#4-9LR分析法概述" class="headerlink" title="4-9LR分析法概述"></a>4-9LR分析法概述</h2><h2 id="4-10-LR0分析"><a href="#4-10-LR0分析" class="headerlink" title="4-10 LR0分析"></a>4-10 LR0分析</h2><h2 id="4-11-LR0分析表构造"><a href="#4-11-LR0分析表构造" class="headerlink" title="4-11 LR0分析表构造"></a>4-11 LR0分析表构造</h2><h2 id="4-12SLR"><a href="#4-12SLR" class="headerlink" title="4-12SLR"></a>4-12SLR</h2><h2 id="4-13LR1分析"><a href="#4-13LR1分析" class="headerlink" title="4-13LR1分析"></a>4-13LR1分析</h2><h2 id="4-14LALR分析法"><a href="#4-14LALR分析法" class="headerlink" title="4-14LALR分析法"></a>4-14LALR分析法</h2><h2 id="4-15二义性文法的LR分析"><a href="#4-15二义性文法的LR分析" class="headerlink" title="4-15二义性文法的LR分析"></a>4-15二义性文法的LR分析</h2><h2 id="4-16LR分析中的错误处理"><a href="#4-16LR分析中的错误处理" class="headerlink" title="4-16LR分析中的错误处理"></a>4-16LR分析中的错误处理</h2><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><h2 id="5-1语法制导翻译概述"><a href="#5-1语法制导翻译概述" class="headerlink" title="5-1语法制导翻译概述"></a>5-1语法制导翻译概述</h2><h2 id="5-2语法制导定义"><a href="#5-2语法制导定义" class="headerlink" title="5-2语法制导定义"></a>5-2语法制导定义</h2><h2 id="5-3SSD的求值顺序"><a href="#5-3SSD的求值顺序" class="headerlink" title="5-3SSD的求值顺序"></a>5-3SSD的求值顺序</h2><h2 id="5-4S属性定义与L属性定义"><a href="#5-4S属性定义与L属性定义" class="headerlink" title="5-4S属性定义与L属性定义"></a>5-4S属性定义与L属性定义</h2><h2 id="5-5语法制导翻译方案"><a href="#5-5语法制导翻译方案" class="headerlink" title="5-5语法制导翻译方案"></a>5-5语法制导翻译方案</h2><h2 id="5-6在非递归的预测分析过程中进行翻译"><a href="#5-6在非递归的预测分析过程中进行翻译" class="headerlink" title="5-6在非递归的预测分析过程中进行翻译"></a>5-6在非递归的预测分析过程中进行翻译</h2><h2 id="5-7在递归预测过程中进行翻译"><a href="#5-7在递归预测过程中进行翻译" class="headerlink" title="5-7在递归预测过程中进行翻译"></a>5-7在递归预测过程中进行翻译</h2><h2 id="5-8L属性定义的自底向上翻译"><a href="#5-8L属性定义的自底向上翻译" class="headerlink" title="5-8L属性定义的自底向上翻译"></a>5-8L属性定义的自底向上翻译</h2><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><h2 id="6-1类型表达式"><a href="#6-1类型表达式" class="headerlink" title="6-1类型表达式"></a>6-1类型表达式</h2><h2 id="6-2声明语句的翻译"><a href="#6-2声明语句的翻译" class="headerlink" title="6-2声明语句的翻译"></a>6-2声明语句的翻译</h2><h2 id="6-3简单赋值语句的翻译"><a href="#6-3简单赋值语句的翻译" class="headerlink" title="6-3简单赋值语句的翻译"></a>6-3简单赋值语句的翻译</h2><h2 id="6-4数组引用的翻译"><a href="#6-4数组引用的翻译" class="headerlink" title="6-4数组引用的翻译"></a>6-4数组引用的翻译</h2><h2 id="6-5控制流语句SDT"><a href="#6-5控制流语句SDT" class="headerlink" title="6-5控制流语句SDT"></a>6-5控制流语句SDT</h2><h2 id="6-6布尔表达式SDT"><a href="#6-6布尔表达式SDT" class="headerlink" title="6-6布尔表达式SDT"></a>6-6布尔表达式SDT</h2><h2 id="6-7控制流的栗子"><a href="#6-7控制流的栗子" class="headerlink" title="6-7控制流的栗子"></a>6-7控制流的栗子</h2><h2 id="6-8布尔表达式的回填"><a href="#6-8布尔表达式的回填" class="headerlink" title="6-8布尔表达式的回填"></a>6-8布尔表达式的回填</h2><h2 id="6-9控制流语句的回填"><a href="#6-9控制流语句的回填" class="headerlink" title="6-9控制流语句的回填"></a>6-9控制流语句的回填</h2><h2 id="6-10SWITCH语句的翻译"><a href="#6-10SWITCH语句的翻译" class="headerlink" title="6-10SWITCH语句的翻译"></a>6-10SWITCH语句的翻译</h2><h2 id="6-11过程调用语句的翻译"><a href="#6-11过程调用语句的翻译" class="headerlink" title="6-11过程调用语句的翻译"></a>6-11过程调用语句的翻译</h2><h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><h2 id="7-1运行存储分配概述"><a href="#7-1运行存储分配概述" class="headerlink" title="7-1运行存储分配概述"></a>7-1运行存储分配概述</h2><h2 id="7-2静态存储分配"><a href="#7-2静态存储分配" class="headerlink" title="7-2静态存储分配"></a>7-2静态存储分配</h2><h2 id="7-3栈式存储分配"><a href="#7-3栈式存储分配" class="headerlink" title="7-3栈式存储分配"></a>7-3栈式存储分配</h2><h2 id="7-4调用序列和返回序列"><a href="#7-4调用序列和返回序列" class="headerlink" title="7-4调用序列和返回序列"></a>7-4调用序列和返回序列</h2><h2 id="7-5非局部数据的访问"><a href="#7-5非局部数据的访问" class="headerlink" title="7-5非局部数据的访问"></a>7-5非局部数据的访问</h2><h2 id="7-6符号表"><a href="#7-6符号表" class="headerlink" title="7-6符号表"></a>7-6符号表</h2><h2 id="7-7符号表建立"><a href="#7-7符号表建立" class="headerlink" title="7-7符号表建立"></a>7-7符号表建立</h2><h1 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h1><h2 id="8-1流图"><a href="#8-1流图" class="headerlink" title="8-1流图"></a>8-1流图</h2><h2 id="8-2常用代码优化方法一"><a href="#8-2常用代码优化方法一" class="headerlink" title="8-2常用代码优化方法一"></a>8-2常用代码优化方法一</h2><h2 id="8-3常用代码优化方案二"><a href="#8-3常用代码优化方案二" class="headerlink" title="8-3常用代码优化方案二"></a>8-3常用代码优化方案二</h2><h2 id="8-4基本快的优化"><a href="#8-4基本快的优化" class="headerlink" title="8-4基本快的优化"></a>8-4基本快的优化</h2><h2 id="8-5数据流分析"><a href="#8-5数据流分析" class="headerlink" title="8-5数据流分析"></a>8-5数据流分析</h2><h2 id="8-6到达定值分析"><a href="#8-6到达定值分析" class="headerlink" title="8-6到达定值分析"></a>8-6到达定值分析</h2><h2 id="8-7到达定值方程的计算"><a href="#8-7到达定值方程的计算" class="headerlink" title="8-7到达定值方程的计算"></a>8-7到达定值方程的计算</h2><h2 id="8-8活跃变量分析"><a href="#8-8活跃变量分析" class="headerlink" title="8-8活跃变量分析"></a>8-8活跃变量分析</h2><h2 id="8-9可用表达式分析"><a href="#8-9可用表达式分析" class="headerlink" title="8-9可用表达式分析"></a>8-9可用表达式分析</h2><h2 id="8-10支配结点和回边"><a href="#8-10支配结点和回边" class="headerlink" title="8-10支配结点和回边"></a>8-10支配结点和回边</h2><h2 id="8-11自然循环及其识别"><a href="#8-11自然循环及其识别" class="headerlink" title="8-11自然循环及其识别"></a>8-11自然循环及其识别</h2><h2 id="8-12删除全局工工资表达式和赋值语句"><a href="#8-12删除全局工工资表达式和赋值语句" class="headerlink" title="8-12删除全局工工资表达式和赋值语句"></a>8-12删除全局工工资表达式和赋值语句</h2><h2 id="8-13代码移动"><a href="#8-13代码移动" class="headerlink" title="8-13代码移动"></a>8-13代码移动</h2><h2 id="8-14作用于归纳变量的强度削弱"><a href="#8-14作用于归纳变量的强度削弱" class="headerlink" title="8-14作用于归纳变量的强度削弱"></a>8-14作用于归纳变量的强度削弱</h2><h2 id="8-15归纳变量的删除"><a href="#8-15归纳变量的删除" class="headerlink" title="8-15归纳变量的删除"></a>8-15归纳变量的删除</h2><h1 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h1><h2 id="9-1代码生成器的主要任务"><a href="#9-1代码生成器的主要任务" class="headerlink" title="9-1代码生成器的主要任务"></a>9-1代码生成器的主要任务</h2><h2 id="9-2一个简单的目标机模型"><a href="#9-2一个简单的目标机模型" class="headerlink" title="9-2一个简单的目标机模型"></a>9-2一个简单的目标机模型</h2><h2 id="9-3指令选择"><a href="#9-3指令选择" class="headerlink" title="9-3指令选择"></a>9-3指令选择</h2><h2 id="9-4寄存器的选择"><a href="#9-4寄存器的选择" class="headerlink" title="9-4寄存器的选择"></a>9-4寄存器的选择</h2><h2 id="9-5寄存器选择函数getReg的设计"><a href="#9-5寄存器选择函数getReg的设计" class="headerlink" title="9-5寄存器选择函数getReg的设计"></a>9-5寄存器选择函数getReg的设计</h2><h2 id="9-6窥孔优化"><a href="#9-6窥孔优化" class="headerlink" title="9-6窥孔优化"></a>9-6窥孔优化</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1zW411t7YE?from=search&seid=16111600084881272278">编译原理（哈工大）</a></p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP和HTTPS协议，看一篇就够了</title>
    <link href="/2020/12/21/network/HTTP%E5%92%8CHTTPS%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/12/21/network/HTTP%E5%92%8CHTTPS%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="https://blog.csdn.net/xiaoming100001/article/details/81109617">原文链接</a></p><h3 id="一、前言："><a href="#一、前言：" class="headerlink" title="一、前言："></a>一、前言：</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/http-https-1.jpeg"><br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/http-https-2.jpeg"><br>先来观察这两张图，第一张访问域名<a href="http://www.12306.cn,谷歌浏览器提示不安全链接,第二张是https//kyfw.12306.cn/otn/regist/init%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E5%AE%89%E5%85%A8%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%BF%99%E6%A0%B7%E5%AD%90%E5%91%A2%EF%BC%9F2017%E5%B9%B41%E6%9C%88%E5%8F%91%E5%B8%83%E7%9A%84Chrome">http://www.12306.cn，谷歌浏览器提示不安全链接，第二张是https://kyfw.12306.cn/otn/regist/init，浏览器显示安全，为什么会这样子呢？2017年1月发布的Chrome</a> 56浏览器开始把收集密码或信用卡数据的HTTP页面标记为“不安全”，若用户使用2017年10月推出的Chrome 62，带有输入数据的HTTP页面和所有以无痕模式浏览的HTTP页面都会被标记为“不安全”，此外，苹果公司强制所有iOS App在2017年1月1日前使用HTTPS加密。</p><h3 id="二、HTTP和HTTPS发展历史"><a href="#二、HTTP和HTTPS发展历史" class="headerlink" title="二、HTTP和HTTPS发展历史"></a>二、HTTP和HTTPS发展历史</h3><h5 id="什么是HTTP"><a href="#什么是HTTP" class="headerlink" title="什么是HTTP?"></a>什么是HTTP?</h5><blockquote><p>超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。</p></blockquote><p>发展历史：</p><table><thead><tr><th>版本</th><th>产生时间</th><th>内容</th><th>发展现状</th></tr></thead><tbody><tr><td>HTTP/0.9</td><td>1991年</td><td>不涉及数据包传输，规定客户端和服务器之间通信格式，只能GET请求</td><td>没有作为正式的标准</td></tr><tr><td>HTTP/1.0</td><td>1996年</td><td>传输内容格式不限制，增加PUT、PATCH、HEAD、 OPTIONS、DELETE命令</td><td>正式作为标准</td></tr><tr><td>HTTP/1.1</td><td>1997年</td><td>持久连接(长连接)、节约带宽、HOST域、管道机制、分块传输编码</td><td>2015年前使用最广泛</td></tr><tr><td>HTTP/2</td><td>2015年</td><td>多路复用、服务器推送、头信息压缩、二进制协议等</td><td>逐渐覆盖市场</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/http-https-3.png"><br>这个Akamai公司建立的一个官方的演示，使用HTTP/1.1和HTTP/2同时请求379张图片，观察请求的时间，明显看出HTTP/2性能占优势。<br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/http-https-4.jpeg"><br>多路复用：通过单一的HTTP/2连接请求发起多重的请求-响应消息，多个请求stream共享一个TCP连接，实现多留并行而不是依赖建立多个TCP连接。</p><h5 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h5><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/http-https-5.png"></p><h5 id="什么是HTTPS？"><a href="#什么是HTTPS？" class="headerlink" title="什么是HTTPS？"></a>什么是HTTPS？</h5><blockquote><p>《图解HTTP》这本书中曾提过HTTPS是身披SSL外壳的HTTP。HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。</p><p>PS:TLS是传输层加密协议，前身是SSL协议，由网景公司1995年发布，有时候两者不区分。</p></blockquote><h5 id="参考连接："><a href="#参考连接：" class="headerlink" title="参考连接："></a>参考连接：</h5><p>1.<a href="https://blog.csdn.net/xiaoming100001/article/details/81109617">https://kamranahmed.info/blog/2016/08/13/http-in-depth/</a></p><p>2.<a href="https://blog.csdn.net/xiaoming100001/article/details/81109617">https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol</a></p><p>3.<a href="https://blog.csdn.net/xiaoming100001/article/details/81109617">https://tools.ietf.org/html/rfc1945</a></p><p>4.<a href="https://blog.csdn.net/xiaoming100001/article/details/81109617">https://http2.github.io/http2-spec/</a></p><p>5.<a href="https://blog.csdn.net/xiaoming100001/article/details/81109617">https://www.zhihu.com/question/34074946</a></p><h3 id="三、HTTP-VS-HTTPS"><a href="#三、HTTP-VS-HTTPS" class="headerlink" title="三、HTTP VS HTTPS"></a>三、HTTP VS HTTPS</h3><h5 id="HTTP特点："><a href="#HTTP特点：" class="headerlink" title="HTTP特点："></a>HTTP特点：</h5><ol><li>无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作</li><li>无连接：HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量。</li><li>基于请求和响应：基本的特性，由客户端发起请求，服务端响应</li><li>简单快速、灵活</li><li>通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性</li></ol><p><strong>下面通过一个简单的抓包实验观察使用HTTP请求传输的数据：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/http-https-6.jpeg"></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/http-https-7.jpeg"></p><h6 id="结果分析：HTTP协议传输数据以明文形式显示"><a href="#结果分析：HTTP协议传输数据以明文形式显示" class="headerlink" title="结果分析：HTTP协议传输数据以明文形式显示"></a>结果分析：HTTP协议传输数据以明文形式显示</h6><h6 id="针对无状态的一些解决策略："><a href="#针对无状态的一些解决策略：" class="headerlink" title="针对无状态的一些解决策略："></a>针对无状态的一些解决策略：</h6><h6 id="场景：逛电商商场用户需要使用的时间比较长，需要对用户一段时间的HTTP通信状态进行保存，比如执行一次登陆操作，在30分钟内所有的请求都不需要再次登陆。"><a href="#场景：逛电商商场用户需要使用的时间比较长，需要对用户一段时间的HTTP通信状态进行保存，比如执行一次登陆操作，在30分钟内所有的请求都不需要再次登陆。" class="headerlink" title="场景：逛电商商场用户需要使用的时间比较长，需要对用户一段时间的HTTP通信状态进行保存，比如执行一次登陆操作，在30分钟内所有的请求都不需要再次登陆。"></a>场景：逛电商商场用户需要使用的时间比较长，需要对用户一段时间的HTTP通信状态进行保存，比如执行一次登陆操作，在30分钟内所有的请求都不需要再次登陆。</h6><ol><li>通过Cookie/Session技术</li><li>HTTP/1.1持久连接（HTTP keep-alive）方法，只要任意一端没有明确提出断开连接，则保持TCP连接状态，在请求首部字段中的Connection: keep-alive即为表明使用了持久连接</li></ol><h4 id="HTTPS特点："><a href="#HTTPS特点：" class="headerlink" title="HTTPS特点："></a>HTTPS特点：</h4><p>基于HTTP协议，通过SSL或TLS提供加密处理数据、验证对方身份以及数据完整性保护</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/http-https-8.jpeg"></p><p>通过抓包可以看到数据不是明文传输，而且HTTPS有如下特点：</p><ol><li>内容加密：采用混合加密技术，中间者无法直接查看明文内容</li><li>验证身份：通过证书认证客户端访问的是自己的服务器</li><li>保护数据完整性：防止传输的内容被中间人冒充或者篡改</li></ol><blockquote><p><strong>混合加密：</strong>结合非对称加密和对称加密技术。客户端使用对称加密生成密钥对传输数据进行加密，然后使用非对称加密的公钥再对秘钥进行加密，所以网络上传输的数据是被秘钥加密的密文和用公钥加密后的秘密秘钥，因此即使被黑客截取，由于没有私钥，无法获取到加密明文的秘钥，便无法获取到明文数据。</p><p><strong>数字摘要：</strong>通过单向hash函数对原文进行哈希，将需加密的明文“摘要”成一串固定长度(如128bit)的密文，不同的明文摘要成的密文其结果总是不相同，同样的明文其摘要必定一致，并且即使知道了摘要也不能反推出明文。</p><p><strong>数字签名技术：</strong>数字签名建立在公钥加密体制基础上，是公钥加密技术的另一类应用。它把公钥加密技术和数字摘要结合起来，形成了实用的数字签名技术。</p></blockquote><ul><li>收方能够证实发送方的真实身份；</li><li>发送方事后不能否认所发送过的报文；</li><li>收方或非法者不能伪造、篡改报文。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/http-https-9.png"></p><p>非对称加密过程需要用到公钥进行加密，那么公钥从何而来？其实公钥就被包含在数字证书中，数字证书通常来说是由受信任的数字证书颁发机构CA，在验证服务器身份后颁发，证书中包含了一个密钥对（公钥和私钥）和所有者识别信息。数字证书被放到服务端，具有服务器身份验证和数据传输加密功能。</p><h3 id="四、HTTP通信传输"><a href="#四、HTTP通信传输" class="headerlink" title="四、HTTP通信传输"></a>四、HTTP通信传输</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/http-https-10.jpeg"></p><p>客户端输入URL回车，DNS解析域名得到服务器的IP地址，服务器在80端口监听客户端请求，端口通过TCP/IP协议（可以通过Socket实现）建立连接。HTTP属于TCP/IP模型中的运用层协议，所以通信的过程其实是对应数据的入栈和出栈。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/http-https-11.jpeg"></p><p>报文从运用层传送到运输层，运输层通过TCP三次握手和服务器建立连接，四次挥手释放连接。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/http-https-12.png"></p><p>为什么需要三次握手呢？为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p><p>比如：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段，但是server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求，于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了，由于client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据，但server却以为新的运输连接已经建立，并一直等待client发来数据。所以没有采用“三次握手”，这种情况下server的很多资源就白白浪费掉了。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/http-https-13.png"></p><p>为什么需要四次挥手呢？TCP是全双工模式，当client发出FIN报文段时，只是表示client已经没有数据要发送了，client告诉server，它的数据已经全部发送完毕了；但是，这个时候client还是可以接受来server的数据；当server返回ACK报文段时，表示它已经知道client没有数据发送了，但是server还是可以发送数据到client的；当server也发送了FIN报文段时，这个时候就表示server也没有数据要发送了，就会告诉client，我也没有数据要发送了，如果收到client确认报文段，之后彼此就会愉快的中断这次TCP连接。</p><h3 id="五、HTTPS实现原理"><a href="#五、HTTPS实现原理" class="headerlink" title="五、HTTPS实现原理"></a>五、HTTPS实现原理</h3><p><strong>SSL建立连接过程</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/http-https-14.png"></p><ol><li>client向server发送请求<a href="https://baidu.com,然后连接到server的443端口,发送的信息主要是随机值1和客户端支持的加密算法./">https://baidu.com，然后连接到server的443端口，发送的信息主要是随机值1和客户端支持的加密算法。</a></li><li>server接收到信息之后给予client响应握手信息，包括随机值2和匹配好的协商加密算法，这个加密算法一定是client发送给server加密算法的子集。</li><li>随即server给client发送第二个响应报文是数字证书。服务端必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥。传送证书，这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容。</li><li>客户端解析证书，这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值（预主秘钥）。</li><li>客户端认证证书通过之后，接下来是通过随机值1、随机值2和预主秘钥组装会话秘钥。然后通过证书的公钥加密会话秘钥。</li><li>传送加密信息，这部分传送的是用证书加密后的会话秘钥，目的就是让服务端使用秘钥解密得到随机值1、随机值2和预主秘钥。</li><li>服务端解密得到随机值1、随机值2和预主秘钥，然后组装会话秘钥，跟客户端会话秘钥相同。</li><li>客户端通过会话秘钥加密一条消息发送给服务端，主要验证服务端是否正常接受客户端加密的消息。</li><li>同样服务端也会通过会话秘钥加密一条消息回传给客户端，如果客户端能够正常接受的话表明SSL层连接建立完成了。</li></ol><p>问题：<br><strong>1.怎么保证保证服务器给客户端下发的公钥是真正的公钥，而不是中间人伪造的公钥呢？</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/http-https-15.png"></p><p><strong>2.证书如何安全传输，被掉包了怎么办？</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/http-https-16.png"></p><p><strong>数字证书内容</strong><br>包括了加密后服务器的公钥、权威机构的信息、服务器域名，还有经过CA私钥签名之后的证书内容（经过先通过Hash函数计算得到证书数字摘要，然后用权威机构私钥加密数字摘要得到数字签名)，签名计算方法以及证书对应的域名。</p><p><strong>验证证书安全性过程</strong></p><ol><li>当客户端收到这个证书之后，使用本地配置的权威机构的公钥对证书进行解密得到服务端的公钥和证书的数字签名，数字签名经过CA公钥解密得到证书信息摘要。</li><li>然后证书签名的方法计算一下当前证书的信息摘要，与收到的信息摘要作对比，如果一样，表示证书一定是服务器下发的，没有被中间人篡改过。因为中间人虽然有权威机构的公钥，能够解析证书内容并篡改，但是篡改完成之后中间人需要将证书重新加密，但是中间人没有权威机构的私钥，无法加密，强行加密只会导致客户端无法解密，如果中间人强行乱修改证书，就会导致证书内容和证书签名不匹配。</li></ol><p><strong>那第三方攻击者能否让自己的证书显示出来的信息也是服务端呢？</strong>（伪装服务端一样的配置）显然这个是不行的，因为当第三方攻击者去CA那边寻求认证的时候CA会要求其提供例如域名的whois信息、域名管理邮箱等证明你是服务端域名的拥有者，而第三方攻击者是无法提供这些信息所以他就是无法骗CA他拥有属于服务端的域名。</p><h3 id="六、运用与总结"><a href="#六、运用与总结" class="headerlink" title="六、运用与总结"></a>六、运用与总结</h3><h5 id="安全性考虑："><a href="#安全性考虑：" class="headerlink" title="安全性考虑："></a>安全性考虑：</h5><ol><li>HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用</li><li>SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行</li></ol><blockquote><p>中间人攻击（MITM攻击）是指，黑客拦截并篡改网络中的通信数据。又分为被动MITM和主动MITM，被动MITM只窃取通信数据而不修改，而主动MITM不但能窃取数据，还会篡改通信数据。最常见的中间人攻击常常发生在公共wifi或者公共路由上。</p></blockquote><h5 id="成本考虑："><a href="#成本考虑：" class="headerlink" title="成本考虑："></a>成本考虑：</h5><ol><li>SSL证书需要购买申请，功能越强大的证书费用越高</li><li>SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗（SSL有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作系统支持，Windows XP就不支持这个扩展，考虑到XP的装机量，这个特性几乎没用）。</li><li>根据ACM CoNEXT数据显示，使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电。</li><li>HTTPS连接缓存不如HTTP高效，流量成本高。</li><li>HTTPS连接服务器端资源占用高很多，支持访客多的网站需要投入更大的成本。</li><li>HTTPS协议握手阶段比较费时，对网站的响应速度有影响，影响用户体验。比较好的方式是采用分而治之，类似12306网站的主页使用HTTP协议，有关于用户信息等方面使用HTTPS。</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http/https</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java程序死锁的排查方法</title>
    <link href="/2020/12/21/note/%E6%AD%BB%E9%94%81%E7%9A%84%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95/"/>
    <url>/2020/12/21/note/%E6%AD%BB%E9%94%81%E7%9A%84%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="死锁成立条件"><a href="#死锁成立条件" class="headerlink" title="死锁成立条件"></a>死锁成立条件</h1><p>1、<code>互斥</code>：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。<br>2、<code>占有且等待</code>：一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源。<br>3、<code>不可抢占</code>：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。<br>4、<code>循环等待</code>：存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源。</p><h1 id="如何排查死锁"><a href="#如何排查死锁" class="headerlink" title="如何排查死锁"></a>如何排查死锁</h1><ul><li>jps 查看进程</li><li>jstack 打印堆栈信息</li><li>jconsole 可视化查看详情</li></ul><h1 id="简单排查示例"><a href="#简单排查示例" class="headerlink" title="简单排查示例"></a>简单排查示例</h1><details>  <summary><span>展开代码</span></summary>  <br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String lockA;<br>    <span class="hljs-keyword">private</span> String lockB;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DeadLock</span><span class="hljs-params">(String lockA, String lockB)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.lockA = lockA;<br>        <span class="hljs-keyword">this</span>.lockB = lockB;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (lockA)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (lockB)&#123;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String lockA=<span class="hljs-string">&quot;lockA&quot;</span>;<br>        String lockB=<span class="hljs-string">&quot;lockB&quot;</span>;<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> DeadLock(lockA,lockB),<span class="hljs-string">&quot;ThreadAA&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> DeadLock(lockB,lockA),<span class="hljs-string">&quot;ThreadBB&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs shell">ikey@mikey:~/Downloads/sdkmoderation/algorithm$ jps<br>31408 Jps<br>30899 Launcher<br>30902 DeadLock<br>4235 Main<br>mikey@mikey:~/Downloads/sdkmoderation/algorithm$ jstack 30902<br>2020-12-21 22:39:40<br>Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.221-b11 mixed mode):<br><br>&quot;Attach Listener&quot; #13 daemon prio=9 os_prio=0 tid=0x00007f60fc001000 nid=0x78e8 waiting on condition [0x0000000000000000]<br>   java.lang.Thread.State: RUNNABLE<br><br>&quot;DestroyJavaVM&quot; #12 prio=5 os_prio=0 tid=0x00007f613c00d800 nid=0x78b7 waiting on condition [0x0000000000000000]<br>   java.lang.Thread.State: RUNNABLE<br><br>&quot;ThreadBB&quot; #11 prio=5 os_prio=0 tid=0x00007f613c20e000 nid=0x78e2 waiting for monitor entry [0x00007f6126944000]<br>   java.lang.Thread.State: BLOCKED (on object monitor)<br>        at demo.DeadLock.run(DeadLock.java:22)<br>        - waiting to lock &lt;0x000000076d283280&gt; (a java.lang.String)<br>        - locked &lt;0x000000076d2832b8&gt; (a java.lang.String)<br>        at java.lang.Thread.run(Thread.java:748)<br><br>&quot;ThreadAA&quot; #10 prio=5 os_prio=0 tid=0x00007f613c20c800 nid=0x78e1 waiting for monitor entry [0x00007f6126a45000]<br>   java.lang.Thread.State: BLOCKED (on object monitor)<br>        at demo.DeadLock.run(DeadLock.java:22)<br>        - waiting to lock &lt;0x000000076d2832b8&gt; (a java.lang.String)<br>        - locked &lt;0x000000076d283280&gt; (a java.lang.String)<br>        at java.lang.Thread.run(Thread.java:748)<br><br>&quot;Service Thread&quot; #9 daemon prio=9 os_prio=0 tid=0x00007f613c207800 nid=0x78df runnable [0x0000000000000000]<br>   java.lang.Thread.State: RUNNABLE<br><br>&quot;C1 CompilerThread2&quot; #8 daemon prio=9 os_prio=0 tid=0x00007f613c204000 nid=0x78de waiting on condition [0x0000000000000000]<br>   java.lang.Thread.State: RUNNABLE<br><br>&quot;C2 CompilerThread1&quot; #7 daemon prio=9 os_prio=0 tid=0x00007f613c202000 nid=0x78dd waiting on condition [0x0000000000000000]<br>   java.lang.Thread.State: RUNNABLE<br><br>&quot;C2 CompilerThread0&quot; #6 daemon prio=9 os_prio=0 tid=0x00007f613c200800 nid=0x78dc waiting on condition [0x0000000000000000]<br>   java.lang.Thread.State: RUNNABLE<br><br>&quot;Monitor Ctrl-Break&quot; #5 daemon prio=5 os_prio=0 tid=0x00007f613c1fe000 nid=0x78db runnable [0x00007f6127262000]<br>   java.lang.Thread.State: RUNNABLE<br>        at java.net.SocketInputStream.socketRead0(Native Method)<br>        at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)<br>        at java.net.SocketInputStream.read(SocketInputStream.java:171)<br>        at java.net.SocketInputStream.read(SocketInputStream.java:141)<br>        at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284)<br>        at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326)<br>        at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178)<br>        - locked &lt;0x000000076d2fa148&gt; (a java.io.InputStreamReader)<br>        at java.io.InputStreamReader.read(InputStreamReader.java:184)<br>        at java.io.BufferedReader.fill(BufferedReader.java:161)<br>        at java.io.BufferedReader.readLine(BufferedReader.java:324)<br>        - locked &lt;0x000000076d2fa148&gt; (a java.io.InputStreamReader)<br>        at java.io.BufferedReader.readLine(BufferedReader.java:389)<br>        at com.intellij.rt.execution.application.AppMainV2$1.run(AppMainV2.java:47)<br><br>&quot;Signal Dispatcher&quot; #4 daemon prio=9 os_prio=0 tid=0x00007f613c183000 nid=0x78c6 runnable [0x0000000000000000]<br>   java.lang.Thread.State: RUNNABLE<br><br>&quot;Finalizer&quot; #3 daemon prio=8 os_prio=0 tid=0x00007f613c151000 nid=0x78c5 in Object.wait() [0x00007f61278f7000]<br>   java.lang.Thread.State: WAITING (on object monitor)<br>        at java.lang.Object.wait(Native Method)<br>        - waiting on &lt;0x000000076d188ed8&gt; (a java.lang.ref.ReferenceQueue$Lock)<br>        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)<br>        - locked &lt;0x000000076d188ed8&gt; (a java.lang.ref.ReferenceQueue$Lock)<br>        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)<br>        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)<br><br>&quot;Reference Handler&quot; #2 daemon prio=10 os_prio=0 tid=0x00007f613c14c800 nid=0x78c4 in Object.wait() [0x00007f61279f8000]<br>   java.lang.Thread.State: WAITING (on object monitor)<br>        at java.lang.Object.wait(Native Method)<br>        - waiting on &lt;0x000000076d186c00&gt; (a java.lang.ref.Reference$Lock)<br>        at java.lang.Object.wait(Object.java:502)<br>        at java.lang.ref.Reference.tryHandlePending(Reference.java:191)<br>        - locked &lt;0x000000076d186c00&gt; (a java.lang.ref.Reference$Lock)<br>        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)<br><br>&quot;VM Thread&quot; os_prio=0 tid=0x00007f613c143000 nid=0x78c1 runnable <br><br>&quot;GC task thread#0 (ParallelGC)&quot; os_prio=0 tid=0x00007f613c023800 nid=0x78bc runnable <br><br>&quot;GC task thread#1 (ParallelGC)&quot; os_prio=0 tid=0x00007f613c025000 nid=0x78bd runnable <br><br>&quot;GC task thread#2 (ParallelGC)&quot; os_prio=0 tid=0x00007f613c027000 nid=0x78be runnable <br><br>&quot;GC task thread#3 (ParallelGC)&quot; os_prio=0 tid=0x00007f613c028800 nid=0x78bf runnable <br><br>&quot;VM Periodic Task Thread&quot; os_prio=0 tid=0x00007f613c20a000 nid=0x78e0 waiting on condition <br><br>JNI global references: 12<br><br><br>Found one Java-level deadlock:<br>=============================<br>&quot;ThreadBB&quot;:<br>  waiting to lock monitor 0x00007f6104006528 (object 0x000000076d283280, a java.lang.String),<br>  which is held by &quot;ThreadAA&quot;<br>&quot;ThreadAA&quot;:<br>  waiting to lock monitor 0x00007f6104005088 (object 0x000000076d2832b8, a java.lang.String),<br>  which is held by &quot;ThreadBB&quot;<br><br>Java stack information for the threads listed above:<br>===================================================<br>&quot;ThreadBB&quot;:<br>        at demo.DeadLock.run(DeadLock.java:22)<br>        - waiting to lock &lt;0x000000076d283280&gt; (a java.lang.String)<br>        - locked &lt;0x000000076d2832b8&gt; (a java.lang.String)<br>        at java.lang.Thread.run(Thread.java:748)<br>&quot;ThreadAA&quot;:<br>        at demo.DeadLock.run(DeadLock.java:22)<br>        - waiting to lock &lt;0x000000076d2832b8&gt; (a java.lang.String)<br>        - locked &lt;0x000000076d283280&gt; (a java.lang.String)<br>        at java.lang.Thread.run(Thread.java:748)<br><br>Found 1 deadlock.<br><br></code></pre></td></tr></table></figure><h1 id="参考相关资料"><a href="#参考相关资料" class="headerlink" title="参考相关资料"></a>参考相关资料</h1><p><a href="https://blog.csdn.net/yuandengta/article/details/107189812">如何快速排查死锁？如何避免死锁？（值得收藏）</a></p>]]></content>
    
    
    <categories>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>死锁排查</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法篇-极客算法训练营总结</title>
    <link href="/2020/12/20/algorithm/%E7%AE%97%E6%B3%95%E7%AF%87-%E6%9E%81%E5%AE%A2%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    <url>/2020/12/20/algorithm/%E7%AE%97%E6%B3%95%E7%AF%87-%E6%9E%81%E5%AE%A2%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="https://blog.csdn.net/Miaoshuowen/article/details/103582532?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.control">原文-极客大学算法训练营毕业总结</a></p><h2 id="1、算法和数据结构脑图"><a href="#1、算法和数据结构脑图" class="headerlink" title="1、算法和数据结构脑图"></a>1、算法和数据结构脑图</h2><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jike-1.png"><br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jike-2.png"></p><h2 id="2、刻意练习–过遍数"><a href="#2、刻意练习–过遍数" class="headerlink" title="2、刻意练习–过遍数"></a>2、刻意练习–过遍数</h2><p><strong>切题四件套</strong></p><ul><li>clarification</li><li>possible solutions<ul><li>compare（time/space）</li><li>optimal（学习最优解加强）</li></ul></li><li>coding（多写）</li><li>test cases</li></ul><p><strong>五遍刷题法：</strong><br>练习缺点、弱点地方，不舒服、枯燥、不爽—就是在进步；</p><p>①刷题第一遍</p><ul><li>5-15分钟：读题+思考</li><li>直接看解法：注意看多解法、比较解法优劣</li><li>背诵、默写好的解法。</li></ul><p>②刷题第二遍</p><ul><li>马上自己写 –&gt;leetcode提交</li><li>多种解法，体会优劣；</li></ul><p>③刷题第三遍</p><ul><li>过了一天后在重复做题</li></ul><p>④刷题第四遍</p><ul><li>过了一周后：反复回来练习相同题目</li></ul><p>⑤刷题第五遍</p><ul><li>面试前一周准备</li></ul><h2 id="3、递归-Recursion"><a href="#3、递归-Recursion" class="headerlink" title="3、递归 Recursion"></a>3、递归 Recursion</h2><p>递归 – 循环<br>通过函数体来进行循环<br>四个条件：</p><ul><li>递回终止条件</li><li>处理当前层逻辑</li><li>下探到下一层</li><li>清理当前层</li></ul><p><strong>思维要求</strong></p><ul><li>不要再进行人肉递归（最大误区）</li><li>找到最近最简方法，将其拆解成可重复解决的问题（重复子问题）</li><li>数学归纳法</li></ul><p>递归代码模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(<span class="hljs-keyword">int</span> level, <span class="hljs-keyword">int</span> param)</span> </span>&#123; <br><br>  <span class="hljs-comment">// terminator </span><br>  <span class="hljs-keyword">if</span> (level &gt; MAX_LEVEL) &#123; <br>    <span class="hljs-comment">// process result </span><br>    <span class="hljs-keyword">return</span>; <br>  &#125; <br><br>  <span class="hljs-comment">// process current logic </span><br>  process(level, param); <br><br>  <span class="hljs-comment">// drill down </span><br>  recur( level: level + <span class="hljs-number">1</span>, newParam); <br><br>  <span class="hljs-comment">// restore current status </span><br> <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分治思维：</strong></p><ul><li>递归终止条件</li><li>拆分子问题</li><li>调子问题的递归函数</li><li>合并结果，有可能要恢复当前层的状态</li></ul><p>分治代码模板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">divide_conquer</span>(<span class="hljs-params">problem, param1, param2, ...</span>):</span> <br>  <span class="hljs-comment"># recursion terminator </span><br>  <span class="hljs-keyword">if</span> problem <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <br>print_result <br><span class="hljs-keyword">return</span> <br><br>  <span class="hljs-comment"># prepare data </span><br>  data = prepare_data(problem) <br>  subproblems = split_problem(problem, data) <br><br>  <span class="hljs-comment"># conquer subproblems </span><br>  subresult1 = self.divide_conquer(subproblems[<span class="hljs-number">0</span>], p1, ...) <br>  subresult2 = self.divide_conquer(subproblems[<span class="hljs-number">1</span>], p1, ...) <br>  subresult3 = self.divide_conquer(subproblems[<span class="hljs-number">2</span>], p1, ...) <br>  …<br><br>  <span class="hljs-comment"># process and generate the final result </span><br>  result = process_result(subresult1, subresult2, subresult3, …)<br><br>  <span class="hljs-comment"># revert the current level states</span><br></code></pre></td></tr></table></figure><h2 id="4、动态规划"><a href="#4、动态规划" class="headerlink" title="4、动态规划"></a>4、动态规划</h2><p>动态规划和递归或者分治，没有根本上的区别（关键看有无最优子结构）<br>共性：找到重复子问题<br>差异性：最优子结构，中途可以淘汰次优解</p><p><strong>动态规划关键点：</strong></p><ul><li>最优子结构 <code>opt[n] = best_of(opt [n-1], opt[n-2],....)</code>（子问题）</li><li>储存中间状态:<code>opt[i]</code> (状态定义）</li><li>递归公式（状态转移方程或者DP方程）</li></ul><p><strong>高阶dp</strong></p><ul><li>状态拥有更多维度</li><li>状态方程更加复杂</li></ul><p><strong>例题：LeetCode72. 编辑距离</strong></p><p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br>删除一个字符<br>替换一个字符</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">示例 <span class="hljs-number">1</span>:<br>输入: word1 = <span class="hljs-string">&quot;horse&quot;</span>, word2 = <span class="hljs-string">&quot;ros&quot;</span><br>输出: <span class="hljs-number">3</span><br>解释: <br>horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)<br>rorse -&gt; rose (删除 &#x27;r&#x27;)<br>rose -&gt; ros (删除 &#x27;e&#x27;)<br><br><span class="hljs-number">12345678</span><br>示例 <span class="hljs-number">2</span>:<br>输入: word1 = <span class="hljs-string">&quot;intention&quot;</span>, word2 = <span class="hljs-string">&quot;execution&quot;</span><br>输出: <span class="hljs-number">5</span><br>解释: <br>intention -&gt; inention (删除 &#x27;t&#x27;)<br>inention -&gt; enention (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)<br>enention -&gt; exention (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)<br>exention -&gt; exection (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)<br>exection -&gt; execution (插入 &#x27;u&#x27;)<br></code></pre></td></tr></table></figure><p><strong>思路：升级维度</strong><br>将word1与word2的长度作为二维数组长度新建二维数组，二维数组用来存储最短编辑距离；<br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jike-3.png"></p><ul><li>如果<code>word1[i]与word2[j]相同，显然 dp[i][j] = dp[i-1][j-1]</code></li><li>如果<code>word1[i]与word2[j]不同，那么dp[i][j]</code>可以通过<ul><li>在<code>dp[i-1][j-1]</code> 的基础上做replance 操作来达到目的</li><li>在<code>dp[i-1][j]</code> 的基础上做insert操作来达到目的</li><li>在<code>dp[i][j-1]</code> 的基础上做insert操作来达到目的</li></ul></li><li>取三者最小情况即可</li></ul><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String word1, String word2)</span> </span>&#123;<br><br><span class="hljs-keyword">int</span> len1 = word1.length();<br><span class="hljs-keyword">int</span> len2 = word2.length();<br><span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len1 + <span class="hljs-number">1</span>][len2 + <span class="hljs-number">1</span>];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len2; i++) &#123;<br>dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= len1; j++) &#123;<br>dp[j][<span class="hljs-number">0</span>] = dp[j - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len1; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= len2; j++) &#123;<br><span class="hljs-keyword">if</span> (word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>dp[i][j] = Math.min(Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]), dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> dp[len1][len2];<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5、字典树，Trie"><a href="#5、字典树，Trie" class="headerlink" title="5、字典树，Trie"></a>5、字典树，Trie</h2><p>字典树，即Trie树，又称单词查找树或键树，是一种数据结构。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。</p><p>优点在于：最大限度的减少无谓的字符串比较，查找效率比哈希表高。</p><p>基本性质：</p><ul><li>节点本身不存完整单词；</li><li>从根节点到某一节点路径上经过的字符链接起来，为该节点的字符串；</li><li>每个节点的所有子节点路径代表字符都不相同。</li></ul><p><strong>核心思想</strong><br>Trie树的核心思想就是空间换时间<br>利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的</p><p><strong>Trie代码模板</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span> </span>&#123;<br><span class="hljs-keyword">private</span> TrieNode[] links;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> R = <span class="hljs-number">26</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isEnd;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TrieNode</span><span class="hljs-params">()</span> </span>&#123;<br>links = <span class="hljs-keyword">new</span> TrieNode[R];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containskey</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span> </span>&#123;<br><span class="hljs-keyword">return</span> links[ch - <span class="hljs-string">&#x27;a&#x27;</span>] != <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> TrieNode <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span> </span>&#123;<br><span class="hljs-keyword">return</span> links[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch, TrieNode node)</span> </span>&#123;<br>links[ch - <span class="hljs-string">&#x27;a&#x27;</span>] = node;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEnd</span><span class="hljs-params">()</span> </span>&#123;<br>isEnd = <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnd</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> isEnd;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie208</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> TrieNode root;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie208</span><span class="hljs-params">()</span> </span>&#123;<br>root = <span class="hljs-keyword">new</span> TrieNode();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;<br>TrieNode node = root;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br><span class="hljs-keyword">char</span> ch = word.charAt(i);<br><span class="hljs-keyword">if</span> (!node.containskey(ch)) &#123;<br>node.put(ch, <span class="hljs-keyword">new</span> TrieNode());<br>&#125;<br>node = node.get(ch);<br>&#125;<br>node.setEnd();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span> </span>&#123;<br>TrieNode node = searchprefix(word);<br><span class="hljs-keyword">return</span> node != <span class="hljs-keyword">null</span> &amp;&amp; node.isEnd();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> TrieNode <span class="hljs-title">searchprefix</span><span class="hljs-params">(String word)</span> </span>&#123;<br>TrieNode node = root;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br><span class="hljs-keyword">char</span> ch = word.charAt(i);<br><span class="hljs-keyword">if</span> (node.containskey(ch)) &#123;<br>node = node.get(ch);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startwith</span><span class="hljs-params">(String prefix)</span> </span>&#123;<br>TrieNode node = searchprefix(prefix);<br><span class="hljs-keyword">return</span> node != <span class="hljs-keyword">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6、并查集"><a href="#6、并查集" class="headerlink" title="6、并查集"></a>6、并查集</h2><p><strong>适用场景</strong><br>组团、配对问题<br>适用场景：组团、配对问题</p><p><strong>基本操作：</strong><br>makeset(s)：建立一个新的并查集，其中包括s个单位元素集合；<br>unionset(s):把元素x和y所在的元素集合合并，要求x和y所在的集合不相交，如果相交则不合并；<br>find(x):找到元素x所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将他们各自的代表比较一下即可；</p><p><strong>并查集代码模板</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Unionimpl</span></span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> []parent;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Unionimpl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>count = n;<br>parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>parent[i] = i;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getcount</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> count;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>&#123;<br><span class="hljs-keyword">while</span>( p != parent[i])&#123;<br>parent[p] = parent[parent[p]];<br>p = parent[p];<br>&#125;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p ,<span class="hljs-keyword">int</span> q)</span></span>&#123;<br><span class="hljs-keyword">int</span> rootp = find(p);<br><span class="hljs-keyword">int</span> rootq = find(q);<br><span class="hljs-keyword">if</span>(rootp ==rootq)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>parent[rootp] = rootq;<br>count --;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7、LRU-Cache缓存"><a href="#7、LRU-Cache缓存" class="headerlink" title="7、LRU Cache缓存"></a>7、LRU Cache缓存</h2><p><strong>最少最近使用</strong></p><p>两个要素：大小、替换策略<br>HashTable + Double LinkedList</p><p><strong>代码模板</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;<br><span class="hljs-comment">// key -&gt; Node(key, val)</span><br><span class="hljs-keyword">private</span> HashMap&lt;Integer, Node&gt; map;<br><span class="hljs-comment">// Node(k1, v1) &lt;-&gt; Node(k2, v2)...</span><br><span class="hljs-keyword">private</span> DoubleList cache;<br><span class="hljs-comment">// 最大容量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cap;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.cap = capacity;<br>map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>cache = <span class="hljs-keyword">new</span> DoubleList();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!map.containsKey(key))<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> val = map.get(key).val;<br><span class="hljs-comment">// 利用 put 方法把该数据提前</span><br>put(key, val);<br><span class="hljs-keyword">return</span> val;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br><span class="hljs-comment">// 先把新节点 x 做出来</span><br>Node x = <span class="hljs-keyword">new</span> Node(key, val);<br><br><span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;<br><span class="hljs-comment">// 删除旧的节点，新的插到头部</span><br>cache.remove(map.get(key));<br>cache.addFirst(x);<br><span class="hljs-comment">// 更新 map 中对应的数据</span><br>map.put(key, x);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (cap == cache.size()) &#123;<br><span class="hljs-comment">// 删除链表最后一个数据</span><br>Node last = cache.removeLast();<br>map.remove(last.key);<br>&#125;<br><span class="hljs-comment">// 直接添加到头部</span><br>cache.addFirst(x);<br>map.put(key, x);<br>&#125;<br>&#125;<br>&#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> key, val;<br><span class="hljs-keyword">public</span> Node next, prev;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.key = k;<br><span class="hljs-keyword">this</span>.val = v;<br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleList</span> </span>&#123;<br><span class="hljs-keyword">private</span> Node head, tail; <span class="hljs-comment">// 头尾虚节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size; <span class="hljs-comment">// 链表元素数</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DoubleList</span><span class="hljs-params">()</span> </span>&#123;<br>head = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>tail = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>head.next = tail;<br>tail.prev = head;<br>size = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 在链表头部添加节点 x</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFirst</span><span class="hljs-params">(Node x)</span> </span>&#123;<br>x.next = head.next;<br>x.prev = head;<br>head.next.prev = x;<br>head.next = x;<br>size++;<br>&#125;<br><br><span class="hljs-comment">// 删除链表中的 x 节点（x 一定存在）</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Node x)</span> </span>&#123;<br>x.prev.next = x.next;<br>x.next.prev = x.prev;<br>size--;<br>&#125;<br><br><span class="hljs-comment">// 删除链表中最后一个节点，并返回该节点</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">removeLast</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (tail.prev == head)<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>Node last = tail.prev;<br>remove(last);<br><span class="hljs-keyword">return</span> last;<br>&#125;<br><br><span class="hljs-comment">// 返回链表长度</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> size;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>LeetCode146. LRU缓存机制</strong><br>运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">示例:<br><br>LRUCache cache = <span class="hljs-keyword">new</span> LRUCache( <span class="hljs-number">2</span> <span class="hljs-comment">/* 缓存容量 */</span> );<br><br>cache.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>cache.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>cache.get(<span class="hljs-number">1</span>);       <span class="hljs-comment">// 返回  1</span><br>cache.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);    <span class="hljs-comment">// 该操作会使得密钥 2 作废</span><br>cache.get(<span class="hljs-number">2</span>);       <span class="hljs-comment">// 返回 -1 (未找到)</span><br>cache.put(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>);    <span class="hljs-comment">// 该操作会使得密钥 1 作废</span><br>cache.get(<span class="hljs-number">1</span>);       <span class="hljs-comment">// 返回 -1 (未找到)</span><br>cache.get(<span class="hljs-number">3</span>);       <span class="hljs-comment">// 返回  3</span><br>cache.get(<span class="hljs-number">4</span>);       <span class="hljs-comment">// 返回  4</span><br></code></pre></td></tr></table></figure><p><strong>题解代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>&lt;<span class="hljs-title">Integer</span>, <span class="hljs-title">Integer</span>&gt; </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br><span class="hljs-keyword">super</span>(capacity, <span class="hljs-number">0.75F</span>, <span class="hljs-keyword">true</span>);<br><span class="hljs-keyword">this</span>.capacity = capacity;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getOrDefault(key, -<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br><span class="hljs-keyword">super</span>.put(key, value);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeEldestEntry</span><span class="hljs-params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;<br><span class="hljs-keyword">return</span> size() &gt; capacity;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8、布隆过滤器"><a href="#8、布隆过滤器" class="headerlink" title="8、布隆过滤器"></a>8、布隆过滤器</h2><p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</p><p>相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的</p><p><strong>实现原理</strong></p><p>HashMap 的问题<br>讲述布隆过滤器的原理之前，我们先思考一下，通常你判断某个元素是否存在用的是什么？应该蛮多人回答 HashMap 吧，确实可以将值映射到 HashMap 的 Key，然后可以在 O(1) 的时间复杂度内返回结果，效率奇高。但是 HashMap 的实现也有缺点，例如存储容量占比高，考虑到负载因子的存在，通常空间是不能被用满的，而一旦你的值很多例如上亿的时候，那 HashMap 占据的内存大小就变得很可观了。</p><p>还比如说你的数据集存储在远程服务器上，本地服务接受输入，而数据集非常大不可能一次性读进内存构建 HashMap 的时候，也会存在问题。</p><p><strong>布隆过滤器数据结构</strong><br>布隆过滤器是一个 bit 向量或者说 bit 数组，长这样：<br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jike-4.png"><br>如果一个元素对应的二进制只要有一个为0，就说明这个元素不在布隆过滤器的索引里面，且可以肯定是不存在的；<br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jike-5.png"></p><p>对于上图而言c元素肯定不在布隆过滤器的索引里面，但是B的索引对应的二进制位刚好都为1，所以二进制位都为1并不代表就存在；但是二进制有0就一定不存在；</p><p>结论：布隆过滤器是存在于缓存中用来较粗的过滤，布隆过滤器中查不到的元素一定不存在，查的到的元素不一定存在。</p><h2 id="9、位运算"><a href="#9、位运算" class="headerlink" title="9、位运算"></a>9、位运算</h2><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jike-6.png"><br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jike-7.png"></p><table><thead><tr><th>x^0</th><th>x</th></tr></thead><tbody><tr><td>x ^ 1s( 1s表示全1）</td><td>~x</td></tr><tr><td>x^(~x)</td><td>1s</td></tr><tr><td>x ^ x</td><td>0</td></tr><tr><td>c = a ^ b</td><td>a ^ c = b， b ^ c =a</td></tr><tr><td>a ^ b ^ c</td><td>a ^ (b ^ c) = (a ^ b) ^ c</td></tr></tbody></table><p>指定位置的位运算</p><table><thead><tr><th>将x最右边的n位清零</th><th>x&amp;（~0&lt;&lt;n）</th></tr></thead><tbody><tr><td>获取x的第n位的幂值</td><td>x &amp;（1&lt;&lt; (n-1) ）</td></tr><tr><td>获取x的第n位值（0或1）</td><td>（x &gt;&gt; n） &amp; 1</td></tr><tr><td>仅将第n位置为1</td><td>x `</td></tr><tr><td>仅将第n位置为0</td><td>x &amp; (~1 &lt;&lt;n ))</td></tr><tr><td>将x最高位至第n位（含）清零</td><td>x &amp; （（1&lt;&lt;n）-1）</td></tr><tr><td>将第n位至第0位（含）清零</td><td>x &amp;(~（（1&lt;&lt;(n+1）-1）)</td></tr></tbody></table><p>位运算实际应用</p><table><thead><tr><th>判断奇偶</th><th></th></tr></thead><tbody><tr><td>x % 2 ==1</td><td>（x &amp;1）==1</td></tr><tr><td>x %2 ==0</td><td>（x&amp;1） == 0</td></tr><tr><td>x&gt;&gt;1</td><td>x/2</td></tr><tr><td>x = x&amp;(x-1)</td><td>清零最低位的1</td></tr><tr><td>x &amp; -x</td><td>得到最低位的1</td></tr><tr><td>x&amp; ~x</td><td>0</td></tr></tbody></table><h2 id="10、排序算法"><a href="#10、排序算法" class="headerlink" title="10、排序算法"></a>10、排序算法</h2><p>十种常见排序算法可以分为两大类：</p><ul><li>比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li><li>非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。<br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jike-8.png"><br><strong>算法复杂度</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jike-9.png"></p><ul><li>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li><li>不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li><li>时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li><li>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</li></ul><p><strong>①冒泡排序–Bubble Sort</strong></p><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><p><strong>算法描述</strong></p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个； 重复步骤1~3，直到排序完成。</li></ul><p><strong>动图展示</strong><br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jike-10.gif" alt="冒泡排序动图"></p><p><strong>②选择排序（Selection Sort）</strong><br>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><p><strong>算法描述</strong><br>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1…n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1…i-1]和R(i…n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1…i]和R[i+1…n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><p><strong>动图演示</strong><br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jike-11.gif" alt="动图演示"></p><p><strong>算法分析</strong></p><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p><p><strong>③插入排序（Insertion Sort）</strong></p><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。<br><strong>算法描述</strong><br>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><p><strong>动图展示</strong><br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jike-12.gif" alt="在这里插入图片描述"><br><strong>算法分析</strong><br>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><p><strong>④希尔排序（Shell Sort）</strong></p><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p><p><strong>算法描述</strong><br>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">function <span class="hljs-title">shellSort</span><span class="hljs-params">(arr)</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> len = arr.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> gap = Math.floor(len / <span class="hljs-number">2</span>); gap &gt; <span class="hljs-number">0</span>; gap = Math.floor(gap / <span class="hljs-number">2</span>)) &#123;<br>        <span class="hljs-comment">// 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = gap; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">var</span> j = i;<br>            <span class="hljs-keyword">var</span> current = arr[i];<br>            <span class="hljs-keyword">while</span> (j - gap &gt;= <span class="hljs-number">0</span> &amp;&amp; current &lt; arr[j - gap]) &#123;<br>                 arr[j] = arr[j - gap];<br>                 j = j - gap;<br>            &#125;<br>            arr[j] = current;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>动图展示</strong><br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jike-13.gif" alt="在这里插入图片描述"></p><p><strong>算法分析</strong></p><p>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。</p><p><strong>⑤归并排序（Merge Sort）</strong></p><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2路归并</p><p><strong>算法描述</strong></p><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><p><strong>动图展示</strong><br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jike-14.gif" alt="在这里插入图片描述"></p><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">function <span class="hljs-title">mergeSort</span><span class="hljs-params">(arr)</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> len = arr.length;<br>    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <span class="hljs-keyword">var</span> middle = Math.floor(len / <span class="hljs-number">2</span>),<br>        left = arr.slice(<span class="hljs-number">0</span>, middle),<br>        right = arr.slice(middle);<br>    <span class="hljs-keyword">return</span> merge(mergeSort(left), mergeSort(right));<br>&#125;<br> <br><span class="hljs-function">function <span class="hljs-title">merge</span><span class="hljs-params">(left, right)</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> result = [];<br> <br>    <span class="hljs-keyword">while</span> (left.length&gt;<span class="hljs-number">0</span> &amp;&amp; right.length&gt;<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (left[<span class="hljs-number">0</span>] &lt;= right[<span class="hljs-number">0</span>]) &#123;<br>            result.push(left.shift());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            result.push(right.shift());<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">while</span> (left.length)<br>        result.push(left.shift());<br> <br>    <span class="hljs-keyword">while</span> (right.length)<br>        result.push(right.shift());<br> <br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>算法分析</strong><br>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。</p><p><strong>⑥快速排序（Quick Sort）</strong></p><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><p><strong>算法描述：</strong><br>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><p><strong>动图展示</strong><br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jike-15.gif" alt="在这里插入图片描述"><br><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">function <span class="hljs-title">quickSort</span><span class="hljs-params">(arr, left, right)</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> len = arr.length,<br>        partitionIndex,<br>        left = typeof left != <span class="hljs-string">&#x27;number&#x27;</span> ? <span class="hljs-number">0</span> : left,<br>        right = typeof right != <span class="hljs-string">&#x27;number&#x27;</span> ? len - <span class="hljs-number">1</span> : right;<br> <br>    <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>        partitionIndex = partition(arr, left, right);<br>        quickSort(arr, left, partitionIndex-<span class="hljs-number">1</span>);<br>        quickSort(arr, partitionIndex+<span class="hljs-number">1</span>, right);<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br> <br><span class="hljs-function">function <span class="hljs-title">partition</span><span class="hljs-params">(arr, left ,right)</span> </span>&#123;     <span class="hljs-comment">// 分区操作</span><br>    <span class="hljs-keyword">var</span> pivot = left,                      <span class="hljs-comment">// 设定基准值（pivot）</span><br>        index = pivot + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = index; i &lt;= right; i++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;<br>            swap(arr, i, index);<br>            index++;<br>        &#125;       <br>    &#125;<br>    swap(arr, pivot, index - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> index-<span class="hljs-number">1</span>;<br>&#125;<br> <br><span class="hljs-function">function <span class="hljs-title">swap</span><span class="hljs-params">(arr, i, j)</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> temp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>⑦堆排序（Heap Sort）</strong></p><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><p><strong>算法描述</strong></p><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ul><p><strong>动图展示</strong><br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jike-16.gif" alt="在这里插入图片描述"></p><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">var</span> len;    <span class="hljs-comment">// 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量</span><br> <br><span class="hljs-function">function <span class="hljs-title">buildMaxHeap</span><span class="hljs-params">(arr)</span> </span>&#123;   <span class="hljs-comment">// 建立大顶堆</span><br>    len = arr.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = Math.floor(len/<span class="hljs-number">2</span>); i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        heapify(arr, i);<br>    &#125;<br>&#125;<br> <br><span class="hljs-function">function <span class="hljs-title">heapify</span><span class="hljs-params">(arr, i)</span> </span>&#123;     <span class="hljs-comment">// 堆调整</span><br>    <span class="hljs-keyword">var</span> left = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>,<br>        right = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>,<br>        largest = i;<br> <br>    <span class="hljs-keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;<br>        largest = left;<br>    &#125;<br> <br>    <span class="hljs-keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;<br>        largest = right;<br>    &#125;<br> <br>    <span class="hljs-keyword">if</span> (largest != i) &#123;<br>        swap(arr, i, largest);<br>        heapify(arr, largest);<br>    &#125;<br>&#125;<br> <br><span class="hljs-function">function <span class="hljs-title">swap</span><span class="hljs-params">(arr, i, j)</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> temp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br> <br><span class="hljs-function">function <span class="hljs-title">heapSort</span><span class="hljs-params">(arr)</span> </span>&#123;<br>    buildMaxHeap(arr);<br> <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = arr.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        swap(arr, <span class="hljs-number">0</span>, i);<br>        len--;<br>        heapify(arr, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>⑧计数排序（Counting Sort）</strong></p><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p><strong>算法描述</strong></p><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><p><strong>动图展示</strong><br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jike-17.gif" alt="在这里插入图片描述"><br><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">function <span class="hljs-title">countingSort</span><span class="hljs-params">(arr, maxValue)</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> bucket = <span class="hljs-keyword">new</span> Array(maxValue + <span class="hljs-number">1</span>),<br>        sortedIndex = <span class="hljs-number">0</span>;<br>        arrLen = arr.length,<br>        bucketLen = maxValue + <span class="hljs-number">1</span>;<br> <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arrLen; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!bucket[arr[i]]) &#123;<br>            bucket[arr[i]] = <span class="hljs-number">0</span>;<br>        &#125;<br>        bucket[arr[i]]++;<br>    &#125;<br> <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; bucketLen; j++) &#123;<br>        <span class="hljs-keyword">while</span>(bucket[j] &gt; <span class="hljs-number">0</span>) &#123;<br>            arr[sortedIndex++] = j;<br>            bucket[j]--;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>算法分析</strong></p><p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p><p><strong>⑨桶排序（Bucket Sort）</strong></p><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p><p><strong>算法描述</strong></p><ul><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来</li></ul><p><strong>图片展示</strong><br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jike-18.png" alt="桶排序"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">function <span class="hljs-title">bucketSort</span><span class="hljs-params">(arr, bucketSize)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (arr.length === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> arr;<br>    &#125;<br> <br>    <span class="hljs-keyword">var</span> i;<br>    <span class="hljs-keyword">var</span> minValue = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">var</span> maxValue = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>      <span class="hljs-keyword">if</span> (arr[i] &lt; minValue) &#123;<br>          minValue = arr[i];                <span class="hljs-comment">// 输入数据的最小值</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i] &gt; maxValue) &#123;<br>          maxValue = arr[i];                <span class="hljs-comment">// 输入数据的最大值</span><br>      &#125;<br>    &#125;<br> <br>    <span class="hljs-comment">// 桶的初始化</span><br>    <span class="hljs-keyword">var</span> DEFAULT_BUCKET_SIZE = <span class="hljs-number">5</span>;            <span class="hljs-comment">// 设置桶的默认数量为5</span><br>    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;<br>    <span class="hljs-keyword">var</span> bucketCount = Math.floor((maxValue - minValue) / bucketSize) + <span class="hljs-number">1</span>;  <br>    <span class="hljs-keyword">var</span> buckets = <span class="hljs-keyword">new</span> Array(bucketCount);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; buckets.length; i++) &#123;<br>        buckets[i] = [];<br>    &#125;<br> <br>    <span class="hljs-comment">// 利用映射函数将数据分配到各个桶中</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);<br>    &#125;<br> <br>    arr.length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; buckets.length; i++) &#123;<br>        insertionSort(buckets[i]);                      <span class="hljs-comment">// 对每个桶进行排序，这里使用了插入排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; buckets[i].length; j++) &#123;<br>            arr.push(buckets[i][j]);                     <br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>算法分析</strong></p><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p><p><strong>⑩基数排序（Radix Sort）</strong></p><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><p><strong>算法描述</strong></p><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ul><p><strong>动图演示</strong><br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jike-19.gif" alt="在这里插入图片描述"></p><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">var</span> counter = [];<br><span class="hljs-function">function <span class="hljs-title">radixSort</span><span class="hljs-params">(arr, maxDigit)</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> mod = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">var</span> dev = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; maxDigit; i++, dev *= <span class="hljs-number">10</span>, mod *= <span class="hljs-number">10</span>) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; arr.length; j++) &#123;<br>            <span class="hljs-keyword">var</span> bucket = parseInt((arr[j] % mod) / dev);<br>            <span class="hljs-keyword">if</span>(counter[bucket]==<span class="hljs-keyword">null</span>) &#123;<br>                counter[bucket] = [];<br>            &#125;<br>            counter[bucket].push(arr[j]);<br>        &#125;<br>        <span class="hljs-keyword">var</span> pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; counter.length; j++) &#123;<br>            <span class="hljs-keyword">var</span> value = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">if</span>(counter[j]!=<span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">while</span> ((value = counter[j].shift()) != <span class="hljs-keyword">null</span>) &#123;<br>                      arr[pos++] = value;<br>                &#125;<br>          &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>算法分析</strong></p><p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p><p>基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p><h2 id="11、经典题"><a href="#11、经典题" class="headerlink" title="11、经典题"></a>11、经典题</h2><p>爬楼梯、硬币兑换<br>括号匹配、括号生成、直方图最大面积、滑动窗口<br>二叉树遍历、分层输出树、判断二叉排序树<br>股票买卖系列、偷房子、字符串编辑距离、最长上升子序列、最长公共子序列<br>异位词（判断和归类）、回文串（最大回文串）、regex和通配符匹配<br>高级数据结构（Trie、BloomFilter、LRU catch 、etc）</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法篇-银行家算法</title>
    <link href="/2020/12/20/algorithm/%E7%AE%97%E6%B3%95%E7%AF%87-%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/"/>
    <url>/2020/12/20/algorithm/%E7%AE%97%E6%B3%95%E7%AF%87-%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h1><blockquote><p>银行家算法（Banker’s Algorithm）是一个避免死锁（Deadlock）的著名算法，是由艾兹格·迪杰斯特拉在1965年为T.H.E系统设计的一种避免死锁产生的算法。它以银行借贷系统的分配策略为基础，判断并保证系统的安全运行。</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，<br>客户应及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。在这样的描述中，银行家就好<br>比操作系统，资金就是资源，客户就相当于要申请资源的进程。<br><br>银行家算法是一种最有代表性的避免死锁的算法。在避免死锁方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算<br>此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。为实现银行家算法，系统必须设置若干数据结构。<br>要解释银行家算法，必须先解释操作系统安全状态和不安全状态。<br>安全序列是指一个进程序列&#123;P1，…，Pn&#125;是安全的，即对于每一个进程Pi(1≤i≤n），它以后尚需要的资源量不超过系统当前剩余资源<br>量与所有进程Pj (j &lt; i )当前占有资源量之和。<br></code></pre></td></tr></table></figure><ul><li><p>安全状态</p><blockquote><p>如果存在一个由系统中所有进程构成的安全序列P1，…，Pn，则系统处于安全状态。安全状态一定是没有死锁发生。</p></blockquote></li><li><p>不安全状态</p><blockquote><p>不存在一个安全序列。不安全状态不一定导致死锁。</p></blockquote></li></ul><h1 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h1><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p><h1 id="死锁条件"><a href="#死锁条件" class="headerlink" title="死锁条件"></a>死锁条件</h1><p>1、<code>互斥</code>：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。<br>2、<code>占有且等待</code>：一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源。<br>3、<code>不可抢占</code>：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。<br>4、<code>循环等待</code>：存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源。</p><h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><p>我们可以把操作系统看作是银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。<br>为保证资金的安全，银行家规定：<br>(1) 当一个顾客对资金的最大需求量不超过银行家现有的资金时就可接纳该顾客；<br>(2) 顾客可以分期贷款，但贷款的总数不能超过最大需求量；<br>(3) 当银行家现有的资金不能满足顾客尚需的贷款数额时，对顾客的贷款可推迟支付，但总能使顾客在有限的时间里得到贷款；<br>(4) 当顾客得到所需的全部资金后，一定能在有限的时间里归还所有的资金.<br>操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。当进程在执行中继续申请资源时，先测试该进程本次申请的资源数是否超过了该资源所剩余的总量。若超过则拒绝分配资源，若能满足则按当前的申请量分配资源，否则也要推迟分配。</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>由用户输入数据，分别对可利用资源向量[矩阵]AVAILABLE、最大需求矩阵MAX、分配矩阵ALLOCATION、需求矩阵NEED赋值。</p><h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p>在避免[死锁]的方法中，所施加的限制条件较弱，有可能获得令人满意的系统性能。在该方法中把系统的状态分为安全状态和不安全状态，只要能使系统始终都处于安全状态，便可以避免发生<a href="">死锁</a>。</p><p>银行家算法的基本思想是分配资源之前，判断系统是否是安全的；若是，才分配。它是最具有代表性的避免[死锁]的算法。</p><p>设进程cusneed提出请求REQUEST [i]，则银行家算法按如下规则进行判断。</p><ul><li><p>(1)如果REQUEST [cusneed] [i]&lt;= NEED[cusneed][i]，则转(2)；否则，出错。</p></li><li><p>(2)如果REQUEST [cusneed] [i]&lt;= AVAILABLE[i]，则转(3)；否则，等待。</p></li><li><p>(3)系统试探分配资源，修改相关数据：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">AVAILABLE[i]-=REQUEST[cusneed][i];<br><br>ALLOCATION[cusneed][i]+=REQUEST[cusneed][i];<br><br>NEED[cusneed][i]-=REQUEST[cusneed][i];<br></code></pre></td></tr></table></figure></li><li><p>(4)系统执行安全性检查，如安全，则分配成立；否则试探险性分配作废，系统恢复原状，进程等待。</p></li></ul><h3 id="安全性检查算法"><a href="#安全性检查算法" class="headerlink" title="安全性检查算法"></a>安全性检查算法</h3><p>(1)设置两个工作向量Work=AVAILABLE;FINISH</p><p>(2)从进程集合中找到一个满足下述条件的进程，</p><p>FINISH==false;</p><p>NEED&lt;=Work;</p><p>如找到，执行（3)；否则，执行（4)</p><p>(3)设进程获得资源，可顺利执行，直至完成，从而释放资源。</p><p>Work=Work+ALLOCATION;</p><p>Finish=true;</p><p>GOTO 2</p><p>(4)如所有的进程Finish= true，则表示安全；否则系统不安全。</p><p>银行家算法流程图</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/yhjsf-1.jpeg"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/c7658a81fb21">银行家算法</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>银行家算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法篇-极客大学算法</title>
    <link href="/2020/12/18/algorithm/%E7%AE%97%E6%B3%95%E7%AF%87-%E6%9E%81%E5%AE%A2%E5%A4%A7%E5%AD%A6%E7%AE%97%E6%B3%95/"/>
    <url>/2020/12/18/algorithm/%E7%AE%97%E6%B3%95%E7%AF%87-%E6%9E%81%E5%AE%A2%E5%A4%A7%E5%AD%A6%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="第01课丨数据结构与算法总览"><a href="#第01课丨数据结构与算法总览" class="headerlink" title="第01课丨数据结构与算法总览"></a>第01课丨数据结构与算法总览</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/datasturts.png" alt="数据结构脑图"></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/suanfanaotu.png" alt="算法脑图"></p><h2 id="切题四件套"><a href="#切题四件套" class="headerlink" title="切题四件套"></a>切题四件套</h2><ul><li>Clarification(清晰题目)</li><li>Possible solutions(解决方法)<ul><li>compare(time/space)(比较时间和空间)</li><li>optimal(加强)</li></ul></li><li>Coding(多写)</li><li>Test cases(测试样例)</li></ul><blockquote><p>用脑图的方式把知识的脉络串联起来，不管对于学习新知识还是巩固已有知识，都是一种很好的学习方式。同学们可以将目前自己所掌握的数据结构和算法知识绘制成脑图，在绘制过程中可以查阅资料，补充目前掌握欠缺的部分，找到自己薄弱的地方。后面再通过课程的学习和刻意练习，动态地将自己绘制的脑图逐步补充、完善，从而达到真正的融会贯通。</p></blockquote><h1 id="第02课丨训练准备和复杂度分析"><a href="#第02课丨训练准备和复杂度分析" class="headerlink" title="第02课丨训练准备和复杂度分析"></a>第02课丨训练准备和复杂度分析</h1><ul><li><p><a href="http://www.zhihu.com/question/21387264">如何理解算法时间复杂度的表示法</a></p></li><li><p><a href="http://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)">Master theorem</a></p></li><li><p><a href="http://zh.wikipedia.org/wiki/%E4%B8%BB%E5%AE%9A%E7%90%86">主定理</a></p></li></ul><h1 id="第03课丨数组、链表、跳表"><a href="#第03课丨数组、链表、跳表" class="headerlink" title="第03课丨数组、链表、跳表"></a>第03课丨数组、链表、跳表</h1><p>· <a href="http://developer.classpath.org/doc/java/util/ArrayList-source.html">Java 源码分析（ArrayList）</a></p><p>· <a href="http://www.geeksforgeeks.org/implementing-a-linked-list-in-java-using-class/">Linked List 的标准实现代码</a></p><p>· [Linked List 示例代码](<a href="http://www.cs.cmu.edu/~adamchik/15-121/lectures/Linked">http://www.cs.cmu.edu/~adamchik/15-121/lectures/Linked</a> Lists/code/LinkedList.java)</p><p>· <a href="http://developer.classpath.org/doc/java/util/LinkedList-source.html">Java 源码分析（LinkedList）</a></p><p>· LRU Cache - Linked list：<a href="http://leetcode-cn.com/problems/lru-cache"> LRU 缓存机制</a></p><p>· Redis - Skip List：<a href="http://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html">跳跃表</a>、<a href="http://www.zhihu.com/question/20202931">为啥 Redis 使用跳表（Skip List）而不是使用 Red-Black？</a></p><p>两数之和题目：<a href="https://leetcode-cn.com/problems/two-sum/"> https://leetcode-cn.com/problems/two-sum/</a></p><p>Array 实战题目</p><p>· <a href="https://leetcode-cn.com/problems/container-with-most-water/">https://leetcode-cn.com/problems/container-with-most-water/</a></p><p>· <a href="https://leetcode-cn.com/problems/move-zeroes/">https://leetcode-cn.com/problems/move-zeroes/</a></p><p>· <a href="https://leetcode.com/problems/climbing-stairs/">https://leetcode.com/problems/climbing-stairs/</a></p><p>· <a href="https://leetcode-cn.com/problems/3sum/">https://leetcode-cn.com/problems/3sum/ </a>(高频老题）</p><p>Linked List 实战题目</p><p>· <a href="https://leetcode.com/problems/reverse-linked-list/">https://leetcode.com/problems/reverse-linked-list/</a></p><p>· <a href="https://leetcode.com/problems/swap-nodes-in-pairs">https://leetcode.com/problems/swap-nodes-in-pairs</a></p><p>· <a href="https://leetcode.com/problems/linked-list-cycle">https://leetcode.com/problems/linked-list-cycle</a></p><p>· <a href="https://leetcode.com/problems/linked-list-cycle-ii">https://leetcode.com/problems/linked-list-cycle-ii</a></p><p>· <a href="https://leetcode.com/problems/reverse-nodes-in-k-group/">https://leetcode.com/problems/reverse-nodes-in-k-group/</a></p><p>课后作业</p><p>· <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/</a></p><p>· <a href="https://leetcode-cn.com/problems/rotate-array/">https://leetcode-cn.com/problems/rotate-array/</a></p><p>· <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></p><p>· <a href="https://leetcode-cn.com/problems/merge-sorted-array/">https://leetcode-cn.com/problems/merge-sorted-array/</a></p><p>· <a href="https://leetcode-cn.com/problems/two-sum/">https://leetcode-cn.com/problems/two-sum/</a></p><p>· <a href="https://leetcode-cn.com/problems/move-zeroes/">https://leetcode-cn.com/problems/move-zeroes/</a></p><p>· <a href="https://leetcode-cn.com/problems/plus-one/">https://leetcode-cn.com/problems/plus-one/</a></p><h1 id="第04课丨栈、队列、优先队列、双端队列"><a href="#第04课丨栈、队列、优先队列、双端队列" class="headerlink" title="第04课丨栈、队列、优先队列、双端队列"></a>第04课丨栈、队列、优先队列、双端队列</h1><p>参考链接</p><p>· <a href="http://docs.oracle.com/javase/10/docs/api/java/util/PriorityQueue.html">Java 的 PriorityQueue 文档</a><br>· <a href="http://developer.classpath.org/doc/java/util/Stack-source.html">Java 的 Stack 源码</a><br>· <a href="http://fuseyism.com/classpath/doc/java/util/Queue-source.html">Java 的 Queue 源码</a><br>· <a href="http://docs.python.org/2/library/heapq.html">Python 的 heapq</a><br>· <a href="http://docs.python.org/2/library/collections.html">高性能的 container 库</a></p><p>Array 实战题目<br> <a href="https://leetcode-cn.com/problems/container-with-most-water/">https://leetcode-cn.com/problems/container-with-most-water/</a><br> <a href="https://leetcode-cn.com/problems/move-zeroes/">https://leetcode-cn.com/problems/move-zeroes/</a><br> <a href="https://leetcode.com/problems/climbing-stairs/">https://leetcode.com/problems/climbing-stairs/</a><br> <a href="https://leetcode-cn.com/problems/3sum/">https://leetcode-cn.com/problems/3sum/</a></p><p>Linked List 实战题目<br> <a href="https://leetcode.com/problems/reverse-linked-list/">https://leetcode.com/problems/reverse-linked-list/</a><br> <a href="https://leetcode.com/problems/swap-nodes-in-pairs">https://leetcode.com/problems/swap-nodes-in-pairs</a><br> <a href="https://leetcode.com/problems/linked-list-cycle">https://leetcode.com/problems/linked-list-cycle</a><br> <a href="https://leetcode.com/problems/linked-list-cycle-ii">https://leetcode.com/problems/linked-list-cycle-ii</a><br> <a href="https://leetcode.com/problems/reverse-nodes-in-k-group/">https://leetcode.com/problems/reverse-nodes-in-k-group/</a></p><p>课后作业<br> <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/</a><br> <a href="https://leetcode-cn.com/problems/rotate-array/">https://leetcode-cn.com/problems/rotate-array/</a><br> <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a><br> <a href="https://leetcode-cn.com/problems/merge-sorted-array/">https://leetcode-cn.com/problems/merge-sorted-array/</a><br> <a href="https://leetcode-cn.com/problems/two-sum/">https://leetcode-cn.com/problems/two-sum/</a><br> <a href="https://leetcode-cn.com/problems/move-zeroes/">https://leetcode-cn.com/problems/move-zeroes/</a><br> <a href="https://leetcode-cn.com/problems/plus-one/">https://leetcode-cn.com/problems/plus-one/</a></p><h1 id="第05课丨哈希表、映射、集合"><a href="#第05课丨哈希表、映射、集合" class="headerlink" title="第05课丨哈希表、映射、集合"></a>第05课丨哈希表、映射、集合</h1><p> Java Set 文档<br> Java Map 文档</p><p>预习题目<br> <a href="https://leetcode-cn.com/problems/valid-parentheses/">https://leetcode-cn.com/problems/valid-parentheses/</a><br> <a href="https://leetcode-cn.com/problems/min-stack/">https://leetcode-cn.com/problems/min-stack/</a></p><p>实战题目<br> <a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram">https://leetcode-cn.com/problems/largest-rectangle-in-histogram</a><br> <a href="https://leetcode-cn.com/problems/sliding-window-maximum">https://leetcode-cn.com/problems/sliding-window-maximum</a></p><p>课后作业<br>用 add first 或 add last 这套新的 API 改写 Deque 的代码<br>分析 Queue 和 Priority Queue 的源码<br><a href="https://leetcode.com/problems/design-circular-deque">https://leetcode.com/problems/design-circular-deque</a><br><a href="https://leetcode.com/problems/trapping-rain-water/">https://leetcode.com/problems/trapping-rain-water/</a></p><h1 id="第06课丨树、二叉树、二叉搜索树"><a href="#第06课丨树、二叉树、二叉搜索树" class="headerlink" title="第06课丨树、二叉树、二叉搜索树"></a>第06课丨树、二叉树、二叉搜索树</h1><p>参考链接</p><p>· <a href="https://visualgo.net/zh/bst">树的遍历 Demo</a></p><p>实战题目</p><p>· <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/</a><br>· <a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">https://leetcode-cn.com/problems/binary-tree-preorder-traversal/</a><br>· <a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/</a><br>· <a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/description">https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/</a><br>· <a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/">https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/</a></p><h1 id="第07课丨泛型递归、树的递归"><a href="#第07课丨泛型递归、树的递归" class="headerlink" title="第07课丨泛型递归、树的递归"></a>第07课丨泛型递归、树的递归</h1><p>参考链接</p><p>· <a href="http://shimo.im/docs/DjqqGCT3xqDYwPyY">递归代码模板</a></p><p>实战题目</p><p>· <a href="https://leetcode-cn.com/problems/climbing-stairs/">https://leetcode-cn.com/problems/climbing-stairs/</a></p><p>· <a href="https://leetcode-cn.com/problems/generate-parentheses/">https://leetcode-cn.com/problems/generate-parentheses/</a></p><p>· <a href="https://leetcode-cn.com/problems/invert-binary-tree/description/">https://leetcode-cn.com/problems/invert-binary-tree/description/</a></p><p>· <a href="https://leetcode-cn.com/problems/validate-binary-search-tree">https://leetcode-cn.com/problems/validate-binary-search-tree</a></p><p>· <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree</a></p><p>· <a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree</a></p><p>· <a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/</a></p><p>每日一课</p><p>· <a href="https://time.geekbang.org/dailylesson/detail/100028406">如何优雅地计算斐波那契数列</a></p><p>课后作业</p><p>· <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p><p>· <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal</a></p><p>· <a href="https://leetcode-cn.com/problems/combinations/">https://leetcode-cn.com/problems/combinations/</a></p><p>· <a href="https://leetcode-cn.com/problems/permutations/">https://leetcode-cn.com/problems/permutations/</a></p><p>· <a href="https://leetcode-cn.com/problems/permutations-ii/">https://leetcode-cn.com/problems/permutations-ii/</a></p><h1 id="第08课丨分治、回溯"><a href="#第08课丨分治、回溯" class="headerlink" title="第08课丨分治、回溯"></a>第08课丨分治、回溯</h1><p>预习题目</p><p>· <a href="https://leetcode-cn.com/problems/powx-n">Pow(x, n)</a> </p><p>· <a href="https://leetcode-cn.com/problems/subsets/">https://leetcode-cn.com/problems/subsets/</a></p><p>参考链接</p><p>· <a href="https://shimo.im/docs/3xvghYh3JJPKwdvt">分治代码模板</a><br>· <a href="https://leetcode-cn.com/problems/generate-parentheses/">括号生成问题</a><br>· <a href="http://www.matrix67.com/blog/archives/361">牛顿迭代法原理</a><br>· <a href="http://www.voidcn.com/article/p-eudisdmk-zm.html">牛顿迭代法代码</a></p><p>实战题目</p><p>· <a href="https://leetcode-cn.com/problems/majority-element/description/">多数元素</a>（简单、但是高频）</p><p>· <a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/</a></p><p>· <a href="https://leetcode-cn.com/problems/n-queens/">https://leetcode-cn.com/problems/n-queens/</a></p><h1 id="第09课丨深度优先搜索和广度优先搜索"><a href="#第09课丨深度优先搜索和广度优先搜索" class="headerlink" title="第09课丨深度优先搜索和广度优先搜索"></a>第09课丨深度优先搜索和广度优先搜索</h1><p>· <a href="http://shimo.im/docs/ddgwCccJQKxkrcTq">DFS 代码模板（递归写法、非递归写法）</a></p><p>· <a href="http://shimo.im/docs/P8TqKHGKt3ytkYYd">BFS 代码模板</a></p><p>实战题目</p><p>· <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/#/description">柠檬水找零</a></p><p>· <a href="https://leetcode-cn.com/problems/minimum-genetic-mutation/#/description">https://leetcode-cn.com/problems/minimum-genetic-mutation/#/description</a></p><p>· <a href="https://leetcode-cn.com/problems/generate-parentheses/#/description">https://leetcode-cn.com/problems/generate-parentheses/#/description</a></p><p>· <a href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/#/description">https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/#/description</a></p><p>课后作业</p><p>· <a href="https://leetcode-cn.com/problems/word-ladder/description/">https://leetcode-cn.com/problems/word-ladder/description/</a></p><p>· <a href="https://leetcode-cn.com/problems/word-ladder-ii/description/">https://leetcode-cn.com/problems/word-ladder-ii/description/</a></p><p>· <a href="https://leetcode-cn.com/problems/number-of-islands/">https://leetcode-cn.com/problems/number-of-islands/</a></p><p>· <a href="https://leetcode-cn.com/problems/minesweeper/description/">https://leetcode-cn.com/problems/minesweeper/description/</a></p><h1 id="第10课丨贪心算法"><a href="#第10课丨贪心算法" class="headerlink" title="第10课丨贪心算法"></a>第10课丨贪心算法</h1><p>参考链接</p><p>· <a href="https://leetcode-cn.com/problems/coin-change/">coin change 题目</a></p><p>· <a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划定义</a></p><p>课后作业</p><p>· <a href="https://leetcode-cn.com/problems/lemonade-change/description/">https://leetcode-cn.com/problems/lemonade-change/description/</a></p><p>· <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/description/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/description/</a></p><p>· <a href="https://leetcode-cn.com/problems/assign-cookies/description/">https://leetcode-cn.com/problems/assign-cookies/description/</a></p><p>· <a href="https://leetcode-cn.com/problems/walking-robot-simulation/description/">https://leetcode-cn.com/problems/walking-robot-simulation/description/</a></p><p>· <a href="https://leetcode-cn.com/problems/jump-game/">https://leetcode-cn.com/problems/jump-game/</a>、</p><p>· <a href="https://leetcode-cn.com/problems/jump-game-ii/">https://leetcode-cn.com/problems/jump-game-ii/</a></p><h1 id="第11课丨二分查找"><a href="#第11课丨二分查找" class="headerlink" title="第11课丨二分查找"></a>第11课丨二分查找</h1><p>参考链接</p><p>· <a href="https://shimo.im/docs/hjQqRQkGgwd9g36J">二分查找代码模板</a></p><p>· <a href="https://www.beyond3d.com/content/articles/8/">Fast InvSqrt() 扩展阅读</a></p><p>实战题目</p><p>· <a href="https://leetcode-cn.com/problems/sqrtx/">https://leetcode-cn.com/problems/sqrtx/</a></p><p>· <a href="https://leetcode-cn.com/problems/valid-perfect-square/">https://leetcode-cn.com/problems/valid-perfect-square/</a></p><p>课后作业</p><p>· <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">https://leetcode-cn.com/problems/search-in-rotated-sorted-array/</a></p><p>· <a href="https://leetcode-cn.com/problems/search-a-2d-matrix/">https://leetcode-cn.com/problems/search-a-2d-matrix/</a></p><p>· <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/</a></p><p>· 使用二分查找，寻找一个半有序数组 [4, 5, 6, 7, 0, 1, 2] 中间无序的地方</p><h1 id="第12课丨动态规划"><a href="#第12课丨动态规划" class="headerlink" title="第12课丨动态规划"></a>第12课丨动态规划</h1><p>参考链接</p><p>· <a href="http://shimo.im/docs/DjqqGCT3xqDYwPyY/">递归代码模板</a></p><p>· <a href="http://shimo.im/docs/3xvghYh3JJPKwdvt/">分治代码模板</a></p><p>· <a href="https://en.wikipedia.org/wiki/Dynamic_programming">动态规划定义</a></p><p>参考链接</p><p>· <a href="https://leetcode-cn.com/problems/unique-paths/">不同路径题目</a></p><p>· <a href="https://leetcode-cn.com/problems/unique-paths-ii/">不同路径 2 题目</a></p><p>· <a href="https://leetcode-cn.com/problems/longest-common-subsequence/">最长公共子序列题目</a></p><p>· <a href="https://www.bilibili.com/video/av53233912?from=search&seid=2847395688604491997">MIT 动态规划课程最短路径算法</a></p><p>实战题目</p><p>· <a href="https://leetcode-cn.com/problems/climbing-stairs/description/">https://leetcode-cn.com/problems/climbing-stairs/description/</a></p><p>· <a href="https://leetcode-cn.com/problems/triangle/description/">https://leetcode-cn.com/problems/triangle/description/</a></p><p>· <a href="https://leetcode.com/problems/triangle/discuss/38735/Python-easy-to-understand-solutions-(top-down-bottom-up)">https://leetcode.com/problems/triangle/discuss/38735/Python-easy-to-understand-solutions-(top-down-bottom-up)</a></p><p>· <a href="https://leetcode-cn.com/problems/maximum-subarray/">https://leetcode-cn.com/problems/maximum-subarray/</a></p><p>· <a href="https://leetcode-cn.com/problems/maximum-product-subarray/description/">https://leetcode-cn.com/problems/maximum-product-subarray/description/</a></p><p>· <a href="https://leetcode.com/problems/coin-change/description/">https://leetcode-cn.com/problems/coin-change/description/</a></p><p>实战题目</p><p>· <a href="https://leetcode-cn.com/problems/house-robber/">https://leetcode-cn.com/problems/house-robber/</a></p><p>· <a href="https://leetcode-cn.com/problems/house-robber-ii/description/">https://leetcode-cn.com/problems/house-robber-ii/description/</a></p><p>· <a href="#/description">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/#/description</a></p><p>· <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p><p>· <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/</a></p><p>· <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></p><p>· <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/</a></p><p>· <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/</a></p><p>· <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/</a></p><p>高级 DP 实战题目</p><p>· <a href="https://leetcode-cn.com/problems/perfect-squares/">https://leetcode-cn.com/problems/perfect-squares/</a></p><p>· <a href="https://leetcode-cn.com/problems/edit-distance/">https://leetcode-cn.com/problems/edit-distance/</a>（重点）</p><p>· <a href="https://leetcode-cn.com/problems/jump-game/">https://leetcode-cn.com/problems/jump-game/</a></p><p>· <a href="https://leetcode-cn.com/problems/jump-game-ii/">https://leetcode-cn.com/problems/jump-game-ii/</a></p><p>· <a href="https://leetcode-cn.com/problems/unique-paths/">https://leetcode-cn.com/problems/unique-paths/</a></p><p>· <a href="https://leetcode-cn.com/problems/unique-paths-ii/">https://leetcode-cn.com/problems/unique-paths-ii/</a></p><p>· <a href="https://leetcode-cn.com/problems/unique-paths-iii/">https://leetcode-cn.com/problems/unique-paths-iii/</a></p><p>· <a href="https://leetcode-cn.com/problems/coin-change/">https://leetcode-cn.com/problems/coin-change/</a></p><p>· <a href="https://leetcode-cn.com/problems/coin-change-2/">https://leetcode-cn.com/problems/coin-change-2/</a></p><p>课后作业</p><p>· <a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">https://leetcode-cn.com/problems/longest-valid-parentheses/</a></p><p>· <a href="https://leetcode-cn.com/problems/minimum-path-sum/">https://leetcode-cn.com/problems/minimum-path-sum/</a></p><p>· <a href="https://leetcode-cn.com/problems/edit-distance/">https://leetcode-cn.com/problems/edit-distance/</a></p><p>· <a href="https://leetcode-cn.com/problems/decode-ways">https://leetcode-cn.com/problems/decode-ways</a></p><p>· <a href="https://leetcode-cn.com/problems/maximal-square/">https://leetcode-cn.com/problems/maximal-square/</a></p><p>· <a href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/">https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/</a></p><p>· <a href="https://leetcode-cn.com/problems/frog-jump/">https://leetcode-cn.com/problems/frog-jump/</a></p><p>· <a href="https://leetcode-cn.com/problems/split-array-largest-sum">https://leetcode-cn.com/problems/split-array-largest-sum</a></p><p>· <a href="https://leetcode-cn.com/problems/student-attendance-record-ii/">https://leetcode-cn.com/problems/student-attendance-record-ii/</a></p><p>· <a href="https://leetcode-cn.com/problems/task-scheduler/">https://leetcode-cn.com/problems/task-scheduler/</a></p><p>· <a href="https://leetcode-cn.com/problems/palindromic-substrings/">https://leetcode-cn.com/problems/palindromic-substrings/</a></p><p>· <a href="https://leetcode-cn.com/problems/minimum-window-substring/">https://leetcode-cn.com/problems/minimum-window-substring/</a></p><p>· <a href="https://leetcode-cn.com/problems/burst-balloons/">https://leetcode-cn.com/problems/burst-balloons/</a></p><h1 id="第13课丨字典树和并查集"><a href="#第13课丨字典树和并查集" class="headerlink" title="第13课丨字典树和并查集"></a>第13课丨字典树和并查集</h1><p>参考链接</p><p>· <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">二叉树的层次遍历</a></p><p>· <a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/">实现 Trie</a></p><p>· <a href="https://shimo.im/docs/Pk6vPY3HJ9hKkh33">Tire 树代码模板</a></p><p>实战题目 / 课后作业</p><p>· <a href="https://leetcode-cn.com/problems/word-search-ii/">单词搜索 II</a></p><p>· <a href="https://leetcode-cn.com/problems/number-of-islands/">岛屿数量</a></p><p>· <a href="https://shimo.im/docs/ydPCH33xDhK9YwWR">并查集代码模板</a></p><p>实战题目 / 课后作业</p><p>· <a href="https://leetcode-cn.com/problems/friend-circles">https://leetcode-cn.com/problems/friend-circles</a></p><p>· <a href="https://leetcode-cn.com/problems/number-of-islands/">https://leetcode-cn.com/problems/number-of-islands/</a></p><p>· <a href="https://leetcode-cn.com/problems/surrounded-regions/">https://leetcode-cn.com/problems/surrounded-regions/</a></p><h1 id="第14课丨高级搜索"><a href="#第14课丨高级搜索" class="headerlink" title="第14课丨高级搜索"></a>第14课丨高级搜索</h1><p>参考链接</p><p>· <a href="http://shimo.im/docs/ddgwCccJQKxkrcTq/">DFS 代码模板</a></p><p>· <a href="http://shimo.im/docs/P8TqKHGKt3ytkYYd/">BFS 代码模板</a></p><p>· <a href="https://nikcheerla.github.io/deeplearningschool/2018/01/01/AlphaZero-Explained/">AlphaZero Explained</a></p><p>· <a href="https://en.wikipedia.org/wiki/Game_complexity">棋类复杂度</a></p><p>实战题目</p><p>· <a href="https://leetcode-cn.com/problems/climbing-stairs/">https://leetcode-cn.com/problems/climbing-stairs/</a></p><p>· <a href="https://leetcode-cn.com/problems/generate-parentheses/">https://leetcode-cn.com/problems/generate-parentheses/</a></p><p>· <a href="https://leetcode-cn.com/problems/n-queens/">https://leetcode-cn.com/problems/n-queens</a></p><p>· <a href="https://leetcode-cn.com/problems/valid-sudoku/description/">https://leetcode-cn.com/problems/valid-sudoku/description/</a></p><p>· <a href="#/description">https://leetcode-cn.com/problems/sudoku-solver/#/description</a></p><p>实战题目</p><p>· <a href="https://leetcode-cn.com/problems/word-ladder/">https://leetcode-cn.com/problems/word-ladder/</a></p><p>· <a href="https://leetcode-cn.com/problems/minimum-genetic-mutation/">https://leetcode-cn.com/problems/minimum-genetic-mutation/</a></p><p>课后作业</p><p>· 总结双向 BFS 代码模版，请同学们提交在第 6 周学习总结中。</p><p>参考链接</p><p>· <a href="https://shimo.im/docs/CXvjHyWhpQcxXjcw/">A* 代码模板</a></p><p>· <a href="https://dataaspirant.com/2015/04/11/five-most-popular-similarity-measures-implementation-in-python/">相似度测量方法</a></p><p>· <a href="https://leetcode.com/problems/shortest-path-in-binary-matrix/discuss/313347/A*-search-in-Python">二进制矩阵中的最短路径的 A* 解法</a></p><p>· <a href="https://zxi.mytechroad.com/blog/searching/8-puzzles-bidirectional-astar-vs-bidirectional-bfs/">8 puzzles 解法比较</a></p><p>实战题目</p><p>· <a href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/">https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/</a></p><p>· <a href="https://leetcode-cn.com/problems/sliding-puzzle/">https://leetcode-cn.com/problems/sliding-puzzle/</a></p><p>· <a href="https://leetcode-cn.com/problems/sudoku-solver/">https://leetcode-cn.com/problems/sudoku-solver/</a></p><h1 id="第15课丨红黑树和AVL树"><a href="#第15课丨红黑树和AVL树" class="headerlink" title="第15课丨红黑树和AVL树"></a>第15课丨红黑树和AVL树</h1><p>· <a href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree">平衡树</a></p><h1 id="第16课丨位运算"><a href="#第16课丨位运算" class="headerlink" title="第16课丨位运算"></a>第16课丨位运算</h1><p>· <a href="https://zh.wikihow.com/%E4%BB%8E%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E8%BF%9B%E5%88%B6">如何从十进制转换为二进制</a></p><p>· <a href="https://shimo.im/docs/rHTyt8hcpT6D9Tj8/">N 皇后位运算代码示例</a></p><p>实战题目</p><p>· <a href="https://leetcode-cn.com/problems/number-of-1-bits/">https://leetcode-cn.com/problems/number-of-1-bits/</a></p><p>· <a href="https://leetcode-cn.com/problems/power-of-two/">https://leetcode-cn.com/problems/power-of-two/</a></p><p>· <a href="https://leetcode-cn.com/problems/reverse-bits/">https://leetcode-cn.com/problems/reverse-bits/</a></p><p>· <a href="https://leetcode-cn.com/problems/n-queens/description/">https://leetcode-cn.com/problems/n-queens/description/</a></p><p>· <a href="https://leetcode-cn.com/problems/n-queens-ii/description/">https://leetcode-cn.com/problems/n-queens-ii/description/</a></p><p>· <a href="https://leetcode-cn.com/problems/counting-bits/description/">https://leetcode-cn.com/problems/counting-bits/description/</a></p><h1 id="第17课丨布隆过滤器和LRU缓存"><a href="#第17课丨布隆过滤器和LRU缓存" class="headerlink" title="第17课丨布隆过滤器和LRU缓存"></a>第17课丨布隆过滤器和LRU缓存</h1><p>参考链接</p><p>· <a href="https://www.cnblogs.com/cpselvis/p/6265825.html">布隆过滤器的原理和实现</a></p><p>· <a href="https://blog.csdn.net/tianyaleixiaowu/article/details/74721877">使用布隆过滤器解决缓存击穿、垃圾邮件识别、集合判重</a></p><p>· <a href="https://shimo.im/docs/xKwrcwrDxRv3QpKG/">布隆过滤器 Python 代码示例</a></p><p>· <a href="https://www.geeksforgeeks.org/bloom-filters-introduction-and-python-implementation/">布隆过滤器 Python 实现示例</a></p><p>· <a href="https://github.com/jhgg/pybloof">高性能布隆过滤器 Python 实现示例</a></p><p>· <a href="https://github.com/lovasoa/bloomfilter/blob/master/src/main/java/BloomFilter.java">布隆过滤器 Java 实现示例 1</a></p><p>· <a href="https://github.com/Baqend/Orestes-Bloomfilter">布隆过滤器 Java 实现示例 2</a></p><p>参考链接</p><p>· <a href="https://www.sqlpassion.at/archive/2018/01/06/understanding-the-meltdown-exploit-in-my-own-simple-words/">Understanding the Meltdown exploit</a></p><p>· <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies">替换算法总揽</a></p><p>· <a href="https://shimo.im/docs/tTxRkGwJpXG6WkGY/">LRU Cache Python 代码示例</a></p><p>实战题目 / 课后作业</p><p>· <a href="#/">https://leetcode-cn.com/problems/lru-cache/#/</a></p><h1 id="第18课丨排序算法"><a href="#第18课丨排序算法" class="headerlink" title="第18课丨排序算法"></a>第18课丨排序算法</h1><p>参考链接</p><p>· <a href="https://www.cnblogs.com/onepixel/p/7674659.html">十大经典排序算法</a></p><p>· <a href="https://shimo.im/docs/98KjvGwwGpTpYGKy/">快速排序代码示例</a></p><p>· <a href="https://shimo.im/docs/YqgG6vtdKwkXJkWx/">归并排序代码示例</a></p><p>· <a href="https://shimo.im/docs/6kRVHRphpgjHgCtx/">堆排序代码示例</a></p><p>· 直播课回顾: <a href="https://pan.baidu.com/s/1sFuZ8GjDCXy5mPCNLZhHxw">https://pan.baidu.com/s/1sFuZ8GjDCXy5mPCNLZhHxw </a>提取码: 2rdy</p><p>课后作业</p><p>用自己熟悉的编程语言，手写各种初级排序代码，提交到第 7 周学习总结中。</p><p>参考链接</p><p>· <a href="https://www.cnblogs.com/onepixel/p/7674659.html">十大经典排序算法</a></p><p>· <a href="https://www.bilibili.com/video/av25136272">9 种经典排序算法可视化动画</a></p><p>· <a href="https://www.bilibili.com/video/av63851336">6 分钟看完 15 种排序算法动画展示</a></p><p>实战题目</p><p>· <a href="https://leetcode-cn.com/problems/relative-sort-array/">https://leetcode-cn.com/problems/relative-sort-array/</a></p><p>· <a href="https://leetcode-cn.com/problems/valid-anagram/">https://leetcode-cn.com/problems/valid-anagram/</a></p><p>· <a href="https://leetcode-cn.com/problems/design-a-leaderboard/">https://leetcode-cn.com/problems/design-a-leaderboard/</a></p><p>· <a href="https://leetcode-cn.com/problems/merge-intervals/">https://leetcode-cn.com/problems/merge-intervals/</a></p><p>· <a href="https://leetcode-cn.com/problems/reverse-pairs/">https://leetcode-cn.com/problems/reverse-pairs/</a></p><h1 id="第19课丨高级动态规划"><a href="#第19课丨高级动态规划" class="headerlink" title="第19课丨高级动态规划"></a>第19课丨高级动态规划</h1><p>参考链接</p><p>· <a href="https://leetcode-cn.com/problems/climbing-stairs/">爬楼梯</a></p><p>· <a href="https://leetcode-cn.com/problems/unique-paths/">不同路径</a></p><p>· <a href="https://leetcode-cn.com/problems/house-robber/">打家劫舍</a></p><p>· <a href="https://leetcode-cn.com/problems/minimum-path-sum/">最小路径和</a></p><p>· <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">股票买卖</a></p><p>课后作业</p><p>在第 8 周学习总结中，写出<a href="https://leetcode-cn.com/problems/unique-paths-ii/">不同路径 2</a>这道题目的状态转移方程。</p><p>· <a href="https://leetcode-cn.com/problems/climbing-stairs/">爬楼梯</a></p><p>· <a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">使用最小花费爬楼梯</a></p><p>· <a href="https://leetcode-cn.com/problems/edit-distance/">编辑距离</a></p><p>课后作业</p><p>· <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a></p><p>· <a href="https://leetcode-cn.com/problems/decode-ways/">https://leetcode-cn.com/problems/decode-ways/</a></p><p>· <a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">https://leetcode-cn.com/problems/longest-valid-parentheses/</a></p><p>· <a href="https://leetcode-cn.com/problems/maximal-rectangle/">https://leetcode-cn.com/problems/maximal-rectangle/</a></p><p>· <a href="https://leetcode-cn.com/problems/distinct-subsequences/">https://leetcode-cn.com/problems/distinct-subsequences/</a></p><p>· <a href="https://leetcode-cn.com/problems/race-car/">https://leetcode-cn.com/problems/race-car/</a></p><h1 id="第20课丨字符串算法"><a href="#第20课丨字符串算法" class="headerlink" title="第20课丨字符串算法"></a>第20课丨字符串算法</h1><p>参考链接</p><p>· <a href="https://lemire.me/blog/2017/07/07/are-your-strings-immutable/">不可变字符串</a></p><p>· <a href="https://shimo.im/docs/KkDKkpWxjjrJXdpY/">Atoi 代码示例</a></p><p>字符串基础问题</p><p>· <a href="https://leetcode-cn.com/problems/to-lower-case/">https://leetcode-cn.com/problems/to-lower-case/</a></p><p>· <a href="https://leetcode-cn.com/problems/length-of-last-word/">https://leetcode-cn.com/problems/length-of-last-word/</a></p><p>· <a href="https://leetcode-cn.com/problems/jewels-and-stones/">https://leetcode-cn.com/problems/jewels-and-stones/</a></p><p>· <a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/">https://leetcode-cn.com/problems/first-unique-character-in-a-string/</a></p><p>· <a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">https://leetcode-cn.com/problems/string-to-integer-atoi/</a></p><p>字符串操作问题</p><p>· <a href="https://leetcode-cn.com/problems/longest-common-prefix/description/">https://leetcode-cn.com/problems/longest-common-prefix/description/</a></p><p>· <a href="https://leetcode-cn.com/problems/reverse-string">https://leetcode-cn.com/problems/reverse-string</a></p><p>· <a href="https://leetcode-cn.com/problems/reverse-string-ii/">https://leetcode-cn.com/problems/reverse-string-ii/</a></p><p>· <a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">https://leetcode-cn.com/problems/reverse-words-in-a-string/</a></p><p>· <a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/</a></p><p>· <a href="https://leetcode-cn.com/problems/reverse-only-letters/">https://leetcode-cn.com/problems/reverse-only-letters/</a></p><p>异位词问题</p><p>· <a href="https://leetcode-cn.com/problems/valid-anagram/">https://leetcode-cn.com/problems/valid-anagram/</a></p><p>· <a href="https://leetcode-cn.com/problems/group-anagrams/">https://leetcode-cn.com/problems/group-anagrams/</a></p><p>· <a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/</a></p><p>回文串问题</p><p>· <a href="https://leetcode-cn.com/problems/valid-palindrome/">https://leetcode-cn.com/problems/valid-palindrome/</a></p><p>· <a href="https://leetcode-cn.com/problems/valid-palindrome-ii/">https://leetcode-cn.com/problems/valid-palindrome-ii/</a></p><p>· <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p><p>最长子串、子序列问题</p><p>· <a href="https://leetcode-cn.com/problems/longest-common-subsequence/">https://leetcode-cn.com/problems/longest-common-subsequence/</a></p><p>· <a href="https://leetcode-cn.com/problems/edit-distance/">https://leetcode-cn.com/problems/edit-distance/</a></p><p>· <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p><p>字符串 +DP 问题</p><p>· <a href="https://leetcode-cn.com/problems/regular-expression-matching/">https://leetcode-cn.com/problems/regular-expression-matching/</a></p><p>· <a href="https://leetcode-cn.com/problems/regular-expression-matching/solution/ji-yu-guan-fang-ti-jie-gen-xiang-xi-de-jiang-jie-b/">https://leetcode-cn.com/problems/regular-expression-matching/solution/ji-yu-guan-fang-ti-jie-gen-xiang-xi-de-jiang-jie-b/</a></p><p>· <a href="https://leetcode-cn.com/problems/wildcard-matching/">https://leetcode-cn.com/problems/wildcard-matching/</a></p><p>· <a href="https://leetcode-cn.com/problems/distinct-subsequences/">https://leetcode-cn.com/problems/distinct-subsequences/</a></p><p>参考链接</p><p>· <a href="http://xn--https-ni33a//www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html">Boyer-Moore 算法</a></p><p>· <a href="https://blog.csdn.net/u012505432/article/details/52210975">Sunday 算法</a></p><p>· <a href="https://shimo.im/docs/dQDxQW8yXPXxh3Hg/">字符串匹配暴力法代码示例</a></p><p>· <a href="https://shimo.im/docs/KXDdkT99TVtXvTXP/">Rabin-Karp 代码示例</a></p><p>· <a href="https://www.bilibili.com/video/av11866460?from=search&seid=17425875345653862171">KMP 字符串匹配算法视频</a></p><p>· <a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">字符串匹配的 KMP 算法</a></p><p>课后作业</p><p>· <a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/">https://leetcode-cn.com/problems/first-unique-character-in-a-string/</a></p><p>· <a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">https://leetcode-cn.com/problems/string-to-integer-atoi/</a></p><p>· <a href="https://leetcode-cn.com/problems/reverse-string-ii/">https://leetcode-cn.com/problems/reverse-string-ii/</a></p><p>· <a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">https://leetcode-cn.com/problems/reverse-words-in-a-string/</a></p><p>· <a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/</a></p><p>· <a href="https://leetcode-cn.com/problems/reverse-only-letters/">https://leetcode-cn.com/problems/reverse-only-letters/</a></p><p>· <a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/</a></p><p>· <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p><p>· <a href="https://leetcode-cn.com/problems/isomorphic-strings/">https://leetcode-cn.com/problems/isomorphic-strings/</a></p><p>· <a href="https://leetcode-cn.com/problems/valid-palindrome-ii/">https://leetcode-cn.com/problems/valid-palindrome-ii/</a></p><p>· <a href="https://leetcode-cn.com/problems/wildcard-matching">https://leetcode-cn.com/problems/wildcard-matching</a></p><p>· <a href="https://leetcode-cn.com/problems/longest-valid-parentheses">https://leetcode-cn.com/problems/longest-valid-parentheses</a></p><p>· <a href="https://leetcode-cn.com/problems/distinct-subsequences/">https://leetcode-cn.com/problems/distinct-subsequences/</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>资料篇-学习资料</title>
    <link href="/2020/12/14/another/%E8%B5%84%E6%96%99%E7%AF%87-%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/"/>
    <url>/2020/12/14/another/%E8%B5%84%E6%96%99%E7%AF%87-%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h1><p><a href="https://github.com/mikeygithub/architect-awesome">architect-awesome</a></p><h1 id="相关书籍"><a href="#相关书籍" class="headerlink" title="相关书籍"></a>相关书籍</h1><p><a href="https://github.com/sorenduan/awesome-java-books">Java 技术书籍大全</a></p><h1 id="教学视频"><a href="#教学视频" class="headerlink" title="教学视频"></a>教学视频</h1><p><a href="https://cloud.189.cn/t/yIbuMnUFjmYz">访问码：c8hx</a></p><h1 id="面试相关"><a href="#面试相关" class="headerlink" title="面试相关"></a>面试相关</h1><p><a href="https://www.yuque.com/itsaysay/mzsmvg/readme">语雀-阿提说说</a></p><h1 id="技术纲要"><a href="#技术纲要" class="headerlink" title="技术纲要"></a>技术纲要</h1><p><a href="https://www.cnblogs.com/lovesqcc/p/13633409.html">互联网应用服务端的常用技术思想与机制纲要</a></p><hr><h1 id="Java-技术书籍大全"><a href="#Java-技术书籍大全" class="headerlink" title="Java 技术书籍大全"></a>Java 技术书籍大全</h1><p>推荐书籍可以点击 -&gt; <strong><a href="https://github.com/sorenduan/awesome-java-books/issues">点击这里</a></strong></p><p>书籍列表 -&gt; <strong><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md">点击这里</a></strong></p><ul><li><p><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E5%85%A5%E9%97%A8%E4%B9%A6%E7%B1%8D">入门书籍</a></p></li><li><p><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E5%9F%BA%E7%A1%80%E4%B9%A6%E7%B1%8D">基础书籍</a></p><ul><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91">多线程与并发</a></li><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B">网络编程</a></li><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a></li><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80">语言基础</a></li></ul></li><li><p><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E8%BF%9B%E9%98%B6">进阶</a></p><ul><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">性能优化</a></li><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B">响应式编程</a></li><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#jvm%E8%99%9A%E6%8B%9F%E6%9C%BA">JVM虚拟机</a></li><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96">代码&amp;设计优化</a></li></ul></li><li><p><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式</a></p></li><li><p><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E6%A1%86%E6%9E%B6%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6">框架与中间件</a></p><ul><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></li><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E7%BC%93%E5%AD%98%E4%B8%8Enosql">缓存与NoSQL</a></li><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">消息队列</a></li><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#orm%E6%A1%86%E6%9E%B6">ORM框架</a></li><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#spring%E5%AE%B6%E6%97%8F">Spring家族</a></li><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E9%AB%98%E5%B9%B6%E5%8F%91">高并发</a></li><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E5%88%86%E5%B8%83%E5%BC%8F">分布式</a></li><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E">搜索引擎</a></li><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E5%A4%A7%E6%95%B0%E6%8D%AE">大数据</a></li></ul></li><li><p><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E6%9E%B6%E6%9E%84">架构</a></p><ul><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84">分布式架构</a></li><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84">微服务架构</a></li><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E6%9E%B6%E6%9E%84%E6%96%B9%E6%B3%95%E8%AE%BA">架构方法论</a></li></ul></li><li><p><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#jvm%E5%91%A8%E8%BE%B9%E8%AF%AD%E8%A8%80">JVM周边语言</a></p></li><li><p><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E9%A2%86%E5%AF%BC%E5%8A%9B%E6%B5%81%E7%A8%8B">项目管理&amp;领导力&amp;流程</a></p><ul><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86">项目管理</a></li><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86">团队管理</a></li></ul></li><li><p><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E6%95%B0%E5%AD%A6%E4%B8%8E%E7%AE%97%E6%B3%95">数学与算法</a></p><ul><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E6%95%B0%E5%AD%A6">数学</a></li><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E7%AE%97%E6%B3%95">算法</a></li></ul></li><li><p><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E8%81%8C%E4%B8%9A%E7%B4%A0%E5%85%BB%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF">职业素养与个人成长</a></p><ul><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E8%81%8C%E4%B8%9A%E7%B4%A0%E5%85%BB%E6%8F%90%E5%8D%87">职业素养提升</a></li><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E4%B8%AA%E4%BA%BA%E8%BD%AF%E6%8A%80%E8%83%BD">个人软技能</a></li></ul></li><li><p><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E5%A4%A7%E5%8E%82%E5%87%BA%E5%93%81">大厂出品</a></p><ul><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6">阿里巴巴技术丛书</a></li><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E4%BA%AC%E4%B8%9C%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6">京东技术丛书</a></li></ul></li><li><p><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E5%B7%A5%E5%85%B7%E4%B9%A6">工具书</a></p></li><li><p><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E9%9D%A2%E8%AF%95%E6%B1%82%E8%81%8C">面试求职</a></p></li><li><p><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E6%A0%BC%E5%B1%80%E4%B8%8E%E8%A7%86%E9%87%8E">格局与视野</a></p></li><li><p><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#java%E4%B9%8B%E5%A4%96">Java之外</a></p><ul><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86">网络知识</a></li><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86">安全知识</a></li><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E5%B7%A5%E5%85%B7">工具</a></li><li><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E8%BF%90%E7%BB%B4devops">运维&amp;DevOps</a></li></ul><p>TOC generated by <a href="https://github.com/xingshaocheng/simple-php-github-toc">simple-php-github-toc</a> </p></li></ul><h2 id="入门书籍"><a href="#入门书籍" class="headerlink" title="入门书籍"></a>入门书籍</h2><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/TA6z3m">《明解Java》</a> - 豆瓣评分 8.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/7urNtH">《Java从入门到精通（第4版 附光盘）》</a> - 豆瓣评分 6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/2dDnsY">《入门很简单丛书：Java Web开发入门很简单》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/7zm17P">《程序员炼成记 从小白到工程师》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ZCbVjQ">《Java从小白到大牛》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/mnkAJR">《JavaWeb项目开发实战入门（全彩版）》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/9TGA0S">《Java精彩编程200例（全彩版）》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/zMDeI7">《Java轻松学》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/td3bUo">《大话Java：程序设计从入门到精通（含DVD光盘1张）》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/HOFu01">《Java语言袖珍指南（第二版）》</a></li></ul><h2 id="基础书籍"><a href="#基础书籍" class="headerlink" title="基础书籍"></a>基础书籍</h2><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ajylTp">《Java编程思想（第4版） [thinking in java]》</a> - 豆瓣评分 9.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/tp87o1">《Java核心技术 卷I：基础知识（原书第10版）》</a> - 豆瓣评分 8.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/fYGMsC">《Java核心技术卷II：高级特性（原书第10版）》</a> - 豆瓣评分 7.7</li></ul><h3 id="多线程与并发"><a href="#多线程与并发" class="headerlink" title="多线程与并发"></a>多线程与并发</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ERgtGV">《华章专业开发者丛书·Java并发编程实战》</a> - 豆瓣评分 9.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/XRUB8H">《Java多线程编程实战指南（设计模式篇）》</a> - 豆瓣评分 8.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/LDOFjh">《图解Java多线程设计模式》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/WXhQuO">《实战Java高并发程序设计》</a> - 豆瓣评分 8.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/e5tZdf">《Java高并发编程详解：多线程与架构设计》</a> - 豆瓣评分 7.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/5p2KoJ">《Java核心技术系列：Java多线程编程核心技术 [Java Multi-thread Programming]》</a> - 豆瓣评分 5.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/RQu2W6">《Java并发编程：核心方法与框架》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/fkn9NP">《Java多线程与Socket：实战微服务框架》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ZwyPCp">《NIO与Socket编程技术指南》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/vB6BA2">《Java并发编程之美》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/fthTzf">《实战Java高并发程序设计（第2版）》</a></li></ul><h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/osowEq">《Java网络编程（第四版） [Java network programming, forth edition]》</a> - 豆瓣评分 7.6</li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/wdrJls">《数据结构与算法分析：Java语言描述（原书第3版）》</a> - 豆瓣评分 8.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/9GKS26">《图解数据结构：使用Java》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/DCJzy6">《数据结构与算法Java语言描述》</a></li></ul><h3 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/MNwLHg">《Java 8实战》</a> - 豆瓣评分 9.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/M6XqLp">《Java函数式编程》</a> - 豆瓣评分 8.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/YApFXv">《Java编程的逻辑》</a> - 豆瓣评分 8.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/UZgI0F">《O’Reilly：Head First Java（中文版 第2版 涵盖Java5.0）》</a> - 豆瓣评分 8.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ZCMWOr">《写给大忙人看的Java核心技术》</a> - 豆瓣评分 7.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ajoGad">《精通lambda表达式：Java多核编程 [Mastering Lambdas: Java Programming in a Multicore]》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/5HXsKg">《Java 9模块化开发：核心原则与实践》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/l7fy1C">《Java JDK 9学习笔记》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/CqmtBM">《Java 9编程参考官方大全（第10版） [Java：Thte Complete Reference，Tenth Edition]》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/JMdy64">《写给大忙人的Java SE 9核心技术》</a></li></ul><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/MBhyO7">《深入分析Java Web技术内幕（修订版）》</a> - 豆瓣评分 7.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/GEdlD0">《Java RESTful Web Service实战（第2版）》</a></li></ul><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/qTFNCP">《Java性能优化权威指南 [Java performance]》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/6CYRQi">《Java程序性能优化：让你的Java程序更快、更稳定》</a> - 豆瓣评分 8.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/KmJo2x">《Java性能权威指南》</a> - 豆瓣评分 8.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/GKe55M">《51CTO学院系列丛书·实战Java虚拟机：JVM故障诊断与性能优化》</a> - 豆瓣评分 8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/sQPN8w">《Java性能调优指南》</a> - 豆瓣评分 7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Uqaj5n">《大话Java性能优化》</a> - 豆瓣评分 4.4</li></ul><h3 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/nvsfLb">《响应式架构：消息模式Actor实现与Scala、Akka应用集成》</a> - 豆瓣评分 8.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/HeIp16">《RxJava响应式编程》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/iIZc0A">《RxJava 2.x 实战》</a></li></ul><h3 id="JVM虚拟机"><a href="#JVM虚拟机" class="headerlink" title="JVM虚拟机"></a>JVM虚拟机</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/DgTnN2">《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》</a> - 豆瓣评分 8.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/73DIJB">《Java核心技术系列：Java虚拟机规范（Java SE 8版） [The Java Virtual Machine Specification Jave SE 8 Edition]》</a> - 豆瓣评分 8.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ct4KRw">《揭秘Java虚拟机：JVM设计原理与实现》</a> - 豆瓣评分 7.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/xJZjRH">《HotSpot实战》</a> - 豆瓣评分 7.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/0ZMjqZ">《Java从入门到动手写虚拟机1（套装共2册）》</a></li></ul><h3 id="代码-amp-设计优化"><a href="#代码-amp-设计优化" class="headerlink" title="代码&amp;设计优化"></a>代码&amp;设计优化</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/QSoCEv">《重构 改善既有代码的设计 Java语言版》</a> - 豆瓣评分 9.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/wxQc3i">《代码大全（第2版）》</a> - 豆瓣评分 9.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/syzAFD">《Effective Java中文版（原书第3版）》</a> - 豆瓣评分 9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Rt31CM">《代码整洁之道 程序员的职业素养》</a> - 豆瓣评分 8.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/XBQxz8">《代码整洁之道 [Clean Code A Handbook of Agile Software Craftsmanship]》</a> - 豆瓣评分 8.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ld8p0r">《Spring实战（第4版）》</a> - 豆瓣评分 8.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/0hnAnw">《代码不朽：编写可维护软件的10大要则（Java版）》</a> - 豆瓣评分 7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/tyYWro">《Java代码与架构之完美优化 实战经典》</a></li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/SJWtpV">《反应式设计模式》</a> - 豆瓣评分 9.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/IGKmVq">《O’Reilly：Head First设计模式（中文版）》</a> - 豆瓣评分 9.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/D59mge">《设计模式：可复用面向对象软件的基础》</a> - 豆瓣评分 9.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/lFwQdc">《实现领域驱动设计 [Implementing Domain-Driven Design]》</a> - 豆瓣评分 8.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/yxTBEJ">《原创精品系列：设计模式之禅（第2版）》</a> - 豆瓣评分 8.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/H9tRFl">《图解设计模式》</a> - 豆瓣评分 8.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/qfAaGS">《大话设计模式》</a> - 豆瓣评分 8.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/PllZtF">《领域驱动设计 软件核心复杂性应对之道 修订版》</a> - 豆瓣评分 8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/xRo8Ur">《Java测试驱动开发》</a> - 豆瓣评分 6.6</li></ul><h2 id="框架与中间件"><a href="#框架与中间件" class="headerlink" title="框架与中间件"></a>框架与中间件</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/i4KCQO">《高性能MySQL（第3版）》</a> - 豆瓣评分 9.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Th90ra">《MySQL技术内幕：InnoDB存储引擎（第2版）》</a> - 豆瓣评分 8.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/YivOvQ">《大型网站系统与Java中间件实践》</a> - 豆瓣评分 7.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/HjaHc2">《深入浅出MySQL 数据库开发 优化与管理维护 第2版》</a> - 豆瓣评分 7.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/oYHlHw">《PostgreSQL修炼之道：从小工到专家》</a> - 豆瓣评分 7.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/hKsMRX">《PostgreSQL技术内幕：查询优化深度探索》</a></li></ul><h3 id="缓存与NoSQL"><a href="#缓存与NoSQL" class="headerlink" title="缓存与NoSQL"></a>缓存与NoSQL</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/uZirI6">《Redis 深度历险：核心原理与应用实践》</a> - 豆瓣评分 9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/VMo7w2">《Redis实战》</a> - 豆瓣评分 8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/GmFr7B">《Redis入门指南（第2版）》</a> - 豆瓣评分 7.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/TKeCR2">《深入分布式缓存：从原理到实践》</a> - 豆瓣评分 7.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/8DuE9W">《人人都是架构师：分布式系统架构落地与瓶颈突破》</a> - 豆瓣评分 6.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/qd9tLA">《MongoDB应用设计模式》</a> - 豆瓣评分 6.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Mlefug">《MongoDB实战 架构、开发与管理》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/1QhhB6">《NoSQL数据库入门与实践（基于MongoDB、Redis）》</a></li></ul><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/4SyxGo">《RabbitMQ实战指南》</a> - 豆瓣评分 9.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/qIwmGY">《Kafka权威指南》</a> - 豆瓣评分 8.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/hqBGgy">《Kafka入门与实践》</a> - 豆瓣评分 7.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/vyU3eK">《RocketMQ实战与原理解析》</a> - 豆瓣评分 7.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/GZh0yK">《Kafka技术内幕 图文详解Kafka源码设计与实现》</a> - 豆瓣评分 6.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/sTtFQn">《深入理解Kafka：核心设计与实践原理》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/GzBNOZ">《分布式消息中间件实践》</a></li></ul><h3 id="ORM框架"><a href="#ORM框架" class="headerlink" title="ORM框架"></a>ORM框架</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/0GXsRh">《MyBatis从入门到精通》</a> - 豆瓣评分 7.7</li></ul><h3 id="Spring家族"><a href="#Spring家族" class="headerlink" title="Spring家族"></a>Spring家族</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ohN8uh">《Spring微服务实战》</a> - 豆瓣评分 8.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/z1QvAP">《Spring Cloud微服务实战》</a> - 豆瓣评分 7.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/FfCbxt">《深入理解Spring Cloud与微服务构建》</a> - 豆瓣评分 7.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/wAPeEw">《MyBatis技术内幕》</a> - 豆瓣评分 7.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/BcQznU">《Spring Boot实战》</a> - 豆瓣评分 7.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/k0xgoA">《深入浅出Spring Boot 2.x》</a> - 豆瓣评分 7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/4Rtvg3">《JavaEE开发的颠覆者：Spring Boot实战》</a> - 豆瓣评分 6.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/2rz8BY">《Spring技术内幕：深入解析Spring架构与设计原理（第2版）》</a> - 豆瓣评分 5.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/xrNcv1">《Spring Boot 2精髓：从构建小系统到架构分布式大系统》</a> - 豆瓣评分 4.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/dtDOqc">《Spring 5开发大全》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/oFsaYt">《Spring Cloud微服务架构进阶》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/SdhhtK">《Spring源码深度解析 第2版》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ghc04R">《Spring MVC实战》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/fCZpVU">《Spring Boot编程思想（核心篇）（限量版亲笔签名书签 随机发售）》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/HO244A">《互联网轻量级SSM框架解密：Spring、Spring MVC、MyBatis源码深度剖析》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/O9L5Nb">《Spring学习指南 第3版》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/k4WSg3">《精通Spring MVC 4》</a></li></ul><h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/htIJgi">《Netty实战》</a> - 豆瓣评分 7.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/81Pbod">《七周七并发模型》</a> - 豆瓣评分 7.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/7tGXx5">《Netty权威指南（第2版）》</a> - 豆瓣评分 6.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/VBYLE0">《Netty进阶之路：跟着案例学Netty》</a></li></ul><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/3rp1Hv">《从Paxos到Zookeeper分布式一致性原理与实践》</a> - 豆瓣评分 7.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/LAyupw">《ZooKeeper：分布式过程协同技术详解》</a> - 豆瓣评分 7.2</li></ul><h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/IdftoH">《从Lucene到Elasticsearch：全文检索实战》</a></li></ul><h3 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/BlEDc7">《Hadoop权威指南：大数据的存储与分析(第4版)》</a> - 豆瓣评分 8.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/dW1kpa">《Hadoop构建数据仓库实践》</a> - 豆瓣评分 8.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/wqb9z0">《HBase权威指南 [HBase： The Definitive Guide]》</a> - 豆瓣评分 8.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/azPD8S">《图解Spark：核心技术与案例实战》</a> - 豆瓣评分 7.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/bd1YCS">《Hive编程指南 [Programming Hive]》</a> - 豆瓣评分 7.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/kFRuj2">《HBase应用架构》</a></li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/pTZ8xk">《Web性能权威指南》</a> - 豆瓣评分 8.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/7tOuAz">《从零开始学架构：照着做，你也能成为架构师》</a> - 豆瓣评分 8.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Qs9SXn">《Java应用架构设计：模块化模式与OSGi》</a> - 豆瓣评分 6.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/GVYZr9">《大型网站技术架构演进与性能优化》</a> - 豆瓣评分 6.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/7y5NpR">《高可用架构（第1卷）》</a> - 豆瓣评分 6.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/kPGIoj">《Java架构师指南》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Bc2TLN">《大话代码架构（项目实战版）》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/mzqn7f">《小团队构建大网站：中小研发团队架构实践》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/zDMNQs">《未来架构 从服务化到云原生(限量签名 随机发放)》</a></li></ul><h3 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/zpE3MI">《可伸缩架构：面向增长应用的高可用》</a> - 豆瓣评分 7.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/HQHcMY">《分布式服务架构：原理、设计与实战》</a> - 豆瓣评分 7.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/9JXTi8">《亿级流量网站架构核心技术 跟开涛学搭建高可用高并发系统》</a> - 豆瓣评分 6.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/zzctjK">《大型分布式网站架构设计与实践》</a> - 豆瓣评分 6.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/l4UA35">《可伸缩服务架构：框架与中间件》</a> - 豆瓣评分 5.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/1YUJxK">《架构探险：从零开始写分布式服务框架》</a> - 豆瓣评分 5.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/4trb76">《Cloud Native分布式架构原理与实践》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/QWumiy">《分布式系统常用技术及案例分析（第2版）》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/53hDaR">《云原生Java：Spring Boot、Spring Cloud与Cloud Foundry弹性系统设计》</a></li></ul><h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/5KB81a">《微服务设计》</a> - 豆瓣评分 8.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/LF3vzd">《生产微服务》</a> - 豆瓣评分 8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/xoCkW1">《架构解密：从分布式到微服务》</a> - 豆瓣评分 5.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/jk1V1F">《Java微服务》</a> - 豆瓣评分 5.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/QvfyPI">《Spring Cloud 微服务架构开发实战（全新升级版）》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/DyZQbc">《微服务实践》</a></li></ul><h3 id="架构方法论"><a href="#架构方法论" class="headerlink" title="架构方法论"></a>架构方法论</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/k8yxj0">《架构整洁之道》</a> - 豆瓣评分 8.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/pQOd7z">《企业应用架构模式 [Patterns of Enterprise Application Architecture]》</a> - 豆瓣评分 8.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ipHhzt">《企业IT架构转型之道 阿里巴巴中台战略思想与架构实战》</a> - 豆瓣评分 8.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/jRMw2b">《聊聊“架构”》</a> - 豆瓣评分 7.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/1gr9nd">《架构真经：互联网技术架构的设计原则（原书第2版）》</a> - 豆瓣评分 7.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/4Y77J0">《软件架构设计：程序员向架构师转型必备（第2版）》</a> - 豆瓣评分 7.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/XOr8py">《恰如其分的软件架构 [Just Enough Software Architecture]》</a> - 豆瓣评分 7.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/lSUYn8">《软件架构设计：大型网站技术架构与业务架构融合之道》</a></li></ul><h2 id="JVM周边语言"><a href="#JVM周边语言" class="headerlink" title="JVM周边语言"></a>JVM周边语言</h2><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/R0JT1a">《Scala编程（第3版）》</a> - 豆瓣评分 9.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/AMZkGX">《Groovy程序设计》</a> - 豆瓣评分 8.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/h6Gnct">《快学Scala（第2版）》</a> - 豆瓣评分 8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/loJfwO">《Kotlin极简教程》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/WvMNgs">《Scala集合技术手册》</a></li></ul><h2 id="项目管理-amp-领导力-amp-流程"><a href="#项目管理-amp-领导力-amp-流程" class="headerlink" title="项目管理&amp;领导力&amp;流程"></a>项目管理&amp;领导力&amp;流程</h2><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/5OmcTI">《构建之法 现代软件工程（第三版）》</a> - 豆瓣评分 9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/gcHfSY">《精益思想（白金版）》</a> - 豆瓣评分 8.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/uZ2nZV">《给产品经理讲技术》</a></li></ul><h3 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/TzKtiz">《持续交付：发布可靠软件的系统方法》</a> - 豆瓣评分 8.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/qEOLhm">《名家经典系列：人件（原书第3版） [Peopleware: Productive Projects and Teams]》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/gc719a">《硝烟中的Scrum和XP：我们如何实施Scrum》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ZHeyFS">《敏捷软件开发实践 估算与计划》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/mUkwcD">《人月神话（40周年中文纪念版） [The Mythical Man-Month：Essays on Software Engineering Anniversary Edition]》</a> - 豆瓣评分 8.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/T9HSMS">《Scrum敏捷软件开发》</a> - 豆瓣评分 8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/D8oZoG">《用户故事与敏捷方法 [User Stories Applied:For Agile Software Development]》</a> - 豆瓣评分 8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/P6RDR3">《用户故事地图 [User Story Mapping]》</a> - 豆瓣评分 7.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/1zgjNd">《知行合一 实现价值驱动的敏捷和精益开发》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Dtrvqn">《互联网项目管理实践精粹》</a></li></ul><h3 id="团队管理"><a href="#团队管理" class="headerlink" title="团队管理"></a>团队管理</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/f2kMe8">《卓有成效的管理者（珍藏版） [The Effective Executive]》</a> - 豆瓣评分 8.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/xLBU9J">《跃迁：从技术到管理的硅谷路径》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/w4p97S">《告别失控 软件开发团队管理必读》</a> - 豆瓣评分 7.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/K5DiJn">《赋能：打造应对不确定性的敏捷团队 [Team of Teams]》</a> - 豆瓣评分 7.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/8Gsrin">《OKR工作法：谷歌、领英等顶级公司的高绩效秘籍 [Radical Focus]》</a> - 豆瓣评分 7.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/PchUJJ">《CTO说》</a> - 豆瓣评分 7.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/wGQe5I">《轻流程 IT团队的积分式绩效管理》</a> - 豆瓣评分 7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/spqdp1">《技术领导力：程序员如何才能带团队》</a> - 豆瓣评分 5.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/pSHHhA">《敏捷文化：如何打造优秀的高效能团队 [The Agile Culture: Leading through Trust and Owner]》</a></li></ul><h2 id="数学与算法"><a href="#数学与算法" class="headerlink" title="数学与算法"></a>数学与算法</h2><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/lcuOQq">《数学之美（第二版）》</a> - 豆瓣评分 8.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Yte3WW">《程序员的数学2 概率统计》</a> - 豆瓣评分 8.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/WiKN9k">《程序员的数学3 线性代数》</a> - 豆瓣评分 8.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/iwv4Zd">《程序员的数学》</a> - 豆瓣评分 7.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/qhD5IJ">《程序员的数学思维修炼（趣味解读）》</a> - 豆瓣评分 5.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/vBLDyU">《统计之美：人工智能时代的科学思维》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/iCEv9a">《统计思维：程序员数学之概率统计（第2版）》</a></li></ul><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/AmwANr">《算法导论（原书第3版）/计算机科学丛书 [Introduction to Algorithms, third edition]》</a> - 豆瓣评分 9.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/J7HWa6">《算法图解》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Jt8KBI">《漫画算法：小灰的算法之旅（全彩）》</a></li></ul><h2 id="职业素养与个人成长"><a href="#职业素养与个人成长" class="headerlink" title="职业素养与个人成长"></a>职业素养与个人成长</h2><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/DGNxfn">《我编程，我快乐：程序员职业规划之道》</a> - 豆瓣评分 7.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/THQJSq">《程序员的自我修养》</a> - 豆瓣评分 6.5</li></ul><h3 id="职业素养提升"><a href="#职业素养提升" class="headerlink" title="职业素养提升"></a>职业素养提升</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/J7iABA">《码农翻身：用故事给技术加点料》</a> - 豆瓣评分 9.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/TL272C">《程序员修炼之道：从小工到专家》</a> - 豆瓣评分 8.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/mAbLoA">《极客与团队：软件工程师的团队生存秘笈》</a> - 豆瓣评分 8.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/8l5o8l">《程序员思维修炼(修订版)》</a> - 豆瓣评分 8.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/s1OiZc">《高效能程序员的修炼》</a> - 豆瓣评分 8.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/XxVx3J">《O’Reilly：卓有成效的程序员 [Productive programmer]》</a> - 豆瓣评分 8.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ODjq2h">《Java工程师修炼之道》</a> - 豆瓣评分 7.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/DKrbwc">《程序员的成长课》</a> - 豆瓣评分 7.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/y36OqE">《高效程序员的45个习惯：敏捷开发修炼之道(修订版)》</a> - 豆瓣评分 7.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/JKgll1">《温伯格技术思想三部曲：颠覆完美软件 软件测试必须知道的几件事》</a> - 豆瓣评分 7.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/0K8XDo">《温伯格技术思想三部曲：程序开发心理学（银年纪念版）》</a> - 豆瓣评分 7.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/AlxMcW">《软件开发本质论：追求简约、体现价值、逐步构建》</a> - 豆瓣评分 7.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/W0uA76">《内外兼修：程序员的成长之路》</a> - 豆瓣评分 6.6</li></ul><h3 id="个人软技能"><a href="#个人软技能" class="headerlink" title="个人软技能"></a>个人软技能</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/I3D7Z0">《把时间当作朋友（第3版 全彩）》</a> - 豆瓣评分 8.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/GZgwi5">《暗时间》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/jpIkyt">《关键对话：如何高效能沟通（原书第2版） [Crucial Conversations: Tools for Talking When Stak]》</a> - 豆瓣评分 8.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/N6YwQD">《温伯格技术思想三部曲：成为技术领导者 掌握全面解决问题的方法》</a> - 豆瓣评分 8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/KkL3kA">《软技能 代码之外的生存指南》</a> - 豆瓣评分 8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/8YQH5T">《程序员健康指南》</a> - 豆瓣评分 7.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/NS6cLf">《如何把事情做到最好：改变全球9800万人的人生指导书 [Mastery]》</a> - 豆瓣评分 7.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Gt5VDT">《程序员的英语》</a> - 豆瓣评分 5.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/oG641c">《高效能人士的七个习惯（30周年纪念版）》</a></li></ul><h2 id="大厂出品"><a href="#大厂出品" class="headerlink" title="大厂出品"></a>大厂出品</h2><h3 id="阿里巴巴技术丛书"><a href="#阿里巴巴技术丛书" class="headerlink" title="阿里巴巴技术丛书"></a>阿里巴巴技术丛书</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/mIi1ic">《码出高效：Java开发手册》</a> - 豆瓣评分 8.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/4888rh">《大数据之路 阿里巴巴大数据实践》</a> - 豆瓣评分 7.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/xHqHfG">《技术之瞳 阿里巴巴技术笔试心得》</a> - 豆瓣评分 7.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/uZYvrV">《淘宝技术这十年》</a> - 豆瓣评分 7.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/VA9xEV">《尽在双11 阿里巴巴技术演进与超越》</a> - 豆瓣评分 7.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/5NdzxY">《逆流而上：阿里巴巴技术成长之路》</a> - 豆瓣评分 6.9</li></ul><h3 id="京东技术丛书"><a href="#京东技术丛书" class="headerlink" title="京东技术丛书"></a>京东技术丛书</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ET1NkI">《京东基础架构建设之路（全彩）》</a> - 豆瓣评分 6.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/0OOBCc">《京东系统质量保障技术实战》</a> - 豆瓣评分 6.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/V6tLFs">《京东技术解密》</a> - 豆瓣评分 6.1</li></ul><h2 id="工具书"><a href="#工具书" class="headerlink" title="工具书"></a>工具书</h2><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/5U9zkK">《Linux命令行与shell脚本编程大全（第3版）》</a> - 豆瓣评分 9.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/28U5lx">《阿里巴巴Java开发手册》</a> - 豆瓣评分 8.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/d5ADPR">《SQL即查即用 （全彩版）》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/VgrIgv">《Linux命令速查手册（第三版）》</a></li></ul><h2 id="面试求职"><a href="#面试求职" class="headerlink" title="面试求职"></a>面试求职</h2><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/IgfC55">《剑指Offer：名企面试官精讲典型编程题（第2版）》</a> - 豆瓣评分 9.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/E4WimD">《编程之美：微软技术面试心得》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/UqcYlU">《Java程序员面试笔试宝典》</a> - 豆瓣评分 7.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/tm79JE">《Java程序员面试宝典（第4版）》</a> - 豆瓣评分 5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/7ujWIz">《编程之法：面试和算法心得》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/eE9uWg">《Java程序员面试算法宝典》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Jc9Xlt">《Java程序员面试笔试真题库》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/VqoEj5">《Java程序员面试笔试真题与解析》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/pfIsU6">《Java核心技术及面试指南》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/j0XMdh">《解忧程序员：高薪编程、求职面试与成长转型宝典》</a></li></ul><h2 id="格局与视野"><a href="#格局与视野" class="headerlink" title="格局与视野"></a>格局与视野</h2><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/bgG9yE">《全球科技通史》</a> - 豆瓣评分 9.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/koCTxD">《浪潮之巅 第三版 套装上下册》</a> - 豆瓣评分 9.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/KbwmLQ">《黑客与画家：硅谷创业之父Paul Graham文集 [Hackers and Painters Big Ldeas From the Computer Age]》</a> - 豆瓣评分 8.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/EcKZym">《软件随想录 卷1》</a> - 豆瓣评分 8.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/px8Sgu">《软件随想录 卷2》</a> - 豆瓣评分 8.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/6jRwgY">《编程人生：15位软件先驱访谈录》</a> - 豆瓣评分 8.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/6Y4Mcd">《大教堂与集市（最新版） [The Cathedral &amp; the Bazaar]》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/3yyV1D">《硅谷之谜：浪潮之巅 续集》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/M7OrgY">《原则 [Principles]》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/PxHueV">《精益创业》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/rdipjJ">《态度：吴军博士新书》</a> - 豆瓣评分 8.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/cP4xDs">《见识》</a> - 豆瓣评分 8.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/oGJFTx">《极限创新 35岁之前改变世界的全球科技精英》</a> - 豆瓣评分 7.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/FBINiB">《大学的终结：泛在大学与高等教育革命》</a> - 豆瓣评分 7.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ZfHw4B">《未来版图 全球聪明公司的科技创新趋势和商业化路径》</a> - 豆瓣评分 7.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/cNCbEF">《你好哇，程序员——漫话程序员面试求职、升职加薪、创业与生活》</a> - 豆瓣评分 6.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/S1ZQhz">《图灵和ACM图灵奖（1966-2015 第五版） 纪念计算机诞生70周年》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/M3PkIU">《文明之光（全彩印刷套装1-4册）入选2014中国好书/第六届中华优秀出版物获奖图书》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/JHxmei">《大师访谈录：成就非凡的软件人生》</a></li></ul><h2 id="Java之外"><a href="#Java之外" class="headerlink" title="Java之外"></a>Java之外</h2><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/RCgC9H">《计算机科学丛书：计算机程序的构造和解释（原书第2版）》</a> - 豆瓣评分 9.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/URRIW5">《计算机科学丛书：编译原理（第2版） [Compilers:Principle,Techniques and Tools]》</a> - 豆瓣评分 9.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/fbemS8">《一个APP的诞生——从零开始设计你的手机应用》</a> - 豆瓣评分 6.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/F4SUYQ">《大型网站性能优化实战：从前端、网络、CDN到后端、大促的全链路性能优化详解》</a></li></ul><h3 id="网络知识"><a href="#网络知识" class="headerlink" title="网络知识"></a>网络知识</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/q3lNRK">《图解HTTP》</a> - 豆瓣评分 8.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Ip1U7X">《图解TCP/IP 第5版》</a> - 豆瓣评分 7.8</li></ul><h3 id="安全知识"><a href="#安全知识" class="headerlink" title="安全知识"></a>安全知识</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/6oCOp8">《白帽子讲Web安全（纪念版）》</a> - 豆瓣评分 7.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/gecmeS">《Web安全攻防：渗透测试实战指南》</a></li></ul><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Fv9ksZ">《Maven实战》</a> - 豆瓣评分 8.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/JvxLfz">《大象：Thinking in UML（第2版）》</a> - 豆瓣评分 8.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/x06AA6">《Git学习指南》</a> - 豆瓣评分 6.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/W50GoO">《UML基础、案例与应用（第3版 修订版）》</a></li></ul><h3 id="运维-amp-DevOps"><a href="#运维-amp-DevOps" class="headerlink" title="运维&amp;DevOps"></a>运维&amp;DevOps</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/3ejMcd">《编码：隐匿在计算机软硬件背后的语言 [Code:The Hidden Language of Computer Hardware and Software]》</a> - 豆瓣评分 9.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/pVBguN">《DevOps实践指南》</a> - 豆瓣评分 9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/RXZBkB">《性能之巅：洞悉系统、企业与云计算》</a> - 豆瓣评分 8.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/kzDG88">《鸟哥的Linux私房菜 基础学习篇 第四版》</a> - 豆瓣评分 8.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Slnb59">《DevOps开发运维训练营》</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习资料</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unix/Linux编程实践教程-学习笔记</title>
    <link href="/2020/12/14/linux/Unix-Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/"/>
    <url>/2020/12/14/linux/Unix-Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="什么是-Linux"><a href="#什么是-Linux" class="headerlink" title="什么是 Linux"></a>什么是 Linux</h1><p class="note note-primary">Linux是由linus开发的一款基于unix的系统，</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cloud Development Platform</title>
    <link href="/2020/12/11/note/%E4%BA%91%E5%BC%80%E5%8F%91/"/>
    <url>/2020/12/11/note/%E4%BA%91%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h1><blockquote><p><a href="https://workbench.aliyun.com/">云开发平台</a>，是阿里云面向广大开发者提供的云上研发工作平台，助力研发团队实现工作的在线化（团队在线、环境在线、代码在线、协同在线）以及研发模式Serverless化，帮助研发团队实现对行业架构经验及架构服务的高效分享与传播，极致提升研发效率，极致降低研发成本。</p></blockquote><p class="note note-primary">    <a href="https://workbench.aliyun.com/" >官方入口</a></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/aliyun-cloud-development.png" alt="创建应用"></p><h1 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/aliyun-cloud-deploy.png" alt="部署应用"></p><h1 id="部署成功"><a href="#部署成功" class="headerlink" title="部署成功"></a>部署成功</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/aliyun-cloud-deploy-success.png" alt="部署成功"></p><h1 id="调试成功"><a href="#调试成功" class="headerlink" title="调试成功"></a>调试成功</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/aliyun-cloud-test-success.png" alt="调试成功"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://help.aliyun.com/document_detail/54788.html">官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>云开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>云开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Service Mesh</title>
    <link href="/2020/12/10/microservice/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AF%87-Service-Mesh/"/>
    <url>/2020/12/10/microservice/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AF%87-Service-Mesh/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Service-Mesh"><a href="#Service-Mesh" class="headerlink" title="Service Mesh"></a>Service Mesh</h1><blockquote><p>Service Mesh(服务网格)，</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://tech.meituan.com/2020/12/03/service-mesh-in-meituan.html">复杂环境下落地Service Mesh的挑战与实践-美团技术团队</a></p><p><a href="https://zhuanlan.zhihu.com/p/61901608">什么是Service Mesh</a></p><p><a href="https://www.jianshu.com/p/27a742e349f7">微服务之-ServiceMes</a></p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Service Mesh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Serverless-FaaS 入门</title>
    <link href="/2020/12/10/note/Serverless-FaaS-%E5%85%A5%E9%97%A8/"/>
    <url>/2020/12/10/note/Serverless-FaaS-%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h1><p>Serverless由开发者实现的服务端逻辑运行在无状态的计算容器中，它由事件触发， 完全被第三方管理，其业务层面的状态则被开发者使用的数据库和存储资源所记录。Serverless涵盖了很多技术，分为两类：FaaS和BaaS。</p><h1 id="FaaS（Function-as-a-Service，函数即服务）"><a href="#FaaS（Function-as-a-Service，函数即服务）" class="headerlink" title="FaaS（Function as a Service，函数即服务）"></a>FaaS（Function as a Service，函数即服务）</h1><p>FaaS意在无须自行管理服务器系统或自己的服务器应用程序，即可直接运行后端代码。其中所指的服务器应用程序，是该技术与容器和PaaS（平台即服务）等其他现代化架构最大的差异。</p><p>FaaS可以取代一些服务处理服务器（可能是物理计算机，但绝对需要运行某种应用程序），这样不仅不需要自行供应服务器，也不需要全时运行应用程序。</p><p>FaaS产品不要求必须使用特定框架或库进行开发。在语言和环境方面，FaaS函数就是常规的应用程序。例如AWS Lambda的函数可以通过Javascript、Python以及任何JVM语言（Java、Clojure、Scala）等实现。然而Lambda函数也可以执行任何捆绑有所需部署构件的进程，因此可以使用任何语言，只要能编译为Unix进程即可。FaaS函数在架构方面确实存在一定的局限，尤其是在状态和执行时间方面。</p><p>在迁往FaaS的过程中，唯一需要修改的代码是“主方法/启动”代码，其中可能需要删除顶级消息处理程序的相关代码（“消息监听器接口”的实现），但这可能只需要更改方法签名即可。在FaaS的世界中，代码的其余所有部分（例如向数据库执行写入的代码）无须任何变化。</p><p>相比传统系统，部署方法会有较大变化 – 将代码上传至FaaS供应商，其他事情均可由供应商完成。目前这种方式通常意味着需要上传代码的全新定义（例如上传zip或JAR文件），随后调用一个专有API发起更新过程。</p><p>FaaS中的函数可以通过供应商定义的事件类型触发。对于亚马逊AWS，此类触发事件可以包括S3（文件）更新、时间（计划任务），以及加入消息总线的消息（例如Kinesis）。通常你的函数需要通过参数指定自己需要绑定到的事件源。</p><p>大部分供应商还允许函数作为对传入Http请求的响应来触发，通常这类请求来自某种该类型的API网关（例如AWS API网关、Webtask）。</p><h1 id="BaaS（Backend-as-a-Service，后端即服务）"><a href="#BaaS（Backend-as-a-Service，后端即服务）" class="headerlink" title="BaaS（Backend as a Service，后端即服务）"></a>BaaS（Backend as a Service，后端即服务）</h1><p>BaaS（Backend as a Service，后端即服务）是指我们不再编写或管理所有服务端组件，可以使用领域通用的远程组件（而不是进程内的库）来提供服务。理解BaaS，需要搞清楚它与PaaS的区别。</p><p>首先BaaS并非PaaS，它们的区别在于：PaaS需要参与应用的生命周期管理，BaaS则仅仅提供应用依赖的第三方服务。典型的PaaS平台需要提供手段让开发者部署和配置应用，例如自动将应用部署到Tomcat容器中，并管理应用的生命周期。BaaS不包含这些内容，BaaS只以API的方式提供应用依赖的后端服务，例如数据库和对象存储。BaaS可以是公共云服务商提供的，也可以是第三方厂商提供的。其次从功能上讲，BaaS可以看作PaaS的一个子集，即提供第三方依赖组件的部分。</p><p>BaaS服务还允许我们依赖其他人已经实现的应用逻辑。对于这点，认证就是一个很好的例子。很多应用都要自己编写实现注册、登录、密码管理等逻辑的代码，而对于不同的应用这些代码往往大同小异。完全可以把这些重复性的工作提取出来，再做成外部服务，而这正是Auth0和Amazon Cognito等产品的目标。它们能实现全面的认证和用户管理，开发团队再也不用自己编写或者管理实现这些功能的代码。</p><h1 id="创建-FaaS"><a href="#创建-FaaS" class="headerlink" title="创建 FaaS"></a>创建 FaaS</h1><blockquote><p>本文采用鹅厂的FaaS作为测试</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/serverless-create.png" alt="avatar"></p><p>创建完成</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/serverless-finish-create.png" alt="avatar"></p><h1 id="编写-FaaS"><a href="#编写-FaaS" class="headerlink" title="编写 FaaS"></a>编写 FaaS</h1><details>  <summary><span>展开代码</span></summary>  <br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;github.com/tencentyun/scf-go-lib/cloudfunction&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> DefineEvent <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// test event define</span><br>    Key1 <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;key1&quot;`</span><br>    Key2 <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;key2&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(ctx context.Context, event DefineEvent)</span> <span class="hljs-params">(<span class="hljs-keyword">string</span>, error)</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;key1:&quot;</span>, event.Key1)<br>    fmt.Println(<span class="hljs-string">&quot;key2:&quot;</span>, event.Key2)<br>    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Hello %s!&quot;</span>, event.Key1), <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// Make the handler available for Remote Procedure Call by Cloud Function</span><br>    cloudfunction.Start(hello)<br>&#125;<br></code></pre></td></tr></table></figure></details><p>打包函数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">GOOS=linux GOARCH=amd64 go build -o main main.go<br>zip main.zip main<br></code></pre></td></tr></table></figure><p>部署函数</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/serverless-deploy.png" alt="avatar"></p><p>测试函数</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/serverless-test.png" alt="avatar"></p><p>发布函数</p><blockquote><p>先配置好ROLE和Api网关</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/serverless-role.png" alt="avatar"></p><p>创建触发器</p><blockquote><p>使用API触发器</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/serverless-role.png" alt="avatar"></p><p>调用函数</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/serverless-test.png" alt="avatar"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://cloud.tencent.com/document/product/583/9199">官方文档</a></p><p><a href="https://blog.csdn.net/cc18868876837/article/details/90672971">看懂 Serverless，这一篇就够了</a></p><p><a href="https://www.jianshu.com/p/e7eb45a10f96">Serverless 入门教程</a></p><p><a href="https://blog.csdn.net/li1669852599/article/details/108795172">通过一个案例，理解FaaS的运行逻辑</a></p>]]></content>
    
    
    <categories>
      
      <category>Serverless</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Faas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx配置SSL</title>
    <link href="/2020/12/09/note/Nginx%E9%85%8D%E7%BD%AESSL/"/>
    <url>/2020/12/09/note/Nginx%E9%85%8D%E7%BD%AESSL/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="获取证书"><a href="#获取证书" class="headerlink" title="获取证书"></a>获取证书</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/ssl-nginx-cert.png" alt="avatar"></p><h1 id="上传证书"><a href="#上传证书" class="headerlink" title="上传证书"></a>上传证书</h1><p>证书内容</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs text">./<br>├── Apache<br>│   ├── 1_root_bundle.crt<br>│   ├── 2_yangbiao.ink.crt<br>│   └── 3_yangbiao.ink.key<br>├── IIS<br>│   ├── keystorePass.txt<br>│   └── yangbiao.ink.pfx<br>├── Nginx<br>│   ├── 1_yangbiao.ink_bundle.crt<br>│   └── 2_yangbiao.ink.key<br>├── Tomcat<br>│   ├── keystorePass.txt<br>│   └── yangbiao.ink.jks<br>└── yangbiao.ink.csr<br><br>4 directories, 10 files<br><br></code></pre></td></tr></table></figure><p>上传证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rsync -r ./Nginx/  root@47.106.210.183:yangbiao.ink/<br></code></pre></td></tr></table></figure><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><ul><li>配置Nginx文件<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs text">server &#123;<br>        # 所有请求走https<br>        rewrite ^(.*)$  https://$host$1 permanent;<br>        ......<br>&#125;<br>server &#123;<br>        listen       443 ssl http2 default_server;<br>        listen       [::]:443 ssl http2 default_server;<br>        server_name  yangbiao.ink;<br>        root         /usr/share/nginx/html;<br>        #配置证书<br>        ssl_certificate &quot;/etc/pki/nginx/server.crt&quot;;<br>        ssl_certificate_key &quot;/etc/pki/nginx/server.key&quot;;<br>        ssl_session_cache shared:SSL:1m;<br>        ssl_session_timeout  10m;<br>        ssl_ciphers HIGH:!aNULL:!MD5;<br>        ssl_prefer_server_ciphers on;<br><br>        # Load configuration files for the default server block.<br>        include /etc/nginx/default.d/*.conf;<br><br>        location / &#123;<br>        &#125;<br><br>        error_page 404 /404.html;<br>        location = /404.html &#123;<br>        &#125;<br><br>        error_page 500 502 503 504 /50x.html;<br>        location = /50x.html &#123;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="测试访问"><a href="#测试访问" class="headerlink" title="测试访问"></a>测试访问</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
    
    
    <categories>
      
      <category>SSL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mermaid使用教程</title>
    <link href="/2020/12/07/tool/Mermaid%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <url>/2020/12/07/tool/Mermaid%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Mermaid简介"><a href="#Mermaid简介" class="headerlink" title="Mermaid简介"></a>Mermaid简介</h1><p>mermaid 美人鱼, 是一个类似 markdown，用文本语法来描述文档图形(流程图、 时序图、甘特图)的工具，您可以在文档中嵌入一段 mermaid 文本来生成 SVG 形式的图形 比如插入下面的代码</p><p>编写代码</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">graph TD<br>    Start --&gt; Stop<br></code></pre></td></tr></table></figure><p>生成图示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    Start --&gt; Stop<br></code></pre></td></tr></table></figure><p>编写代码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">graph TD<br>    B((开始)) <span class="hljs-comment">--&gt;C&#123;判断&#125;</span><br>    C <span class="hljs-comment">--  a=1 --&gt;D[执行语句1]</span><br>    C <span class="hljs-comment">--  a=2  --&gt;E[执行语句2]</span><br>    C <span class="hljs-comment">--  a=3 --&gt;F[执行语句3]</span><br>    C <span class="hljs-comment">-- a=4  --&gt;G[执行语句4]</span><br>    D<span class="hljs-comment">--&gt; AA((结束))</span><br>    E<span class="hljs-comment">--&gt; AA</span><br>    F<span class="hljs-comment">--&gt; AA</span><br>   G<span class="hljs-comment">--&gt; AA      </span><br></code></pre></td></tr></table></figure><p>生成对应图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    B((开始)) --&gt;C&#123;判断&#125;<br>    C --  a&#x3D;1 --&gt;D[执行语句1]<br>    C --  a&#x3D;2  --&gt;E[执行语句2]<br>    C --  a&#x3D;3 --&gt;F[执行语句3]<br>    C -- a&#x3D;4  --&gt;G[执行语句4]<br>    D--&gt; AA((结束))<br>    E--&gt; AA<br>    F--&gt; AA<br>   G--&gt; AA      <br></code></pre></td></tr></table></figure><h1 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h1><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><table>    <tr>        <th>格式</th>        <th>描述</th>    </tr>    <tr>        <td>TB</td>        <td>从上到下</td>    </tr>    <tr>        <td>TD</td>        <td>自顶向下/从上至下相同</td>    </tr>        <tr>        <td>BT</td>        <td>从下至上</td>    </tr>    <tr>        <td>RL</td>        <td>从右至左</td>    </tr>    <tr>        <td>LR</td>        <td>从左至右</td>    </tr></table><p>代码</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">graph LR<br>    A--&gt;|text|B<br></code></pre></td></tr></table></figure><p>图示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph LR<br>    A--&gt;|text|B<br></code></pre></td></tr></table></figure><h2 id="顺序图"><a href="#顺序图" class="headerlink" title="顺序图"></a>顺序图</h2><p>代码</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">sequenceDiagram<br>    autonumber<br>    Alice-&gt;&gt;John: Hello John, how are you?<br>    loop Healthcheck<br>        John-&gt;&gt;John: Fight against hypochondria<br>    end<br>    Note right of John: Rational thoughts!<br>    John--&gt;&gt;Alice: Great!<br>    John-&gt;&gt;Bob: How about you?<br>    Bob--&gt;&gt;John: Jolly good!<br></code></pre></td></tr></table></figure><p>图像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">sequenceDiagram<br>    autonumber<br>    Alice-&gt;&gt;John: Hello John, how are you?<br>    loop Healthcheck<br>        John-&gt;&gt;John: Fight against hypochondria<br>    end<br>    Note right of John: Rational thoughts!<br>    John--&gt;&gt;Alice: Great!<br>    John-&gt;&gt;Bob: How about you?<br>    Bob--&gt;&gt;John: Jolly good!<br></code></pre></td></tr></table></figure><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>代码</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">classDiagram<br>classA &lt;|-- classB : implements<br>classC *-- classD : composition<br>classE o-- classF : association<br></code></pre></td></tr></table></figure><p>图示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">classDiagram<br>classA &lt;|-- classB : implements<br>classC *-- classD : composition<br>classE o-- classF : association<br></code></pre></td></tr></table></figure><h2 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h2><p>代码</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">stateDiagram-v2<br>    [*] --&gt; Still<br>    Still --&gt; [*]<br><br>    Still --&gt; Moving<br>    Moving --&gt; Still<br>    Moving --&gt; Crash<br>    Crash --&gt; [*]<br></code></pre></td></tr></table></figure><p>图示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">stateDiagram-v2<br>    [*] --&gt; Still<br>    Still --&gt; [*]<br><br>    Still --&gt; Moving<br>    Moving --&gt; Still<br>    Moving --&gt; Crash<br>    Crash --&gt; [*]<br></code></pre></td></tr></table></figure><h2 id="实体关系图"><a href="#实体关系图" class="headerlink" title="实体关系图"></a>实体关系图</h2><p>代码</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs text">erDiagram<br>    CUSTOMER ||--o&#123; ORDER : places<br>    CUSTOMER &#123;<br>        string name<br>        string custNumber<br>        string sector<br>    &#125;<br>    ORDER ||--|&#123; LINE-ITEM : contains<br>    ORDER &#123;<br>        int orderNumber<br>        string deliveryAddress<br>    &#125;<br>    LINE-ITEM &#123;<br>        string productCode<br>        int quantity<br>        float pricePerUnit<br>    &#125;<br></code></pre></td></tr></table></figure><p>图示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">erDiagram<br>    CUSTOMER ||--o&#123; ORDER : places<br>    CUSTOMER &#123;<br>        string name<br>        string custNumber<br>        string sector<br>    &#125;<br>    ORDER ||--|&#123; LINE-ITEM : contains<br>    ORDER &#123;<br>        int orderNumber<br>        string deliveryAddress<br>    &#125;<br>    LINE-ITEM &#123;<br>        string productCode<br>        int quantity<br>        float pricePerUnit<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="用户旅程"><a href="#用户旅程" class="headerlink" title="用户旅程"></a>用户旅程</h2><p>代码</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">journey<br>    title My working day<br>    section Go to work<br>      Make tea: 5: Me<br>      Go upstairs: 3: Me<br>      Do work: 1: Me, Cat<br>    section Go home<br>      Go downstairs: 5: Me<br>      Sit down: 5: Me<br></code></pre></td></tr></table></figure><p>图示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">journey<br>    title My working day<br>    section Go to work<br>      Make tea: 5: Me<br>      Go upstairs: 3: Me<br>      Do work: 1: Me, Cat<br>    section Go home<br>      Go downstairs: 5: Me<br>      Sit down: 5: Me<br></code></pre></td></tr></table></figure><h2 id="甘特"><a href="#甘特" class="headerlink" title="甘特"></a>甘特</h2><p>代码</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">gantt<br>    title A Gantt Diagram<br>    dateFormat  YYYY-MM-DD<br>    section Section<br>    A task           :a1, 2014-01-01, 30d<br>    Another task     :after a1  , 20d<br>    section Another<br>    Task in sec      :2014-01-12  , 12d<br>    another task      : 24d<br></code></pre></td></tr></table></figure><p>图示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">gantt<br>    title A Gantt Diagram<br>    dateFormat  YYYY-MM-DD<br>    section Section<br>    A task           :a1, 2014-01-01, 30d<br>    Another task     :after a1  , 20d<br>    section Another<br>    Task in sec      :2014-01-12  , 12d<br>    another task      : 24d<br></code></pre></td></tr></table></figure><h2 id="饼形图"><a href="#饼形图" class="headerlink" title="饼形图"></a>饼形图</h2><p>代码</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">pie<br>    title Key elements in Product X<br>    &quot;Calcium&quot; : 42.96<br>    &quot;Potassium&quot; : 50.05<br>    &quot;Magnesium&quot; : 10.01<br>    &quot;Iron&quot; :  5<br></code></pre></td></tr></table></figure><p>图示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">pie<br>    title Key elements in Product X<br>    &quot;Calcium&quot; : 42.96<br>    &quot;Potassium&quot; : 50.05<br>    &quot;Magnesium&quot; : 10.01<br>    &quot;Iron&quot; :  5<br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://mermaid-js.github.io/mermaid/#/">官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mermaid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARP地址解析协议</title>
    <link href="/2020/12/07/network/ARP%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/12/07/network/ARP%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="协议简介"><a href="#协议简介" class="headerlink" title="协议简介"></a>协议简介</h1><p>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；</p><blockquote><p>收到返回消息后将该IP地址和物理地址存入本机<code>ARP缓存</code>中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。</p></blockquote><p>地址解析协议是建立在网络中各个主机互相信任的基础上的，局域网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；<br>由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。<br>相关协议有RARP、代理ARP。NDP用于在IPv6中代替地址解析协议。</p><ul><li><p>Mac地址</p><blockquote><p><strong>Mac地址</strong>由设备制造商定义/分配，<strong>每一个硬件设备都有一个链路层主地址（MAC地址）</strong>，保存在设备的永久内存中。设备的mac地址不会改变（现在可以进行mac地址伪装） 　　</p></blockquote></li><li><p><strong>IP地址</strong></p><blockquote><p><strong>IP地址</strong>由用户配置给网络接口， 网络接口的IP地址是可以发生变化的<strong>（通过DHCP获取IP，变化速度比较快）</strong></p></blockquote></li></ul><ul><li>查看缓存表</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">arp -a<br></code></pre></td></tr></table></figure><p>显示</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">接口: 192.168.2.226 --- 0x8<br>  Internet 地址         物理地址              类型<br>  192.168.2.1           68-db-54-bb-32-84     动态<br>  192.168.2.255         ff-ff-ff-ff-ff-ff     静态<br>  224.0.0.22            01-00-5e-00-00-16     静态<br>  224.0.0.251           01-00-5e-00-00-fb     静态<br>  224.0.0.252           01-00-5e-00-00-fc     静态<br>  239.255.255.250       01-00-5e-7f-ff-fa     静态<br>  255.255.255.255       ff-ff-ff-ff-ff-ff     静态<br></code></pre></td></tr></table></figure><h1 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h1><ol><li>每个主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址之间的对应关系。</li><li>主机（网络接口）<strong>新加入网络时</strong>（也可能只是mac地址发生变化，接口重启等）， 会发送免费ARP报文把<strong>自己IP地址与Mac地址的映射关系广播给其他主机。</strong></li><li>网络上的主机接收到免费ARP报文时，会更新自己的ARP缓冲区。将新的映射关系更新到自己的ARP表中。</li><li>某个主机需要发送报文时，首先检查 ARP 列表中是否有对应 IP 地址的目的主机的 MAC 地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送 ARP 数据包，该数据包包括的内容有：源主机 IP 地址，源主机 MAC 地址，目的主机的 IP 地址等。</li><li>当本网络的所有主机收到该 ARP 数据包时：</li></ol><p>​       <strong>（A）</strong>首先检查数<strong>据包中的 IP 地址是否是自己的 IP 地址</strong>，如果<strong>不是，则忽略该数据包。</strong></p><p>​       <strong>（B</strong>)  如果是，<strong>则首先从数据包中取出源主机的 IP 和 MAC 地址写入到 ARP 列表中，如果已经存在，则覆盖。</strong></p><p>​       <strong>（C）</strong> 然后将自己的 MAC 地址写入 ARP 响应包中，告诉源主机自己是它想要找的 MAC 地址。</p><p>​     6.源主机收到 ARP 响应包后。将目的主机的 IP 和 MAC 地址写入 ARP 列表，并利用此信息发送数据。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/csguo/p/7542944.html">ARP地址解析协议原理</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ARP协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Travis-CI搭建CD/CI环境</title>
    <link href="/2020/12/06/devops/Travis-CI%E6%90%AD%E5%BB%BACD-CI%E7%8E%AF%E5%A2%83/"/>
    <url>/2020/12/06/devops/Travis-CI%E6%90%AD%E5%BB%BACD-CI%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><ul><li><a href="https://github.com/">github账号</a></li><li><a href="https://hub.docker.com/">dockerhub账号</a></li><li><a href="travis-ci.org">Travis-CI账号</a></li></ul><h1 id="开启服务"><a href="#开启服务" class="headerlink" title="开启服务"></a>开启服务</h1><p>进入<a href="travis-ci.org">Travis-CI官网</a>开启服务</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/travis-ci-open-service.png" alt="img"></p><h1 id="安装Travis"><a href="#安装Travis" class="headerlink" title="安装Travis"></a>安装Travis</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get -y update<br>sudo apt-get -y install build-essential zlib1g-dev libssl-dev libreadline6-dev libyaml-dev<br><span class="hljs-built_in">cd</span> /tmp<br><span class="hljs-comment"># 由于众所周知的网络原因，此处可能需要使用到http_proxy</span><br>wget http://ftp.ruby-lang.org/pub/ruby/2.1/ruby-2.1.5.tar.gz <br>tar -xvzf ruby-2.1.5.tar.gz<br><span class="hljs-built_in">cd</span> ruby-2.1.5/<br>./configure --prefix=/usr/<span class="hljs-built_in">local</span><br>make<br>sudo make install<br></code></pre></td></tr></table></figure><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gem install travis<br></code></pre></td></tr></table></figure><p>如果网络实在太差，可以使用RubyGems 镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">gem sources --add https://gems.ruby-china.org/<br>gem sources --remove https://rubygems.org/<br>gem sources --remove http://rubygems.org/<br>gem sources -l<br></code></pre></td></tr></table></figure><h1 id="客户端登入"><a href="#客户端登入" class="headerlink" title="客户端登入"></a>客户端登入</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">travis login --org<br></code></pre></td></tr></table></figure><ul><li>登入失败</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">root@mikey:/home/mikey# travis login<br>Outdated CLI version, run `gem install travis`.<br>Shell completion not installed. Would you like to install it now? |y| y<br>We need your GitHub login to identify you.<br>This information will not be sent to Travis CI, only to api.github.com.<br>The password will not be displayed.<br><br>Try running with --github-token or --auto if you don&#x27;t want to enter your password anyway.<br><br>Username: hhufu     <br>Password for hhufu: ********<br>Bad credentials. The API can&#x27;t be accessed using username/password authentication. Please create a personal access token to access this endpoint: http://github.com/settings/tokens<br>for a full error report, run travis report<br></code></pre></td></tr></table></figure><p>解决方法: 可以使用Token进行登入</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">root@mikey:/home/mikey# travis login --org --github-token 6534404071f94d2be86d6e3e16d691<br>Outdated CLI version, run `gem install travis`.<br>Successfully logged in as hhufu!<br></code></pre></td></tr></table></figure><h1 id="公钥配置"><a href="#公钥配置" class="headerlink" title="公钥配置"></a>公钥配置</h1><p>本地服务生成公钥,一路回车</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen<br></code></pre></td></tr></table></figure><p>将公钥上传致部署服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-copy-id -i ~/.ssh/id_rsa.pub root@47.106.210.184<br></code></pre></td></tr></table></figure><p>免密登入测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh root@47.106.210.184<br></code></pre></td></tr></table></figure><h1 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h1><p>进入项目目录中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">travis init --org<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/gems/</span><span class="hljs-number">2.5</span>.<span class="hljs-number">0</span><span class="hljs-regexp">/gems/</span>travis-<span class="hljs-number">1.9</span>.<span class="hljs-number">1</span><span class="hljs-regexp">/lib/</span>travis<span class="hljs-regexp">/tools/</span>system.rb:<span class="hljs-number">79</span>: warning: Insecure world writable dir <span class="hljs-regexp">/home/mi</span>key/Devtools in PATH, mode <span class="hljs-number">040777</span><br>Outdated CLI version, run `gem install travis`.<br>Detected repository as hhufu/innovate, is <span class="hljs-keyword">this</span> correct? |yes| yes<br>Main programming language used: |Ruby| <br>.travis.yml <span class="hljs-keyword">file</span> created!<br>not allowed to update service hook <span class="hljs-keyword">for</span> hhufu/innovate<br></code></pre></td></tr></table></figure><p>添加秘钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">travis encrypt-file ~/.ssh/id_rsa --add<br></code></pre></td></tr></table></figure><p>当在官网查看到有秘钥存在就表示成功了</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/travis-ci-key-success.png" alt="img"></p><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><details>  <summary><span>配置文件</span></summary>  <br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">matrix:</span><br>  <span class="hljs-attr">include:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">language:</span> <span class="hljs-string">node_js</span><br>    <span class="hljs-attr">node_js:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">10.16</span><span class="hljs-number">.1</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-attr">only:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">master</span><br>    <span class="hljs-attr">install:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span><br>    <span class="hljs-attr">script:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">build</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span> <span class="hljs-string">build</span> <span class="hljs-string">.</span> <span class="hljs-string">-t</span> <span class="hljs-string">&quot;$DOCKER_NAME/innovate-admin-vue:latest&quot;</span><br>    <span class="hljs-attr">addons:</span><br>      <span class="hljs-attr">ssh_known_hosts:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;$SERVER_IP&quot;</span><br>    <span class="hljs-attr">after_success:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span> <span class="hljs-string">login</span> <span class="hljs-string">-u=$DOCKER_NAME</span> <span class="hljs-string">-p=&quot;$DOCKER_PWD&quot;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span> <span class="hljs-string">push</span> <span class="hljs-string">$DOCKER_NAME/innovate-admin-vue:latest</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">chmod</span> <span class="hljs-number">600</span> <span class="hljs-string">~/.ssh/id_rsa</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">rsync</span> <span class="hljs-string">-az</span> <span class="hljs-string">--delete</span> <span class="hljs-string">./docker-compose.yml</span> <span class="hljs-string">root@$SERVER_IP:$DOCKER_NAME/innovate-admin-vue/</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ssh</span> <span class="hljs-string">-o</span> <span class="hljs-string">&quot;StrictHostKeyChecking no&quot;</span> <span class="hljs-string">-i</span> <span class="hljs-string">id_rsa</span> <span class="hljs-string">root@$SERVER_IP</span> <span class="hljs-string">&quot;cd $DOCKER_NAME/innovate-admin-vue/;docker-compose</span><br><span class="hljs-string">      -f docker-compose.yml pull;docker-compose -f docker-compose.yml up -d;exit&quot;</span><br>    <span class="hljs-attr">before_install:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">openssl</span> <span class="hljs-string">aes-256-cbc</span> <span class="hljs-string">-K</span> <span class="hljs-string">$encrypted_1687bb340939_key</span> <span class="hljs-string">-iv</span> <span class="hljs-string">$encrypted_1687bb340939_iv</span>  <span class="hljs-string">-in</span><br>      <span class="hljs-string">id_rsa.enc</span> <span class="hljs-string">-out</span> <span class="hljs-string">~/.ssh/id_rsa</span> <span class="hljs-string">-d</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">chmod</span> <span class="hljs-number">600</span> <span class="hljs-string">~/.ssh/id_rsa</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">echo</span> <span class="hljs-string">-e</span> <span class="hljs-string">&quot;Host $SERVER_IP\n\tStrictHostKeyChecking no\n&quot;</span> <span class="hljs-string">&gt;&gt;</span> <span class="hljs-string">~/.ssh/config</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">cd</span> <span class="hljs-string">$DOCKER_NAME/innovate-admin-vue</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">language:</span> <span class="hljs-string">java</span><br>    <span class="hljs-attr">services:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span><br>    <span class="hljs-attr">sudo:</span> <span class="hljs-string">required</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-attr">only:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">master</span><br>    <span class="hljs-attr">script:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">mvn</span> <span class="hljs-string">install</span> <span class="hljs-string">-DskipTests=true</span> <span class="hljs-string">-Dmaven.javadoc.skip=true</span> <span class="hljs-string">-B</span> <span class="hljs-string">-V</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span> <span class="hljs-string">build</span> <span class="hljs-string">.</span> <span class="hljs-string">-t</span> <span class="hljs-string">&quot;$DOCKER_NAME/innovate-admin:latest&quot;</span><br>    <span class="hljs-attr">before_install:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">openssl</span> <span class="hljs-string">aes-256-cbc</span> <span class="hljs-string">-K</span> <span class="hljs-string">$encrypted_1687bb340939_key</span> <span class="hljs-string">-iv</span> <span class="hljs-string">$encrypted_1687bb340939_iv</span><br>      <span class="hljs-string">-in</span> <span class="hljs-string">id_rsa.enc</span> <span class="hljs-string">-out</span> <span class="hljs-string">~/.ssh/id_rsa</span> <span class="hljs-string">-d</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">chmod</span> <span class="hljs-number">600</span> <span class="hljs-string">~/.ssh/id_rsa</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">echo</span> <span class="hljs-string">-e</span> <span class="hljs-string">&quot;Host $SERVER_IP\n\tStrictHostKeyChecking no\n&quot;</span> <span class="hljs-string">&gt;&gt;</span> <span class="hljs-string">~/.ssh/config</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">cd</span> <span class="hljs-string">$DOCKER_NAME/innovate-admin</span><br>    <span class="hljs-attr">after_success:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span> <span class="hljs-string">login</span> <span class="hljs-string">-u=$DOCKER_NAME</span> <span class="hljs-string">-p=&quot;$DOCKER_PWD&quot;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span> <span class="hljs-string">push</span> <span class="hljs-string">$DOCKER_NAME/innovate-admin:latest</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">chmod</span> <span class="hljs-number">600</span> <span class="hljs-string">~/.ssh/id_rsa</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">rsync</span> <span class="hljs-string">-az</span> <span class="hljs-string">--delete</span> <span class="hljs-string">./docker-compose.yml</span> <span class="hljs-string">root@$SERVER_IP:$DOCKER_NAME/innovate-admin/</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ssh</span> <span class="hljs-string">-o</span> <span class="hljs-string">&quot;StrictHostKeyChecking no&quot;</span> <span class="hljs-string">-i</span> <span class="hljs-string">id_rsa</span> <span class="hljs-string">root@$SERVER_IP</span> <span class="hljs-string">&quot;cd $DOCKER_NAME/innovate-admin/;docker-compose</span><br><span class="hljs-string">      -f docker-compose.yml pull;docker-compose -f docker-compose.yml up -d;exit&quot;</span><br><span class="hljs-attr">notifications:</span><br>  <span class="hljs-attr">email:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">biaogejiushibiao@outlook.com</span><br>  <span class="hljs-attr">on_success:</span> <span class="hljs-string">change</span><br>  <span class="hljs-attr">on_failure:</span> <span class="hljs-string">always</span><br><span class="hljs-attr">before_install:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">openssl</span> <span class="hljs-string">aes-256-cbc</span> <span class="hljs-string">-K</span> <span class="hljs-string">$encrypted_1687bb340939_key</span> <span class="hljs-string">-iv</span> <span class="hljs-string">$encrypted_1687bb340939_iv</span><br>  <span class="hljs-string">-in</span> <span class="hljs-string">id_rsa.enc</span> <span class="hljs-string">-out</span> <span class="hljs-string">~\/.ssh/id_rsa</span> <span class="hljs-string">-d</span><br><br></code></pre></td></tr></table></figure></details><br><p>根据自己项目需要来进行编写，更多选项参考<a href="https://docs.travis-ci.com/user/tutorial/">官方文档</a></p><h1 id="提交部署"><a href="#提交部署" class="headerlink" title="提交部署"></a>提交部署</h1><p>提交代码即可完成自动部署工作</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/travis-ci-run-success.png" alt="avatar"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://docs.travis-ci.com/">官方文档</a><br><a href="http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html">持续集成服务 Travis CI 教程</a></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CD/CI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>I/O多路复用之select、poll和epoll的区别</title>
    <link href="/2020/12/03/linux/Select%20poll%E5%92%8Cepoll%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2020/12/03/linux/Select%20poll%E5%92%8Cepoll%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h1><ul><li><p>首先，我们明确一个概念，Linux所谓的用户态和内核态，本质是对CPU提供的功能的一层封装抽象。现代CPU，其设计目标主要是为了完美高效的实现一个多任务系统，多任务系统的三个核心特征是：权限分级、数据隔离和任务切换。<br>以X86_64架构为例，权限分级通过CPU的多模式机制和分段机制实现，数据隔离通过分页机制实现，任务切换通过中断机制和任务机制（TR/TSS）实现。</p></li><li><p>然后，给内核态和用户态一个相对精确的概念定义。内核态和用户态的概念，是Linux为了有效实现CPU的权限分级和数据隔离的目标而出现的，是通过组合CPU的分段机制+分页机制而形成的。<br>还是以X86_64架构为例，在当CPU处于保护模式下时（X86_64CPU有5种模式，保护模式是其中之一，此时CPU.CR0.PE=1），当CPU.CS=系统代码段时（CS.CPL=0）为内核态，此时通过CPU的指令有操控全部寄存器的权限（包括FLAGS和CR寄存器），<br>当CPU.CS=用户代码段时（CS.CPL=3）为用户态，此时通过CPU的指令只有操控部分寄存器的权限。</p></li><li><p>所谓“一个进程主动跳进内核态”，是指该进程中的一个执行线程通过INT或者SYSCALL指令，使得当前线程的CS=系统代码段（这里还有不同的细节，不多说了）。</p></li><li><p>每个用户进程都有自己的虚拟地址空间，用户进程之间切换的时候，通过切换页表（CR3）来实现，不用改CS寄存器和DS寄存器。所以没有“代码映射在0-3G”一说。<br>就像班级名称和学号，同样的学号在不同的班级代表不同的人，同样的虚拟地址在不同的页表中代表不同的物理内存空间。</p></li><li><p>内核态允许多个用户线程同时进入，不存在阻塞的现象，尤其是多核CPU的情况下。</p></li><li><p>除了用户线程可以进入内核态之外，还有内核线程，即内核自己要干的事情，这种线程只运行在内核态。</p></li></ul><br><p>从CPU的寄存器视角看，指令运行所处的三种CPU状态<br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/keylin-1.jpg" alt="img"></p><p>从Linux线程角度看，指令运行所处的两种状态（要么属于某线程，要么黑色切换中)<br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/keylin-2.jpg" alt="img"></p><p>Linux下，线程类型*CPU状态决定数据空间<br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/keylin-3.jpg" alt="img"></p><br><p><a href="https://www.zhihu.com/question/397142622/answer/1246315406">Linux用户态和内核态怎么理解？ - 知乎</a></p><h1 id="Linux-I-O模型"><a href="#Linux-I-O模型" class="headerlink" title="Linux I/O模型"></a>Linux I/O模型</h1><p><a href="https://blog.csdn.net/z_ryan/article/details/80873449">Linux五种IO模型</a></p><p><a href="https://www.cnblogs.com/luyucheng/p/6249551.html">Linux下常见的IO模型</a></p><h1 id="select模型"><a href="#select模型" class="headerlink" title="select模型"></a>select模型</h1><blockquote><p>epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现</p></blockquote><p>select本质上是通过<code>设置或者检查存放fd标志位的数据结构</code>来进行下一步处理。这样所带来的缺点是：</p><p>1、 单个进程可监视的fd数量被限制，即能监听端口的大小有限。</p><pre><code>  一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.</code></pre><p>2、 对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低：</p><pre><code>   当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</code></pre><p>3、需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大</p><p><code>fd</code>全称是file descriptor,是进程独有的文件描述符表的索引</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/select-process.png" alt="avatar"></p><h1 id="poll-模型"><a href="#poll-模型" class="headerlink" title="poll 模型"></a>poll 模型</h1><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p><p>它没有最大连接数的限制，原因是它是基于<code>链表</code>来存储的，但是同样有一个缺点：</p><p>1、大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。                   </p><p>2、poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</p><h1 id="epoll模型"><a href="#epoll模型" class="headerlink" title="epoll模型"></a>epoll模型</h1><p>epoll有EPOLLLT和EPOLLET两种触发模式，LT是默认的模式，ET是“高速”模式。LT模式下，只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作，而在ET（边缘触发）模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无 论fd中是否还有数据可读。所以在ET模式下，read一个fd的时候一定要把它的buffer读光，也就是说一直读到read的返回值小于请求值，或者 遇到EAGAIN错误。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。</p><p>epoll为什么要有EPOLLET触发模式？</p><p>如果采用EPOLLLT模式的话，系统中一旦有大量你不需要读写的就绪文件描述符，它们每次调用epoll_wait都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率.。而采用EPOLLET这种边沿触发模式的话，当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你！！！这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符</p><p>epoll的优点</p><p>1、没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；<br>2、效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；<br>即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</p><p>3、 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/epoll-process.png" alt="avatar"></p><h1 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h1><p>1、支持一个进程所能打开的最大连接数</p><p>select</p><blockquote><p>单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是3232，同理64位机器上FD_SETSIZE为3264），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。</p></blockquote><p>poll</p><blockquote><p>poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的</p></blockquote><p>epoll</p><blockquote><p>虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接</p></blockquote><p>2、FD剧增后带来的IO效率问题</p><p>select</p><blockquote><p>因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。</p></blockquote><p>poll</p><blockquote><p>同上</p></blockquote><p>epoll</p><blockquote><p>因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。</p></blockquote><p>3、 消息传递方式</p><p>select</p><blockquote><p>内核需要将消息传递到用户空间，都需要内核拷贝动作</p></blockquote><p>poll</p><blockquote><p>同上</p></blockquote><p>epoll</p><blockquote><p>epoll通过内核和用户空间共享一块内存来实现的。</p></blockquote><p><strong>总结</strong></p><p>综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点。</p><p>1、表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</p><p>2、select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善</p><h1 id="底层代码"><a href="#底层代码" class="headerlink" title="底层代码"></a>底层代码</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs text">EPOLL(7)                                                                                  Linux Programmer&#x27;s Manual                                                                                  EPOLL(7)<br><br>NAME<br>       epoll - I/O event notification facility<br><br>SYNOPSIS<br>       #include &lt;sys/epoll.h&gt;<br><br>DESCRIPTION<br>       The  epoll  API  performs a similar task to poll(2): monitoring multiple file descriptors to see if I/O is possible on any of them.  The epoll API can be used either as an edge-triggered or a level-<br>       triggered interface and scales well to large numbers of watched file descriptors.  The following system calls are provided to create and manage an epoll instance:<br><br>       *  epoll_create(2) creates a new epoll instance and returns a file descriptor referring to that instance.  (The more recent epoll_create1(2) extends the functionality of epoll_create(2).)<br><br>       *  Interest in particular file descriptors is then registered via epoll_ctl(2).  The set of file descriptors currently registered on an epoll instance is sometimes called an epoll set.<br><br>       *  epoll_wait(2) waits for I/O events, blocking the calling thread if no events are currently available.<br><br>   Level-triggered and edge-triggered<br>       The epoll event distribution interface is able to behave both as edge-triggered (ET) and as level-triggered (LT).  The difference between the two mechanisms can be  described  as  follows.   Suppose<br>       that this scenario happens:<br><br>       1. The file descriptor that represents the read side of a pipe (rfd) is registered on the epoll instance.<br><br>       2. A pipe writer writes 2 kB of data on the write side of the pipe.<br><br>       3. A call to epoll_wait(2) is done that will return rfd as a ready file descriptor.<br><br>       4. The pipe reader reads 1 kB of data from rfd.<br><br>       5. A call to epoll_wait(2) is done.<br><br>       If the rfd file descriptor has been added to the epoll interface using the EPOLLET (edge-triggered) flag, the call to epoll_wait(2) done in step 5 will probably hang despite the available data still<br>       present in the file input buffer; meanwhile the remote peer might be expecting a response based on the data it already sent.  The reason for this is that edge-triggered  mode  delivers  events  only<br>       when  changes occur on the monitored file descriptor.  So, in step 5 the caller might end up waiting for some data that is already present inside the input buffer.  In the above example, an event on<br>       rfd will be generated because of the write done in 2 and the event is consumed in 3.  Since the read operation done in 4 does not consume the whole buffer data, the call  to  epoll_wait(2)  done  in<br>       step 5 might block indefinitely.<br><br>       An application that employs the EPOLLET flag should use nonblocking file descriptors to avoid having a blocking read or write starve a task that is handling multiple file descriptors.  The suggested<br>       way to use epoll as an edge-triggered (EPOLLET) interface is as follows:<br><br>              i   with nonblocking file descriptors; and<br><br>              ii  by waiting for an event only after read(2) or write(2) return EAGAIN.<br><br>       By contrast, when used as a level-triggered interface (the default, when EPOLLET is not specified), epoll is simply a faster poll(2), and can be used wherever the latter is used since it shares  the<br>       same semantics.<br><br>       Since  even  with edge-triggered epoll, multiple events can be generated upon receipt of multiple chunks of data, the caller has the option to specify the EPOLLONESHOT flag, to tell epoll to disable<br>       the associated file descriptor after the receipt of an event with epoll_wait(2).  When the EPOLLONESHOT flag is specified, it is the caller&#x27;s  responsibility  to  rearm  the  file  descriptor  using<br>       epoll_ctl(2) with EPOLL_CTL_MOD.<br><br>   Interaction with autosleep<br>       If  the system is in autosleep mode via /sys/power/autosleep and an event happens which wakes the device from sleep, the device driver will keep the device awake only until that event is queued.  To<br>       keep the device awake until the event has been processed, it is necessary to use the epoll_ctl(2) EPOLLWAKEUP flag.<br><br>       When the EPOLLWAKEUP flag is set in the events field for a struct epoll_event, the system will be kept awake from the moment the event is queued, through the epoll_wait(2)  call  which  returns  the<br>       event until the subsequent epoll_wait(2) call.  If the event should keep the system awake beyond that time, then a separate wake_lock should be taken before the second epoll_wait(2) call.<br><br>   /proc interfaces<br>       The following interfaces can be used to limit the amount of kernel memory consumed by epoll:<br><br>       /proc/sys/fs/epoll/max_user_watches (since Linux 2.6.28)<br>              This  specifies  a  limit  on  the  total  number  of file descriptors that a user can register across all epoll instances on the system.  The limit is per real user ID.  Each registered file<br>              descriptor costs roughly 90 bytes on a 32-bit kernel, and roughly 160 bytes on a 64-bit kernel.  Currently, the default value for max_user_watches is 1/25 (4%) of the  available  low  memory,<br>              divided by the registration cost in bytes.<br><br>   Example for suggested usage<br>       While the usage of epoll when employed as a level-triggered interface does have the same semantics as poll(2), the edge-triggered usage requires more clarification to avoid stalls in the application<br>       event loop.  In this example, listener is a nonblocking socket on which listen(2) has been called.  The function do_use_fd() uses the new ready file descriptor until EAGAIN  is  returned  by  either<br>       read(2)  or write(2).  An event-driven state machine application should, after having received EAGAIN, record its current state so that at the next call to do_use_fd() it will continue to read(2) or<br>       write(2) from where it stopped before.<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs cgo">           #define MAX_EVENTS 10<br>           struct epoll_event ev, events[MAX_EVENTS];<br>           int listen_sock, conn_sock, nfds, epollfd;<br><br>           &#x2F;* Code to set up listening socket, &#39;listen_sock&#39;,<br>              (socket(), bind(), listen()) omitted *&#x2F;<br><br>           epollfd &#x3D; epoll_create1(0);<br>           if (epollfd &#x3D;&#x3D; -1) &#123;<br>               perror(&quot;epoll_create1&quot;);<br>               exit(EXIT_FAILURE);<br>           &#125;<br><br>           ev.events &#x3D; EPOLLIN;<br>           ev.data.fd &#x3D; listen_sock;<br>           if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &amp;ev) &#x3D;&#x3D; -1) &#123;<br>               perror(&quot;epoll_ctl: listen_sock&quot;);<br>               exit(EXIT_FAILURE);<br>           &#125;<br><br>           for (;;) &#123;<br>               nfds &#x3D; epoll_wait(epollfd, events, MAX_EVENTS, -1);<br>               if (nfds &#x3D;&#x3D; -1) &#123;<br>                   perror(&quot;epoll_wait&quot;);<br>                   exit(EXIT_FAILURE);<br>               &#125;<br><br>               for (n &#x3D; 0; n &lt; nfds; ++n) &#123;<br>                   if (events[n].data.fd &#x3D;&#x3D; listen_sock) &#123;<br>                       conn_sock &#x3D; accept(listen_sock,<br>                                          (struct sockaddr *) &amp;addr, &amp;addrlen);<br>                       if (conn_sock &#x3D;&#x3D; -1) &#123;<br>                           perror(&quot;accept&quot;);<br>                           exit(EXIT_FAILURE);<br>                       &#125;<br>                       setnonblocking(conn_sock);<br>                       ev.events &#x3D; EPOLLIN | EPOLLET;<br>                       ev.data.fd &#x3D; conn_sock;<br>                       if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock,<br>                                   &amp;ev) &#x3D;&#x3D; -1) &#123;<br>                           perror(&quot;epoll_ctl: conn_sock&quot;);<br>                           exit(EXIT_FAILURE);<br>                       &#125;<br>                   &#125; else &#123;<br>                       do_use_fd(events[n].data.fd);<br>                   &#125;<br>               &#125;<br>           &#125;<br>&#96;&#96;&#96; <br><br>&#96;&#96;&#96;text<br>       When used as an edge-triggered interface, for performance reasons, it is possible to add the file descriptor inside the epoll interface (EPOLL_CTL_ADD) once by specifying  (EPOLLIN|EPOLLOUT).   This<br>       allows you to avoid continuously switching between EPOLLIN and EPOLLOUT calling epoll_ctl(2) with EPOLL_CTL_MOD.<br><br>   Questions and answers<br>       Q0  What is the key used to distinguish the file descriptors registered in an epoll set?<br><br>       A0  The key is the combination of the file descriptor number and the open file description (also known as an &quot;open file handle&quot;, the kernel&#39;s internal representation of an open file).<br><br>       Q1  What happens if you register the same file descriptor on an epoll instance twice?<br><br>       A1  You will probably get EEXIST.  However, it is possible to add a duplicate (dup(2), dup2(2), fcntl(2) F_DUPFD) file descriptor to the same epoll instance.  This can be a useful technique for fil‐<br>           tering events, if the duplicate file descriptors are registered with different events masks.<br><br>       Q2  Can two epoll instances wait for the same file descriptor?  If so, are events reported to both epoll file descriptors?<br><br>       A2  Yes, and events would be reported to both.  However, careful programming may be needed to do this correctly.<br><br>       Q3  Is the epoll file descriptor itself poll&#x2F;epoll&#x2F;selectable?<br><br>       A3  Yes.  If an epoll file descriptor has events waiting, then it will indicate as being readable.<br><br>       Q4  What happens if one attempts to put an epoll file descriptor into its own file descriptor set?<br><br>       A4  The epoll_ctl(2) call fails (EINVAL).  However, you can add an epoll file descriptor inside another epoll file descriptor set.<br><br>       Q5  Can I send an epoll file descriptor over a UNIX domain socket to another process?<br><br>       A5  Yes, but it does not make sense to do this, since the receiving process would not have copies of the file descriptors in the epoll set.<br><br>       Q6  Will closing a file descriptor cause it to be removed from all epoll sets automatically?<br><br>       A6  Yes, but be aware of the following point.  A file descriptor is a reference to an open file description (see open(2)).  Whenever a file descriptor is duplicated  via  dup(2),  dup2(2),  fcntl(2)<br>           F_DUPFD,  or  fork(2),  a new file descriptor referring to the same open file description is created.  An open file description continues to exist until all file descriptors referring to it have<br>           been closed.  A file descriptor is removed from an epoll set only after all the file descriptors referring to the underlying open file description  have  been  closed  (or  before  if  the  file<br>           descriptor  is  explicitly  removed using epoll_ctl(2) EPOLL_CTL_DEL).  This means that even after a file descriptor that is part of an epoll set has been closed, events may be reported for that<br>           file descriptor if other file descriptors referring to the same underlying file description remain open.<br><br>       Q7  If more than one event occurs between epoll_wait(2) calls, are they combined or reported separately?<br><br>       A7  They will be combined.<br><br>       Q8  Does an operation on a file descriptor affect the already collected but not yet reported events?<br><br>       A8  You can do two operations on an existing file descriptor.  Remove would be meaningless for this case.  Modify will reread available I&#x2F;O.<br><br>       Q9  Do I need to continuously read&#x2F;write a file descriptor until EAGAIN when using the EPOLLET flag (edge-triggered behavior) ?<br><br>       A9  Receiving an event from epoll_wait(2) should suggest to you that such file descriptor is ready for the requested I&#x2F;O  operation.   You  must  consider  it  ready  until  the  next  (nonblocking)<br>           read&#x2F;write yields EAGAIN.  When and how you will use the file descriptor is entirely up to you.<br><br>           For packet&#x2F;token-oriented files (e.g., datagram socket, terminal in canonical mode), the only way to detect the end of the read&#x2F;write I&#x2F;O space is to continue to read&#x2F;write until EAGAIN.<br><br>           For  stream-oriented  files (e.g., pipe, FIFO, stream socket), the condition that the read&#x2F;write I&#x2F;O space is exhausted can also be detected by checking the amount of data read from &#x2F; written to<br>           the target file descriptor.  For example, if you call read(2) by asking to read a certain amount of data and read(2) returns a lower number of bytes, you can be sure of having exhausted the read<br>           I&#x2F;O  space  for  the  file  descriptor.  The same is true when writing using write(2).  (Avoid this latter technique if you cannot guarantee that the monitored file descriptor always refers to a<br>           stream-oriented file.)<br><br>   Possible pitfalls and ways to avoid them<br>       o Starvation (edge-triggered)<br><br>       If there is a large amount of I&#x2F;O space, it is possible that by trying to drain it the other files will not get processed causing starvation.  (This problem is not specific to epoll.)<br><br>       The solution is to maintain a ready list and mark the file descriptor as ready in its associated data structure, thereby allowing the application to remember which files need  to  be  processed  but<br>       still round robin amongst all the ready files.  This also supports ignoring subsequent events you receive for file descriptors that are already ready.<br><br>       o If using an event cache...<br><br>       If  you use an event cache or store all the file descriptors returned from epoll_wait(2), then make sure to provide a way to mark its closure dynamically (i.e., caused by a previous event&#39;s process‐<br>       ing).  Suppose you receive 100 events from epoll_wait(2), and in event #47 a condition causes event #13 to be closed.  If you remove the structure and close(2) the file  descriptor  for  event  #13,<br>       then your event cache might still say there are events waiting for that file descriptor causing confusion.<br><br>       One  solution  for this is to call, during the processing of event 47, epoll_ctl(EPOLL_CTL_DEL) to delete file descriptor 13 and close(2), then mark its associated data structure as removed and link<br>       it to a cleanup list.  If you find another event for file descriptor 13 in your batch processing, you will discover the file descriptor had been previously removed and there will be no confusion.<br><br>VERSIONS<br>       The epoll API was introduced in Linux kernel 2.5.44.  Support was added to glibc in version 2.3.2.<br><br>CONFORMING TO<br>       The epoll API is Linux-specific.  Some other systems provide similar mechanisms, for example, FreeBSD has kqueue, and Solaris has &#x2F;dev&#x2F;poll.<br><br>NOTES<br>       The set of file descriptors that is being monitored via an epoll file descriptor can be viewed via the entry for the epoll file descriptor in the process&#39;s &#x2F;proc&#x2F;[pid]&#x2F;fdinfo directory.  See proc(5)<br>       for further details.<br><br>       The kcmp(2) KCMP_EPOLL_TFD operation can be used to test whether a file descriptor is present in an epoll instance.<br><br>SEE ALSO<br>       epoll_create(2), epoll_create1(2), epoll_ctl(2), epoll_wait(2), poll(2), select(2)<br><br>COLOPHON<br>       This  page  is  part  of  release  4.15  of  the  Linux  man-pages  project.   A  description  of  the project, information about reporting bugs, and the latest version of this page, can be found at<br>       https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;man-pages&#x2F;.<br><br>Linux                                                                                             2017-09-15                                                                                         EPOLL(7)<br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/sunweiye/p/11172751.html">select、poll和epoll的区别</a></p><p><a href="https://www.cnblogs.com/zhaodahai/p/6831456.html">linux下select/poll/epoll机制的比较</a></p><p><a href="https://www.cnblogs.com/aspirant/p/9166944.html">select、poll、epoll之间的区别(搜狗面试)</a></p><p><a href="https://blog.csdn.net/nanxiaotao/article/details/90612404">select、poll、epoll的原理与区别</a></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>I/O</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tomcat组件架构</title>
    <link href="/2020/12/02/java/Tomcat%E7%BB%84%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    <url>/2020/12/02/java/Tomcat%E7%BB%84%E4%BB%B6%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Tomcat总体架构"><a href="#Tomcat总体架构" class="headerlink" title="Tomcat总体架构"></a>Tomcat总体架构</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/tomcat-framework.png" alt="img"></p><table>    <tr>        <td>组件名称</td>        <td>说明</td>    </tr>    <tr>        <td>Server</td>        <td>表示整个Servlet容器，因此Tomcat运行环境中只有唯一一个Servlet实例</td>    </tr>    <tr>        <td>Service</td>        <td>Service表示一个或者多个Connector的集合，这些Connector共享同一个Container来处理其请求。在同一个Tomcat实例内可以包含任意多个Service实例，他们相互独立</td>    </tr>      <tr>        <td>Connector</td>        <td>即Tomcat链接器，用于监听并转化Socker请求，同时将读取的Socket请求交由Container处理，支持不同协议以及不同I/O方式</td>    </tr>    <tr>        <td>Container</td>        <td>Container表示能够执行客户端请求并返回响应的一类对象。在Tomcat中存在不同级别的容器：Engine、Host、Context、Wrapper</td>    </tr>      <tr>        <td>Engine</td>        <td>表示整个Servlet引擎。在Tomcat中，Engine为最高层的容器对象。尽管Engine不是</td>    </tr>    <tr>        <td>Host</td>        <td>Host作为一类容器，表示Servlet引擎(即Engine)中的虚拟机，与一个服务器的网络名有关，如域名等。客户端可以使用这个网络名连接服务器，真个名称必须要在DNS服务器上注册</td>    </tr>      <tr>        <td>Context</td>        <td>Context作为一类容器，用于表示ServletContent，在Servlet规范中，一个ServletContext即表示一个独立的Web应用。</td>    </tr>    <tr>        <td>Wrapper</td>        <td>Wrapper作为一类容器，用于表示Web应用中定义的Servlet</td>    </tr>        <tr>        <td>Executor</td>        <td>表示Tomcat组件可以共享的线程池</td>    </tr></table><h1 id="Tomcat-应用服务器启动"><a href="#Tomcat-应用服务器启动" class="headerlink" title="Tomcat 应用服务器启动"></a>Tomcat 应用服务器启动</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/tomcat-start.png" alt="img"></p><h1 id="Tomcat-请求处理"><a href="#Tomcat-请求处理" class="headerlink" title="Tomcat 请求处理"></a>Tomcat 请求处理</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/tomcat-request.png" alt="img"></p><h1 id="Tomcat-类加载器"><a href="#Tomcat-类加载器" class="headerlink" title="Tomcat 类加载器"></a>Tomcat 类加载器</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/tomcat-classloader.png" alt="img"></p><p>除每个Web的类加载器外，Tomcat也提供了3个基础的类加载器和Web应用类加载器，而且这三个类加载器指向的路径和包列表均可以由<code>catalina.properties</code>配置。</p><ul><li>Common: 以System为父加载器，是位于Tomcat应用服务器顶层的公用类加载器。其路径为<code>common.loader</code>，默认指向$CATALINA_HOME/lib下的包。</li><li>Catalina: 以Common为父加载器，是用于加载Tomcat应用服务器的类加载器，其路径为<code>server.loader</code>，默认为空，此时Tomcat使用Common类加载器加载应用资源。</li><li>Shared: 以Common为父加载器，是所有Web应用的父加载器，其路径为<code>shared.loader</code>,默认为空。此时Tomcat使用<code>Common</code>类加载器作为Web应用的父加载器。</li><li>Web应用: 以Shard为父加载器，加载<code>/WEB-INF/classs</code>目录下的未压缩的Class和资源文件以及<code>/WEB-INF/lib</code>目录下的Jar包。如前所示，该类加载器只对当前Web应用可见，对其他应用均不可见。</li></ul><br><p>Java默认类加载机制</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">从缓存中加载<br>如果缓存中没有，则从父类加载器中加载。<br>如果父类加载器没有，则从当前类加载器加载<br>如果没有则抛出异常<br></code></pre></td></tr></table></figure><p>Tomcat的加载机制稍有不同<code>首先尝试通过当前类加载器加载，然后才进行委派</code></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">从缓存中加载<br>如果没有，则从JVM的Bootstrap类加载器加载。<br>如果没有，则从当前类加载器加载(按照WEB-INF/classes、WEB-INF/lib的顺序)<br>如果没有，则从父类加载器加载，由于父类加载器采用的默认的委派模式，所以加载顺序为System、Common、Shared<br></code></pre></td></tr></table></figure><p>Tomcat提供了delegate属性用于控制是否启用Java委派模式，默认为false，当为true时启用</p><p><strong>作用</strong></p><blockquote><p><code>Tomcat通过该机制实现了为WEB应用中的Jar包覆盖服务器提供包的目的</code>，Java核心类库，Servlet规范相关类库是无法覆盖的，此外Java默认的诸多XML工具包，由于位于Jvm的Bootstrap类加载器也无法覆盖，只能通过endorsed的方式实现。</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="">Tomcat架构解析.刘光瑞</a></p><p><a href="https://www.cnblogs.com/biaogejiushibiao/p/10397354.html">简单实现HttpServer服务器</a></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tomcat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法篇-Dijkstra算法</title>
    <link href="/2020/12/02/algorithm/%E7%AE%97%E6%B3%95%E7%AF%87-Dijkstra%E7%AE%97%E6%B3%95/"/>
    <url>/2020/12/02/algorithm/%E7%AE%97%E6%B3%95%E7%AF%87-Dijkstra%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="迪克斯特拉算法"><a href="#迪克斯特拉算法" class="headerlink" title="迪克斯特拉算法"></a>迪克斯特拉算法</h1><p>迪杰斯特拉算法(Dijkstra)是由荷兰计算机科学家<code>狄克斯特</code>拉于1959 年提出的，因此又叫狄克斯特拉算法。是从一个顶点到其余各顶点的最短路径算法，解决的是<code>有权图中最短路径</code>问题。</p><p>迪杰斯特拉算法主要特点是</p><blockquote><p>从起始点开始，采用<code>贪心算法</code>的策略，<code>每次遍历到始点距离最近且未访问过的顶点的邻接节点，更新始点到其距离，直到扩展到终点为止</code>。</p></blockquote><h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><p>按路径长度递增次序产生算法：</p><p>把顶点集合V分成两组： </p><ul><li>S：已求出的顶点的集合（初始时只含有源点V0） </li><li>V-S=T：尚未确定的顶点集合 </li></ul><p>将T中顶点按递增的次序加入到S中，保证： </p><ul><li>从源点V0到S中其他各顶点的长度都不大于从V0到T中任何顶点的最短路径长度  </li><li>每个顶点对应一个距离值 </li></ul><p>S中顶点：从V0到此顶点的长度<br>T中顶点：从V0到此顶点的只包括S中顶点作中间顶点的最短路径长度  </p><p>依据：可以证明V0到T中顶点Vk的，或是从V0到Vk的直接路径的权值；或是从V0经S中顶点到Vk的路径权值之和。（反证法可证）</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/dijkstra-1.gif" alt="img"></p><h1 id="求最短路径步骤"><a href="#求最短路径步骤" class="headerlink" title="求最短路径步骤"></a>求最短路径步骤</h1><p>G={V,E}</p><ol><li><p>初始时令 S={V0},T=V-S={其余顶点}，T中顶点对应的距离值,若存在&lt;V0,Vi&gt;，d(V0,Vi)为&lt;V0,Vi&gt;弧上的权值,若不存在&lt;V0,Vi&gt;，d(V0,Vi)为∞ </p></li><li><p>从T中选取一个与S中顶点有关联边且权值最小的顶点W，加入到S中  </p></li><li><p>对其余T中顶点的距离值进行修改：若加进W作中间顶点，从V0到Vi的距离值缩短，则修改此距离值,重复上述步骤2、3，直到S  中包含所有顶点，即W=Vi为止 </p></li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><details>  <summary><span>展开代码</span></summary>  <br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure></details><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/lbperfect123/article/details/84281300">Dijkstra算法图文详解</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最短路径</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Servlet生命周期</title>
    <link href="/2020/12/02/java/Servlet%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2020/12/02/java/Servlet%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Servlet-生命周期"><a href="#Servlet-生命周期" class="headerlink" title="Servlet 生命周期"></a>Servlet 生命周期</h1><p>Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：</p><ul><li>Servlet 初始化后调用 <strong>init ()</strong> 方法。</li><li>Servlet 调用 <strong>service()</strong> 方法来处理客户端的请求。</li><li>Servlet 销毁前调用 <strong>destroy()</strong> 方法。</li><li>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。</li></ul><p>现在让我们详细讨论生命周期的方法。</p><h2 id="init-方法"><a href="#init-方法" class="headerlink" title="init() 方法"></a>init() 方法</h2><p>init 方法被设计成只调用一次。它在第一次创建 Servlet 时被调用，在后续每次用户请求时不再调用。因此，它是用于一次性初始化，就像 Applet 的 init 方法一样。</p><p>Servlet 创建于用户第一次调用对应于该 Servlet 的 URL 时，但是您也可以指定 Servlet 在服务器第一次启动时被加载。</p><p>当用户调用一个 Servlet 时，就会创建一个 Servlet 实例，每一个用户请求都会产生一个新的线程，适当的时候移交给 doGet 或 doPost 方法。init() 方法简单地创建或加载一些数据，这些数据将被用于 Servlet 的整个生命周期。</p><p>init 方法的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>  <span class="hljs-comment">// 初始化代码...</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="service-方法"><a href="#service-方法" class="headerlink" title="service() 方法"></a>service() 方法</h2><p>service() 方法是执行实际任务的主要方法。Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。</p><p>每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service() 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut，doDelete 等方法。</p><p>下面是该方法的特征：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> service(ServletRequest request, <br>                    ServletResponse response) <br>      <span class="hljs-keyword">throws</span> ServletException, IOException&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>service() 方法由容器调用，service 方法在适当的时候调用 doGet、doPost、doPut、doDelete 等方法。所以，您不用对 service() 方法做任何动作，您只需要根据来自客户端的请求类型来重写 doGet() 或 doPost() 即可。</p><p>doGet() 和 doPost() 方法是每次服务请求中最常用的方法。下面是这两种方法的特征。</p><h2 id="doGet-方法"><a href="#doGet-方法" class="headerlink" title="doGet() 方法"></a>doGet() 方法</h2><p>GET 请求来自于一个 URL 的正常请求，或者来自于一个未指定 METHOD 的 HTML 表单，它由 doGet() 方法处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request,</span></span><br><span class="hljs-function"><span class="hljs-params">                  HttpServletResponse response)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>    <span class="hljs-comment">// Servlet 代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="doPost-方法"><a href="#doPost-方法" class="headerlink" title="doPost() 方法"></a>doPost() 方法</h2><p>POST 请求来自于一个特别指定了 METHOD 为 POST 的 HTML 表单，它由 doPost() 方法处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest request,</span></span><br><span class="hljs-function"><span class="hljs-params">                   HttpServletResponse response)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>    <span class="hljs-comment">// Servlet 代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="destroy-方法"><a href="#destroy-方法" class="headerlink" title="destroy() 方法"></a>destroy() 方法</h2><p>destroy() 方法只会被调用一次，在 Servlet 生命周期结束时被调用。destroy() 方法可以让您的 Servlet 关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动。</p><p>在调用 destroy() 方法之后，servlet 对象被标记为垃圾回收。destroy 方法定义如下所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">destroy</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-comment">// 终止化代码...</span><br>&#125;<br></code></pre></td></tr></table></figure><table>    <tr>        <td><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/servlet-class.png" alt="img"><br>        </td><br>        <td><br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/generic-servlet.png" alt="img"><br>        </td><br>    </tr></p></table><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p>下图显示了一个典型的 Servlet 生命周期方案。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/Servlet-LifeCycle.jpg" alt="img"></p><ul><li>第一个到达服务器的 HTTP 请求被委派到 Servlet 容器。</li><li>Servlet 容器在调用 service() 方法之前加载 Servlet。</li><li>然后 Servlet 容器处理由多个线程产生的多个请求，每个线程执行一个单一的 Servlet 实例的 service() 方法。</li></ul><h1 id="Servlet-源码"><a href="#Servlet-源码" class="headerlink" title="Servlet 源码"></a>Servlet 源码</h1><details>  <summary><span>展开</span></summary>  <br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Source code recreated from a .class file by IntelliJ IDEA</span><br><span class="hljs-comment">// (powered by Fernflower decompiler)</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-keyword">package</span> javax.servlet.http;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.text.MessageFormat;<br><span class="hljs-keyword">import</span> java.util.Enumeration;<br><span class="hljs-keyword">import</span> java.util.ResourceBundle;<br><span class="hljs-keyword">import</span> javax.servlet.GenericServlet;<br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.ServletOutputStream;<br><span class="hljs-keyword">import</span> javax.servlet.ServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.ServletResponse;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericServlet</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String METHOD_DELETE = <span class="hljs-string">&quot;DELETE&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String METHOD_HEAD = <span class="hljs-string">&quot;HEAD&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String METHOD_GET = <span class="hljs-string">&quot;GET&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String METHOD_OPTIONS = <span class="hljs-string">&quot;OPTIONS&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String METHOD_POST = <span class="hljs-string">&quot;POST&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String METHOD_PUT = <span class="hljs-string">&quot;PUT&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String METHOD_TRACE = <span class="hljs-string">&quot;TRACE&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String HEADER_IFMODSINCE = <span class="hljs-string">&quot;If-Modified-Since&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String HEADER_LASTMOD = <span class="hljs-string">&quot;Last-Modified&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String LSTRING_FILE = <span class="hljs-string">&quot;javax.servlet.http.LocalStrings&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ResourceBundle lStrings = ResourceBundle.getBundle(<span class="hljs-string">&quot;javax.servlet.http.LocalStrings&quot;</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpServlet</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        String protocol = req.getProtocol();<br>        String msg = lStrings.getString(<span class="hljs-string">&quot;http.method_get_not_supported&quot;</span>);<br>        <span class="hljs-keyword">if</span> (protocol.endsWith(<span class="hljs-string">&quot;1.1&quot;</span>)) &#123;<br>            resp.sendError(<span class="hljs-number">405</span>, msg);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            resp.sendError(<span class="hljs-number">400</span>, msg);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getLastModified</span><span class="hljs-params">(HttpServletRequest req)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1L</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doHead</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        NoBodyResponse response = <span class="hljs-keyword">new</span> NoBodyResponse(resp);<br>        <span class="hljs-keyword">this</span>.doGet(req, response);<br>        response.setContentLength();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        String protocol = req.getProtocol();<br>        String msg = lStrings.getString(<span class="hljs-string">&quot;http.method_post_not_supported&quot;</span>);<br>        <span class="hljs-keyword">if</span> (protocol.endsWith(<span class="hljs-string">&quot;1.1&quot;</span>)) &#123;<br>            resp.sendError(<span class="hljs-number">405</span>, msg);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            resp.sendError(<span class="hljs-number">400</span>, msg);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPut</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        String protocol = req.getProtocol();<br>        String msg = lStrings.getString(<span class="hljs-string">&quot;http.method_put_not_supported&quot;</span>);<br>        <span class="hljs-keyword">if</span> (protocol.endsWith(<span class="hljs-string">&quot;1.1&quot;</span>)) &#123;<br>            resp.sendError(<span class="hljs-number">405</span>, msg);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            resp.sendError(<span class="hljs-number">400</span>, msg);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doDelete</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        String protocol = req.getProtocol();<br>        String msg = lStrings.getString(<span class="hljs-string">&quot;http.method_delete_not_supported&quot;</span>);<br>        <span class="hljs-keyword">if</span> (protocol.endsWith(<span class="hljs-string">&quot;1.1&quot;</span>)) &#123;<br>            resp.sendError(<span class="hljs-number">405</span>, msg);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            resp.sendError(<span class="hljs-number">400</span>, msg);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Method[] getAllDeclaredMethods(Class&lt;? extends HttpServlet&gt; c) &#123;<br>        Class&lt;?&gt; clazz = c;<br><br>        Method[] allMethods;<br>        <span class="hljs-keyword">for</span>(allMethods = <span class="hljs-keyword">null</span>; !clazz.equals(HttpServlet.class); clazz = clazz.getSuperclass()) &#123;<br>            Method[] thisMethods = clazz.getDeclaredMethods();<br>            <span class="hljs-keyword">if</span> (allMethods != <span class="hljs-keyword">null</span> &amp;&amp; allMethods.length &gt; <span class="hljs-number">0</span>) &#123;<br>                Method[] subClassMethods = allMethods;<br>                allMethods = <span class="hljs-keyword">new</span> Method[thisMethods.length + allMethods.length];<br>                System.arraycopy(thisMethods, <span class="hljs-number">0</span>, allMethods, <span class="hljs-number">0</span>, thisMethods.length);<br>                System.arraycopy(subClassMethods, <span class="hljs-number">0</span>, allMethods, thisMethods.length, subClassMethods.length);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                allMethods = thisMethods;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> allMethods != <span class="hljs-keyword">null</span> ? allMethods : <span class="hljs-keyword">new</span> Method[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doOptions</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        Method[] methods = <span class="hljs-keyword">this</span>.getAllDeclaredMethods(<span class="hljs-keyword">this</span>.getClass());<br>        <span class="hljs-keyword">boolean</span> ALLOW_GET = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">boolean</span> ALLOW_HEAD = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">boolean</span> ALLOW_POST = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">boolean</span> ALLOW_PUT = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">boolean</span> ALLOW_DELETE = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">boolean</span> ALLOW_TRACE = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">boolean</span> ALLOW_OPTIONS = <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; methods.length; ++i) &#123;<br>            String methodName = methods[i].getName();<br>            <span class="hljs-keyword">if</span> (methodName.equals(<span class="hljs-string">&quot;doGet&quot;</span>)) &#123;<br>                ALLOW_GET = <span class="hljs-keyword">true</span>;<br>                ALLOW_HEAD = <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (methodName.equals(<span class="hljs-string">&quot;doPost&quot;</span>)) &#123;<br>                ALLOW_POST = <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (methodName.equals(<span class="hljs-string">&quot;doPut&quot;</span>)) &#123;<br>                ALLOW_PUT = <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (methodName.equals(<span class="hljs-string">&quot;doDelete&quot;</span>)) &#123;<br>                ALLOW_DELETE = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br><br>        StringBuilder allow = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">if</span> (ALLOW_GET) &#123;<br>            allow.append(<span class="hljs-string">&quot;GET&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (ALLOW_HEAD) &#123;<br>            <span class="hljs-keyword">if</span> (allow.length() &gt; <span class="hljs-number">0</span>) &#123;<br>                allow.append(<span class="hljs-string">&quot;, &quot;</span>);<br>            &#125;<br><br>            allow.append(<span class="hljs-string">&quot;HEAD&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (ALLOW_POST) &#123;<br>            <span class="hljs-keyword">if</span> (allow.length() &gt; <span class="hljs-number">0</span>) &#123;<br>                allow.append(<span class="hljs-string">&quot;, &quot;</span>);<br>            &#125;<br><br>            allow.append(<span class="hljs-string">&quot;POST&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (ALLOW_PUT) &#123;<br>            <span class="hljs-keyword">if</span> (allow.length() &gt; <span class="hljs-number">0</span>) &#123;<br>                allow.append(<span class="hljs-string">&quot;, &quot;</span>);<br>            &#125;<br><br>            allow.append(<span class="hljs-string">&quot;PUT&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (ALLOW_DELETE) &#123;<br>            <span class="hljs-keyword">if</span> (allow.length() &gt; <span class="hljs-number">0</span>) &#123;<br>                allow.append(<span class="hljs-string">&quot;, &quot;</span>);<br>            &#125;<br><br>            allow.append(<span class="hljs-string">&quot;DELETE&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (ALLOW_TRACE) &#123;<br>            <span class="hljs-keyword">if</span> (allow.length() &gt; <span class="hljs-number">0</span>) &#123;<br>                allow.append(<span class="hljs-string">&quot;, &quot;</span>);<br>            &#125;<br><br>            allow.append(<span class="hljs-string">&quot;TRACE&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (ALLOW_OPTIONS) &#123;<br>            <span class="hljs-keyword">if</span> (allow.length() &gt; <span class="hljs-number">0</span>) &#123;<br>                allow.append(<span class="hljs-string">&quot;, &quot;</span>);<br>            &#125;<br><br>            allow.append(<span class="hljs-string">&quot;OPTIONS&quot;</span>);<br>        &#125;<br><br>        resp.setHeader(<span class="hljs-string">&quot;Allow&quot;</span>, allow.toString());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doTrace</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        String CRLF = <span class="hljs-string">&quot;\r\n&quot;</span>;<br>        StringBuilder buffer = (<span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;TRACE &quot;</span>)).append(req.getRequestURI()).append(<span class="hljs-string">&quot; &quot;</span>).append(req.getProtocol());<br>        Enumeration reqHeaderEnum = req.getHeaderNames();<br><br>        <span class="hljs-keyword">while</span>(reqHeaderEnum.hasMoreElements()) &#123;<br>            String headerName = (String)reqHeaderEnum.nextElement();<br>            buffer.append(CRLF).append(headerName).append(<span class="hljs-string">&quot;: &quot;</span>).append(req.getHeader(headerName));<br>        &#125;<br><br>        buffer.append(CRLF);<br>        <span class="hljs-keyword">int</span> responseLength = buffer.length();<br>        resp.setContentType(<span class="hljs-string">&quot;message/http&quot;</span>);<br>        resp.setContentLength(responseLength);<br>        ServletOutputStream out = resp.getOutputStream();<br>        out.print(buffer.toString());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        String method = req.getMethod();<br>        <span class="hljs-keyword">long</span> lastModified;<br>        <span class="hljs-keyword">if</span> (method.equals(<span class="hljs-string">&quot;GET&quot;</span>)) &#123;<br>            lastModified = <span class="hljs-keyword">this</span>.getLastModified(req);<br>            <span class="hljs-keyword">if</span> (lastModified == -<span class="hljs-number">1L</span>) &#123;<br>                <span class="hljs-keyword">this</span>.doGet(req, resp);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">long</span> ifModifiedSince = req.getDateHeader(<span class="hljs-string">&quot;If-Modified-Since&quot;</span>);<br>                <span class="hljs-keyword">if</span> (ifModifiedSince &lt; lastModified) &#123;<br>                    <span class="hljs-keyword">this</span>.maybeSetLastModified(resp, lastModified);<br>                    <span class="hljs-keyword">this</span>.doGet(req, resp);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    resp.setStatus(<span class="hljs-number">304</span>);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(<span class="hljs-string">&quot;HEAD&quot;</span>)) &#123;<br>            lastModified = <span class="hljs-keyword">this</span>.getLastModified(req);<br>            <span class="hljs-keyword">this</span>.maybeSetLastModified(resp, lastModified);<br>            <span class="hljs-keyword">this</span>.doHead(req, resp);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(<span class="hljs-string">&quot;POST&quot;</span>)) &#123;<br>            <span class="hljs-keyword">this</span>.doPost(req, resp);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(<span class="hljs-string">&quot;PUT&quot;</span>)) &#123;<br>            <span class="hljs-keyword">this</span>.doPut(req, resp);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(<span class="hljs-string">&quot;DELETE&quot;</span>)) &#123;<br>            <span class="hljs-keyword">this</span>.doDelete(req, resp);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(<span class="hljs-string">&quot;OPTIONS&quot;</span>)) &#123;<br>            <span class="hljs-keyword">this</span>.doOptions(req, resp);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(<span class="hljs-string">&quot;TRACE&quot;</span>)) &#123;<br>            <span class="hljs-keyword">this</span>.doTrace(req, resp);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            String errMsg = lStrings.getString(<span class="hljs-string">&quot;http.method_not_implemented&quot;</span>);<br>            Object[] errArgs = <span class="hljs-keyword">new</span> Object[]&#123;method&#125;;<br>            errMsg = MessageFormat.format(errMsg, errArgs);<br>            resp.sendError(<span class="hljs-number">501</span>, errMsg);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">maybeSetLastModified</span><span class="hljs-params">(HttpServletResponse resp, <span class="hljs-keyword">long</span> lastModified)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!resp.containsHeader(<span class="hljs-string">&quot;Last-Modified&quot;</span>)) &#123;<br>            <span class="hljs-keyword">if</span> (lastModified &gt;= <span class="hljs-number">0L</span>) &#123;<br>                resp.setDateHeader(<span class="hljs-string">&quot;Last-Modified&quot;</span>, lastModified);<br>            &#125;<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest req, ServletResponse res)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-keyword">if</span> (req <span class="hljs-keyword">instanceof</span> HttpServletRequest &amp;&amp; res <span class="hljs-keyword">instanceof</span> HttpServletResponse) &#123;<br>            HttpServletRequest request = (HttpServletRequest)req;<br>            HttpServletResponse response = (HttpServletResponse)res;<br>            <span class="hljs-keyword">this</span>.service(request, response);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletException(<span class="hljs-string">&quot;non-HTTP request or response&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></details><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/javaloveiphone/article/details/8154791">servlet的执行原理与生命周期</a></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法篇-BFPRT算法</title>
    <link href="/2020/11/30/algorithm/%E7%AE%97%E6%B3%95%E7%AF%87-BFPRT%E7%AE%97%E6%B3%95/"/>
    <url>/2020/11/30/algorithm/%E7%AE%97%E6%B3%95%E7%AF%87-BFPRT%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><blockquote><p>中位数的中位数算法</p></blockquote><p>在一堆数中求其前 k 大或前 k 小的问题，简称 TOP-K 问题。而目前解决 TOP-K 问题最有效的算法即是 <strong>BFPRT 算法</strong>，又称为<strong>中位数的中位数算法</strong>，该算法由 Blum、Floyd、Pratt、Rivest、Tarjan 提出，最坏时间复杂度为 <code>O(n)</code>。</p><p>在首次接触 TOP-K 问题时，我们的第一反应就是可以先对所有数据进行一次排序，然后取其前 k 即可，但是这么做有两个问题：</p><ol><li>快速排序的平均复杂度为 <code>O(nlogn)</code>，但最坏时间复杂度为 <code>O(n^2)</code>，不能始终保证较好的复杂度；</li><li>我们只需要前 k 大的，而对其余不需要的数也进行了排序，浪费了大量排序时间。</li></ol><p>除这种方法之外，堆排序也是一个比较好的选择，可以维护一个大小为 k 的堆，时间复杂度为 <code>O(nlogk)</code>。</p><p>那是否还存在更有效的方法呢？我们来看下 BFPRT 算法的做法。</p><p><strong>在快速排序的基础上</strong>，首先通过判断主元位置与k的大小使递归的规模变小，其次通过修改快速排序中<strong>主元的选取方法</strong>来降低快速排序在<strong>最坏情况下的时间复杂度</strong>。</p><p>下面先来简单回顾下快速排序的过程，以升序为例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 选取主元；<br><span class="hljs-bullet">2.</span> 以选取的主元为分界点，把小于主元的放在左边，大于主元的放在右边；<br><span class="hljs-bullet">3.</span> 分别对左边和右边进行递归，重复上述过程。<br></code></pre></td></tr></table></figure><h1 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h1><p>BFPRT 算法步骤如下：</p><blockquote><p>1.将序列中所有元素按5个元素一组进行划分，最后一组可能少于5个元素，对每一组元素进行插入排序选出中间的元素即为中位数；</p></blockquote><blockquote><p>2.对所有中位数重复步骤1，即对中位数进行分组，求得它们的中位数；重复此步骤，直到只有一个中位数；</p></blockquote><blockquote><p>3.遍历序列，得到该中位数的下标；</p></blockquote><blockquote><p>4.以该中位数作为pivot，对序列进行Partion划分过程，返回划分后的中位数的下标；</p></blockquote><blockquote><p>5.根据下标得出当前中位数是第X小元素，判断X是否等于K，若是则表明该中位数即为第K小元素，返回下标；否则，判断X是否大于K，若是，则从中位数左边的元素中找出第K小元素；否则，从中位数右边的元素中找出第K-x小元素（因为经过Partion后，中位数左边的元素都小于等于该中位数）。</p></blockquote><p>下面为代码实现，其所求为<strong>前 k 小的数</strong>：</p><details>  <summary><span>代码</span></summary>  <br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs cgo">#include &lt;iostream&gt;<br>using namespace std;<br> <br>&#x2F;&#x2F; 插入排序  <br>void insertSort(int R[], int low, int high) &#123;<br>int i, j, tmp;<br>for (i &#x3D; low + 1; i &lt;&#x3D; high; ++i) &#123;<br>tmp &#x3D; R[i];<br>j &#x3D; i - 1;<br>while (j &gt;&#x3D; low &amp;&amp; R[j] &gt; tmp) &#123;<br>R[j + 1] &#x3D; R[j];<br>--j;<br>&#125;<br>R[j + 1] &#x3D; tmp;<br>&#125;<br>&#125;<br> <br>&#x2F;&#x2F; 递归寻找中位数的中位数  <br>int FindMid(int R[], int low, int high) &#123;<br>&#x2F;&#x2F; 只有一个元素<br>if (low &#x3D;&#x3D; high) &#123;<br>return R[low];<br>&#125;<br>int i, k;<br>&#x2F;&#x2F; 将序列划分为5个元素一组，分别求取中位数<br>for (i &#x3D; low; i + 4 &lt;&#x3D; high; i +&#x3D; 5) &#123;<br>insertSort(R, i, i + 4);<br>k &#x3D; i - low;<br>&#x2F;&#x2F; 将中位数交换到前面<br>swap(R[low + k &#x2F; 5], R[i + 2]);<br>&#125;<br>int n &#x3D; high - i + 1;<br>&#x2F;&#x2F; 最后一组不足5个元素<br>if (n &gt; 0) &#123;<br>insertSort(R, i, high);<br>k &#x3D; i - low;<br>swap(R[low + k &#x2F; 5], R[i + n &#x2F; 2]);<br>&#125;<br>k &#x3D; k &#x2F; 5;<br>&#x2F;&#x2F; 只有一个中位数<br>if (k &#x3D;&#x3D; 0) &#123;<br>return R[low];<br>&#125;<br>return FindMid(R, low, low + k);<br>&#125;<br> <br>&#x2F;&#x2F; 寻找中位数的所在位置  <br>int FindId(int R[], int low, int high, int median) &#123;<br>for (int i &#x3D; low; i &lt;&#x3D; high; ++i) &#123;<br>if (median &#x3D;&#x3D; R[i]) &#123;<br>return i;<br>&#125;<br>&#125;<br>return -1;<br>&#125;<br> <br>&#x2F;&#x2F;进行划分过程  <br>int Partion(int R[], int low, int high, int index) &#123;<br>if (low &lt;&#x3D; high) &#123;<br>&#x2F;&#x2F; 将中位数与第1个元素交换<br>swap(R[index], R[low]);<br>int tmp &#x3D; R[low];<br>int i &#x3D; low, j &#x3D; high;<br>&#x2F;&#x2F; 将小于中位数的元素交换到中位数的左边，大于中位数的元素交换到中位数的右边<br>while (i !&#x3D; j) &#123;<br>while (j &gt; i&amp;&amp;R[j] &gt;&#x3D; tmp) &#123;<br>--j;<br>&#125;<br>R[i] &#x3D; R[j];<br>while (i &lt; j&amp;&amp;R[i] &lt;&#x3D; tmp) &#123;<br>++i;<br>&#125;<br>R[j] &#x3D; R[i];<br>&#125;<br>R[i] &#x3D; tmp;<br>return i;<br>&#125;<br>return -1;<br>&#125;<br> <br>int BFPTR(int R[], int low, int high, int K)&#123;<br>&#x2F;&#x2F; 中位数<br>int median &#x3D; FindMid(R, low, high);<br>&#x2F;&#x2F; 中位数下标<br>int index &#x3D; FindId(R, low, high, median);<br>&#x2F;&#x2F; 划分，得到中位数新的下标<br>int newIndex &#x3D; Partion(R, low, high, index);<br>&#x2F;&#x2F; 中位数在当前序列[low..high]中的位置<br>int rank &#x3D; newIndex - low + 1;<br>if (rank &#x3D;&#x3D; K) &#123;<br>&#x2F;&#x2F; 中位数是第K小元素<br>&#x2F;&#x2F; 左边的K个元素（包括中位数）为Top-K<br>&#x2F;&#x2F; 返回中位数下标<br>return newIndex;<br>&#125;<br>else if (rank &gt; K) &#123;<br>return BFPTR(R, low, newIndex - 1, K);<br>&#125;<br>return BFPTR(R, newIndex + 1, high, K - rank);<br>&#125;<br></code></pre></td></tr></table></figure></details><br><details>  <summary><span>代码测试</span></summary>  <br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cgo">int main(int argc, char** argv)<br>&#123;<br>    const int N &#x3D; 12;<br>    int i;<br>    int R[] &#x3D; &#123; 12, 1, 8, 10, 6, 2, 5, 9, 11, 3, 4, 7 &#125;;<br>    cout &lt;&lt; &quot;原始数据：&quot;;<br>    for (i &#x3D; 0; i &lt; N; ++i)<br>    &#123;<br>        cout &lt;&lt; R[i] &lt;&lt; &quot; &quot;;<br>    &#125;<br>    cout &lt;&lt; endl &lt;&lt; endl;<br>    int K, index;<br>    int R1[N];<br>    for (int t &#x3D; 1; t &lt;&#x3D; 12; ++t)<br>    &#123;<br>        K &#x3D; t;<br>        for (i &#x3D; 0; i &lt; N; ++i)<br>        &#123;<br>            R1[i] &#x3D; R[i];<br>        &#125;<br>        index &#x3D; BFPTR(R1, 0, N - 1, K);<br>        cout &lt;&lt; &quot;处理后的数据：&quot;;<br>        for (i &#x3D; 0; i &lt; N; ++i)<br>        &#123;<br>            cout &lt;&lt; R1[i] &lt;&lt; &quot; &quot;;<br>        &#125;<br>        cout &lt;&lt; endl;<br>        cout &lt;&lt; &quot;第&quot; &lt;&lt; K &lt;&lt; &quot;小元素：&quot; &lt;&lt; R1[index] &lt;&lt; endl;<br>        cout &lt;&lt; &quot;Top-&quot; &lt;&lt; K &lt;&lt; &quot; 的数据：&quot;;<br>        &#x2F;&#x2F; 对Top-K元素进行排序，方便查看<br>        insertSort(R1, index - K + 1, index);<br>        for (i &#x3D; index - K + 1; i &lt;&#x3D; index; ++i)<br>        &#123;<br>            cout &lt;&lt; R1[i] &lt;&lt; &quot; &quot;;<br>        &#125;<br>        cout &lt;&lt; endl &lt;&lt; endl;<br>    &#125;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行如下：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs tap">原始数据：12<span class="hljs-number"> 1 </span>8<span class="hljs-number"> 10 </span>6<span class="hljs-number"> 2 </span>5<span class="hljs-number"> 9 </span>11<span class="hljs-number"> 3 </span>4 7<br> <br>处理后的数据：1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>6<span class="hljs-number"> 5 </span>7<span class="hljs-number"> 12 </span>9<span class="hljs-number"> 11 </span>10 8<br>第1小元素：1<br>Top-1 的数据：1<br> <br>处理后的数据：1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>6<span class="hljs-number"> 5 </span>7<span class="hljs-number"> 12 </span>9<span class="hljs-number"> 11 </span>10 8<br>第2小元素：2<br>Top-2 的数据：1 2<br> <br>处理后的数据：1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>6<span class="hljs-number"> 5 </span>7<span class="hljs-number"> 12 </span>9<span class="hljs-number"> 11 </span>10 8<br>第3小元素：3<br>Top-3 的数据：1<span class="hljs-number"> 2 </span>3<br> <br>处理后的数据：3<span class="hljs-number"> 2 </span>1<span class="hljs-number"> 4 </span>6<span class="hljs-number"> 5 </span>7<span class="hljs-number"> 12 </span>9<span class="hljs-number"> 11 </span>10 8<br>第4小元素：4<br>Top-4 的数据：1<span class="hljs-number"> 2 </span>3 4<br> <br>处理后的数据：3<span class="hljs-number"> 2 </span>1<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 6 </span>7<span class="hljs-number"> 12 </span>9<span class="hljs-number"> 11 </span>10 8<br>第5小元素：5<br>Top-5 的数据：1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5<br> <br>处理后的数据：3<span class="hljs-number"> 2 </span>1<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 6 </span>7<span class="hljs-number"> 12 </span>9<span class="hljs-number"> 11 </span>10 8<br>第6小元素：6<br>Top-6 的数据：1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5 6<br> <br>处理后的数据：1<span class="hljs-number"> 5 </span>4<span class="hljs-number"> 6 </span>3<span class="hljs-number"> 2 </span>7<span class="hljs-number"> 12 </span>9<span class="hljs-number"> 11 </span>10 8<br>第7小元素：7<br>Top-7 的数据：1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 6 </span>7<br> <br>处理后的数据：1<span class="hljs-number"> 5 </span>4<span class="hljs-number"> 6 </span>3<span class="hljs-number"> 2 </span>7<span class="hljs-number"> 8 </span>9<span class="hljs-number"> 10 </span>11 12<br>第8小元素：8<br>Top-8 的数据：1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 6 </span>7 8<br> <br>处理后的数据：1<span class="hljs-number"> 5 </span>4<span class="hljs-number"> 6 </span>3<span class="hljs-number"> 2 </span>7<span class="hljs-number"> 8 </span>9<span class="hljs-number"> 10 </span>11 12<br>第9小元素：9<br>Top-9 的数据：1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 6 </span>7<span class="hljs-number"> 8 </span>9<br> <br>处理后的数据：1<span class="hljs-number"> 5 </span>4<span class="hljs-number"> 6 </span>3<span class="hljs-number"> 2 </span>7<span class="hljs-number"> 8 </span>9<span class="hljs-number"> 10 </span>11 12<br>第10小元素：10<br>Top-10 的数据：1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 6 </span>7<span class="hljs-number"> 8 </span>9 10<br> <br>处理后的数据：1<span class="hljs-number"> 5 </span>4<span class="hljs-number"> 6 </span>3<span class="hljs-number"> 2 </span>7<span class="hljs-number"> 8 </span>9<span class="hljs-number"> 10 </span>11 12<br>第11小元素：11<br>Top-11 的数据：1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 6 </span>7<span class="hljs-number"> 8 </span>9<span class="hljs-number"> 10 </span>11<br> <br>处理后的数据：1<span class="hljs-number"> 5 </span>4<span class="hljs-number"> 6 </span>3<span class="hljs-number"> 2 </span>7<span class="hljs-number"> 8 </span>9<span class="hljs-number"> 10 </span>11 12<br>第12小元素：12<br>Top-12 的数据：1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 6 </span>7<span class="hljs-number"> 8 </span>9<span class="hljs-number"> 10 </span>11 12<br></code></pre></td></tr></table></figure></details><h1 id="时间复杂"><a href="#时间复杂" class="headerlink" title="时间复杂"></a>时间复杂</h1><p>BFPRT 算法在最坏情况下的时间复杂度是 O(n)，下面予以证明。令 T(n) 为所求的时间复杂度，则有：</p><p><code>T(n)≤T(n 5)+T(&#123;7n&#125;&#123;10&#125;)+c⋅n &#123;c 为一个正常数&#125;</code></p><p>其中：</p><ul><li>T(n/5)来自 GetPivotIndex()，n 个元素，5 个一组，共有 ⌊n/5⌋ 个中位数；</li><li>T(7n/10) 来自 BFPRT()，在 ⌊n/5⌋ 个中位数中，主元 x 大于其中 1/2⋅ n/5=n/10 的中位数，而每个中位数在其本来的 5 个数的小组中又大于或等于其中的 3 个数，所以主元 x 至少大于所有数中的 n/10*3=3n/10 个。即划分之后，任意一边的长度至少为 3/10，在最坏情况下，每次选择都选到了 7/10 的那一部分。</li><li>c⋅n 来自其它操作，比如 InsertSort()，以及 GetPivotIndex() 和 Partition() 里所需的一些额外操作。</li></ul><p>其中 c 为一个正常数，故t也是一个正常数，即 T(n)≤10c⋅n，因此 <code>T(n)=O(n)</code>。</p><p>接下来我们再来探讨下 BFPRT 算法为何选 5 作为分组主元，而不是 2, 3, 7, 9 呢？</p><p>首先排除偶数，对于偶数我们很难取舍其中位数，而奇数很容易。再者对于 3 而言，会有 T(n)≤T(\frac n 3)+T({2n}3)+c⋅n，它本身还是操作了 n 个元素，与以 5 为主元的 {9n}{10}10 相比，其复杂度并没有减少。对于 7，9，… 而言，上式中的 10c，其整体都会增加，所以与 5 相比，5 更适合。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="">算法导论</a></li><li><a href="https://en.wikipedia.org/wiki/Median_of_medians">Median of medians</a>.维基百科</li><li><a href="https://blog.csdn.net/qq_40938077/article/details/81213820">bfprt算法解析</a></li><li><a href="https://blog.csdn.net/softimite_zifeng/article/details/77103544">bfprt算法</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试篇-Java面试资料汇总</title>
    <link href="/2020/11/29/interview/%E9%9D%A2%E8%AF%95%E7%AF%87-Java%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/"/>
    <url>/2020/11/29/interview/%E9%9D%A2%E8%AF%95%E7%AF%87-Java%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><details>  <summary><span>2019年中国互联网企业100强名单</span></summary>  <br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs text"><br><br>排名中文名称中文简称主要品牌<br>1阿里巴巴（中国）有限公司阿里巴巴淘宝、阿里云、高德<br>2深圳市腾讯计算机系统有限责任公司腾讯公司微信、QQ、腾讯网<br>3百度公司百度百度、爱奇艺<br>4京东集团京东商城、物流、京东云<br>5浙江蚂蚁小微金融服务集团股份有限公司蚂蚁金服支付宝、相互宝、芝麻信用蚂蚁森林<br>6网易集团网易网易邮箱、网易严选、网易新闻<br>7美团点评美团美团、大众点评、美团外卖、美团买菜<br>8北京字节跳动科技有限公司字节跳动抖音、今日头条<br>9三六零安全科技股份有限公司三六零360安全卫士、360浏览器<br>10新浪公司新浪公司新浪网、微博<br>11上海寻梦信息技术有限公司拼多多拼多多<br>12搜狐公司搜狐搜狐媒体、搜狐视频<br>13北京五八信息技术有限公司58集团58同城、赶集网、安居客<br>14苏宁控股集团有限公司苏宁控股苏宁易购、PP视频<br>15小米集团小米集团小米、米家、米兔<br>16携程计算机技术（上海）有限公司携程旅行网携程旅行网、天巡<br>17用友网络科技股份有限公司用友网络U8c、财务云、精智工业互联网平台<br>18北京猎豹移动科技有限公司猎豹移动猎豹清理大师、AI智能服务机器人<br>19北京车之家信息技术有限公司汽车之家汽车之家、二手车之家<br>20湖南快乐阳光互动娱乐传媒有限公司快乐阳光芒果TV<br>21唯品会（中国）有限公司唯品会唯品会<br>22央视国际网络有限公司央视网央视网、中国IPTV、CCTV手机电视<br>23三七文娱（广州）网络科技有限公司三七互娱37手游、极光网络、37游戏、37Games<br>24北京昆仑万维科技股份有限公司昆仑万维GameArk、闲徕互娱、Grindr<br>25浪潮集团有限公司浪潮浪潮云，天元数据网、爱城市网、一贷通<br>26北京网聘咨询有限公司智联招聘智联招聘<br>27新华网股份有限公司新华网学习进行时、国家相册、思客<br>28人民网股份有限公司人民网中国共产党新闻网、强国论坛、两会进行时<br>29同程旅游集团同程旅游同程旅游、艺龙旅行网<br>30武汉斗鱼网络科技有限公司斗鱼直播斗鱼直播<br>31广州华多网络科技有限公司欢聚时代多玩游戏网、YYLive<br>32网宿科技股份有限公司网宿科技网宿云分发、网宿云、网宿网盾<br>33咪咕文化科技有限公司咪咕文化咪咕视频、咪咕音乐、咪咕阅读<br>34巨人网络集团股份有限公司巨人网络征途系列、仙侠世界系列<br>35贵阳朗玛信息技术股份有限公司朗玛信息39互联网医院、39健康网、39健康智慧家庭<br>36鹏博士电信传媒集团股份有限公司鹏博士鹏博士数据中心、鹏博士云网、长城宽带<br>37上海钢银电子商务股份有限公司钢银电商钢银电商<br>38东方明珠新媒体股份有限公司东方明珠百视通、东方购物、SITV<br>39黑龙江龙采科技集团有限责任公司龙采科技集团龙采、资海、采云平台、龙采智慧云<br>40深圳市迅雷网络技术有限公司迅雷集团迅雷X、迅雷影音、玩客云<br>41易车控股有限公司易车易车网、易鑫集团<br>42四三九九网络股份有限公司43994399小游戏、4399休闲娱乐平台<br>43上海米哈游网络科技股份有限公司米哈游米哈游<br>44完美世界股份有限公司完美世界完美世界游戏、完美世界影视<br>45竞技世界（北京）网络技术有限公司竞技世界JJ比赛<br>46前锦网络信息技术（上海）有限公司前程无忧前程无忧、应届生求职网、51米多多<br>47北京蜜莱坞网络科技有限公司映客直播映客APP、种子视频<br>48无锡华云数据技术服务有限公司华云数据集团华云、CloudUltra®、H2CI™<br>49上海波克城市网络科技股份有限公司波克城市波克城市、捕鱼达人、猫咪公寓<br>50东软集团股份有限公司东软集团Neusoft东软<br>51盛跃网络科技（上海）有限公司盛趣游戏盛趣游戏<br>52科大讯飞股份有限公司科大讯飞讯飞输入法、讯飞翻译机、讯飞听见<br>53优刻得科技股份有限公司优刻得UCloud、优铭云、安全屋<br>54杭州顺网科技股份有限公司顺网科技网维大师、顺网云、顺网游戏<br>55北京光环新网科技股份有限公司光环新网互联网数据中心服务、云计算及相关服务<br>56汇通达网络股份有限公司汇通达超级老板APP、汇通达汇掌柜APP+微商城<br>57深圳市房多多网络科技有限公司房多多房多多<br>58福建网龙计算机网络信息技术有限公司网龙网络公司魔域、英魂之刃、101贝考<br>59美图公司美图美图秀秀、美颜相机、美拍<br>60汇量科技集团汇量科技Mobvista、Mintegral、GameAnalytics<br>61广州多益网络股份有限公司多益网络多益网络、神武、梦想世界<br>62深圳市创梦天地科技有限公司创梦天地乐逗游戏<br>63深圳市梦网科技发展有限公司梦网科技富信RBM、IM云、物联云<br>64上海二三四五网络控股集团股份有限公司二三四五2345网址导航、2345加速浏览器<br>65北京搜房科技发展有限公司房天下房天下网、开发云、家居云<br>66世纪龙信息网络有限责任公司世纪龙（21CN）天翼云盘、189邮箱、21CN门户<br>67游族网络股份有限公司游族网络少年三国志、权力的游戏凛冬将至<br>68河南锐之旗网络科技有限公司锐之旗锐之旗、云和数据<br>69好未来教育科技集团好未来学而思网校<br>70珍岛信息技术（上海）股份有限公司珍岛珍岛、T云、Trueland<br>71杭州边锋网络技术有限公司边锋网络边锋游戏、游戏茶苑<br>72金蝶软件（中国）有限公司金蝶软件金蝶、金蝶云<br>73上海幻电信息科技有限公司哔哩哔哩哔哩哔哩<br>74湖南竞网智赢网络技术有限公司竞网智营销综合服务、网络营销推广服务<br>75北京中钢网信息股份有限公司中钢网中钢网、抢钢宝、现货通<br>76湖南草花互动网络科技有限公司草花互动草花手游平台<br>77北京密境和风科技有限公司花椒直播花椒直播<br>78贝壳找房（北京）科技有限公司贝壳找房贝壳找房<br>79二六三网络通信股份有限公司二六三网络通信263云通信、263企业邮箱、263企业直播<br>80南京途牛科技有限公司途牛途牛旅游网、笛风云、途牛金服<br>81东方财富信息股份有限公司东方财富东方财富网、天天基金网、股吧<br>82拉卡拉支付股份有限公司拉卡拉拉卡拉支付、积分购<br>83厦门吉比特网络技术股份有限公司吉比特《问道》、《问道手游》、《不思议迷宫》<br>84福建乐游网络科技有限公司乐游网络6Y乐游网、乐游App<br>85广州荔支网络技术有限公司荔枝荔枝APP<br>86深圳市岚悦网络科技有限公司中手游中手游<br>87满帮集团满帮货车帮、运满满<br>88山东开创集团股份有限公司开创集团开创、开创云、众创社群、曹操送<br>89厦门翔通动漫有限公司翔通动漫绿豆蛙、酷巴熊等动漫IP<br>90第一视频通信传媒有限公司第一视频集团第一视频网、疯狂体育、中阿卫视<br>91上海东方网股份有限公司东方网翱翔、东方头条、纵相<br>92上海创蓝文化传播有限公司创蓝253短信、空号检测、国际短信<br>93中至数据集团股份有限公司中至数据集团中至长尾广告、中至游戏<br>94行吟信息科技（上海）有限公司小红书小红书APP、小红书之家<br>95湖北盛天网络技术股份有限公司盛天网络易乐游网娱平台、战吧电竞平台<br>96百合佳缘网络集团股份有限公司百合佳缘集团世纪佳缘网、百合网、百合情感<br>97上海找钢网信息科技股份有限公司找钢网钢铁全产业链电商、找钢指数<br>98厦门美柚信息科技有限公司美柚美柚、柚宝宝、柚子街<br>99深圳市思贝克集团有限公司思贝克思贝克、SPEK<br>100山东海看网络科技有限公司 [1] 海看海看IPTV、轻快融媒、海看健康<br></code></pre></td></tr></table></figure></details><p><a href="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/pdf/labuladong%E7%9A%84%E7%AE%97%E6%B3%95%E5%B0%8F%E6%8A%84%E5%AE%98%E6%96%B9%E5%AE%8C%E6%95%B4%E7%89%88.pdf">labuladong的算法小抄官方完整版</a></p><p><a href="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/pdf/JavaGuide%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB%E7%89%88.pdf">JavaGuide面试突击版</a></p><p><a href="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/pdf/%E7%AC%AC%E4%BA%8C%E6%9C%9F%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90.pdf">第二期字节跳动面试题附答案解析</a></p><p><a href="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/pdf/%E7%AC%AC%E4%B8%80%E6%9C%9F%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%86%85%E9%83%A8%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C.pdf">第一期阿里巴巴内部面试参考手册(P5-P7)</a></p><p><a href="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/pdf/SpringBoot%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88.pdf">SpringBoot面试专题及答案.pdf</a></p><p><a href="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/pdf/MySQL55%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88.pdf">MySQL55题及答案</a></p><p><a href="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/pdf/SpringCloud%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88.pdf">SpringCloud面试专题及答案.pdf</a></p><p><a href="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/pdf/redis%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.pdf">redis面试题及答案(上)</a></p><p><a href="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/pdf/1000%E9%81%93%E4%BA%92%E8%81%94%E7%BD%91Java%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E9%A2%98.pdf">1000道互联网Java工程师面试题</a></p><h1 id="面试高频题目"><a href="#面试高频题目" class="headerlink" title="面试高频题目"></a>面试高频题目</h1><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ol><li>Java 中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？</li><li><code>String</code> <code>、 StringBuffer</code> 和 <code>StringBuilder</code> 的区别是什么? <code>String</code> 为什么是不可变的?</li><li>== 与 equals?hashCode 与 equals ?</li><li>Java 反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？</li><li>谈谈对 Java 注解的理解，解决了什么问题？</li><li>Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？</li><li>内部类了解吗？匿名内部类了解吗？</li><li>BIO,NIO,AIO 有什么区别?</li></ol><h3 id="Java-集合框架"><a href="#Java-集合框架" class="headerlink" title="Java 集合框架"></a>Java 集合框架</h3><ol><li>说说 List,Set,Map 三者的区别？三者底层的数据结构？</li><li>有哪些集合是线程不安全的？怎么解决呢？</li><li>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</li><li>HashMap 和 Hashtable 的区别？HashMap 和 HashSet 区别？HashMap 和 TreeMap 区别？</li><li>HashMap 的底层实现</li><li>HashMap 的长度为什么是 2 的幂次方</li><li>ConcurrentHashMap 和 Hashtable 的区别？</li><li>ConcurrentHashMap 线程安全的具体实现方式/底层具体实现</li></ol><h3 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h3><ol><li>jvm 内存结构</li><li>jvm 调优参数</li><li>什么是类加载？何时类加载？类加载流程？</li><li>知道哪些类加载器。类加载器之间的关系？</li><li>类加载器的双亲委派了解么？结合 Tomcat 说一下双亲委派（Tomcat 如何打破双亲委托机制？…）。</li><li><strong>为什么需要双亲委派</strong></li><li>Java 内存模型</li><li>栈中存放什么数据，堆中呢？</li><li>大对象放在哪个内存区域</li><li>堆区如何分类</li><li>垃圾回收有哪些算法</li><li>GC 的全流程</li><li>GC 中老年代用什么回收方法？</li></ol><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ol><li>线程和进程的区别。</li><li>什么是上下文切换?</li><li>什么是线程死锁?如何避免死锁?</li><li>乐观锁和悲观锁了解么？</li><li>说说 <code>sleep()</code> 方法和 <code>wait()</code> 方法区别和共同点?</li><li><strong>Java 线程池有哪些参数？阻塞队列有几种？拒绝策略有几种？新线程添加的流程?</strong></li><li>实现 <code>Runnable</code> 接口和 <code>Callable</code> 接口的区别。</li><li><strong>讲一下 JMM(Java 内存模型)。<code>volatile</code> 关键字解决了什么问题？说说 <code>synchronized</code> 关键字和 <code>volatile</code> 关键字的区别。</strong></li><li><strong>AQS 原理了解么？AQS 组件有哪些？</strong></li><li>用过 CountDownLatch 么？什么场景下用的？</li></ol><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ol><li>OSI 与 TCP/IP 各层的结构与功能,都有哪些协议?为什么网络要分层？</li><li><strong>计算机网络的一些常见状态码</strong></li><li>ping 所使用的协议</li><li><strong>TCP 的三次握手与四次挥手的内容？TCP 为什么连接是三次握手而断开是四次握手？</strong></li><li>TCP 与 UDP 的区别及使用场景</li><li>TCP 是如何保证传输的可靠性？</li><li><strong>一次完整的 HTTP 请求所经的步骤</strong></li><li>HTTP 协议了解么？HTTP 是基于 TCP 还是 UDP 的？</li><li>HTTP 报文的内容简单说一下！HTTP 请求报文和响应报文中有哪些数据？</li><li>HTTP 和 HTTPS 的区别了解么？</li><li>HTTP 请求有哪些常见的状态码？</li><li>HTTP 长连接和短连接了解么？</li><li><strong>Cookie 和 Session 的关系</strong></li><li>URI 和 URL 的区别是什么?</li></ol><h2 id="算法和数据结构"><a href="#算法和数据结构" class="headerlink" title="算法和数据结构"></a>算法和数据结构</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ol><li>LRU 算法了解吗？你能实现一个吗？</li><li>写排序算法（快排、堆排）</li><li>使用数组实现一个栈</li><li>使用数组实现一个队列</li><li>实现一个链表、反转链表、</li><li>……</li></ol><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ol><li>数组 vs 链表</li><li>栈的应用场景</li><li>队列的分类、应用场景</li><li>红黑树的特点、红黑树 vs 二叉查找树</li><li>哈希表、哈希表应用场景</li><li>布隆过滤器了解吗？</li><li>……</li></ol><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ol><li>何为设计模式？有哪些常见的设计模式？</li><li>单例模式了解么？说一下单例模式的使用场景。手写一个单例模式的实现。</li><li>观察者模式了解么？说一下观察者模式的使用场景。</li><li>工厂模式了解么？说一下工厂模式的使用场景。</li><li>责任链模式了解么？哪些开源项目（Netty、MyBatis …）中用到了责任链模式？怎么用的？</li><li>SOLID 原则了解么？简单谈谈自己对于单一职责原则和开闭原则的理解。</li><li>阅读 Spring 源码的时候什么设计模式最让你影响深刻？能简单讲讲吗？</li></ol><h3 id="常见框架"><a href="#常见框架" class="headerlink" title="常见框架"></a>常见框架</h3><h4 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h4><ol><li>什么是 Spring 框架?</li><li>列举一些重要的 Spring 模块？</li><li>谈谈自己对于 Spring IoC 和 AOP 的理解</li><li>Spring Bean 的生命周期说一下</li><li>Spring 中的 bean 的作用域有哪些?</li><li>拦截器和过滤器了解么？</li><li>Spring 动态代理默认用哪一种</li><li>hibernate 和 mybatis 区别</li><li>Spring Boot 和 Spring 的区别</li><li>说出使用 Spring Boot 的主要优点</li><li>什么是 Spring Boot Starter?</li><li>介绍一下<code>@SpringBootApplication</code> 注解</li><li>Spring Boot 的自动配置是如何实现的?</li><li>Spring Boot 支持哪些嵌入式 web 容器？</li></ol><h4 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h4><ol><li>BIO,NIO 和 AIO 有啥区别？</li><li>Netty 是什么？为啥不直接用 NIO 呢?</li><li>为什么要用 Netty？Netty 应用场景了解么？</li><li>介绍一下 Netty 的核心组件？</li><li>Bootstrap 和 ServerBootstrap 了解么？</li><li>NioEventLoopGroup 默认的构造函数会起多少线程？</li><li>Netty 线程模型了解么？</li><li>什么是 TCP 粘包/拆包?有什么解决办法呢？</li><li>Netty 长连接、心跳机制了解么？</li></ol><h3 id="权限认证"><a href="#权限认证" class="headerlink" title="权限认证"></a>权限认证</h3><ol><li>认证 (Authentication) 和授权 (Authorization)的区别是什么？</li><li>什么是 Cookie ? Cookie 的作用是什么?如何在服务端使用 Cookie ?</li><li>Cookie 和 Session 有什么区别？如何使用 Session 进行身份验证？</li><li>如果没有 Cookie 的话 Session 还能用吗？</li><li>为什么 Cookie 无法防止 CSRF 攻击，而 token 可以？</li><li>什么是 Token?什么是 JWT?如何基于 Token 进行身份验证？</li><li>什么是 OAuth 2.0？</li><li>什么是 SSO(单点登录)？</li></ol><h3 id="微服务-分布式"><a href="#微服务-分布式" class="headerlink" title="微服务/分布式"></a>微服务/分布式</h3><h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><p><strong>RPC 基础：</strong></p><ol><li>了解 RPC 吗？有哪些常见的 RPC 框架？</li><li>如果让你自己设计 RPC 框架你会如何设计？</li><li>服务之间的调用为啥不直接用 HTTP 而用 RPC？</li></ol><p><strong>Dubbo:</strong></p><ol><li>Dubbo 了解吗？</li><li>Dubbo 的工作原理了解么？注册中心扮演了什么角色？注册中心挂了可以继续通信吗？</li><li>Dubbo 的负载均衡策略了解么？</li><li>Dubbo 的 spi 机制了解么？带来了啥好处？</li></ol><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><ol><li>为什么要用消息队列?</li><li>对比一下常见的消息队列?</li><li>如何保证消息不被重复消费?</li><li>如何保证消息消费的顺序性?</li></ol><h4 id="分布式-ID"><a href="#分布式-ID" class="headerlink" title="分布式 ID"></a>分布式 ID</h4><ol><li>何为 ID？</li><li>何为分布式 ID？</li><li>一个合格的分布式 ID 需要满足什么要求?</li><li>分布式 ID 常见的生成方法有哪些？（数据库主键自增、数据库的号段模式、UUID、SNOWFLAKE 等等）</li></ol><h4 id="其他-网关、限流…"><a href="#其他-网关、限流…" class="headerlink" title="其他(网关、限流…)"></a>其他(网关、限流…)</h4><ol><li>为什么要网关？</li><li>为什么要用分布式锁？有哪些实现方式？</li><li>限流的算法有哪些？</li><li>什么是服务熔断？什么是服务降级？</li><li>为什么要分布式 id ？分布式 id 生成策略有哪些？</li><li>微服务下为什需要链路追踪系统？</li></ol><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h4><ol><li>非关系型数据库和关系型数据库的区别？</li><li><strong>事务的四大特性了解么?</strong></li><li><strong>MySQL 事务隔离级别？默认是什么级别？</strong></li><li><strong>乐观锁与悲观锁的区别?</strong></li><li>MySQL 数据库两种存储引擎的区别?</li></ol><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><ol><li><strong>为什么索引能提高查询速度?</strong></li><li>聚集索引和非聚集索引的区别？非聚集索引一定回表查询吗?</li><li>索引这么多优点，为什么不对表中的每一个列创建一个索引呢？(使用索引一定能提高查询性能吗?)</li><li><strong>索引底层的数据结构了解么？Hash 索引和 B+树索引优劣分析</strong></li><li>B+树做索引比红黑树好在哪里？</li><li><strong>最左前缀匹配原则了解么？</strong></li><li>什么是覆盖索引</li></ol><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ol><li><strong>分布式缓存常见的技术选型方案有哪些？说一下 Redis 和 Memcached 的区别和共同点</strong></li><li>说一下有缓存情况下查询数据和修改数据的流程。</li><li><strong>Redis 有哪些数据结构？SDS 了解么？</strong></li><li>Redis 内存满了怎么办？</li><li>Redis 内存淘汰算法除了 LRU 还有哪些？</li><li>Redis 给缓存数据设置过期时间有啥用？Redis 是如何判断数据是否过期的呢？</li><li>Redis 事务了解么？(Redis 可以通过 <strong>MULTI，EXEC，DISCARD 和 WATCH</strong> 等命令来实现事务功能)</li><li><strong>缓存穿透和缓存雪崩问题了解么？有哪些解决办法？</strong></li><li>如何基于 Redis 实现分布式锁？</li></ol><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><ol><li>一条 SQL 语句在 MySQL 中如何执行的？</li><li><strong>explain 命令了解么？</strong></li><li>简单说一下 SQL 调优思路。</li><li>简单说一下大表优化的思路。</li><li>分库分表了解么？为什么要分库分表？有哪些常见的分库分表工具(<code>sharding-jdbc</code>、<code>TSharding</code>、<code>MyCAT</code>…)？</li></ol><h2 id="系统设计-场景题"><a href="#系统设计-场景题" class="headerlink" title="系统设计/场景题"></a>系统设计/场景题</h2><ol><li>假如有 10 亿个数，只有一个重复，内存只能放下 5 亿个数，怎么找到这个重复的数字？</li><li>如何设计一个秒杀系统（服务端、数据库、分布式）？分布式系统的设计？</li><li>有一个服务器专门接收大量请求，怎么设计？</li><li>如果让你自己设计 RPC 框架你会如何设计？</li><li>怎么快速出现一个 stackoverflow 错误？</li></ol><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ol><li>自我介绍。</li><li>说说你的项目中的亮点有哪些。</li><li>画一下你的项目的架构图。</li><li>Restful 了解吗？简单说一下自己对它的认识，如果我要返回一个 boolean 类型的数据怎么办？</li></ol>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>资料</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试篇-Spring框架</title>
    <link href="/2020/11/29/interview/%E9%9D%A2%E8%AF%95%E7%AF%87-Spring%E6%A1%86%E6%9E%B6/"/>
    <url>/2020/11/29/interview/%E9%9D%A2%E8%AF%95%E7%AF%87-Spring%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="1、Spring是什么"><a href="#1、Spring是什么" class="headerlink" title="1、Spring是什么?"></a>1、Spring是什么?</h1><blockquote><p>Spring是一个轻量级的IoC和AOP容器框架。是为Java应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。常见的配置方式有三种：基于XML的配置、基于注解的配置、基于Java的配置。</p></blockquote><p>主要由以下几个模块组成：</p><ul><li><p>Spring Core：核心类库，提供IOC服务；</p></li><li><p>Spring Context：提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）；</p></li><li><p>Spring AOP：AOP服务；</p></li><li><p>Spring DAO：对JDBC的抽象，简化了数据访问异常的处理；</p></li><li><p>Spring ORM：对现有的ORM框架的支持；</p></li><li><p>Spring Web：提供了基本的面向Web的综合特性，例如多方文件上传；</p></li><li><p>Spring MVC：提供面向Web应用的Model-View-Controller实现。</p></li></ul><h1 id="2、Spring-的优点？"><a href="#2、Spring-的优点？" class="headerlink" title="2、Spring 的优点？"></a>2、Spring 的优点？</h1><p>（1）spring属于低侵入式设计，代码的污染极低；</p><p>（2）spring的DI机制将对象之间的依赖关系交由框架处理，减低组件的耦合性；</p><p>（3）Spring提供了AOP技术，支持将一些通用任务，如安全、事务、日志、权限等进行集中式管理，从而提供更好的复用。</p><p>（4）spring对于主流的应用框架提供了集成支持。</p><h1 id="3、Spring的AOP理解："><a href="#3、Spring的AOP理解：" class="headerlink" title="3、Spring的AOP理解："></a>3、Spring的AOP理解：</h1><p>OOP面向对象，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p><p>AOP，一般称为面向切面，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理。</p><p>AOP实现的关键在于 代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。</p><p>（1）AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。</p><p>（2）Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p><p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：</p><pre><code>    ①JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例,  生成目标类的代理对象。    ②如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</code></pre><p>（3）静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。</p><p> InvocationHandler 的 invoke(Object  proxy,Method  method,Object[] args)：proxy是最终生成的代理实例;  method 是被代理目标实例的某个具体方法;  args 是被代理目标实例某个方法的具体入参, 在方法反射调用时使用。</p><h1 id="4、Spring的IoC理解："><a href="#4、Spring的IoC理解：" class="headerlink" title="4、Spring的IoC理解："></a>4、Spring的IoC理解：</h1><p>（1）IOC就是控制反转，是指创建对象的控制权的转移，以前创建对象的主动权和时机是由自己把控的，而现在这种权力转移到Spring容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系，对象与对象之间松散耦合，也利于功能的复用。DI依赖注入，和控制反转是同一个概念的不同角度的描述，即 应用程序在运行时依赖IoC容器来动态注入对象需要的外部资源。</p><p>（2）最直观的表达就是，IOC让对象的创建不用去new了，可以由spring自动生产，使用java的反射机制，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法的。</p><p>（3）Spring的IOC有三种注入方式 ：构造器注入、setter方法注入、根据注解注入。</p><p>IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。</p><h1 id="5、BeanFactory和ApplicationContext有什么区别？"><a href="#5、BeanFactory和ApplicationContext有什么区别？" class="headerlink" title="5、BeanFactory和ApplicationContext有什么区别？"></a>5、BeanFactory和ApplicationContext有什么区别？</h1><pre><code>    BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</code></pre><p>（1）BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</p><p>①继承MessageSource，因此支持国际化。</p><p>②统一的资源文件访问方式。</p><p>③提供在监听器中注册bean的事件。</p><p>④同时加载多个配置文件。</p><p>⑤载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</p><p>（2）①BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p><pre><code>    ②ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。    ③相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</code></pre><p>（3）BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</p><p>（4）BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p><h1 id="6、请解释Spring-Bean的生命周期？"><a href="#6、请解释Spring-Bean的生命周期？" class="headerlink" title="6、请解释Spring Bean的生命周期？"></a>6、请解释Spring Bean的生命周期？</h1><p> 首先说一下Servlet的生命周期：实例化，初始init，接收请求service，销毁destroy；</p><p> Spring上下文中的Bean生命周期也类似，如下：</p><p>（1）实例化Bean：</p><p>对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的bean。</p><p>（2）设置对象属性（依赖注入）：</p><p>实例化后的对象被封装在BeanWrapper对象中，紧接着，Spring根据BeanDefinition中的信息 以及 通过BeanWrapper提供的设置属性的接口完成依赖注入。</p><p>（3）处理Aware接口：</p><p>接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给Bean：</p><p>①如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String beanId)方法，此处传递的就是Spring配置文件中Bean的id值；</p><p>②如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory()方法，传递的是Spring工厂自身。</p><p>③如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文；</p><p>（4）BeanPostProcessor：</p><p>如果想对Bean进行一些自定义的处理，那么可以让Bean实现了BeanPostProcessor接口，那将会调用postProcessBeforeInitialization(Object obj, String s)方法。</p><p>（5）InitializingBean 与 init-method：</p><p>如果Bean在Spring配置文件中配置了 init-method 属性，则会自动调用其配置的初始化方法。</p><p>（6）如果这个Bean实现了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法；由于这个方法是在Bean初始化结束时调用的，所以可以被应用于内存或缓存技术；</p><p>以上几个步骤完成后，Bean就已经被正确创建了，之后就可以使用这个Bean了。</p><p>（7）DisposableBean：</p><p>当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的destroy()方法；</p><p>（8）destroy-method：</p><p>最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。</p><h1 id="7、-解释Spring支持的几种bean的作用域。"><a href="#7、-解释Spring支持的几种bean的作用域。" class="headerlink" title="7、 解释Spring支持的几种bean的作用域。"></a>7、 解释Spring支持的几种bean的作用域。</h1><p>Spring容器中的bean可以分为5个范围：</p><p>（1）singleton：默认，每个容器中只有一个bean的实例，单例的模式由BeanFactory自身来维护。</p><p>（2）prototype：为每一个bean请求提供一个实例。</p><p>（3）request：为每一个网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。</p><p>（4）session：与request范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。</p><p>（5）global-session：全局作用域，global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。全局作用域与Servlet中的session作用域效果相同。</p><h1 id="8、Spring框架中的单例Beans是线程安全的么？"><a href="#8、Spring框架中的单例Beans是线程安全的么？" class="headerlink" title="8、Spring框架中的单例Beans是线程安全的么？"></a>8、Spring框架中的单例Beans是线程安全的么？</h1><blockquote><p>Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。<br>但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。<br>如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。最浅显的解决办法就是将多态bean的作用域由“singleton”变更为“prototype”。</p></blockquote><p><a href="https://www.cnblogs.com/myseries/p/11729800.html">参考资料</a></p><ul><li>@Scope(value=”prototype”)</li><li>ThreadLocal</li></ul><h1 id="9、Spring如何处理线程并发问题？"><a href="#9、Spring如何处理线程并发问题？" class="headerlink" title="9、Spring如何处理线程并发问题？"></a>9、Spring如何处理线程并发问题？</h1><p>在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，解决线程安全问题。</p><p>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。</p><p>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p><h1 id="10-1、Spring基于xml注入bean的几种方式："><a href="#10-1、Spring基于xml注入bean的几种方式：" class="headerlink" title="10-1、Spring基于xml注入bean的几种方式："></a>10-1、Spring基于xml注入bean的几种方式：</h1><p>（1）Set方法注入；</p><p>（2）构造器注入：①通过index设置参数的位置；②通过type设置参数类型；</p><p>（3）静态工厂注入；</p><p>（4）实例工厂；</p><p>详细内容可以阅读：<a href="https://blog.csdn.net/a745233700/article/details/89307518">https://blog.csdn.net/a745233700/article/details/89307518</a></p><h1 id="10-2、Spring的自动装配："><a href="#10-2、Spring的自动装配：" class="headerlink" title="10-2、Spring的自动装配："></a>10-2、Spring的自动装配：</h1><p>在spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象，使用autowire来配置自动装载模式。</p><p>在Spring框架xml配置中共有5种自动装配：</p><p>（1）no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。</p><p>（2）byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。 </p><p>（3）byType：通过参数的数据类型进行自动装配。</p><p>（4）constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。</p><p>（5）autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。</p><p>基于注解的方式：</p><p>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config /&gt;。在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：</p><p>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</p><p>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</p><p>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required=false。</p><p>@Autowired可用于：构造函数、成员变量、Setter方法</p><p>注：@Autowired和@Resource之间的区别</p><p>(1) @Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</p><p>(2) @Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</p><h1 id="11、Spring-框架中都用到了哪些设计模式？"><a href="#11、Spring-框架中都用到了哪些设计模式？" class="headerlink" title="11、Spring 框架中都用到了哪些设计模式？"></a>11、Spring 框架中都用到了哪些设计模式？</h1><p>（1）工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；</p><p>（2）单例模式：Bean默认为单例模式。</p><p>（3）代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</p><p>（4）模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</p><p>（5）观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。</p><h1 id="12、Spring事务的实现方式和实现原理："><a href="#12、Spring事务的实现方式和实现原理：" class="headerlink" title="12、Spring事务的实现方式和实现原理："></a>12、Spring事务的实现方式和实现原理：</h1><p>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。</p><p>（1）Spring事务的种类：</p><p>spring支持编程式事务管理和声明式事务管理两种方式：</p><p>①编程式事务管理使用TransactionTemplate。</p><p>②声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p><p>声明式事务最大的优点就是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过@Transactional注解的方式，便可以将事务规则应用到业务逻辑中。</p><p>声明式事务管理要优于编程式事务管理，这正是spring倡导的非侵入式的开发方式，使业务代码不受污染，只要加上注解就可以获得完全的事务支持。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p><p>（2）spring的事务传播行为：</p><p>spring事务的传播行为说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。</p><p>① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p><p>② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。‘</p><p>③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p><p>④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</p><p>⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p><p>⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</p><p>⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</p><p>（3）Spring中的隔离级别：</p><p>① ISOLATION_DEFAULT：这是个 PlatfromTransactionManager 默认的隔离级别，使用数据库默认的事务隔离级别。</p><p>② ISOLATION_READ_UNCOMMITTED：读未提交，允许另外一个事务可以看到这个事务未提交的数据。</p><p>③ ISOLATION_READ_COMMITTED：读已提交，保证一个事务修改的数据提交后才能被另一事务读取，而且能看到该事务对已有记录的更新。</p><p>④ ISOLATION_REPEATABLE_READ：可重复读，保证一个事务修改的数据提交后才能被另一事务读取，但是不能看到该事务对已有记录的更新。</p><p>⑤ ISOLATION_SERIALIZABLE：一个事务在执行的过程中完全看不到其他事务对数据库所做的更新。</p><h1 id="13、Spring框架中有哪些不同类型的事件？"><a href="#13、Spring框架中有哪些不同类型的事件？" class="headerlink" title="13、Spring框架中有哪些不同类型的事件？"></a>13、Spring框架中有哪些不同类型的事件？</h1><p>Spring 提供了以下5种标准的事件：</p><p>（1）上下文更新事件（ContextRefreshedEvent）：在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。</p><p>（2）上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始/重新开始容器时触发该事件。</p><p>（3）上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。</p><p>（4）上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</p><p>（5）请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。</p><p>如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。</p><h1 id="14、解释一下Spring-AOP里面的几个名词："><a href="#14、解释一下Spring-AOP里面的几个名词：" class="headerlink" title="14、解释一下Spring AOP里面的几个名词："></a>14、解释一下Spring AOP里面的几个名词：</h1><p>（1）切面（Aspect）：被抽取的公共模块，可能会横切多个对象。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。</p><p>（2）连接点（Join point）：指方法，在Spring AOP中，一个连接点 总是 代表一个方法的执行。 </p><p>（3）通知（Advice）：在切面的某个特定的连接点（Join point）上执行的动作。通知有各种类型，其中包括“around”、“before”和“after”等通知。许多AOP框架，包括Spring，都是以拦截器做通知模型， 并维护一个以连接点为中心的拦截器链。</p><p>（4）切入点（Pointcut）：切入点是指 我们要对哪些Join point进行拦截的定义。通过切入点表达式，指定拦截的方法，比如指定拦截add<em>、search</em>。</p><p>（5）引入（Introduction）：（也被称为内部类型声明（inter-type declaration））。声明额外的方法或者某个类型的字段。Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用一个引入来使bean实现 IsModified 接口，以便简化缓存机制。</p><p>（6）目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。也有人把它叫做 被通知（adviced） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。</p><p>（7）织入（Weaving）：指把增强应用到目标对象来创建新的代理对象的过程。Spring是在运行时完成织入。</p><p>切入点（pointcut）和连接点（join point）匹配的概念是AOP的关键，这使得AOP不同于其它仅仅提供拦截功能的旧技术。 切入点使得定位通知（advice）可独立于OO层次。 例如，一个提供声明式事务管理的around通知可以被应用到一组横跨多个对象中的方法上（例如服务层的所有业务操作）。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/spring-interview.png" alt="avatar"></p><h1 id="15、Spring通知有哪些类型？"><a href="#15、Spring通知有哪些类型？" class="headerlink" title="15、Spring通知有哪些类型？"></a>15、Spring通知有哪些类型？</h1><p><a href="https://blog.csdn.net/qq_32331073/article/details/80596084">https://blog.csdn.net/qq_32331073/article/details/80596084</a></p><p>（1）前置通知（Before advice）：在某连接点（join point）之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。</p><p>（2）返回后通知（After returning advice）：在某连接点（join point）正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。 </p><p>（3）抛出异常后通知（After throwing advice）：在方法抛出异常退出时执行的通知。 </p><p>（4）后通知（After (finally) advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。 </p><p>（5）环绕通知（Around Advice）：包围一个连接点（join point）的通知，如方法调用。这是最强大的一种通知类型。 环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。 环绕通知是最常用的一种通知类型。大部分基于拦截的AOP框架，例如Nanning和JBoss4，都只提供环绕通知。 </p><p>同一个aspect，不同advice的执行顺序：</p><p>①没有异常情况下的执行顺序：</p><p>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterReturning</p><p>②有异常情况下的执行顺序：</p><p>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterThrowing:异常发生<br>java.lang.RuntimeException: 异常发生</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试篇-Linux系统</title>
    <link href="/2020/11/27/interview/%E9%9D%A2%E8%AF%95%E7%AF%87-Linux%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/11/27/interview/%E9%9D%A2%E8%AF%95%E7%AF%87-Linux%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="Linux-面试题答案解析"><a href="#Linux-面试题答案解析" class="headerlink" title="Linux 面试题答案解析"></a>Linux 面试题答案解析</h2><h3 id="1、绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示-切换目录用什么命令？"><a href="#1、绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示-切换目录用什么命令？" class="headerlink" title="1、绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示? 切换目录用什么命令？"></a>1、绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示? 切换目录用什么命令？</h3><p>答案：</p><p>绝对路径： 如/etc/init.d</p><p>当前目录和上层目录： ./ ../</p><p>主目录： ~/</p><p>切换目录： cd</p><h3 id="2、怎么查看当前进程？怎么执行退出？怎么查看当前路径？"><a href="#2、怎么查看当前进程？怎么执行退出？怎么查看当前路径？" class="headerlink" title="2、怎么查看当前进程？怎么执行退出？怎么查看当前路径？"></a>2、怎么查看当前进程？怎么执行退出？怎么查看当前路径？</h3><p>答案：</p><p>查看当前进程： ps</p><p>执行退出： exit</p><p>查看当前路径： pwd</p><h3 id="3、怎么清屏？怎么退出当前命令？怎么执行睡眠？怎么查看当前用户-id？查看指定帮助用什么命令？"><a href="#3、怎么清屏？怎么退出当前命令？怎么执行睡眠？怎么查看当前用户-id？查看指定帮助用什么命令？" class="headerlink" title="3、怎么清屏？怎么退出当前命令？怎么执行睡眠？怎么查看当前用户 id？查看指定帮助用什么命令？"></a>3、怎么清屏？怎么退出当前命令？怎么执行睡眠？怎么查看当前用户 id？查看指定帮助用什么命令？</h3><p>答案：</p><p>清屏： clear</p><p>退出当前命令： ctrl+c 彻底退出</p><p>执行睡眠 ： ctrl+z 挂起当前进程 fg 恢复后台</p><p>查看当前用户 id： ”id“：查看显示目前登陆账户的 uid 和 gid 及所属分组及用户名</p><p>查看指定帮助： 如 man adduser 这个很全 而且有例子； adduser –help 这个告诉你一些常用参数； info adduesr；</p><h3 id="4、Ls-命令执行什么功能？-可以带哪些参数，有什么区别？"><a href="#4、Ls-命令执行什么功能？-可以带哪些参数，有什么区别？" class="headerlink" title="4、Ls 命令执行什么功能？ 可以带哪些参数，有什么区别？"></a>4、Ls 命令执行什么功能？ 可以带哪些参数，有什么区别？</h3><p>答案：</p><p>ls 执行的功能： 列出指定目录中的目录，以及文件</p><p>哪些参数以及区别： a 所有文件 l 详细信息，包括大小字节数，可读可写可执行的权限等</p><h3 id="5、建立软链接-快捷方式-，以及硬链接的命令。"><a href="#5、建立软链接-快捷方式-，以及硬链接的命令。" class="headerlink" title="5、建立软链接(快捷方式)，以及硬链接的命令。"></a>5、建立软链接(快捷方式)，以及硬链接的命令。</h3><p>答案：</p><p>软链接： ln -s slink source</p><p>硬链接： ln link source</p><h3 id="6、目录创建用什么命令？创建文件用什么命令？复制文件用什么命令？"><a href="#6、目录创建用什么命令？创建文件用什么命令？复制文件用什么命令？" class="headerlink" title="6、目录创建用什么命令？创建文件用什么命令？复制文件用什么命令？"></a>6、目录创建用什么命令？创建文件用什么命令？复制文件用什么命令？</h3><p>答案：</p><p>创建目录： mkdir</p><p>创建文件：典型的如 touch，vi 也可以创建文件，其实只要向一个不存在的文件输出，都会创建文件</p><p>复制文件： cp 7. 文件权限修改用什么命令？格式是怎么样的？</p><p>文件权限修改： chmod</p><p>格式如下：</p><p>chmodu+xfile 给 file 的属主增加执行权限 chmod 751 file 给 file 的属主分配读、写、执行(7)的权限，给 file 的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限</p><p>chmodu=rwx,g=rx,o=xfile 上例的另一种形式 chmod =r file 为所有用户分配读权限</p><p>chmod444file 同上例 chmod a-wx,a+r file 同上例</p><p>$ chmod -R u+r directory 递归地给 directory 目录下所有文件和子目录的属主分配读的权限</p><h3 id="7、查看文件内容有哪些命令可以使用？"><a href="#7、查看文件内容有哪些命令可以使用？" class="headerlink" title="7、查看文件内容有哪些命令可以使用？"></a>7、查看文件内容有哪些命令可以使用？</h3><p>答案：</p><p>vi 文件名 #编辑方式查看，可修改</p><p>cat 文件名 #显示全部文件内容</p><p>more 文件名 #分页显示文件内容</p><p>less 文件名 #与 more 相似，更好的是可以往前翻页</p><p>tail 文件名 #仅查看尾部，还可以指定行数</p><p>head 文件名 #仅查看头部,还可以指定行数</p><h3 id="8、随意写文件命令？怎么向屏幕输出带空格的字符串，比如”hello-world”"><a href="#8、随意写文件命令？怎么向屏幕输出带空格的字符串，比如”hello-world”" class="headerlink" title="8、随意写文件命令？怎么向屏幕输出带空格的字符串，比如”hello world”?"></a>8、随意写文件命令？怎么向屏幕输出带空格的字符串，比如”hello world”?</h3><p>答案：</p><p>写文件命令：vi</p><p>向屏幕输出带空格的字符串:echo hello world</p><h3 id="9、终端是哪个文件夹下的哪个文件？黑洞文件是哪个文件夹下的哪个命令？"><a href="#9、终端是哪个文件夹下的哪个文件？黑洞文件是哪个文件夹下的哪个命令？" class="headerlink" title="9、终端是哪个文件夹下的哪个文件？黑洞文件是哪个文件夹下的哪个命令？"></a>9、终端是哪个文件夹下的哪个文件？黑洞文件是哪个文件夹下的哪个命令？</h3><p>答案：</p><p>终端 /dev/tty</p><p>黑洞文件 /dev/null</p><h3 id="10、移动文件用哪个命令？改名用哪个命令？"><a href="#10、移动文件用哪个命令？改名用哪个命令？" class="headerlink" title="10、移动文件用哪个命令？改名用哪个命令？"></a>10、移动文件用哪个命令？改名用哪个命令？</h3><p>答案：</p><p>mv mv</p><h3 id="11、复制文件用哪个命令？如果需要连同文件夹一块复制呢？如果需要有提示功能呢？"><a href="#11、复制文件用哪个命令？如果需要连同文件夹一块复制呢？如果需要有提示功能呢？" class="headerlink" title="11、复制文件用哪个命令？如果需要连同文件夹一块复制呢？如果需要有提示功能呢？"></a>11、复制文件用哪个命令？如果需要连同文件夹一块复制呢？如果需要有提示功能呢？</h3><p>答案：</p><p>cp -r</p><h3 id="12、删除文件用哪个命令？如果需要连目录及目录下文件一块删除呢？删除空文件夹用什么命令？"><a href="#12、删除文件用哪个命令？如果需要连目录及目录下文件一块删除呢？删除空文件夹用什么命令？" class="headerlink" title="12、删除文件用哪个命令？如果需要连目录及目录下文件一块删除呢？删除空文件夹用什么命令？"></a>12、删除文件用哪个命令？如果需要连目录及目录下文件一块删除呢？删除空文件夹用什么命令？</h3><p>答案：</p><p>rm -r dir</p><h3 id="13、Linux-下命令有哪几种可使用的通配符？分别代表什么含义"><a href="#13、Linux-下命令有哪几种可使用的通配符？分别代表什么含义" class="headerlink" title="13、Linux 下命令有哪几种可使用的通配符？分别代表什么含义?"></a>13、Linux 下命令有哪几种可使用的通配符？分别代表什么含义?</h3><p>答案：</p><p>“？”可替代单个字符。</p><p>“*”可替代任意多个字符。</p><p>方括号“[charset]”可替代 charset 集中的任何单个字符，如[a-z]，[abABC]</p><h3 id="14、用什么命令对一个文件的内容进行统计？-行号、单词数、字节数"><a href="#14、用什么命令对一个文件的内容进行统计？-行号、单词数、字节数" class="headerlink" title="14、用什么命令对一个文件的内容进行统计？(行号、单词数、字节数)"></a>14、用什么命令对一个文件的内容进行统计？(行号、单词数、字节数)</h3><p>答案：</p><p>wc 命令 - c 统计字节数 - l 统计行数 - w 统计字数。</p><h3 id="15、Grep-命令有什么用？-如何忽略大小写？-如何查找不含该串的行"><a href="#15、Grep-命令有什么用？-如何忽略大小写？-如何查找不含该串的行" class="headerlink" title="15、Grep 命令有什么用？ 如何忽略大小写？ 如何查找不含该串的行?"></a>15、Grep 命令有什么用？ 如何忽略大小写？ 如何查找不含该串的行?</h3><p>答案：</p><p>是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。</p><p>grep [stringSTRING] filename grep [^string] filename</p><h3 id="16、Linux-中进程有哪几种状态？在-ps-显示出来的信息中，分别用什么符号表示的？"><a href="#16、Linux-中进程有哪几种状态？在-ps-显示出来的信息中，分别用什么符号表示的？" class="headerlink" title="16、Linux 中进程有哪几种状态？在 ps 显示出来的信息中，分别用什么符号表示的？"></a>16、Linux 中进程有哪几种状态？在 ps 显示出来的信息中，分别用什么符号表示的？</h3><p>答案：</p><p>（1）不可中断状态：进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指进程不响应异步信号。</p><p>（2）暂停状态/跟踪状态：向进程发送一个 SIGSTOP 信号，它就会因响应该信号 而进入 TASK_STOPPED 状态;当进程正在被跟踪时，它处于 TASK_TRACED 这个特殊的状态。正被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。</p><p>（3）就绪状态：在 run_queue 队列里的状态</p><p>（4）运行状态：在 run_queue 队列里的状态</p><p>（5）可中断睡眠状态：处于这个状态的进程因为等待某某事件的发生（比如等待socket 连接、等待信号量），而被挂起</p><p>（6）zombie 状态（僵尸）：父亲没有通过 wait 系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉</p><p>（7）退出状态</p><p>D 不可中断 Uninterruptible（usually IO）</p><p>R 正在运行，或在队列中的进程</p><p>S 处于休眠状态</p><p>T 停止或被追踪</p><p>Z 僵尸进程</p><p>W 进入内存交换（从内核 2.6 开始无效）</p><p>X 死掉的进程</p><h3 id="17、怎么使一个命令在后台运行"><a href="#17、怎么使一个命令在后台运行" class="headerlink" title="17、怎么使一个命令在后台运行?"></a>17、怎么使一个命令在后台运行?</h3><p>答案：</p><p>一般都是使用 &amp; 在命令结尾来让程序自动运行。(命令后可以不追加空格)</p><h3 id="18、利用-ps-怎么显示所有的进程-怎么利用-ps-查看指定进程的信息？"><a href="#18、利用-ps-怎么显示所有的进程-怎么利用-ps-查看指定进程的信息？" class="headerlink" title="18、利用 ps 怎么显示所有的进程? 怎么利用 ps 查看指定进程的信息？"></a>18、利用 ps 怎么显示所有的进程? 怎么利用 ps 查看指定进程的信息？</h3><p>答案：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef (system v 输出)<br>ps -aux bsd 格式输出<br>ps -ef | grep pid<br></code></pre></td></tr></table></figure><h3 id="19、哪个命令专门用来查看后台任务"><a href="#19、哪个命令专门用来查看后台任务" class="headerlink" title="19、哪个命令专门用来查看后台任务?"></a>19、哪个命令专门用来查看后台任务?</h3><p>答案：</p><p>jobs</p><h3 id="20、把后台任务调到前台执行使用什么命令-把停下的后台任务在后台执行起来用什么命令"><a href="#20、把后台任务调到前台执行使用什么命令-把停下的后台任务在后台执行起来用什么命令" class="headerlink" title="20、把后台任务调到前台执行使用什么命令?把停下的后台任务在后台执行起来用什么命令?"></a>20、把后台任务调到前台执行使用什么命令?把停下的后台任务在后台执行起来用什么命令?</h3><p>答案：</p><p>把后台任务调到前台执行 fg</p><p>把停下的后台任务在后台执行起来 bg</p><h3 id="21、终止进程用什么命令-带什么参数"><a href="#21、终止进程用什么命令-带什么参数" class="headerlink" title="21、终止进程用什么命令? 带什么参数?"></a>21、终止进程用什么命令? 带什么参数?</h3><p>答案：</p><p>kill [-s &lt;信息名称或编号&gt;][程序] 或 kill [-l &lt;信息编号&gt;]</p><p>kill-9 pid</p><h3 id="22、怎么查看系统支持的所有信号？"><a href="#22、怎么查看系统支持的所有信号？" class="headerlink" title="22、怎么查看系统支持的所有信号？"></a>22、怎么查看系统支持的所有信号？</h3><p>答案：</p><p>kill -l</p><h3 id="23、搜索文件用什么命令-格式是怎么样的"><a href="#23、搜索文件用什么命令-格式是怎么样的" class="headerlink" title="23、搜索文件用什么命令? 格式是怎么样的?"></a>23、搜索文件用什么命令? 格式是怎么样的?</h3><p>答案：</p><p>find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt;</p><p>whereis 加参数与文件名</p><p>locate 只加文件名</p><p>find 直接搜索磁盘，较慢。</p><p>find / -name “string*”</p><h3 id="24、查看当前谁在使用该主机用什么命令-查找自己所在的终端信息用什么命令"><a href="#24、查看当前谁在使用该主机用什么命令-查找自己所在的终端信息用什么命令" class="headerlink" title="24、查看当前谁在使用该主机用什么命令? 查找自己所在的终端信息用什么命令?"></a>24、查看当前谁在使用该主机用什么命令? 查找自己所在的终端信息用什么命令?</h3><p>答案：</p><p>查找自己所在的终端信息：who am i</p><p>查看当前谁在使用该主机：who</p><h3 id="25、使用什么命令查看用过的命令列表"><a href="#25、使用什么命令查看用过的命令列表" class="headerlink" title="25、使用什么命令查看用过的命令列表?"></a>25、使用什么命令查看用过的命令列表?</h3><p>答案：</p><p>history</p><h3 id="26、使用什么命令查看磁盘使用空间？-空闲空间呢"><a href="#26、使用什么命令查看磁盘使用空间？-空闲空间呢" class="headerlink" title="26、使用什么命令查看磁盘使用空间？ 空闲空间呢?"></a>26、使用什么命令查看磁盘使用空间？ 空闲空间呢?</h3><p>答案：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">df -hl<br></code></pre></td></tr></table></figure><p>文件系统 容量 已用 可用 已用% 挂载点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">Filesystem Size Used Avail Use% Mounted on /dev/hda2 45G 19G 24G<br><span class="hljs-meta">44%</span><span class="bash"> /</span><br>/dev/hda1 494M 19M 450M 4% /boot<br></code></pre></td></tr></table></figure><h3 id="27、使用什么命令查看网络是否连通"><a href="#27、使用什么命令查看网络是否连通" class="headerlink" title="27、使用什么命令查看网络是否连通?"></a>27、使用什么命令查看网络是否连通?</h3><p>答案：</p><p>netstat</p><h3 id="28、使用什么命令查看-ip-地址及接口信息？"><a href="#28、使用什么命令查看-ip-地址及接口信息？" class="headerlink" title="28、使用什么命令查看 ip 地址及接口信息？"></a>28、使用什么命令查看 ip 地址及接口信息？</h3><p>答案：</p><p>ifconfig</p><h3 id="29、查看各类环境变量用什么命令"><a href="#29、查看各类环境变量用什么命令" class="headerlink" title="29、查看各类环境变量用什么命令?"></a>29、查看各类环境变量用什么命令?</h3><p>答案：</p><p>查看所有 env</p><p>查看某个，如 home： env $HOME</p><h3 id="30、通过什么命令指定命令提示符"><a href="#30、通过什么命令指定命令提示符" class="headerlink" title="30、通过什么命令指定命令提示符?"></a>30、通过什么命令指定命令提示符?</h3><p>答案：</p><p>\u：显示当前用户账号</p><p>\h：显示当前主机名</p><p>\W：只显示当前路径最后一个目录</p><p>\w：显示当前绝对路径（当前用户目录会以~代替）</p><p>$PWD：显示当前全路径</p><p>$：显示命令行’$’或者’#’符号</p><p>#：下达的第几个命令</p><p>\d：代表日期，格式为 week day month date，例如：”MonAug1”</p><p>\t：显示时间为 24 小时格式，如：HH：MM：SS</p><p>\T：显示时间为 12 小时格式</p><p>\A：显示时间为 24 小时格式：HH：MM</p><p>\v：BASH 的版本信息 如 export PS1=’[\u@\h\w#]$‘</p><h3 id="31、查找命令的可执行文件是去哪查找的-怎么对其进行设置及添加"><a href="#31、查找命令的可执行文件是去哪查找的-怎么对其进行设置及添加" class="headerlink" title="31、查找命令的可执行文件是去哪查找的? 怎么对其进行设置及添加?"></a>31、查找命令的可执行文件是去哪查找的? 怎么对其进行设置及添加?</h3><p>答案：</p><p>whereis [-bfmsu][-B &lt;目录&gt;…][-M &lt;目录&gt;…][-S &lt;目录&gt;…][文件…]</p><p>补充说明：whereis 指令会在特定目录中查找符合条件的文件。这些文件的烈性应属于原始代码，二进制文件，或是帮助文件。</p><p>-b 只查找二进制文件。</p><p>-B &lt;目录&gt; 只在设置的目录下查找二进制文件。 -f 不显示文件名前的路径名称。</p><p>-m 只查找说明文件。</p><p>-M &lt;目录&gt; 只在设置的目录下查找说明文件。-s 只查找原始代码文件。</p><p>-S &lt;目录&gt; 只在设置的目录下查找原始代码文件。 -u 查找不包含指定类型的文件。</p><p>w -h ich 指令会在 PATH 变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。</p><p>-n 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。</p><p>-p 与-n 参数相同，但此处的包括了文件的路径。 -w 指定输出时栏位的宽度。</p><p>-V 显示版本信息</p><h3 id="32、通过什么命令查找执行命令"><a href="#32、通过什么命令查找执行命令" class="headerlink" title="32、通过什么命令查找执行命令?"></a>32、通过什么命令查找执行命令?</h3><p>答案：</p><p>which 只能查可执行文件</p><p>whereis 只能查二进制文件、说明文档，源文件等</p><h3 id="33、怎么对命令进行取别名？"><a href="#33、怎么对命令进行取别名？" class="headerlink" title="33、怎么对命令进行取别名？"></a>33、怎么对命令进行取别名？</h3><p>答案：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">alias la=&#x27;ls -a&#x27;<br></code></pre></td></tr></table></figure><h3 id="34、du-和-df-的定义，以及区别？"><a href="#34、du-和-df-的定义，以及区别？" class="headerlink" title="34、du 和 df 的定义，以及区别？"></a>34、du 和 df 的定义，以及区别？</h3><p>答案：</p><p>du 显示目录或文件的大小</p><p>df 显示每个&lt;文件&gt;所在的文件系统的信息，默认是显示所有文件系统。（文件系统分配其中的一些磁盘块用来记录它自身的一些数据，如 i 节点，磁盘分布图，间接块，超级块等。这些数据对大多数用户级的程序来说是不可见的，通常称为 Meta Data。） du 命令是用户级的程序，它不考虑 Meta Data，而 df命令则查看文件系统的磁盘分配图并考虑 Meta Data。</p><p>df 命令获得真正的文件系统数据，而 du 命令只查看文件系统的部分情况。</p><h3 id="35、awk-详解。"><a href="#35、awk-详解。" class="headerlink" title="35、awk 详解。"></a>35、awk 详解。</h3><p>答案：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">awk &#x27;&#123;pattern + action&#125;&#x27; &#123;<br>filenames<br>&#125;<br><span class="hljs-meta">#</span><span class="bash">cat /etc/passwd |awk -F <span class="hljs-string">&#x27;:&#x27;</span> <span class="hljs-string">&#x27;&#123;print 1&quot;t&quot;7&#125;&#x27;</span> //-F 的意思是以<span class="hljs-string">&#x27;:&#x27;</span>分隔 root</span><br>/bin/bash<br>daemon /bin/sh 搜索/etc/passwd 有 root 关键字的所有行<br><span class="hljs-meta">#</span><span class="bash">awk -F: <span class="hljs-string">&#x27;/root/&#x27;</span> /etc/passwd root:x:0:0:root:/root:/bin/bash</span><br></code></pre></td></tr></table></figure><h3 id="36、当你需要给命令绑定一个宏或者按键的时候，应该怎么做呢？"><a href="#36、当你需要给命令绑定一个宏或者按键的时候，应该怎么做呢？" class="headerlink" title="36、当你需要给命令绑定一个宏或者按键的时候，应该怎么做呢？"></a>36、当你需要给命令绑定一个宏或者按键的时候，应该怎么做呢？</h3><p>答案：</p><p>可以使用 bind 命令，bind 可以很方便地在 shell 中实现宏或按键的绑定。在进行按键绑定的时候，我们需要先获取到绑定按键对应的字符序列。</p><p>比如获取 F12 的字符序列获取方法如下：先按下 Ctrl+V,然后按下 F12 .我们就可以得到 F12 的字符序列 ^[[24~。</p><p>接着使用 bind 进行绑定。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# bind ‘”e[24~&quot;:&quot;date&quot;&#x27;<br></code></pre></td></tr></table></figure><p>注意：相同的按键在不同的终端或终端模拟器下可能会产生不同的字符序列。</p><p>【附】也可以使用 showkey -a 命令查看按键对应的字符序列。</p><h3 id="37、如果一个-linux-新手想要知道当前系统支持的所有命令的列表，他需要怎么做？"><a href="#37、如果一个-linux-新手想要知道当前系统支持的所有命令的列表，他需要怎么做？" class="headerlink" title="37、如果一个 linux 新手想要知道当前系统支持的所有命令的列表，他需要怎么做？"></a>37、如果一个 linux 新手想要知道当前系统支持的所有命令的列表，他需要怎么做？</h3><p>答案：</p><p>使用命令 compgen -c，可以打印出所有支持的命令列表。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]$ compgen -c<br>ll<br>ls<br>which<br>if<br>then else<br>elif<br>fi<br>case<br>esac<br>for<br>select<br>until<br>do<br>done<br></code></pre></td></tr></table></figure><h3 id="38、如果你的助手想要打印出当前的目录栈，你会建议他怎么做？"><a href="#38、如果你的助手想要打印出当前的目录栈，你会建议他怎么做？" class="headerlink" title="38、如果你的助手想要打印出当前的目录栈，你会建议他怎么做？"></a>38、如果你的助手想要打印出当前的目录栈，你会建议他怎么做？</h3><p>答案：</p><p>使用 Linux 命令 dirs 可以将当前的目录栈打印出来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# dirs<br>/usr/share/X11<br></code></pre></td></tr></table></figure><p>【附】：目录栈通过 pushd popd 来操作。</p><h3 id="39、你的系统目前有许多正在运行的任务，在不重启机器的条件下，有什么方法可以把所有正在运行的进程移除呢？"><a href="#39、你的系统目前有许多正在运行的任务，在不重启机器的条件下，有什么方法可以把所有正在运行的进程移除呢？" class="headerlink" title="39、你的系统目前有许多正在运行的任务，在不重启机器的条件下，有什么方法可以把所有正在运行的进程移除呢？"></a>39、你的系统目前有许多正在运行的任务，在不重启机器的条件下，有什么方法可以把所有正在运行的进程移除呢？</h3><p>答案：</p><p>使用 linux 命令 ’disown -r ’可以将所有正在运行的进程移除。</p><h3 id="40、bash-shell-中的-hash-命令有什么作用？"><a href="#40、bash-shell-中的-hash-命令有什么作用？" class="headerlink" title="40、bash shell 中的 hash 命令有什么作用？"></a>40、bash shell 中的 hash 命令有什么作用？</h3><p>答案：</p><p>linux 命令’hash’管理着一个内置的哈希表，记录了已执行过的命令的完整路径,用该命令可以打印出你所使用过的命令以及执行的次数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# hash<br>hits command<br>2 /bin/ls<br>2 /bin/su<br></code></pre></td></tr></table></figure><h3 id="41、哪一个-bash-内置命令能够进行数学运算。"><a href="#41、哪一个-bash-内置命令能够进行数学运算。" class="headerlink" title="41、哪一个 bash 内置命令能够进行数学运算。"></a>41、哪一个 bash 内置命令能够进行数学运算。</h3><p>答案：</p><p>bash shell 的内置命令 let 可以进行整型数的数学运算。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">! /bin/bash</span><br>let c=a+b<br></code></pre></td></tr></table></figure><h3 id="42、怎样一页一页地查看一个大文件的内容呢？"><a href="#42、怎样一页一页地查看一个大文件的内容呢？" class="headerlink" title="42、怎样一页一页地查看一个大文件的内容呢？"></a>42、怎样一页一页地查看一个大文件的内容呢？</h3><p>答案：</p><p>通过管道将命令”cat file_name.txt” 和 ’more’ 连接在一起可以实现这个需要.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# cat file_name.txt | more<br></code></pre></td></tr></table></figure><h3 id="43、数据字典属于哪一个用户的？"><a href="#43、数据字典属于哪一个用户的？" class="headerlink" title="43、数据字典属于哪一个用户的？"></a>43、数据字典属于哪一个用户的？</h3><p>答案：</p><p>数据字典是属于’SYS’用户的，用户‘SYS’ 和 ’SYSEM’是由系统默认自动创建的</p><h3 id="44、怎样查看一个-linux-命令的概要与用法？假设你在-bin-目录中偶然看到一个你从没见过的的命令，怎样才能知道它的作用和用法呢？"><a href="#44、怎样查看一个-linux-命令的概要与用法？假设你在-bin-目录中偶然看到一个你从没见过的的命令，怎样才能知道它的作用和用法呢？" class="headerlink" title="44、怎样查看一个 linux 命令的概要与用法？假设你在/bin 目录中偶然看到一个你从没见过的的命令，怎样才能知道它的作用和用法呢？"></a>44、怎样查看一个 linux 命令的概要与用法？假设你在/bin 目录中偶然看到一个你从没见过的的命令，怎样才能知道它的作用和用法呢？</h3><p>答案：</p><p>使用命令 whatis 可以先出显示出这个命令的用法简要，比如，你可以使用 whatiszcat 去查看‘zcat’的介绍以及使用简要。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# whatis zcat<br>zcat [gzip] (1) – compress or expand files<br></code></pre></td></tr></table></figure><h3 id="45、使用哪一个命令可以查看自己文件系统的磁盘空间配额呢？"><a href="#45、使用哪一个命令可以查看自己文件系统的磁盘空间配额呢？" class="headerlink" title="45、使用哪一个命令可以查看自己文件系统的磁盘空间配额呢？"></a>45、使用哪一个命令可以查看自己文件系统的磁盘空间配额呢？</h3><p>答案：</p><p>使用命令 repquota 能够显示出一个文件系统的配额信息</p><p>【附】只有 root 用户才能够查看其它用户的配额。</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题-操作系统</title>
    <link href="/2020/11/23/interview/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/11/23/interview/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/operating-system/linux">原文链接 侵删</a></p><h1 id="Linux五种I-O模型"><a href="#Linux五种I-O模型" class="headerlink" title="Linux五种I/O模型"></a>Linux五种I/O模型</h1><ul><li><p>阻塞I/O</p></li><li><p>非阻塞I/O</p></li><li><p>I/O复用</p></li><li><p>信号驱动I/O</p></li><li><p>异步I/O</p></li></ul><h1 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h1><p>同步 </p><blockquote><p>两个同步任务相互依赖，并且一个任务必须以依赖于另一任务的某种方式执行。 比如在A-&gt;B事件模型中，你需要先完成 A 才能执行B。 再换句话说，同步调用中被调用者未处理完请求之前，调用不返回，调用者会一直等待结果的返回。</p></blockquote><p>异步</p><blockquote><p>两个异步的任务完全独立的，一方的执行不需要等待另外一方的执行。再换句话说，异步调用种一调用就返回结果不需要等待结果返回，当结果返回的时候通过回调函数或者其他方式拿着结果再做相关事情，</p></blockquote><h1 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h1><p>阻塞</p><blockquote><p>阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。</p></blockquote><p>非阻塞</p><blockquote><p>非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。</p></blockquote><ul><li>如何区分 “同步/异步 ”和 “阻塞/非阻塞” 呢？</li></ul><blockquote><p>同步/异步是从<code>行为角度</code>描述事物的，而阻塞和非阻塞描述的<code>当前事物的状态</code>（等待调用结果时的状态）。</p></blockquote><p>面试官顶着蓬松的假发向我走来，只见他一手拿着厚重的 Thinkpad ，一手提着他那淡黄的长裙。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/ceeb653ely1gd8wj5evc4j20i00n0dh0.jpg" alt="img"></p><h1 id="什么是操作系统？"><a href="#什么是操作系统？" class="headerlink" title="什么是操作系统？"></a>什么是操作系统？</h1><p>👨‍💻<strong>面试官</strong> ： 先来个简单问题吧！<strong>什么是操作系统？</strong></p><p>🙋 <strong>我</strong> ：我通过以下四点向您介绍一下什么是操作系统吧！</p><ol><li><strong>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。</strong></li><li><strong>操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。</strong> 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。</li><li><strong>操作系统存在屏蔽了硬件层的复杂性。</strong> 操作系统就像是硬件使用的负责人，统筹着各种相关事项。</li><li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理</strong>。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/Kernel_Layout.png" alt="Kernel_Layout"></p><h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>👨‍💻<strong>面试官</strong> ：<strong>什么是系统调用呢？</strong> 能不能详细介绍一下。</p><p>🙋 <strong>我</strong> ：介绍系统调用之前，我们先来了解一下用户态和系统态。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/006r3PQBjw1fbimb5c3srj30b40b40t9-20200404224750646.jpg" alt="img"></p><p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p><ol><li>用户态(user mode) : 用户态运行的进程或可以直接读取用户程序的数据。</li><li>系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li></ol><p>说了用户态和系统态之后，那么什么是系统调用呢？</p><p>我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！</p><p>也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p><p>这些系统调用按功能大致可分为如下几类：</p><ul><li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li><li>文件管理。完成文件的读、写、创建及删除等功能。</li><li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li><li>进程通信。完成进程之间的消息传递或信号传递等功能。</li><li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li></ul><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h2 id="2-1-进程和线程的区别"><a href="#2-1-进程和线程的区别" class="headerlink" title="2.1 进程和线程的区别"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/operating-system/basis?id=_21-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB">2.1 进程和线程的区别</a></h2><p>👨‍💻<strong>面试官</strong>: 好的！我明白了！那你再说一下： <strong>进程和线程的区别</strong>。</p><p>🙋 <strong>我：</strong> 好的！ 下图是 Java 内存区域，我们从 JVM 的角度来说一下线程和进程之间的关系吧！</p><blockquote><p>如果你对 Java 内存区域 (运行时数据区) 这部分知识不太了解的话可以阅读一下这篇文章：<a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F">《可能是把 Java 内存区域讲的最清楚的一篇文章》</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/ff96fed0e2a354bb16bbc84dcedf503a.png" alt="jvm运行时数据区域"></p><p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)\</strong>资源，但是每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p><p><strong>总结：</strong> 线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><h2 id="2-2-进程有哪几种状态"><a href="#2-2-进程有哪几种状态" class="headerlink" title="2.2 进程有哪几种状态?"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/operating-system/basis?id=_22-%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81">2.2 进程有哪几种状态?</a></h2><p>👨‍💻<strong>面试官</strong> ： 那你再说说<strong>进程有哪几种状态?</strong></p><p>🙋 <strong>我</strong> ：我们一般把进程大致分为 5 种状态，这一点和 <a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/JavaConcurrencyBasicsCommonInterviewQuestionsSummary.md#6-%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81">线程</a>很像！</p><ul><li><strong>创建状态(new)</strong> ：进程正在被创建，尚未到就绪状态。</li><li><strong>就绪状态(ready)</strong> ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。</li><li><strong>运行状态(running)</strong> ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。</li><li><strong>阻塞状态(waiting)</strong> ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</li><li><strong>结束状态(terminated)</strong> ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li></ul><blockquote><p>订正：下图中 running 状态被 interrupt 向 ready 状态转换的箭头方向反了。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/d38202593012b457debbcd74994c6292.png" alt="process-state"></p><h2 id="2-3-进程间的通信方式"><a href="#2-3-进程间的通信方式" class="headerlink" title="2.3 进程间的通信方式"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/operating-system/basis?id=_23-%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F">2.3 进程间的通信方式</a></h2><p>👨‍💻<strong>面试官</strong> ：<strong>进程间的通信常见的的有哪几种方式呢?</strong></p><p>🙋 <strong>我</strong> ：大概有 7 种常见的进程间的通信方式。</p><blockquote><p>下面这部分总结参考了:<a href="https://www.jianshu.com/p/c1015f5ffa74">《进程间通信 IPC (InterProcess Communication)》</a> 这篇文章，推荐阅读，总结的非常不错。</p></blockquote><ol><li><strong>管道/匿名管道(Pipes)</strong> ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</li><li><strong>有名管道(Names Pipes)</strong> : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li><li><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li><li><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。</strong></li><li><strong>信号量(Semaphores)</strong> ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li><li><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</li><li><strong>套接字(Sockets)</strong> : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li></ol><h2 id="2-4-线程间的同步的方式"><a href="#2-4-线程间的同步的方式" class="headerlink" title="2.4 线程间的同步的方式"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/operating-system/basis?id=_24-%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F">2.4 线程间的同步的方式</a></h2><p>👨‍💻<strong>面试官</strong> ：<strong>那线程间的同步的方式有哪些呢?</strong></p><p>🙋 <strong>我</strong> ：线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：</p><ol><li>**互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</li><li><strong>信号量(Semphares)</strong> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量</li><li><strong>事件(Event)</strong> :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操</li></ol><h2 id="2-5-进程的调度算法"><a href="#2-5-进程的调度算法" class="headerlink" title="2.5 进程的调度算法"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/operating-system/basis?id=_25-%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">2.5 进程的调度算法</a></h2><p>👨‍💻<strong>面试官</strong> ：<strong>你知道操作系统中进程的调度算法有哪些吗?</strong></p><p>🙋 <strong>我</strong> ：嗯嗯！这个我们大学的时候学过，是一个很重要的知识点！</p><p>为了确定首先执行哪个进程以及最后执行哪个进程以实现最大 CPU 利用率，计算机科学家已经定义了一些算法，它们是：</p><ul><li><strong>先到先服务(FCFS)调度算法</strong> : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li><li><strong>短作业优先(SJF)的调度算法</strong> : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li><li><strong>时间片轮转调度算法</strong> : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li><li><strong>多级反馈队列调度算法</strong> ：前面介绍的几种进程调度的算法都有一定的局限性。如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong> 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</li><li><strong>优先级调度</strong> ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li></ul><h1 id="操作系统内存管理基础"><a href="#操作系统内存管理基础" class="headerlink" title="操作系统内存管理基础"></a>操作系统内存管理基础</h1><h2 id="3-1-内存管理介绍"><a href="#3-1-内存管理介绍" class="headerlink" title="3.1 内存管理介绍"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/operating-system/basis?id=_31-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BB%8B%E7%BB%8D">3.1 内存管理介绍</a></h2><p>👨‍💻 <strong>面试官</strong>: <strong>操作系统的内存管理主要是做什么？</strong></p><p>🙋 <strong>我：</strong> 操作系统的内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。</p><h2 id="3-2-常见的几种内存管理机制"><a href="#3-2-常见的几种内存管理机制" class="headerlink" title="3.2 常见的几种内存管理机制"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/operating-system/basis?id=_32-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6">3.2 常见的几种内存管理机制</a></h2><p>👨‍💻 <strong>面试官</strong>: <strong>操作系统的内存管理机制了解吗？内存管理有哪几种方式?</strong></p><p>🙋 <strong>我：</strong> 这个在学习操作系统的时候有了解过。</p><p>简单分为<strong>连续分配管理方式</strong>和<strong>非连续分配管理方式</strong>这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 <strong>块式管理</strong> 。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如<strong>页式管理</strong> 和 <strong>段式管理</strong>。</p><ol><li><strong>块式管理</strong> ： 远古时代的计算机操系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。</li><li><strong>页式管理</strong> ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</li><li><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。但是，最重要的是段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。</li></ol><p>👨‍💻<strong>面试官</strong> ： 回答的还不错！不过漏掉了一个很重要的 <strong>段页式管理机制</strong> 。段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 <strong>段页式管理机制</strong> 中段与段之间以及段的内部的都是离散的。</p><p>🙋 <strong>我</strong> ：谢谢面试官！刚刚把这个给忘记了～</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/6af89bc8gw1f8txoxc2asj20k00k0mxv.jpg" alt="这就很尴尬了_尴尬表情"></p><h2 id="3-3-快表和多级页表"><a href="#3-3-快表和多级页表" class="headerlink" title="3.3 快表和多级页表"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/operating-system/basis?id=_33-%E5%BF%AB%E8%A1%A8%E5%92%8C%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8">3.3 快表和多级页表</a></h2><p>👨‍💻<strong>面试官</strong> ： 页表管理机制中有两个很重要的概念：快表和多级页表，这两个东西分别解决了页表管理中很重要的两个问题。你给我简单介绍一下吧！</p><p>🙋 <strong>我</strong> ：在分页内存管理中，很重要的两点是：</p><ol><li>虚拟地址到物理地址的转换要快。</li><li>解决虚拟地址空间大，页表也会很大的问题。</li></ol><h4 id="快表"><a href="#快表" class="headerlink" title="快表"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/operating-system/basis?id=%E5%BF%AB%E8%A1%A8">快表</a></h4><p>为了解决虚拟地址到物理地址的转换速度，操作系统在 <strong>页表方案</strong> 基础之上引入了 <strong>快表</strong> 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p><p>使用快表之后的地址转换流程是这样的：</p><ol><li>根据虚拟地址中的页号查快表；</li><li>如果该页在快表中，直接从快表中读取相应的物理地址；</li><li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li><li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li></ol><p>看完了之后你会发现快表和我们平时经常在我们开发的系统使用的缓存（比如 Redis）很像，的确是这样的，操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。</p><h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/operating-system/basis?id=%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8">多级页表</a></h4><p>引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景，具体可以查看下面这篇文章</p><ul><li>多级页表如何节约内存：<a href="https://www.polarxiong.com/archives/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98.html">https://www.polarxiong.com/archives/多级页表如何节约内存.html</a></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/operating-system/basis?id=%E6%80%BB%E7%BB%93">总结</a></h4><p>为了提高内存的空间性能，提出了多级页表的概念；但是提到空间性能是以浪费时间性能为基础的，因此为了补充损失的时间性能，提出了快表（即 TLB）的概念。 不论是快表还是多级页表实际上都利用到了程序的局部性原理，局部性原理在后面的虚拟内存这部分会介绍到。</p><h3 id="3-4-分页机制和分段机制的共同点和区别"><a href="#3-4-分页机制和分段机制的共同点和区别" class="headerlink" title="3.4 分页机制和分段机制的共同点和区别"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/operating-system/basis?id=_34-%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6%E5%92%8C%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB">3.4 分页机制和分段机制的共同点和区别</a></h3><p>👨‍💻<strong>面试官</strong> ： <strong>分页机制和分段机制有哪些共同点和区别呢？</strong></p><p>🙋 <strong>我</strong> ：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/de80a5ably1gcuslckpygg208c08cwfu.gif" alt="img"></p><ol><li>共同点 ：</li></ol><ul><li>分页机制和分段机制都是为了提高内存利用率，较少内存碎片。</li><li>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li></ul><ol start="2"><li>区别：</li></ol><ul><li>页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。</li><li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。</li></ul><h2 id="3-5-逻辑-虚拟-地址和物理地址"><a href="#3-5-逻辑-虚拟-地址和物理地址" class="headerlink" title="3.5 逻辑(虚拟)地址和物理地址"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/operating-system/basis?id=_35-%E9%80%BB%E8%BE%91%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80">3.5 逻辑(虚拟)地址和物理地址</a></h2><p>👨‍💻<strong>面试官</strong> ：你刚刚还提到了<strong>逻辑地址和物理地址</strong>这两个概念，我不太清楚，你能为我解释一下不？</p><p>🙋 <strong>我：</strong> em…好的嘛！我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。</p><h2 id="3-6-CPU-寻址了解吗-为什么需要虚拟地址空间"><a href="#3-6-CPU-寻址了解吗-为什么需要虚拟地址空间" class="headerlink" title="3.6 CPU 寻址了解吗?为什么需要虚拟地址空间?"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/operating-system/basis?id=_36-cpu-%E5%AF%BB%E5%9D%80%E4%BA%86%E8%A7%A3%E5%90%97%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4">3.6 CPU 寻址了解吗?为什么需要虚拟地址空间?</a></h2><p>👨‍💻<strong>面试官</strong> ：<strong>CPU 寻址了解吗?为什么需要虚拟地址空间?</strong></p><p>🙋 <strong>我</strong> ：这部分我真不清楚！</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/a9cf8ef6ly1fhqpdipcyfj20ce0b4wex.jpg%20.jpeg" alt="img"></p><p>于是面试完之后我默默去查阅了相关文档！留下了没有技术的泪水。。。</p><blockquote><p>这部分内容参考了 Microsoft 官网的介绍，地址：<a href="https://msdn.microsoft.com/zh-cn/library/windows/hardware/hh439648(v=vs.85).aspx">https://msdn.microsoft.com/zh-cn/library/windows/hardware/hh439648(v=vs.85).aspx</a></p></blockquote><p>现代处理器使用的是一种称为 <strong>虚拟寻址(Virtual Addressing)</strong> 的寻址方式。<strong>使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。</strong> 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为 <strong>内存管理单元（Memory Management Unit, MMU）</strong> 的硬件。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/2b27dac8cc647f8aac989da2d1166db2.png" alt="MMU_principle_updated"></p><p><strong>为什么要有虚拟地址空间呢？</strong></p><p>先从没有虚拟地址空间的时候说起吧！没有虚拟地址空间的时候，<strong>程序都是直接访问和操作的都是物理内存</strong> 。但是这样有什么问题呢？</p><ol><li>用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。</li><li>想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行。为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。</li></ol><p><strong>总结来说：如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难。</strong></p><p>通过虚拟地址访问内存有以下优势：</p><ul><li>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。</li><li>程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。</li><li>不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li></ul><h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><h2 id="4-1-什么是虚拟内存-Virtual-Memory"><a href="#4-1-什么是虚拟内存-Virtual-Memory" class="headerlink" title="4.1 什么是虚拟内存(Virtual Memory)?"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/operating-system/basis?id=_41-%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98virtual-memory">4.1 什么是虚拟内存(Virtual Memory)?</a></h2><p>👨‍💻<strong>面试官</strong> ：再问你一个常识性的问题！<strong>什么是虚拟内存(Virtual Memory)?</strong></p><p>🙋 <strong>我</strong> ：这个在我们平时使用电脑特别是 Windows 系统的时候太常见了。很多时候我们使用点开了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存。<strong>为什么可以这样呢？</strong> 正是因为 <strong>虚拟内存</strong> 的存在，通过 <strong>虚拟内存</strong> 可以让程序可以拥有超过系统物理内存大小的可用内存空间。另外，<strong>虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）</strong>。这样会更加有效地管理内存并减少出错。</p><p><strong>虚拟内存</strong>是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存“的技术。<strong>虚拟内存的重要意义是它定义了一个连续的虚拟地址空间</strong>，并且 <strong>把内存扩展到硬盘空间</strong>。推荐阅读：<a href="https://juejin.im/post/59f8691b51882534af254317">《虚拟内存的那点事儿》</a></p><p>维基百科中有几句话是这样介绍虚拟内存的。</p><blockquote><p><strong>虚拟内存</strong> 使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如 RAM）的使用也更有效率。目前，大多数操作系统都使用了虚拟内存，如 Windows 家族的“虚拟内存”；Linux 的“交换空间”等。From:<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">https://zh.wikipedia.org/wiki/虚拟内存</a></p></blockquote><h2 id="4-2-局部性原理"><a href="#4-2-局部性原理" class="headerlink" title="4.2 局部性原理"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/operating-system/basis?id=_42-%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86">4.2 局部性原理</a></h2><p>👨‍💻<strong>面试官</strong> ：要想更好地理解虚拟内存技术，必须要知道计算机中著名的<strong>局部性原理</strong>。另外，局部性原理既适用于程序结构，也适用于数据结构，是非常重要的一个概念。</p><p>🙋 <strong>我</strong> ：局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。</p><blockquote><p>以下内容摘自《计算机操作系统教程》 第 4 章存储器管理。</p></blockquote><p>早在 1968 年的时候，就有人指出我们的程序在执行的时候往往呈现局部性规律，也就是说在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。</p><p>局部性原理表现在以下两个方面：</p><ol><li><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li><li><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li></ol><p>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。</p><h2 id="4-3-虚拟存储器"><a href="#4-3-虚拟存储器" class="headerlink" title="4.3 虚拟存储器"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/operating-system/basis?id=_43-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8">4.3 虚拟存储器</a></h2><p>👨‍💻<strong>面试官</strong> ：都说了虚拟内存了。你再讲讲<strong>虚拟存储器</strong>把！</p><p>🙋 <strong>我</strong> ：</p><blockquote><p>这部分内容来自：<a href="https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/13.html">王道考研操作系统知识点整理</a>。</p></blockquote><p>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器——<strong>虚拟存储器</strong>。</p><p>实际上，我觉得虚拟内存同样是一种时间换空间的策略，你用 CPU 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的空间来支持程序的运行。不得不感叹，程序世界几乎不是时间换空间就是空间换时间。</p><h2 id="4-4-虚拟内存的技术实现"><a href="#4-4-虚拟内存的技术实现" class="headerlink" title="4.4 虚拟内存的技术实现"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/operating-system/basis?id=_44-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0">4.4 虚拟内存的技术实现</a></h2><p>👨‍💻<strong>面试官</strong> ：<strong>虚拟内存技术的实现呢？</strong></p><p>🙋 <strong>我</strong> ：<strong>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。</strong> 虚拟内存的实现有以下三种方式：</p><ol><li><strong>请求分页存储管理</strong> ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li><li><strong>请求分段存储管理</strong> ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li><li><strong>请求段页式存储管理</strong></li></ol><p><strong>这里多说一下？很多人容易搞混请求分页与分页存储管理，两者有何不同呢？</strong></p><p>请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因，我们在上面已经分析过了。</p><p>它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。</p><p>不管是上面那种实现方式，我们一般都需要：</p><ol><li>一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</li><li><strong>缺页中断</strong>：如果<strong>需执行的指令或访问的数据尚未在内存</strong>（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段<strong>调入到内存</strong>，然后继续执行程序；</li><li><strong>虚拟地址空间</strong> ：逻辑地址到物理地址的变换。</li></ol><h2 id="4-5-页面置换算法"><a href="#4-5-页面置换算法" class="headerlink" title="4.5 页面置换算法"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/operating-system/basis?id=_45-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">4.5 页面置换算法</a></h2><p>👨‍💻<strong>面试官</strong> ：虚拟内存管理很重要的一个概念就是页面置换算法。那你说一下 <strong>页面置换算法的作用?常见的页面置换算法有哪些?</strong></p><p>🙋 <strong>我</strong> ：</p><blockquote><p>这个题目经常作为笔试题出现，网上已经给出了很不错的回答，我这里只是总结整理了一下。</p></blockquote><p>地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。</p><blockquote><p><strong>缺页中断</strong> 就是要访问的<strong>页</strong>不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。</p></blockquote><p>当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。</p><ul><li><strong>OPT 页面置换算法（最佳页面置换算法）</strong> ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。</li><li><strong>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）</strong> : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</li><li><strong>LRU （Least Currently Used）页面置换算法（最近最久未使用页面置换算法）</strong> ：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</li><li><strong>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）</strong> : 该置换算法选择在之前时期使用最少的页面作为淘汰页。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《计算机操作系统—汤小丹》第四版</li><li><a href="https://book.douban.com/subject/1230413/">《深入理解计算机系统》</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83">https://zh.wikipedia.org/wiki/输入输出内存管理单元</a></li><li><a href="https://baike.baidu.com/item/%E5%BF%AB%E8%A1%A8/19781679">https://baike.baidu.com/item/快表/19781679</a></li><li><a href="https://www.jianshu.com/p/1d47ed0b46d5">https://www.jianshu.com/p/1d47ed0b46d5</a></li><li><a href="https://www.studytonight.com/operating-system">https://www.studytonight.com/operating-system</a></li><li><a href="https://www.geeksforgeeks.org/interprocess-communication-methods/">https://www.geeksforgeeks.org/interprocess-communication-methods/</a></li><li><a href="https://juejin.im/post/59f8691b51882534af254317">https://juejin.im/post/59f8691b51882534af254317</a></li><li>王道考研操作系统知识点整理： <a href="https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/13.html">https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/13.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构篇-基础数据结构</title>
    <link href="/2020/11/23/datastructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2020/11/23/datastructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈(stack)"></a>栈(stack)</h1><p class="note note-primary">栈(stack)是限制插入和删除只能在一 个位置上进行的表,该位置是表的末端,叫做栈顶(top)。它是后进先出(LIFO)的。对栈的基本操作只有 push(进栈)和 pop(出栈)两种,  前者相当于插入,后者相当于删除最后的元素。</p><blockquote><p>特点: <code>先进后出</code></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/stack.png" alt="栈"></p><h1 id="堆-heap"><a href="#堆-heap" class="headerlink" title="堆(heap)"></a>堆(heap)</h1><p class="note note-primary">定义:完全二叉树的数组对象,将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆。(ki <= k2i,ki <= k2i+1)或者(ki >= k2i,ki >= k2i+1), (i = 1,2,3,4...n/2)    </p><blockquote><p>特点: 非线性数据结构，相当于一维数组，有两个直接后继。常见的堆有二叉堆、斐波那契堆等。</p></blockquote><details>  <summary><span>堆上浮</span></summary>  <br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//堆上浮调整</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">upAdjust</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> childIndex = array.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> parentIndex = (childIndex - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//temp保存插入的叶子节点值，用于最后的赋值</span><br>        <span class="hljs-keyword">int</span> temp = array[childIndex];<br>        <span class="hljs-keyword">while</span> (childIndex &gt; <span class="hljs-number">0</span> &amp;&amp; temp &lt; array[parentIndex]) &#123;<br>            <span class="hljs-comment">//无需真正交换，单向赋值即可</span><br>            array[childIndex] = array[parentIndex];<br>            childIndex = parentIndex;<br>            parentIndex = (parentIndex - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        &#125;<br>        arr[childIndex] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span>堆下沉</span></summary>  <br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 堆下沉调整</span><br><span class="hljs-comment">     * array 待调整的堆</span><br><span class="hljs-comment">     * parentIndex 要“下沉”的父节点</span><br><span class="hljs-comment">     * length 堆的有效大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">downAdjust</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> parentIndex, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> temp = array[parentIndex];<span class="hljs-comment">//保存父节点值，用于最后复制</span><br>        <span class="hljs-keyword">int</span> childIndex = <span class="hljs-number">2</span> * parentIndex + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (childIndex &lt; length) &#123;<br>            <span class="hljs-comment">//如果有右孩子，且右孩子小于左孩子的值，则定位到右孩子</span><br>            <span class="hljs-keyword">if</span> (childIndex + <span class="hljs-number">1</span> &lt; length &amp;&amp; array[childIndex + <span class="hljs-number">1</span>] &lt; array[childIndex]) &#123;<br>                childIndex++;<br>            &#125;<br>            <span class="hljs-comment">//如果父节点小于任何一个孩子的值，则直接跳出</span><br>            <span class="hljs-keyword">if</span> (temp &lt; array[childIndex]) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//无需真正交换，单向赋值即可</span><br>            array[parentIndex] = array[childIndex];<br>            parentIndex = childIndex;<br>            childIndex = <span class="hljs-number">2</span> * childIndex + <span class="hljs-number">1</span>;<br>        &#125;<br>        array[parentIndex] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><h1 id="普通队列-queue"><a href="#普通队列-queue" class="headerlink" title="普通队列(queue)"></a>普通队列(queue)</h1><p class="note note-primary">队列是一种特殊的 线性表 ,特殊之处在于它只允许在表的前端(front)进行删除操作,而在表的后端(rear)进行插入操作,和栈一样,队列是一种操作受限制的线性表。进行插入操作的端称为队尾,进行删除操作的端称为队头。</p><blockquote><p>特点: <code>后进先出</code></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/queue.png" alt="avatar"></p><h1 id="优先队列-PriorityQueue"><a href="#优先队列-PriorityQueue" class="headerlink" title="优先队列(PriorityQueue)"></a>优先队列(PriorityQueue)</h1><ul><li><p>最大优先队列</p><p class="note note-primary">  无论入队顺序如何，都是当前最大的元素优先出队</p></li><li><p>最小优先队列</p><p class="note note-primary">  无论入队顺序如何，都是当前最小的元素优先出队</p></li></ul><details>  <summary><span>优先队列代码实现</span></summary>  <br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PriorityQueue</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] array;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PriorityQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//队列初始长度为32</span><br>        array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">32</span>];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 入队</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 入队元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-comment">//队列长度超出范围，扩容</span><br>        <span class="hljs-keyword">if</span> (size &gt;= array.length) &#123;<br>            resize();<br>        &#125;<br>        array[size++] = key;<br>        upAdjust();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 出队</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deQueue</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;the queue is empty !&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//获取堆顶元素</span><br>        <span class="hljs-keyword">int</span> head = array[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//让最后一个元素移动到堆顶</span><br>        array[<span class="hljs-number">0</span>] = array[--size];<br>        downAdjust();<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * “上浮”调整</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">upAdjust</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> childIndex = size - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> parentIndex = (childIndex - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// temp 保存插入的叶子节点值，用于最后的赋值</span><br>        <span class="hljs-keyword">int</span> temp = array[childIndex];<br>        <span class="hljs-keyword">while</span> (childIndex &gt; <span class="hljs-number">0</span> &amp;&amp; temp &gt; array[parentIndex]) &#123;<br>        <span class="hljs-comment">//无须真正交换，单向赋值即可</span><br>            array[childIndex] = array[parentIndex];<br>            childIndex = parentIndex;<br>            parentIndex = parentIndex / <span class="hljs-number">2</span>;<br>        &#125;<br>        array[childIndex] = temp;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * “下沉”调整</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">downAdjust</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// temp 保存父节点的值，用于最后的赋值</span><br>        <span class="hljs-keyword">int</span> parentIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> temp = array[parentIndex];<br>        <span class="hljs-keyword">int</span> childIndex = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (childIndex &lt; size) &#123;<br>        <span class="hljs-comment">// 如果有右孩子，且右孩子大于左孩子的值，则定位到右孩子</span><br>            <span class="hljs-keyword">if</span> (childIndex + <span class="hljs-number">1</span> &lt; size &amp;&amp; array[childIndex + <span class="hljs-number">1</span>] &gt; array[childIndex]) &#123;<br>                childIndex++;<br>            &#125;<br>        <span class="hljs-comment">// 如果父节点大于任何一个孩子的值，直接跳出</span><br>            <span class="hljs-keyword">if</span> (temp &gt;= array[childIndex])<br>                <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//无须真正交换，单向赋值即可</span><br>            array[parentIndex] = array[childIndex];<br>            parentIndex = childIndex;<br>            childIndex = <span class="hljs-number">2</span> * childIndex + <span class="hljs-number">1</span>;<br>        &#125;<br>        array[parentIndex] = temp;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 队列扩容</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resize</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//队列容量翻倍</span><br>        <span class="hljs-keyword">int</span> newSize = <span class="hljs-keyword">this</span>.size * <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">this</span>.array = Arrays.copyOf(<span class="hljs-keyword">this</span>.array, newSize);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        PriorityQueue priorityQueue = <span class="hljs-keyword">new</span> PriorityQueue();<br>        priorityQueue.enQueue(<span class="hljs-number">3</span>);<br>        priorityQueue.enQueue(<span class="hljs-number">5</span>);<br>        priorityQueue.enQueue(<span class="hljs-number">10</span>);<br>        priorityQueue.enQueue(<span class="hljs-number">2</span>);<br>        priorityQueue.enQueue(<span class="hljs-number">7</span>);<br>        System.out.println(<span class="hljs-string">&quot; 出队元素：&quot;</span> + priorityQueue.deQueue());<br>        System.out.println(<span class="hljs-string">&quot; 出队元素：&quot;</span> + priorityQueue.deQueue());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></details><h1 id="链表-Link"><a href="#链表-Link" class="headerlink" title="链表(Link)"></a>链表(Link)</h1><p class="note note-primary">链表是一种数据结构,和数组同级。比如,Java 中我们使用的 ArrayList,其实现原理是数组。而LinkedList 的实现原理就是链表了。链表在进行循环遍历时效率不高,但是插入和删除时优势明显。</p><blockquote><p>特点: <code>插入、修改速度快、查询速度慢</code></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/link.png" alt="avatar"></p><h1 id="散列表-Hash-Table"><a href="#散列表-Hash-Table" class="headerlink" title="散列表(Hash Table)"></a>散列表(Hash Table)</h1><p class="note note-primary">散列表(Hash table,也叫哈希表)是一种查找算法,与链表、树等算法不同的是,散列表算法在查找时不需要进行一系列和关键字(关键字是数据元素中某个数据项的值,用以标识一个数据元素)的比较操作。</p><p>散列表算法希望能尽量做到不经过任何比较,通过一次存取就能得到所查找的数据元素,因而必须要在数据元素的存储位置和它的关键字(可用 key 表示)之间建立一个确定的对应关系,使每个关键字和散列表中一个唯一的存储位置相对应。因此在查找时,只要根据这个对应关系找到给定关键字在散列表中的位置即可。这种对应关系被称为散列函数(可用 h(key)表示)。</p><p>用的构造散列函数的方法有:<br>(1)直接定址法: 取关键字或关键字的某个线性函数值为散列地址。即:h(key) = key 或 h(key) = a * key + b,其中 a 和 b 为常数。<br>(2)数字分析法<br>(3)平方取值法: 取关键字平方后的中间几位为散列地址。<br>(4)折叠法:将关键字分割成位数相同的几部分,然后取这几部分的叠加和作为散列地址。<br>(5)除留余数法:取关键字被某个不大于散列表表长 m 的数 p 除后所得的余数为散列地址,即:h(key) = key MOD p p ≤ m<br>(6)随机数法:选择一个随机函数,取关键字的随机函数值为它的散列地址,即:h(key) = random(key)</p><h1 id="树结构-Tree"><a href="#树结构-Tree" class="headerlink" title="树结构(Tree)"></a>树结构(Tree)</h1><p>计算机科学中的树</p><table><thead><tr><th>二叉树</th><th>▪ <a href="http://baike.baidu.com/view/88806.htm">二叉树</a>  ▪ <a href="http://baike.baidu.com/view/389459.htm">二叉查找树</a>  ▪ <a href="http://baike.baidu.com/view/6667519.htm">笛卡尔树</a>  ▪ [Top tree](<a href="http://baike.baidu.com/searchword/?word=Top">http://baike.baidu.com/searchword/?word=Top</a> tree&amp;pic=1&amp;sug=1&amp;enc=utf8)   ▪ <a href="http://baike.baidu.com/searchword/?word=T%E6%A0%91&pic=1&sug=1&enc=utf8">T树</a></th></tr></thead><tbody><tr><td>自平衡二叉查找树</td><td>▪ <a href="http://baike.baidu.com/searchword/?word=AA%E6%A0%91&pic=1&sug=1&enc=utf8">AA树</a>  ▪ <a href="http://baike.baidu.com/view/671745.htm">AVL树</a>  ▪ <a href="http://baike.baidu.com/view/133754.htm">红黑树</a>  ▪ <a href="http://baike.baidu.com/view/1118088.htm">伸展树</a>   ▪ <a href="http://baike.baidu.com/searchword/?word=%E6%A0%91%E5%A0%86&pic=1&sug=1&enc=utf8">树堆</a>  ▪ <a href="http://baike.baidu.com/searchword/?word=%E8%8A%82%E7%82%B9%E5%A4%A7%E5%B0%8F%E5%B9%B3%E8%A1%A1%E6%A0%91&pic=1&sug=1&enc=utf8">节点大小平衡树</a></td></tr><tr><td>B树</td><td>▪ <a href="http://baike.baidu.com/view/298408.htm">B树</a>  ▪ <a href="http://baike.baidu.com/view/1168762.htm">B+树</a>  ▪ <strong>B*树</strong>  ▪ <a href="http://baike.baidu.com/searchword/?word=Bx%E6%A0%91&pic=1&sug=1&enc=utf8">Bx树</a>   ▪ <a href="http://baike.baidu.com/searchword/?word=UB%E6%A0%91&pic=1&sug=1&enc=utf8">UB树</a>  ▪ <a href="http://baike.baidu.com/view/1668085.htm">2-3树</a>  ▪ <a href="http://baike.baidu.com/view/1995382.htm">2-3-4树</a>  ▪ <a href="http://baike.baidu.com/searchword/?word=(a,b)-%E6%A0%91&pic=1&sug=1&enc=utf8">(a,b)-树</a>   ▪ [Dancing tree](<a href="http://baike.baidu.com/searchword/?word=Dancing">http://baike.baidu.com/searchword/?word=Dancing</a> tree&amp;pic=1&amp;sug=1&amp;enc=utf8)  ▪ <a href="http://baike.baidu.com/searchword/?word=H%E6%A0%91&pic=1&sug=1&enc=utf8">H树</a></td></tr><tr><td>Trie</td><td>▪ <a href="http://baike.baidu.com/searchword/?word=%E5%89%8D%E7%BC%80%E6%A0%91&pic=1&sug=1&enc=utf8">前缀树</a>  ▪ <a href="http://baike.baidu.com/view/117678.htm">后缀树</a>  ▪ <a href="http://baike.baidu.com/searchword/?word=%E5%9F%BA%E6%95%B0%E6%A0%91&pic=1&sug=1&enc=utf8">基数树</a></td></tr><tr><td>空间划分树</td><td>▪ <a href="http://baike.baidu.com/view/2063378.htm">四叉树</a>  ▪ <a href="http://baike.baidu.com/view/1035343.htm">八叉树</a>  ▪ <a href="http://baike.baidu.com/view/8668561.htm">k-d树</a>  ▪ <a href="http://baike.baidu.com/searchword/?word=vp-%E6%A0%91&pic=1&sug=1&enc=utf8">vp-树</a>   ▪ <a href="http://baike.baidu.com/view/906563.htm">R树</a>  ▪ <a href="http://baike.baidu.com/searchword/?word=R*%E6%A0%91&pic=1&sug=1&enc=utf8">R*树</a>  ▪ <a href="http://baike.baidu.com/searchword/?word=R+%E6%A0%91&pic=1&sug=1&enc=utf8">R+树</a>  ▪ <a href="http://baike.baidu.com/searchword/?word=X%E6%A0%91&pic=1&sug=1&enc=utf8">X树</a>   ▪ <a href="http://baike.baidu.com/searchword/?word=M%E6%A0%91&pic=1&sug=1&enc=utf8">M树</a>  ▪ <a href="http://baike.baidu.com/view/670683.htm">线段树</a>  ▪ <a href="http://baike.baidu.com/searchword/?word=%E5%B8%8C%E5%B0%94%E4%BC%AF%E7%89%B9R%E6%A0%91&pic=1&sug=1&enc=utf8">希尔伯特R树</a>  ▪ <a href="http://baike.baidu.com/searchword/?word=%E4%BC%98%E5%85%88R%E6%A0%91&pic=1&sug=1&enc=utf8">优先R树</a></td></tr><tr><td>非二叉树</td><td>▪ [Exponential tree](<a href="http://baike.baidu.com/searchword/?word=Exponential">http://baike.baidu.com/searchword/?word=Exponential</a> tree&amp;pic=1&amp;sug=1&amp;enc=utf8)  ▪ [Fusion tree](<a href="http://baike.baidu.com/searchword/?word=Fusion">http://baike.baidu.com/searchword/?word=Fusion</a> tree&amp;pic=1&amp;sug=1&amp;enc=utf8)  ▪ <a href="http://baike.baidu.com/searchword/?word=%E5%8C%BA%E9%97%B4%E6%A0%91&pic=1&sug=1&enc=utf8">区间树</a>  ▪ [PQ tree](<a href="http://baike.baidu.com/searchword/?word=PQ">http://baike.baidu.com/searchword/?word=PQ</a> tree&amp;pic=1&amp;sug=1&amp;enc=utf8)   ▪ [Range tree](<a href="http://baike.baidu.com/searchword/?word=Range">http://baike.baidu.com/searchword/?word=Range</a> tree&amp;pic=1&amp;sug=1&amp;enc=utf8)  ▪ [SPQR tree](<a href="http://baike.baidu.com/searchword/?word=SPQR">http://baike.baidu.com/searchword/?word=SPQR</a> tree&amp;pic=1&amp;sug=1&amp;enc=utf8)  ▪ [Van Emde Boas tree](<a href="http://baike.baidu.com/searchword/?word=Van">http://baike.baidu.com/searchword/?word=Van</a> Emde Boas tree&amp;pic=1&amp;sug=1&amp;enc=utf8)</td></tr><tr><td>其他类型</td><td>▪ <a href="http://baike.baidu.com/view/249120.htm">堆</a>  ▪ <a href="http://baike.baidu.com/searchword/?word=%E6%95%A3%E5%88%97%E6%A0%91&pic=1&sug=1&enc=utf8">散列树</a>  ▪ [Finger tree](<a href="http://baike.baidu.com/searchword/?word=Finger">http://baike.baidu.com/searchword/?word=Finger</a> tree&amp;pic=1&amp;sug=1&amp;enc=utf8)  ▪ [Metric tree](<a href="http://baike.baidu.com/searchword/?word=Metric">http://baike.baidu.com/searchword/?word=Metric</a> tree&amp;pic=1&amp;sug=1&amp;enc=utf8)   ▪ [Cover tree](<a href="http://baike.baidu.com/searchword/?word=Cover">http://baike.baidu.com/searchword/?word=Cover</a> tree&amp;pic=1&amp;sug=1&amp;enc=utf8)  ▪ <a href="http://baike.baidu.com/searchword/?word=BK-tree&pic=1&sug=1&enc=utf8">BK-tree</a>  ▪ [Doubly-chained tree](<a href="http://baike.baidu.com/searchword/?word=Doubly-chained">http://baike.baidu.com/searchword/?word=Doubly-chained</a> tree&amp;pic=1&amp;sug=1&amp;enc=utf8)  ▪ <a href="http://baike.baidu.com/searchword/?word=iDistance&pic=1&sug=1&enc=utf8">iDistance</a>   ▪ [Link-cut tree](<a href="http://baike.baidu.com/searchword/?word=Link-cut">http://baike.baidu.com/searchword/?word=Link-cut</a> tree&amp;pic=1&amp;sug=1&amp;enc=utf8)  ▪ <a href="http://baike.baidu.com/view/1420784.htm">树状数组</a></td></tr></tbody></table><details>  <summary><span>两种存储结构：链表和数组</span></summary>  <br><ul><li>数组表示</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/wanquanerchashu-link.png" alt="数组表示">  </p><blockquote><p>数组表示按照二叉树深度优先存入二维数组</p></blockquote><p>父节点下标=parent<br>左子树=2*parent+1<br>右子树=2*parent+2</p><ul><li>链表表示</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/wanquanerchashu-array.png" alt="链表表示">  </p><blockquote><p>left指向左子树,right指向右子树</p></blockquote></details><h1 id="二叉树-Binary-tree"><a href="#二叉树-Binary-tree" class="headerlink" title="二叉树(Binary tree)"></a>二叉树(Binary tree)</h1><p class="note note-primary">定义: 由一个称为根（root）的元素及两个不相交的、被分别称为左子树和右子树的二叉树组成，是有序树   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TB;<br>    A((1))--&gt;B((2))<br>    A((1))--&gt;C((3))<br>    B((2))--&gt;E((4))<br>    B((2))--&gt;F((5))<br>    C((3))--&gt;G((6))<br>    C((3))--&gt;H((7))<br><br></code></pre></td></tr></table></figure><blockquote></blockquote><h1 id="平衡二叉树-Balance-Tree"><a href="#平衡二叉树-Balance-Tree" class="headerlink" title="平衡二叉树(Balance Tree)"></a>平衡二叉树(Balance Tree)</h1><blockquote><p>任意节点的子树的高度差都小于等于1,并且左右两个子树都是一棵平衡二叉树。</p></blockquote><p><a href="/2020/12/23/datastructure/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/">详细内容</a></p><h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p class="note note-primary">    定义:叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TB;<br>    A((1))--&gt;B((2))<br>    A((1))--&gt;C((3))<br>    B((2))--&gt;E((4))<br>    B((2))--&gt;F((5))<br>    C((3))--&gt;G((6))<br>    C((3))--&gt;H((7))<br>    E((4))--&gt;i((8))<br>    E((4))--&gt;j((9))<br>    F((5))--&gt;k((10))<br></code></pre></td></tr></table></figure><blockquote><p>特点：<br>具有n个结点的完全二叉树的深度[log2k]+1（注：[ ]表示向下取整）<br>满二叉树肯定是完全二叉树，而完全二叉树不一定是满二叉树</p></blockquote><p class="note note-danger">完全二叉树判定算法思路</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">判断一棵树是否是完全二叉树的思路  <br>1 如果树为空，则直接返回错<br>2 如果树不为空：层序遍历二叉树<br>  2.1 如果一个结点左右孩子都不为空，则pop该节点，将其左右孩子入队列；<br>  2.1 如果遇到一个结点，左孩子为空，右孩子不为空，则该树一定不是完全二叉树；<br>  2.2 如果遇到一个结点，左孩子不为空，右孩子为空；或者左右孩子都为空；则该节点之后的队列中的结点都为叶子节点；<br>  该树才是完全二叉树，否则就不是完全二叉树；<br></code></pre></td></tr></table></figure><h1 id="满二叉树-Full-Binary-Tree"><a href="#满二叉树-Full-Binary-Tree" class="headerlink" title="满二叉树(Full Binary Tree)"></a>满二叉树(Full Binary Tree)</h1><p class="note note-primary">定义:一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TB;<br>    A((1))--&gt;B((2))<br>    A((1))--&gt;C((3))<br>    B((2))--&gt;E((4))<br>    B((2))--&gt;F((5))<br>    C((3))--&gt;G((6))<br>    C((3))--&gt;H((7))<br></code></pre></td></tr></table></figure><blockquote><p>特点：一个层数为k的满二叉树的叶子结点个数（也就是最后一层）：2^(k-1)<br>结点总数是(2^k) -1</p></blockquote><h1 id="二叉排序树-Binary-Sort-Tree"><a href="#二叉排序树-Binary-Sort-Tree" class="headerlink" title="二叉排序树(Binary Sort Tree)"></a>二叉排序树(Binary Sort Tree)</h1><p class="note note-primary">定义:左子树所有节点值小于它的根节点值,且右子树所有节点值大于它的根节点值,则这样的二叉树就是排序二叉树。</p><p class="note note-danger">插入操作</p>新节点与当前节点比较,如果相同则表示已经存在且不能再重复插入;如果小于当前节点,则到左子树中寻找,如果左子树为空则当前节点为要找的父节点,新节点插入到当前节点的左子树即可;如果大于当前节点,则到右子树中寻找,如果右子树为空则当前节点为要找的父节点,新节点插入到当前节点的右子树即可。<p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/sort-2-tree.png" alt="插入操作"></p><p class="note note-danger">删除操作</p><p>删除操作主要分为三种情况,即要删除的节点无子节点,要删除的节点只有一个子节点,要删除的节点有两个子节点。</p><ol><li>对于要删除的节点无子节点可以直接删除,即让其父节点将该子节点置空即可。</li><li>对于要删除的节点只有一个子节点,则替换要删除的节点为其子节点。</li><li>对于要删除的节点有两个子节点,则首先找该节点的替换节点(即右子树中最小的节点),接着替换要删除的节点为替换节点,然后删除替换节点。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/delete-2-tree.png" alt="删除操作"></p><p class="note note-danger">查询操作    </p><p>查找操作的主要流程为:先和根节点比较,如果相同就返回,如果小于根节点则到左子树中递归查找,如果大于根节点则到右子树中递归查找。因此在排序二叉树中可以很容易获取最大(最右最深子节点)和最小(最左最深子节点)值。</p><blockquote><p>它能确保任何一个结点的左右子树的<code>高度差小于两倍</code>。</p></blockquote><p><a href="https://mikeygithub.github.io/2020/12/27/datastructure/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/">详细参考</a></p><h1 id="红黑树-Red-Black-Tree"><a href="#红黑树-Red-Black-Tree" class="headerlink" title="红黑树(Red-Black-Tree)"></a>红黑树(Red-Black-Tree)</h1><p>R-B Tree,全称是 Red-Black Tree,又称为“红黑树”,它一种特殊的二叉查找树(近似平衡的二叉搜索树)。红黑树的每个节点上都有存储位表示节点的颜色,可以是红(Red)或黑(Black)。</p><p class="note note-primary">红黑树的特性    </p><p>(1)每个节点或者是黑色,或者是红色。<br>(2)根节点是黑色。<br>(3)每个叶子节点(NIL)是黑色。 [注意:这里叶子节点,是指为空(NIL 或 NULL)的叶子节点!]<br>(4)如果一个节点是红色的,则它的子节点必须是黑色的。<br>(5)从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p><details>  <summary><span>左旋</span></summary>  <br><p>对 x 进行左旋,意味着,将“x 的右孩子”设为“x 的父亲节点”;即,将 x 变成了一个左节点(x成了为 z 的左孩子)!。 因此,左旋中的“左”,意味着“被旋转的节点将变成一个左节点”。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/left-spin.png" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cgo">LEFT-ROTATE(T, x)<br>y ← right[x]<br>&#x2F;&#x2F; 前提:这里假设 x 的右孩子为 y。下面开始正式操作<br>right[x] ← left[y]<br>&#x2F;&#x2F; 将 “y 的左孩子” 设为 “x 的右孩子”,即 将β设为 x 的右孩子<br>p[left[y]] ← x &#x2F;&#x2F; 将 “x” 设为 “y 的左孩子的父亲”,即 将β的父亲设为 x<br>p[y] ← p[x] &#x2F;&#x2F; 将 “x 的父亲” 设为 “y 的父亲”<br>if p[x] &#x3D; nil[T]<br>then root[T] ← y<br>&#x2F;&#x2F; 情况 1:如果 “x 的父亲” 是空节点,则将 y 设为根节点<br>else if x &#x3D; left[p[x]]<br>then left[p[x]] ← y<br>&#x2F;&#x2F; 情况 2:如果 x 是它父节点的左孩子,则将 y 设为“x 的父节点<br>的左孩子”<br>else right[p[x]] ← y &#x2F;&#x2F; 情况 3:(x 是它父节点的右孩子) 将 y 设为“x 的父节点的右孩<br>子”<br>left[y] ← x &#x2F;&#x2F; 将 “x” 设为 “y 的左孩子”<br>p[x] ← y &#x2F;&#x2F; 将 “x 的父节点” 设为 “y”<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/left-spin-sub.png" alt="avatar"></p></details><details>  <summary><span>右旋</span></summary>  <br><p>对 x 进行右旋,意味着,将“x 的左孩子”设为“x 的父亲节点”;即,将 x 变成了一个右节点(x成了为 y 的右孩子)! 因此,右旋中的“右”,意味着“被旋转的节点将变成一个右节点”。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/right-spin.png" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cgo">RIGHT-ROTATE(T, y)<br>x ← left[y]<br>&#x2F;&#x2F; 前提:这里假设 y 的左孩子为 x。下面开始正式操作<br>left[y] ← right[x] &#x2F;&#x2F; 将 “x 的右孩子” 设为 “y 的左孩子”,即 将β设为 y 的左孩子<br>p[right[x]] ← y &#x2F;&#x2F; 将 “y” 设为 “x 的右孩子的父亲”,即 将β的父亲设为 y<br>p[x] ← p[y]<br>&#x2F;&#x2F; 将 “y 的父亲” 设为 “x 的父亲”<br>if p[y] &#x3D; nil[T]<br>then root[T] ← x<br>&#x2F;&#x2F; 情况 1:如果 “y 的父亲” 是空节点,则将 x 设为根节点<br>else if y &#x3D; right[p[y]]<br>then right[p[y]] ← x<br>&#x2F;&#x2F; 情况 2:如果 y 是它父节点的右孩子,则将 x 设为“y 的父节<br>点的左孩子”<br>else left[p[y]] ← x<br>&#x2F;&#x2F; 情况 3:(y 是它父节点的左孩子) 将 x 设为“y 的父节点的左孩<br>子”<br>right[x] ← y<br>p[y] ← x<br>&#x2F;&#x2F; 将 “y” 设为 “x 的右孩子”<br>&#x2F;&#x2F; 将 “y 的父节点” 设为 “x”<br></code></pre></td></tr></table></figure></details><details>  <summary><span>添加</span></summary>  <br><p>第一步: 将红黑树当作一颗二叉查找树,将节点插入。</p><p>第二步:将插入的节点着色为”红色”。根据被插入节点的父节点的情况,可以将”当节点 z 被着色为红色节点,并插入二叉树”划分为三种情况来处理。</p><p>1 情况说明:被插入的节点是根节点。</p><blockquote><p>处理方法:直接把此节点涂为黑色。</p></blockquote><p>2 情况说明:被插入的节点的父节点是黑色。</p><blockquote><p>处理方法:什么也不需要做。节点被插入后,仍然是红黑树。</p></blockquote><p>3 情况说明:被插入的节点的父节点是红色。这种情况下,被插入节点是一定存在非空祖父节点的;进一步的讲,被插入节点也一定存在叔叔节点(即使叔叔节点为空,我们也视之为存在,空节点本身就是黑色节点)。理解这点之后,我们依据”叔叔节点的情况”,将这种情况进一步划分为 3种情况(Case)。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/case-1-3.png" alt="avatar"></p><p>第三步: 通过一系列的旋转或着色等操作,使之重新成为一颗红黑树。</p></details><details>  <summary><span>删除</span></summary>  <br><p>第一步:将红黑树当作一颗二叉查找树,将节点删除。这和”删除常规二叉查找树中删除节点的方法是一样的”。分 3 种情况:<br>1 被删除节点没有儿子,即为叶节点。那么,直接将该节点删除就 OK 了。<br>2 被删除节点只有一个儿子。那么,直接删除该节点,并用该节点的唯一子节点顶替它的位置。<br>3 被删除节点有两个儿子。那么,先找出它的后继节点;然后把“它的后继节点的内容”复制给“该节点的内容”;之后,删除“它的后继节点”。</p><p>第二步:通过”旋转和重新着色”等一系列来修正该树,使之重新成为一棵红黑树。</p><p>因为”第一步”中删除节点之后,可能会违背红黑树的特性。所以需要通过”旋转和重新着色”来修正该树,使之重新成为一棵红黑树。</p><p>选择重着色 3 种情况。</p><p>1 情况说明:x 是“红+黑”节点。</p><blockquote><p>处理方法:直接把 x 设为黑色,结束。此时红黑树性质全部恢复。</p></blockquote><p>2 情况说明:x 是“黑+黑”节点,且 x 是根。</p><blockquote><p>处理方法:什么都不做,结束。此时红黑树性质全部恢复。</p></blockquote><p>3 情况说明:x 是“黑+黑”节点,且 x 不是根。</p><blockquote><p>处理方法:这种情况又可以划分为 4 种子情况。这 4 种子情况如下表所示:</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/case-1-4.png" alt="avatar"></p></details><p class="note note-primary">AVL VS Red Balck Tree</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/avl-vs-red-black-tree.png" alt="AVL VS Red Balck Tree"></p><p><a href="https://www.jianshu.com/p/038585421b73">参考资料</a></p><p><a href="https://www.cnblogs.com/skywang12345/p/3624343.html">代码实现</a></p><h1 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h1><p>B-tree 又叫平衡多路查找树。一棵 m 阶的 B-tree (m 叉树)的特性如下(其中 ceil(x)是一个取上限的函数):</p><ol><li><p>树中每个结点至多有 m 个孩子;</p></li><li><p>除根结点和叶子结点外,其它每个结点至少有有 ceil(m / 2)个孩子;</p></li><li><p>若根结点不是叶子结点,则至少有 2 个孩子(特殊情况:没有孩子的根结点,即根结点为叶子结点,整棵树只有一个根节点);</p></li><li><p>所有叶子结点都出现在同一层,叶子结点不包含任何关键字信息(可以看做是外部结点或查询失败的结点,实际上这些结点不存在,指向这些结点的指针都为 null);</p></li><li><p>每个非终端结点中包含有 n 个关键字信息: (n,P0,K1,P1,K2,P2,……,Kn,Pn)。其中:</p></li></ol><p>a) Ki (i=1…n)为关键字,且关键字按顺序排序 K(i-1)&lt; Ki。<br>b) Pi 为指向子树根的接点,且指针 P(i-1)指向子树种所有结点的关键字均小于 Ki,但都大于 K(i-1)。<br>c) 关键字的个数 n 必须满足: ceil(m / 2)-1 &lt;= n &lt;= m-1。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/balance-tree.png" alt="avatar"></p><p>一棵 m 阶的 B+tree 和 m 阶的 B-tree 的差异在于:<br>1.有 n 棵子树的结点中含有 n 个关键字; (B-tree 是 n 棵子树有 n-1 个关键字)<br>2.所有的叶子结点中包含了全部关键字的信息,及指向含有这些关键字记录的指针,且叶子结点本身依关键字的大小自小而大的顺序链接。 (B-tree 的叶子节点并没有包括全部需要查找的信息)<br>3.所有的非终端结点可以看成是索引部分,结点中仅含有其子树根结点中最大(或最小)关键字。<br>(B-tree 的非终节点也包含需要查找的有效信息)</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/balance-tree-detail.png" alt="avatar"></p><h1 id="B-树-B-Tree"><a href="#B-树-B-Tree" class="headerlink" title="B+树(B+Tree)"></a>B+树(B+Tree)</h1><p><a href="https://mikeygithub.github.io/2020/12/27/datastructure/B%E6%A0%91B+%E6%A0%91B*%E6%A0%91/">参考</a></p><h1 id="B树-BTree"><a href="#B树-BTree" class="headerlink" title="B树(BTree)"></a>B<em>树(B</em>Tree)</h1><p><a href="https://mikeygithub.github.io/2020/12/27/datastructure/B%E6%A0%91B+%E6%A0%91B*%E6%A0%91/">参考</a></p><h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><blockquote><p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p></blockquote><blockquote><p>设二叉树具有n个带权值的叶结点，那么从根结点到各个叶结点的路径长度与相应结点权值的乘积的和，叫做二叉树的带权路径长度。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/hfms-gs.png"></p><p class="note note-primary">    对于具有n个叶子结点的哈夫曼树，共有2n-1个结点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cgo">typedef struct&#123;<br>    char data;&#x2F;&#x2F;结点值<br>    double weight;&#x2F;&#x2F;权重<br>    int parent;&#x2F;&#x2F;双亲结点<br>    int lchild;&#x2F;&#x2F;左孩子结点<br>    int rchild;&#x2F;&#x2F;右孩子结点<br>&#125;HTNode;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/wpl.png"></p><p class="note note-danger">    相同的叶结点构造出不同的二叉树</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/hfm-1.png"></p><blockquote><p>具有最小带权路径长度的二叉树称为哈夫曼树（也称最优树）</p></blockquote><p>构造哈夫曼树的原则：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">权值越大的叶结点越靠近根结点。<br>权值越小的叶结点越远离根结点<br></code></pre></td></tr></table></figure><p>构造哈夫曼树的过程：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">（1）给定的n个权值&#123;W1，W2，…，Wn&#125;构造n棵只有一个叶结点的二叉树，从而得到一个二叉树的集合F=&#123;T1，T2，…，Tn&#125;。<br>（2）在F中选取根结点的权值最小和次小的两棵二叉树作为左、右子树构造一棵新的二叉树，这棵新的二叉树根结点的权值为其左、右子树根结点权值之和。<br>（3）在集合F中删除作为左、右子树的两棵二叉树，并将新建立的二叉树加入到集合F中。<br>（4）重复（2）、（3）两步，当F中只剩下一棵二叉树时，这棵二叉树便是所要建立的哈夫曼树。<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/hfm-demo.png" alt="构造例子"></p><p>哈夫曼树的特点:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">n1 = 0：因为每次两棵树合并。<br>n = n0+n1+n2 = n0+n2 = 2n0-1<br></code></pre></td></tr></table></figure><h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><blockquote><p>规定哈夫曼树中的左分支为0，右分支为1，则从根结点到每个叶结点所经过的分支对应的0和1组成的序列便为该结点对应字符的编码。这样的编码称为哈夫曼编码。</p></blockquote><p class="note note-primary">    哈夫曼编码特点：权值越大的字符编码越短，反之越长。哈夫曼编码属0、1二进制编码</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/hfm-code-demo.png" alt="构造例子"></p><p class="note note-danger">    在一组字符的哈夫曼编码中，不可能出现一个字符的哈夫曼编码是另一个字符哈夫曼编码的前缀。哈夫曼编码也称为前缀编码。</p><h1 id="位图-graph"><a href="#位图-graph" class="headerlink" title="位图(graph)"></a>位图(graph)</h1><blockquote><p>位图的原理就是用一个 bit 来标识一个数字是否存在,采用一个 bit 来存储一个数据,所以这样可以大大的节省空间。 bitmap 是很常用的数据结构,比如用于 Bloom Filter 中;用于无重复整数的排序等等。bitmap 通常基于数组来实现,数组中每个元素可以看成是一系列二进制数,所有元素组成更大的二进制集合。</p></blockquote><p><a href="https://www.cnblogs.com/polly333/p/4760275.html">参考资料</a></p><h1 id="布隆管理器-Bloom-Filter"><a href="#布隆管理器-Bloom-Filter" class="headerlink" title="布隆管理器(Bloom Filter)"></a>布隆管理器(Bloom Filter)</h1><p>布隆过滤器是Bloom于1970年提出的，其由二进制向量(或者位数组)和一系列随机映射函数(哈希函数)两个部分组成的数据结构。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/bloom.png" alt="图片"></p><p>位数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。这样申请一个 100w 个元素的位数组只占用 1000000Bit / 8 = 125000 Byte = 125000/1024 kb ≈ 122kb 的空间</p><details>    <summary>        <span>代码实现</span>    </summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> main;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.nio.charset.Charset;<br><span class="hljs-keyword">import</span> java.security.MessageDigest;<br><span class="hljs-keyword">import</span> java.security.NoSuchAlgorithmException;<br><span class="hljs-keyword">import</span> java.util.BitSet;<br><span class="hljs-keyword">import</span> java.util.Collection;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BloomFilter</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">2326638072608273135L</span>;<br>    <span class="hljs-keyword">private</span> BitSet bitset;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> bitSetSize;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> bitsPerElement;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> expectedNumberOfFilterElements;<span class="hljs-comment">//可以加入的元素的最大个数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numberOfAddedElements;<span class="hljs-comment">//过滤器容器中元素的实际数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> k; <span class="hljs-comment">// 哈希函数的个数</span><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Charset charset = Charset.forName(<span class="hljs-string">&quot;UTF-8&quot;</span>);<span class="hljs-comment">//存储哈希值的字符串的编码方式</span><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String hashName = <span class="hljs-string">&quot;MD5&quot;</span>; <span class="hljs-comment">//在大多数情况下，MD5提供了较好的散列准确度。如有必要，可以换成 SHA1算法</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> MessageDigest digestFunction;<span class="hljs-comment">//MessageDigest类用于为应用程序提供信息摘要算法的功能，如 MD5 或 SHA 算法</span><br>    <span class="hljs-keyword">static</span> &#123; <span class="hljs-comment">// 初始化 MessageDigest 的摘要算法对象</span><br>        MessageDigest tmp;<br>        <span class="hljs-keyword">try</span> &#123;<br>            tmp = java.security.MessageDigest.getInstance(hashName);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) &#123;<br>            tmp = <span class="hljs-keyword">null</span>;<br>        &#125;<br>        digestFunction = tmp;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造一个空的布隆过滤器. 过滤器的长度为c*n</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> c</span><br><span class="hljs-comment">     *            表示每一个元素占有多少位</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> n</span><br><span class="hljs-comment">     *            表示过滤器能加入的最大元素数量</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> k</span><br><span class="hljs-comment">     *            表示须要使用的哈希函数的个数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BloomFilter</span><span class="hljs-params">(<span class="hljs-keyword">double</span> c, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.expectedNumberOfFilterElements = n;<br>        <span class="hljs-keyword">this</span>.k = k;<br>        <span class="hljs-keyword">this</span>.bitsPerElement = c;<br>        <span class="hljs-keyword">this</span>.bitSetSize = (<span class="hljs-keyword">int</span>) Math.ceil(c * n);<br>        numberOfAddedElements = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>.bitset = <span class="hljs-keyword">new</span> BitSet(bitSetSize);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造一个空的布隆过滤器。最优哈希函数的个数将由过滤器的总大小和期望元素个数来确定。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bitSetSize</span><br><span class="hljs-comment">     *            指定了过滤器的总大小</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expectedNumberOElements</span><br><span class="hljs-comment">     *            指定了过滤器能加入的最大的元素数量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BloomFilter</span><span class="hljs-params">(<span class="hljs-keyword">int</span> bitSetSize, <span class="hljs-keyword">int</span> expectedNumberOElements)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(bitSetSize / (<span class="hljs-keyword">double</span>) expectedNumberOElements,  expectedNumberOElements, (<span class="hljs-keyword">int</span>) Math.round((bitSetSize / (<span class="hljs-keyword">double</span>) expectedNumberOElements)* Math.log(<span class="hljs-number">2.0</span>)));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过指定误报率来构造一个过滤器。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * 每一个元素所占的位数和哈希函数的数量会依据误报率来得出。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> falsePositiveProbability</span><br><span class="hljs-comment">     *            所期望误报率.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expectedNumberOfElements</span><br><span class="hljs-comment">     *            要加入的元素的数量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BloomFilter</span><span class="hljs-params">(<span class="hljs-keyword">double</span> falsePositiveProbability, <span class="hljs-keyword">int</span> expectedNumberOfElements)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(Math.ceil(-(Math.log(falsePositiveProbability) / Math.log(<span class="hljs-number">2</span>)))/ Math.log(<span class="hljs-number">2</span>), <span class="hljs-comment">// c = k/ln(2)</span><br>                expectedNumberOfElements,<br>                (<span class="hljs-keyword">int</span>) Math.ceil(-(Math.log(falsePositiveProbability) / Math.log(<span class="hljs-number">2</span>)))); <span class="hljs-comment">// k = ln(2)m/n</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 依据旧过滤器的数据。又一次构造一个新的过滤器</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bitSetSize</span><br><span class="hljs-comment">     *            指定了过滤器所需位的大小</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expectedNumberOfFilterElements</span><br><span class="hljs-comment">     *            指定了过滤器所能加入的元素的最大数量</span><br><span class="hljs-comment">     *            to contain.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> actualNumberOfFilterElements</span><br><span class="hljs-comment">     *            指定了原来过滤器的数据的数量</span><br><span class="hljs-comment">     *            &lt;code&gt;filterData&lt;/code&gt; BitSet.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> filterData</span><br><span class="hljs-comment">     *            原有过滤器中的BitSet对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BloomFilter</span><span class="hljs-params">(<span class="hljs-keyword">int</span> bitSetSize, <span class="hljs-keyword">int</span> expectedNumberOfFilterElements,</span></span><br><span class="hljs-function"><span class="hljs-params">                       <span class="hljs-keyword">int</span> actualNumberOfFilterElements, BitSet filterData)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(bitSetSize, expectedNumberOfFilterElements);<br>        <span class="hljs-keyword">this</span>.bitset = filterData;<br>        <span class="hljs-keyword">this</span>.numberOfAddedElements = actualNumberOfFilterElements;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 依据字符串的内容生成摘要</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> val</span><br><span class="hljs-comment">     *            字符串的内容</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> charset</span><br><span class="hljs-comment">     *            输入数据的编码方式</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>    输出为一个long类型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">createHash</span><span class="hljs-params">(String val, Charset charset)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> createHash(val.getBytes(charset));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 依据字符串内容生成摘要</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> val</span><br><span class="hljs-comment">     *            指定了输入的字符串。默认的编码为 UTF-8</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 输出为一个long类型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">createHash</span><span class="hljs-params">(String val)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> createHash(val, charset);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 依据字节数组生成摘要</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data</span><br><span class="hljs-comment">     *            输入数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 输出为long类型的摘要</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">createHash</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] data)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> h = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">byte</span>[] res;<br><br>        <span class="hljs-keyword">synchronized</span> (digestFunction) &#123;<br>            res = digestFunction.digest(data);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            h &lt;&lt;= <span class="hljs-number">8</span>;<br>            h |= ((<span class="hljs-keyword">int</span>) res[i]) &amp; <span class="hljs-number">0xFF</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> h;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 重写equals方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (obj == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (getClass() != obj.getClass()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">final</span> BloomFilter&lt;E&gt; other = (BloomFilter&lt;E&gt;) obj;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.expectedNumberOfFilterElements != other.expectedNumberOfFilterElements) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.k != other.k) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.bitSetSize != other.bitSetSize) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.bitset != other.bitset<br>                &amp;&amp; (<span class="hljs-keyword">this</span>.bitset == <span class="hljs-keyword">null</span> || !<span class="hljs-keyword">this</span>.bitset.equals(other.bitset))) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 重写了hashCode方法</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> hash = <span class="hljs-number">7</span>;<br>        hash = <span class="hljs-number">61</span> * hash + (<span class="hljs-keyword">this</span>.bitset != <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">this</span>.bitset.hashCode() : <span class="hljs-number">0</span>);<br>        hash = <span class="hljs-number">61</span> * hash + <span class="hljs-keyword">this</span>.expectedNumberOfFilterElements;<br>        hash = <span class="hljs-number">61</span> * hash + <span class="hljs-keyword">this</span>.bitSetSize;<br>        hash = <span class="hljs-number">61</span> * hash + <span class="hljs-keyword">this</span>.k;<br>        <span class="hljs-keyword">return</span> hash;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 依据最大元素数量和过滤器的大小来计算误报率。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * 方法的返回值为误报率。假设插入的元素个数小于最大值，则误报率会比返回值要小。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 期望的误报率.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">expectedFalsePositiveProbability</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getFalsePositiveProbability(expectedNumberOfFilterElements);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过插入的元素数量和过滤器容器大小来计算实际的误报率。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> numberOfElements</span><br><span class="hljs-comment">     *            插入的元素的个数.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 误报率.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getFalsePositiveProbability</span><span class="hljs-params">(<span class="hljs-keyword">double</span> numberOfElements)</span> </span>&#123;<br>        <span class="hljs-comment">// (1 - e^(-k * n / m)) ^ k</span><br>        <span class="hljs-keyword">return</span> Math.pow((<span class="hljs-number">1</span> - Math.exp(-k * (<span class="hljs-keyword">double</span>) numberOfElements<br>                / (<span class="hljs-keyword">double</span>) bitSetSize)), k);<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过实际插入的元素数量和过滤器容器大小来计算实际的误报率。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 误报率.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getFalsePositiveProbability</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getFalsePositiveProbability(numberOfAddedElements);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回哈希函数的个数 k</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  k.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getK</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 清空过滤器元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;<br>        bitset.clear();<br>        numberOfAddedElements = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向过滤器中加入元素。</span><br><span class="hljs-comment">     * 加入的元素的toString()方法将会被调用。返回的字符串作为哈希函数的输出。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> element</span><br><span class="hljs-comment">     *            要加入的元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E element)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> hash;<br>        String valString = element.toString();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; k; x++) &#123;<br>            hash = createHash(valString + Integer.toString(x));<br>            hash = hash % (<span class="hljs-keyword">long</span>) bitSetSize;<br>            bitset.set(Math.abs((<span class="hljs-keyword">int</span>) hash), <span class="hljs-keyword">true</span>);<br>        &#125;<br>        numberOfAddedElements++;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加入一个元素集合到过滤器中</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> c</span><br><span class="hljs-comment">     *            元素集合.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAll</span><span class="hljs-params">(Collection&lt;?</span></span><br><span class="hljs-function"><span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">            extends E&gt; c)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (E element : c)<br>            add(element);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用来推断元素是否在过滤器中。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     假设已存在。返回 true。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> element</span><br><span class="hljs-comment">     *            要检查的元素.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 假设预计该元素已存在。则返回true</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(E element)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> hash;<br>        String valString = element.toString();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; k; x++) &#123;<br>            hash = createHash(valString + Integer.toString(x));<br>            hash = hash % (<span class="hljs-keyword">long</span>) bitSetSize;<br>            <span class="hljs-keyword">if</span> (!bitset.get(Math.abs((<span class="hljs-keyword">int</span>) hash)))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 推断一个集合中的元素是否都在过滤器中。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> c</span><br><span class="hljs-comment">     *            要检查的元素集合</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 假设集合全部的元素都在过滤器中。则返回true。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (E element : c)<br>            <span class="hljs-keyword">if</span> (!contains(element))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 得到某一位的值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bit</span><br><span class="hljs-comment">     *            bit的位置.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 假设该位被设置，则返回true。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">getBit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> bit)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> bitset.get(bit);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置过滤器某一位的值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bit</span><br><span class="hljs-comment">     *            要设置的位置.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment">     *            true表示已经成功设置。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    false表示改为被清除。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> bit, <span class="hljs-keyword">boolean</span> value)</span> </span>&#123;<br>        bitset.set(bit, value);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回存放信息的位数组.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 位数组.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BitSet <span class="hljs-title">getBitSet</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> bitset;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 得到过滤器中位数组个大小。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 数组大小.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.bitSetSize;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回已加入的元素的个数</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 元素个数.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.numberOfAddedElements;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 得到能加入的元素的最大数量</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  最大数量.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getExpectedNumberOfElements</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> expectedNumberOfFilterElements;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 得到每一个元素占用的位的个数的期望值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 每一个元素占用的位数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getExpectedBitsPerElement</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.bitsPerElement;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 得到每一个元素占用位数的实际值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 每一个元素占用的位数.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getBitsPerElement</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.bitSetSize / (<span class="hljs-keyword">double</span>) numberOfAddedElements;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><p>优点 </p><ol><li>占用空间小，节省内存空间。</li><li>查询效率高，相对于普通的容器结构。</li></ol><p>缺点<br>  1.返回的数据结果是概率性的，并不是完全准确，在数据量越多误报可能性越大。</p><p>原理</p><p>  1.当元素加入布隆过滤器的时候，会对元素进行哈希运算，得到其哈希值（有几个函数得到几个哈希值）<br>  2.根据得到的哈希值，在位数组中把对应的下标的值设置为1。<br>  3.在对数据查询判断时对其取哈希如果每个哈希对应的元素的数组值都为1则该数据存在。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/bloom-hash.png" alt="图片"></p><p>特点<br>  布隆过滤器检测存在该元素其可能出现误判，布隆过滤器检测该元素不存在则该元素一定不存在。</p><p>应用场景</p><ol><li>防止恶意请求，缓存穿透，垃圾邮件，黑名单。</li><li>去重功能。</li></ol><p>实际应用</p><ol><li>比特币网络</li><li>分布式系统(Map-Reduce) - Hadoop、Search engine</li><li>Redis缓存</li><li>垃圾邮件、评论等的过滤</li></ol><h1 id="最近使用缓存-LRU-Cache"><a href="#最近使用缓存-LRU-Cache" class="headerlink" title="最近使用缓存(LRU Cache)"></a>最近使用缓存(LRU Cache)</h1><ul><li>两个要素: 大小、替换策略</li><li>HashTable + Double LinkedList</li><li>O(1)查询、O(1)修改、更新</li></ul><details>    <summary>        <span>LRU Cache</span>    </summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DLinkedNode</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> key;<br>        <span class="hljs-keyword">int</span> value;<br>        DLinkedNode prev;<br>        DLinkedNode next;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DLinkedNode</span><span class="hljs-params">()</span> </span>&#123;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DLinkedNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _key, <span class="hljs-keyword">int</span> _value)</span> </span>&#123;<br>            key = _key;<br>            value = _value;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="hljs-keyword">new</span> HashMap&lt;Integer, DLinkedNode&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;<br>    <span class="hljs-keyword">private</span> DLinkedNode head, tail;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>.capacity = capacity;<br>        <span class="hljs-comment">// 使用伪头部和伪尾部节点</span><br>        head = <span class="hljs-keyword">new</span> DLinkedNode();<br>        tail = <span class="hljs-keyword">new</span> DLinkedNode();<br>        head.next = tail;<br>        tail.prev = head;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        DLinkedNode node = cache.get(key);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span><br>        moveToHead(node);<br>        <span class="hljs-keyword">return</span> node.value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        DLinkedNode node = cache.get(key);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 如果 key 不存在，创建一个新的节点</span><br>            DLinkedNode newNode = <span class="hljs-keyword">new</span> DLinkedNode(key, value);<br>            <span class="hljs-comment">// 添加进哈希表</span><br>            cache.put(key, newNode);<br>            <span class="hljs-comment">// 添加至双向链表的头部</span><br>            addToHead(newNode);<br>            ++size;<br>            <span class="hljs-keyword">if</span> (size &gt; capacity) &#123;<br>                <span class="hljs-comment">// 如果超出容量，删除双向链表的尾部节点</span><br>                DLinkedNode tail = removeTail();<br>                <span class="hljs-comment">// 删除哈希表中对应的项</span><br>                cache.remove(tail.key);<br>                --size;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span><br>            node.value = value;<br>            moveToHead(node);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addToHead</span><span class="hljs-params">(DLinkedNode node)</span> </span>&#123;<br>        node.prev = head;<br>        node.next = head.next;<br>        head.next.prev = node;<br>        head.next = node;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeNode</span><span class="hljs-params">(DLinkedNode node)</span> </span>&#123;<br>        node.prev.next = node.next;<br>        node.next.prev = node.prev;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">moveToHead</span><span class="hljs-params">(DLinkedNode node)</span> </span>&#123;<br>        removeNode(node);<br>        addToHead(node);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> DLinkedNode <span class="hljs-title">removeTail</span><span class="hljs-params">()</span> </span>&#123;<br>        DLinkedNode res = tail.prev;<br>        removeNode(res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">数据结构-在线演示</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试篇-自我介绍</title>
    <link href="/2020/11/19/interview/%E9%9D%A2%E8%AF%95%E7%AF%87-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/"/>
    <url>/2020/11/19/interview/%E9%9D%A2%E8%AF%95%E7%AF%87-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>面试官您好，很高兴能参加这次面试。我叫，就读于梧州学院软件工程专业。目前主要学习的方向是Java的后端开发。</p><h2 id="学习方面："><a href="#学习方面：" class="headerlink" title="学习方面："></a>学习方面：</h2><p>出于个人的兴趣，选择了计算机相关专业，在校期间学习的主要一些计算机基础知识。从大一开始加入学校软件开发中心机构，在老师的带领下接触项目开发，通过不断的锻炼和学习，现在可以带领团队独立开发项目。期间也接触过挺多项目的开发。</p><p>在校期间积极参加相关学科竞赛，先后取得一些不错奖项，像计算机设计大赛，中国软件杯，广西人工智能大赛，互联网+大赛，多项软件著作权等等。</p><h2 id="实践方面："><a href="#实践方面：" class="headerlink" title="实践方面："></a>实践方面：</h2><p>2019年,曾在一家小公司实习过三个月，主要负责业务系统的后台开发，（难点：数据查询十分缓慢，优化方法：1.使用redis进行数据缓存 2.通过explain工具对SQL进行分析,对表进行建立索引）</p><h2 id="兴趣爱好："><a href="#兴趣爱好：" class="headerlink" title="兴趣爱好："></a>兴趣爱好：</h2><p>渴望学习技术，平时喜欢逛一些技术论坛，通过教学视频学习一些主流技术，写写相关技术博客。</p><h2 id="参与项目："><a href="#参与项目：" class="headerlink" title="参与项目："></a>参与项目：</h2><ul><li>《大学生创新创业管理系统》<br>项目难点：<br>业务需求的频繁变更、</li></ul><ul><li>《高校毕业设计及过程监管平台》<br>项目难点：<br>聊天室的实现、</li></ul><ul><li>《公共地点人流量预警监控平台》<br>项目难点：<br>多线程视频窗口显示、</li></ul><ul><li><p>《基于区块链政校企信息共享平台》<br>项目难点：<br>区块链网络的搭建、</p></li><li><p>《智慧农业监控平台》<br>项目难点：</p></li></ul><h2 id="提问问题"><a href="#提问问题" class="headerlink" title="提问问题"></a>提问问题</h2><ul><li>加班情况</li><li>加班费</li><li>薪资结构</li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法篇-刷题记录</title>
    <link href="/2020/11/19/algorithm/%E7%AE%97%E6%B3%95%E7%AF%87-%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/11/19/algorithm/%E7%AE%97%E6%B3%95%E7%AF%87-%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="刷题前言"><a href="#刷题前言" class="headerlink" title="刷题前言"></a>刷题前言</h1><blockquote><p>先复习一波<a href="https://mikeygithub.github.io/2020/11/14/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">算法基础</a>、建议根据题目类型来刷、这样有利于熟悉其规律和提高速度</p></blockquote><h1 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h1><blockquote><p>链表一般采用双指针</p></blockquote><details>  <summary><span><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof">反转链表(简单)</a></span></summary>  <br><p>解题思路</p><blockquote><p>迭代: 双指针，pre,cur 完善</p></blockquote><blockquote><p>递归: 递归到尾节点，将其返回，设置下一个节点为</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//迭代</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        ListNode prev = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//指向前一个节点</span><br>        ListNode curr = head;<span class="hljs-comment">//当前节点</span><br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-keyword">null</span>) &#123;<br>            ListNode nextTemp = curr.next;<br>            curr.next = prev;<br>            prev = curr;<br>            curr = nextTemp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br><br>    <span class="hljs-comment">//递归</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//递归结束条件返回初始链表最后一个结点</span><br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode p = reverseList(head.next);<span class="hljs-comment">//</span><br>        head.next.next = head;<span class="hljs-comment">//</span><br>        head.next = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//下一个结点</span><br>        <span class="hljs-keyword">return</span> p;<span class="hljs-comment">//始终返回初始链表最后一个结点</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/linked-list-cycle/">环形链表(简单)</a></span></summary>  <br><p>题目</p><blockquote><p>给定一个链表，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 如果链表中存在环，则返回 true 。 否则，返回 false 。</p></blockquote><p>解题思路</p><blockquote><p>采用哈希表或者快慢指针两中方法</p></blockquote><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        ListNode slow = head;<br>        ListNode fast = head.next;<br>        <span class="hljs-keyword">while</span> (slow != fast) &#123;<br>            <span class="hljs-keyword">if</span> (fast == <span class="hljs-keyword">null</span> || fast.next == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/"><span>环形链表 II(中等)</span></a>    </summary>    <br><p>解题思路</p><blockquote><p>先判断是否存在环，再确定其入环节点，采用双指针迭代，步长分别为1和2，当有环时两者会重逢，确定入环节点<code>头节点到环入口的距离=环的长度</code></p></blockquote><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/">官方解题</a></p><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<span class="hljs-comment">//空值返回</span><br>        ListNode slow = head, fast = head;<span class="hljs-comment">//俩个指针,slow步长1,fast步长2</span><br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//移动</span><br>            slow = slow.next;<br>            <span class="hljs-keyword">if</span> (fast.next != <span class="hljs-keyword">null</span>) fast = fast.next.next;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            <span class="hljs-comment">//指针重逢</span><br>            <span class="hljs-keyword">if</span> (fast == slow) &#123;<span class="hljs-comment">//</span><br>                ListNode ptr = head;<span class="hljs-comment">//</span><br>                <span class="hljs-keyword">while</span> (ptr != slow) &#123;<span class="hljs-comment">//当fast和slow重逢时，头节点到环入口的距离=环的长度</span><br>                    ptr = ptr.next;<br>                    slow = slow.next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> ptr;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/"><span>相交链表(简单)</span></a>    </summary>    <br><p>解题思路</p><blockquote><p>两条链表分别同时遍历，当到达链尾时<code>指向对方表头</code>再次重逢就是该节点</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">A:1-2-3-4-5<br>B:7-8-9-3-4-5<br><br>  1-2<br> \<br>  3-4-5<br> /<br>7-9-8<br><br>遍历<br>1-2-3-4-5-7-8-9-`3`<br>7-8-9-3-4-5-1-2-`3`<br></code></pre></td></tr></table></figure><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 定义两个指针, 第一轮让两个到达末尾的节点指向另一个链表的头部, 最后如果相遇则为交点(在第一轮移动中恰好抹除了长度差)</span><br><span class="hljs-comment">         * 两个指针等于移动了相同的距离, 有交点就返回, 无交点就是各走了两条指针的长度</span><br><span class="hljs-comment">         **/</span><br>        <span class="hljs-keyword">if</span> (headA == <span class="hljs-keyword">null</span> || headB == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        ListNode pA = headA, pB = headB;<br>        <span class="hljs-comment">// 在这里第一轮体现在pA和pB第一次到达尾部会移向另一链表的表头, 而第二轮体现在如果pA或pB相交就返回交点, 不相交最后就是null==null</span><br>        <span class="hljs-keyword">while</span> (pA != pB) &#123;<br>            pA = pA == <span class="hljs-keyword">null</span> ? headB : pA.next;<br>            pB = pB == <span class="hljs-keyword">null</span> ? headA : pB.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/"><span>反转链表II(中等)</span></a>    </summary>    <br><p>解题思路</p><blockquote><p>递归</p><p>迭代</p></blockquote><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">K个一组翻转链表(困难)</a></span>    </summary><p>解题思路</p><blockquote></blockquote><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//判断当前链表是否大于K</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists">合并两个有序链表(简单)</a></span></summary>  <br><p>解题思路</p><blockquote><p>递归或者迭代双指针</p></blockquote><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 递归</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> l1</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> l2</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l2 == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;<br>            l1.next = mergeTwoLists(l1.next, l2);<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l2.next = mergeTwoLists(l1, l2.next);<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 迭代</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> l1</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> l2</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br><br>        ListNode prehead = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<span class="hljs-comment">//定义一个头指针</span><br>        ListNode prev = prehead;<span class="hljs-comment">//前一个指针</span><br><br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val) &#123;<br>                prev.next = l1;<br>                l1 = l1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                prev.next = l2;<br>                l2 = l2.next;<br>            &#125;<br>            prev = prev.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span><br>        prev.next = l1 == <span class="hljs-keyword">null</span> ? l2 : l1;<br><br>        <span class="hljs-keyword">return</span> prehead.next;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></details><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/palindrome-linked-list">回文链表(简单)</a></span>    </summary><p>解题思路</p><blockquote><p>1.数组双指针判断</p><p>2.递归双指针判断</p></blockquote><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    ListNode prev = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">//递归</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        prev = head;<br>        <span class="hljs-keyword">return</span> helper(head);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">helper</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">boolean</span> res = helper(head.next);<br>        <span class="hljs-keyword">if</span> (head.val != prev.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        prev = prev.next;<br>        <span class="hljs-keyword">if</span> (prev == head) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">//双指针</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome1</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        List&lt;ListNode&gt; arr = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;<br>            arr.add(head);<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = arr.size() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">if</span> (arr.get(i).val != arr.get(j).val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            i++;<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof">链表中倒数第k个节点(简单)</a></span>    </summary><p>解题思路</p><blockquote><p>1.两轮循环先获取链表长度，然后循环 长度-k次</p><p>2.双指针判断，前指针走k步后，双指针同时向后移动，直到前指针指向链尾部</p></blockquote><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        ListNode former = head, latter = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)<br>            former = former.next;<br>        <span class="hljs-keyword">while</span> (former != <span class="hljs-keyword">null</span>) &#123;<br>            former = former.next;<br>            latter = latter.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> latter;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">合并K个升序链表(困难)</a></span>    </summary><p>解题思路</p><blockquote></blockquote><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;<br>        ListNode ans = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; lists.length; ++i) &#123;<br>            ans = mergeTwoLists(ans, lists[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode a, ListNode b)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (a == <span class="hljs-keyword">null</span> || b == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> a != <span class="hljs-keyword">null</span> ? a : b;<br>        &#125;<br>        ListNode head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        ListNode tail = head, aPtr = a, bPtr = b;<br>        <span class="hljs-keyword">while</span> (aPtr != <span class="hljs-keyword">null</span> &amp;&amp; bPtr != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (aPtr.val &lt; bPtr.val) &#123;<br>                tail.next = aPtr;<br>                aPtr = aPtr.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                tail.next = bPtr;<br>                bPtr = bPtr.next;<br>            &#125;<br>            tail = tail.next;<br>        &#125;<br>        tail.next = (aPtr != <span class="hljs-keyword">null</span> ? aPtr : bPtr);<br>        <span class="hljs-keyword">return</span> head.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/lru-cache/">LRU 缓存机制(中等)</a></span>    </summary><p>解题思路</p><blockquote><p>LRU 缓存机制可以通过<code>哈希表</code>辅以<code>双向链表</code>实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。</p></blockquote><p>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</p><p>哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。</p><p>这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(1) 的时间内完成 get 或者 put 操作。具体的方法如下：</p><blockquote><p>对于 get 操作，首先判断 key 是否存在：如果 key 不存在，则返回 −1；如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。</p></blockquote><blockquote><p>对于 put 操作，首先判断 key 是否存在：如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。</p></blockquote><p>上述各项操作中，访问哈希表的时间复杂度为 O(1)，在双向链表的头部添加节点、在双向链表的尾部删除节点的复杂度也为 O(1)。而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在 O(1)<br>时间内完成。</p><p>小贴士</p><p>在双向链表的实现中，使用一个伪头部（dummy head）和伪尾部（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。</p><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DLinkedNode</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> key;<br>        <span class="hljs-keyword">int</span> value;<br>        DLinkedNode prev;<br>        DLinkedNode next;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DLinkedNode</span><span class="hljs-params">()</span> </span>&#123;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DLinkedNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _key, <span class="hljs-keyword">int</span> _value)</span> </span>&#123;<br>            key = _key;<br>            value = _value;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="hljs-keyword">new</span> HashMap&lt;Integer, DLinkedNode&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;<br>    <span class="hljs-keyword">private</span> DLinkedNode head, tail;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>.capacity = capacity;<br>        <span class="hljs-comment">// 使用伪头部和伪尾部节点</span><br>        head = <span class="hljs-keyword">new</span> DLinkedNode();<br>        tail = <span class="hljs-keyword">new</span> DLinkedNode();<br>        head.next = tail;<br>        tail.prev = head;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        DLinkedNode node = cache.get(key);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span><br>        moveToHead(node);<br>        <span class="hljs-keyword">return</span> node.value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        DLinkedNode node = cache.get(key);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 如果 key 不存在，创建一个新的节点</span><br>            DLinkedNode newNode = <span class="hljs-keyword">new</span> DLinkedNode(key, value);<br>            <span class="hljs-comment">// 添加进哈希表</span><br>            cache.put(key, newNode);<br>            <span class="hljs-comment">// 添加至双向链表的头部</span><br>            addToHead(newNode);<br>            ++size;<br>            <span class="hljs-keyword">if</span> (size &gt; capacity) &#123;<br>                <span class="hljs-comment">// 如果超出容量，删除双向链表的尾部节点</span><br>                DLinkedNode tail = removeTail();<br>                <span class="hljs-comment">// 删除哈希表中对应的项</span><br>                cache.remove(tail.key);<br>                --size;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span><br>            node.value = value;<br>            moveToHead(node);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addToHead</span><span class="hljs-params">(DLinkedNode node)</span> </span>&#123;<br>        node.prev = head;<br>        node.next = head.next;<br>        head.next.prev = node;<br>        head.next = node;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeNode</span><span class="hljs-params">(DLinkedNode node)</span> </span>&#123;<br>        node.prev.next = node.next;<br>        node.next.prev = node.prev;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">moveToHead</span><span class="hljs-params">(DLinkedNode node)</span> </span>&#123;<br>        removeNode(node);<br>        addToHead(node);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> DLinkedNode <span class="hljs-title">removeTail</span><span class="hljs-params">()</span> </span>&#123;<br>        DLinkedNode res = tail.prev;<br>        removeNode(res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：对于 put 和 get 都是 O(1)。</p><p>空间复杂度：O(capacity)，因为哈希表和双向链表最多存储 capacity+1 个元素。</p></details><h1 id="树型结构"><a href="#树型结构" class="headerlink" title="树型结构"></a>树型结构</h1><blockquote><p>在树的题目当中主要围绕着,前序、中序、后续、广度、深度遍历来进行解题，所以掌握其十分重要，直接上迭代版本，递归太简单就不上了</p></blockquote><details>  <summary><span>前序遍历</span></summary>  <br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>            stack.push(root);<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>                TreeNode tmp = stack.pop();<br>                list.add(tmp.val);<br>                <span class="hljs-keyword">if</span> (tmp.right != <span class="hljs-keyword">null</span>)<br>                    stack.push(tmp.right);<br>                <span class="hljs-keyword">if</span> (tmp.left != <span class="hljs-keyword">null</span>)<br>                    stack.push(tmp.left);<br>            &#125;<br>            <span class="hljs-keyword">return</span> list;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span>中序遍历</span></summary>  <br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span> || !stack.isEmpty()) &#123;<br>                <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 一路向左把沿途结点压入栈</span><br>                    stack.push(root);<br>                    root = root.left;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (!stack.isEmpty()) &#123;<br>                    root = stack.pop();<span class="hljs-comment">// 弹出栈</span><br>                    list.add(root.val);<br>                    root = root.right;<span class="hljs-comment">// 转向右节点</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> list;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span>后序遍历</span></summary>  <br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">postorderTreversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>            stack.push(root);<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>                TreeNode tmp = stack.pop();<br>                list.add(tmp.val);<br>                <span class="hljs-keyword">if</span> (tmp.left != <span class="hljs-keyword">null</span>) &#123;<br>                    stack.push(tmp.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (tmp.right != <span class="hljs-keyword">null</span>) &#123;<br>                    stack.push(tmp.right);<br>                &#125;<br>            &#125;<br>            Collections.reverse(list);<br>            <span class="hljs-keyword">return</span> list;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span>广度优先 </span></summary>  <br><blockquote><p>借助队列</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (!Objects.isNull(root)) queue.add(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            TreeNode node = queue.poll();<span class="hljs-comment">//出队</span><br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) queue.add(node.left);<br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) queue.add(node.right);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span>深度优先 </span></summary>  <br><blockquote><p>借助栈</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        stack.push(root);<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            TreeNode tmp = stack.pop();<br>            list.add(tmp.val);<br>            <span class="hljs-keyword">if</span> (tmp.left != <span class="hljs-keyword">null</span>) stack.push(tmp.left);<br>            <span class="hljs-keyword">if</span> (tmp.right != <span class="hljs-keyword">null</span>) stack.push(tmp.right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof">平衡二叉树(简单)</a></span></summary>  <br><p>判断是否是平衡二叉树</p><blockquote><p>判断树是否为平衡二叉树</p></blockquote><p>测试用例</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/balance_binary_tree.jpg" alt="avatar"></p><p>输入：root = [3,9,20,null,null,15,7]<br>输出：true</p><p>解题思路</p><blockquote><p>平衡二叉树：左右子树高度差不超过一，根据这一特点，递归判断各个节点的子树是否符合条件，不满足则直接返回false,直到递归完成。</p></blockquote><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>    TreeNode left;<br>    TreeNode right;<br><br>    TreeNode() &#123;<br>    &#125;<br><br>    TreeNode(<span class="hljs-keyword">int</span> val) &#123;<br>        <span class="hljs-keyword">this</span>.val = val;<br>    &#125;<br><br>    TreeNode(<span class="hljs-keyword">int</span> val, TreeNode left, TreeNode right) &#123;<br>        <span class="hljs-keyword">this</span>.val = val;<br>        <span class="hljs-keyword">this</span>.left = left;<br>        <span class="hljs-keyword">this</span>.right = right;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断是否为平衡二叉树</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> Math.abs(height(root.left) - height(root.right)) &lt;= <span class="hljs-number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取当前节点树高度</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">height</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> Math.max(height(root.left), height(root.right)) + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/list-of-depth-lcci" >特定深度节点链表(中等)</a> </span></summary>  <br><p>特定深度节点链表</p><p>题目描述</p><blockquote><p>给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 D，则会创建出 D 个链表）。返回一个包含所有深度的链表的数组。</p></blockquote><p>示例</p><p>输入：[1,2,3,4,5,null,7,8]</p><pre><code>    1   /  \   2    3 / \    \ 4   5    7</code></pre><p>/ 8</p><p>输出：[[1],[2,3],[4,5,7],[8]]</p><p>实现思路</p><blockquote><p>通过广度优先遍历对树进行逐层遍历构造链表，通过每一次获取当前队列长度读取当前层的元素个数(关键)</p></blockquote><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode[] listOfDepth(TreeNode tree) &#123;<br><br>        List&lt;ListNode&gt; listNodes = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">//广度优先遍历</span><br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        queue.add(tree);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-keyword">int</span> size = queue.size();<span class="hljs-comment">//队列大小（核心）</span><br>            ListNode head, tmp;<br>            head = tmp = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<span class="hljs-comment">//链表临时头节点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<span class="hljs-comment">//循环当前层元素</span><br>                TreeNode treeNode = queue.poll();<span class="hljs-comment">//从对头取当前元素</span><br>                <span class="hljs-comment">//构建链表</span><br>                tmp.next = <span class="hljs-keyword">new</span> ListNode(treeNode.val);<br>                tmp = tmp.next;<br>                <span class="hljs-comment">//将下一层元素压入队列</span><br>                <span class="hljs-keyword">if</span> (treeNode.left != <span class="hljs-keyword">null</span>) queue.add(treeNode.left);<br>                <span class="hljs-keyword">if</span> (treeNode.right != <span class="hljs-keyword">null</span>) queue.add(treeNode.right);<br>            &#125;<br>            <span class="hljs-comment">//将每一条链表添加到list中</span><br>            listNodes.add(head.next);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> listNodes.toArray(<span class="hljs-keyword">new</span> ListNode[]&#123;&#125;);<br>    &#125;<br>&#125;<br>```        <br><br>&lt;/details&gt;<br><br>&lt;details&gt;<br>  &lt;summary&gt;&lt;span&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal&quot; &gt;N叉树的前序遍历(简单)&lt;/a&gt; &lt;/span&gt;&lt;/summary&gt;<br>  &lt;br&gt;<br><br>N叉树的前序遍历<br><br>题目描述<br><br>给定一个 N 叉树，返回其节点值的前序遍历。<br><br>例如，给定一个 <span class="hljs-number">3</span>叉树 :<br><br>![avatar](https:<span class="hljs-comment">//cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/n-tree.png)</span><br><br>返回其前序遍历: [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]。<br><br>代码实现<br><br> ```java<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tree</span> </span>&#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorder</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>        list.add(root.val);<br>        <span class="hljs-comment">//遍历子节点</span><br>        root.children.forEach(v -&gt; &#123;<br>            preorder(v);<br>        &#125;);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorder</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>        <span class="hljs-comment">//容器</span><br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> list;<br>        &#125;<br>        <span class="hljs-comment">//首个节点</span><br>        stack.push(root);<br>        <span class="hljs-comment">//迭代</span><br>        <span class="hljs-keyword">while</span> (!stack.empty()) &#123;<br>            Node tmp = stack.pop();<span class="hljs-comment">//出栈</span><br>            list.add(tmp.val);<span class="hljs-comment">//插入值</span><br>            Collections.reverse(tmp.children);<span class="hljs-comment">//将子节点进行反转</span><br>            tmp.children.forEach(v -&gt; stack.push(v));<span class="hljs-comment">//压栈</span><br>        &#125;<br>        <span class="hljs-comment">//返回结果</span><br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/maximum-binary-tree">最大二叉树(中等)</a> </span></summary>  <br><p>最大二叉树</p><p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p><p>二叉树的根是数组中的最大元素。 左子树是通过数组中最大值左边部分构造出的最大二叉树。 右子树是通过数组中最大值右边部分构造出的最大二叉树。 通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p><p> </p><p>示例 ：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[3,2,1,6,0,5]<br>输出：返回下面这棵树的根节点：<br><br>      6<br>    /   \<br>  <span class="hljs-number"> 3 </span>    5<br>    \    / <br>    <span class="hljs-number"> 2 </span><span class="hljs-number"> 0 </span>  <br>       \<br>        1<br> <br></code></pre></td></tr></table></figure><p>提示：给定的数组的大小在 [1, 1000] 之间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//获得最大值</span><br>        <span class="hljs-keyword">int</span> maxIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[maxIndex] &lt; nums[i]) maxIndex = i;<br>        &#125;<br>        <span class="hljs-comment">//构造当前节点</span><br>        TreeNode node = <span class="hljs-keyword">new</span> TreeNode(nums[maxIndex]);<br>        <span class="hljs-comment">//构造左子树</span><br>        <span class="hljs-keyword">if</span> (maxIndex &gt;= <span class="hljs-number">0</span>)<span class="hljs-comment">//左边数组还有值</span><br>            node.left = constructMaximumBinaryTree(Arrays.copyOfRange(nums, <span class="hljs-number">0</span>, maxIndex));<br>        <span class="hljs-comment">//构造右子树</span><br>        <span class="hljs-keyword">if</span> (maxIndex &lt; nums.length - <span class="hljs-number">1</span>)<span class="hljs-comment">//右边数组还有值</span><br>            node.right = constructMaximumBinaryTree(Arrays.copyOfRange(nums, maxIndex + <span class="hljs-number">1</span>, nums.length));<br>        <span class="hljs-comment">//返回当前节点</span><br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/maximum-binary-tree-ii" >最大二叉树 II(中等)</a>  </span></summary>  <br><p>最大树定义：一个树，其中每个节点的值都大于其子树中的任何其他值。</p><p>给出最大树的根节点 root。</p><p>就像之前的问题那样，给定的树是从表 A（root = Construct(A)）递归地使用下述 Construct(A) 例程构造的：</p><p>如果 A 为空，返回 null 否则，令 A[i] 作为 A 的最大元素。创建一个值为 A[i] 的根节点 root root 的左子树将被构建为 Construct([A[0], A[1], …, A[i-1]])<br>root 的右子树将被构建为 Construct([A[i+1], A[i+2], …, A[A.length - 1]])<br>返回 root 请注意，我们没有直接给定 A，只有一个根节点 root = Construct(A).</p><p>假设 B 是 A 的副本，并附加值 val。保证 B 中的值是不同的。</p><p>返回 Construct(B)。</p><p> </p><p>示例 1：</p><p>输入：root = [4,1,3,null,null,2], val = 5 输出：[5,4,null,1,3,null,null,2]<br>解释：A = [1,4,2,3], B = [1,4,2,3,5]<br>示例 2：</p><p>输入：root = [5,2,4,null,1], val = 3 输出：[5,2,4,null,1,null,3]<br>解释：A = [2,1,5,4], B = [2,1,5,4,3]<br>示例 3：</p><p>输入：root = [5,2,3,null,1], val = 4 输出：[5,2,4,null,1,3]<br>解释：A = [2,1,5,3], B = [2,1,5,3,4]</p><p>提示：</p><p>1 &lt;= B.length &lt;= 100</p></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof">二叉搜索树的第k大节点(简单)</a> </span></summary>  <br><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p><p> </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">示例</span> <span class="hljs-attr">1:</span><br><br><span class="hljs-string">输入:</span> <span class="hljs-string">root</span> <span class="hljs-string">=</span> [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>]<span class="hljs-string">,</span> <span class="hljs-string">k</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span><br>   <span class="hljs-number">3</span><br>  <span class="hljs-string">/</span> <span class="hljs-string">\</span><br> <span class="hljs-number">1</span>   <span class="hljs-number">4</span><br>  <span class="hljs-string">\</span><br>   <span class="hljs-number">2</span><br><span class="hljs-string">输出:</span> <span class="hljs-number">4</span><br><span class="hljs-string">示例</span> <span class="hljs-attr">2:</span><br><br><span class="hljs-string">输入:</span> <span class="hljs-string">root</span> <span class="hljs-string">=</span> [<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>]<span class="hljs-string">,</span> <span class="hljs-string">k</span> <span class="hljs-string">=</span> <span class="hljs-number">3</span><br>       <span class="hljs-number">5</span><br>      <span class="hljs-string">/</span> <span class="hljs-string">\</span><br>     <span class="hljs-number">3</span>   <span class="hljs-number">6</span><br>    <span class="hljs-string">/</span> <span class="hljs-string">\</span><br>   <span class="hljs-number">2</span>   <span class="hljs-number">4</span><br>  <span class="hljs-string">/</span><br> <span class="hljs-number">1</span><br><span class="hljs-string">输出:</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>限制： 1 ≤ k ≤ 二叉搜索树元素个数</p><p>解题思路</p><blockquote><p>二叉搜索树、通过中许遍历得到递增序列、那么优先改变一下，从右子树先遍历即可得到递减序列</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthLargest</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// clarification:  root == null?   k &lt;= 1?</span><br>        helper(root, k);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span>) helper(root.right, k);<br><br>        <span class="hljs-keyword">if</span> (++count == k) &#123;<br>            ans = root.val;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) helper(root.left, k);<br>    &#125;<br>&#125;<br>```      <br><br>&lt;/details&gt;<br><br>&lt;details&gt;<br>  &lt;summary&gt;&lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-good-leaf-nodes-pairs/&quot;&gt;好叶子节点对的数量(中等)&lt;/a&gt;&lt;/span&gt;&lt;/summary&gt;<br>  &lt;br&gt;<br><br>给你二叉树的根节点 root 和一个整数 distance 。<br><br>如果二叉树中两个 叶 节点之间的 最短路径长度 小于或者等于 distance ，那它们就可以构成一组 好叶子节点对 。<br><br>返回树中 好叶子节点对的数量 。<br><br>示例<br><br>```text<br>输入: root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-keyword">null</span>,<span class="hljs-number">4</span>], distance = <span class="hljs-number">3</span><br>       <span class="hljs-number">1</span><br>      / \<br>     <span class="hljs-number">2</span>   <span class="hljs-number">3</span><br>      \<br>       <span class="hljs-number">4</span><br>输出: <span class="hljs-number">1</span><br>解释：树的叶节点是 <span class="hljs-number">3</span> 和 <span class="hljs-number">4</span> ，它们之间的最短路径的长度是 <span class="hljs-number">3</span> 。这是唯一的好叶子节点对。<br></code></pre></td></tr></table></figure><p>解题思路</p><blockquote><p>父节点和子节点的距离是 1</p></blockquote><blockquote><p>对树后序遍历 ，需要返回这个节点到其下方所有叶子节点的距离</p></blockquote><blockquote><p>这样就可以将这个节点的左子树所有叶子节点和右子树所有叶子节点都凑个对</p></blockquote><blockquote><p>然后将所有叶子节点不超过距离的弄到一起返回</p></blockquote><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//计数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countPairs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> distance)</span> </span>&#123;<br>        dfs(root, distance);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">//后续遍历</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> distance)</span> </span>&#123;<br>        <span class="hljs-comment">//当前节点为空返回空</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList();<br>        <span class="hljs-comment">//叶子节点</span><br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;<br>            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList();<br>            list.add(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> list;<br>        &#125;<br>        <span class="hljs-comment">//</span><br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList();<br>        <span class="hljs-comment">//左叶子节点的距离</span><br>        List&lt;Integer&gt; left = dfs(root.left, distance);<br>        <span class="hljs-comment">//判断是否超过distance</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> it : left) &#123;<br>            <span class="hljs-keyword">if</span> (++it &gt; distance)<br>                <span class="hljs-keyword">continue</span>;<br>            list.add(it);<br>        &#125;<br>        <span class="hljs-comment">//右叶子节点的距离</span><br>        List&lt;Integer&gt; right = dfs(root.right, distance);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> it : right) &#123;<br>            <span class="hljs-keyword">if</span> (++it &gt; distance)<br>                <span class="hljs-keyword">continue</span>;<br>            list.add(it);<br>        &#125;<br>        <span class="hljs-comment">//</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l : left) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r : right) &#123;<br>                <span class="hljs-keyword">if</span> (l + r + <span class="hljs-number">2</span> &lt;= distance)<br>                    ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes">具有所有最深节点的最小子树(中等)</a></span></summary>  <br><p>题目描述</p><blockquote><p>给定一个根为 root 的二叉树，每个节点的深度是 该节点到根的最短距离 。 如果一个节点在 整个树 的任意节点之间具有最大的深度，则该节点是 最深的 。 一个节点的 子树 是该节点加上它的所有后代的集合。 返回能满足 以该节点为根的子树中包含所有最深的节点 这一条件的具有最大深度的节点。</p></blockquote><p><code>说的云里雾里，人话：最深叶子节点的最近公共祖先</code></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/sketch1.png" alt="avatar"></p><blockquote><p>输入：root = [3,5,1,6,2,0,8,null,null,7,4]<br>输出：[2,7,4]<br>解释： 我们返回值为 2 的节点，在图中用黄色标记。 在图中用蓝色标记的是树的最深的节点。 注意，节点 5、3 和 2 包含树中最深的节点，但节点 2 的子树最小，因此我们返回它。</p></blockquote><p>解题思路</p><blockquote><p>对于一个节点，如果左子树高度==右子树高度，这个节点就是答案，如果左子树高度&lt;右子树高度，查找右子树，否则查找左子树</p></blockquote><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">subtreeWithAllDeepest</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<span class="hljs-comment">//为空返回</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> ldep = maxDepth(root.left), rdep = maxDepth(root.right);<span class="hljs-comment">//获取左右最大深度</span><br>            <span class="hljs-keyword">if</span> (ldep == rdep) <span class="hljs-keyword">return</span> root;<span class="hljs-comment">//相等返回</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ldep &gt; rdep) <span class="hljs-keyword">return</span> subtreeWithAllDeepest(root.left);<span class="hljs-comment">//左边深度大、查找左边</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> subtreeWithAllDeepest(root.right);<span class="hljs-comment">//右边深度大、查找右边</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<span class="hljs-comment">//获取当前节点的最大深度</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/paths-with-sum-lcci/">求和路径(中等)</a></span></summary>  <br><p>题目描述</p><p>给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。</p><p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p><pre><code>          5         / \        4   8       /   / \      11  13  4     /  \    / \    7    2  5   1</code></pre><p>返回:3 解释：和为 22 的路径有：[5,4,11,2], [5,8,4,5], [4,11,7]<br>提示：节点总数 &lt;= 10000</p><p>解题思路</p><blockquote><p>求出当前节点为根路径是否满足，递归判断每个节点</p></blockquote><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        helper(root, sum);<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) pathSum(root.left, sum);<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span>) pathSum(root.right, sum);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode node, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sum == node.val) count++;<br>        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) helper(node.left, sum - node.val);<br>        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) helper(node.right, sum - node.val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal">二叉树的层序遍历(中等)</a></span></summary>  <br><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p>  </p><p>示例： 二叉树：[3,9,20,null,null,15,7],</p><pre><code> 3/ \</code></pre><p>9 20 /  <br>15 7 返回其层次遍历结果：</p><p>[<br>[3],<br>[9,20],<br>[15,7]<br>]</p><p>解题思路</p><blockquote><p>广度优先遍历，采用队列获取其每层的长度</p></blockquote><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        List&lt;Integer&gt; list;<br>        <span class="hljs-keyword">if</span> (!Objects.isNull(root)) queue.add(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-keyword">int</span> size = queue.size();<br>            list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                TreeNode node = queue.poll();<br>                list.add(node.val);<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) queue.add(node.left);<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) queue.add(node.right);<br>            &#125;<br>            result.add(list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree">二叉树的最近公共祖先(中等)</a></span></summary><p>题目描述</p><blockquote><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p></blockquote><p>解题思路</p><blockquote><p>对树DFS判断其目标节点是否存在，如果存在返回true寻找另一个节点，当两个节点都找到，递归返回获得其第一个公共节点</p></blockquote><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span> || p == root || q == root)<span class="hljs-keyword">return</span> root;<span class="hljs-comment">//递归结束条件</span><br>        TreeNode left = lowestCommonAncestor(root.left,p,q);<span class="hljs-comment">//深度优先遍历左子树</span><br>        TreeNode right = lowestCommonAncestor(root.right,p,q);<span class="hljs-comment">//深度优先遍历右子树</span><br>        <span class="hljs-keyword">if</span>(left!=<span class="hljs-keyword">null</span> &amp;&amp; right != <span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span> root;<span class="hljs-comment">//找到节点将其返回</span><br>        <span class="hljs-keyword">return</span> left == <span class="hljs-keyword">null</span> ? right : left;<span class="hljs-comment">//否则返回已查询到的节点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree">二叉树的直径(容易)</a></span></summary>  <br><p>题目描述</p><blockquote><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p></blockquote><p>示例 :<br>给定二叉树</p><pre><code>       1      / \     2   3    / \        4   5    </code></pre><p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><p>注意：两结点之间的路径长度是以它们之间边的数目表示。</p><p>解题思路</p><blockquote><p>深度优先搜索，分别递归计算每个节点的左右子树的路径之和，默认值为1超过则更新，递归向上执行</p></blockquote><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ans;<span class="hljs-comment">//记录最大路径</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<span class="hljs-comment">//方法入口</span><br>        ans = <span class="hljs-number">1</span>;<br>        depth(root);<br>        <span class="hljs-keyword">return</span> ans - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//深度优先遍历</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 访问到空节点了，返回0</span><br>        <span class="hljs-keyword">int</span> L = depth(node.left); <span class="hljs-comment">// 左儿子为根的子树的深度</span><br>        <span class="hljs-keyword">int</span> R = depth(node.right); <span class="hljs-comment">// 右儿子为根的子树的深度</span><br>        ans = Math.max(ans, L + R + <span class="hljs-number">1</span>); <span class="hljs-comment">// 计算d_node即L+R+1 并更新ans</span><br>        <span class="hljs-keyword">return</span> Math.max(L, R) + <span class="hljs-number">1</span>; <span class="hljs-comment">// 返回该节点为根的子树的深度</span><br>    &#125;<br>&#125;<br><br>``` <br><br>&lt;/details&gt;<br><br>&lt;details&gt;<br>  &lt;summary&gt;&lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal&quot;&gt;二叉树的锯齿形层次遍历(中等)&lt;/a&gt;&lt;/span&gt;&lt;/summary&gt;<br>  &lt;br&gt;<br><br>题目描述<br>&gt; 给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。<br><br>例如： 给定二叉树 [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>],<br><br>     <span class="hljs-number">3</span><br>    / \<br><br><span class="hljs-number">9</span> <span class="hljs-number">20</span> /  \<br><span class="hljs-number">15</span> <span class="hljs-number">7</span> 返回锯齿形层次遍历如下：<br><br>[<br>[<span class="hljs-number">3</span>],<br>[<span class="hljs-number">20</span>,<span class="hljs-number">9</span>],<br>[<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>]<br><br>解题思路<br>&gt; 广度优先遍历，每次将当前层元素出队，使用一个全局变量判断方向，调用addLast或者addFirst。<br><br>代码实现<br><br>```java<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode node, <span class="hljs-keyword">int</span> level, List&lt;List&lt;Integer&gt;&gt; results)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (level &gt;= results.size()) &#123;<br>            LinkedList&lt;Integer&gt; newLevel = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>            newLevel.add(node.val);<br>            results.add(newLevel);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (level % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>                results.get(level).add(node.val);<br>            <span class="hljs-keyword">else</span><br>                results.get(level).add(<span class="hljs-number">0</span>, node.val);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) DFS(node.left, level + <span class="hljs-number">1</span>, results);<br>        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) DFS(node.right, level + <span class="hljs-number">1</span>, results);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>        &#125;<br>        List&lt;List&lt;Integer&gt;&gt; results = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>        DFS(root, <span class="hljs-number">0</span>, results);<br>        <span class="hljs-keyword">return</span> results;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree">二叉树的最大深度(简单)</a></span></summary>  <br><p>解题思路</p><blockquote><p>递归每次递归返回+1,返回左右节点较大的值。</p></blockquote><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (Objects.isNull(root)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/balanced-binary-tree" taget="_blank">验证二叉搜索树(中等)</a></span></summary>  <br><p>题目描述</p><blockquote><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p></blockquote><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含小于当前节点的数。</li><li>节点的右子树只包含大于当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p>示例 1:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入:<br>     <span class="hljs-number">2</span><br>    / <span class="hljs-string">\</span><br>   <span class="hljs-number">1</span>   <span class="hljs-number">3</span><br>输出: <span class="hljs-literal">true</span><br>示例 <span class="hljs-number">2</span>:<br> <br>输入:<br>     <span class="hljs-number">5</span><br>    / <span class="hljs-string">\</span><br>   <span class="hljs-number">1</span>   <span class="hljs-number">4</span><br>      / <span class="hljs-string">\</span><br>     <span class="hljs-number">3</span>   <span class="hljs-number">6</span><br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。</p><p>解题思路</p><blockquote><p>获取左右子书的边界值，递归判断每一个节点是否满足条件</p></blockquote><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//函数入口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> helper(root, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//DFS</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode node, Integer lower, Integer upper)</span> </span>&#123;<br>        <span class="hljs-comment">//空节点返回</span><br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-comment">//如果存在左子树则左子书最大值要小于当前节点值</span><br>        <span class="hljs-keyword">if</span> (lower != <span class="hljs-keyword">null</span> &amp;&amp; node.val &lt;= lower) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">//如果存在左子树则左子书最大值要小于当前节点值</span><br>        <span class="hljs-keyword">if</span> (upper != <span class="hljs-keyword">null</span> &amp;&amp; node.val &gt;= upper) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">//递归判断左子树</span><br>        <span class="hljs-keyword">if</span> (!helper(node.left, lower, val)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<span class="hljs-comment">//关键</span><br>        <span class="hljs-comment">//递归判断右子树</span><br>        <span class="hljs-keyword">if</span> (!helper(node.right, val, upper)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<span class="hljs-comment">//关键</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum" taget="_blank">二叉树中的最大路径和(困难)</a></span></summary>  <br><p>题目描述</p><blockquote><p>给定一个非空二叉树，返回其最大路径和。</p></blockquote><p>本题中，路径被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p><p>  </p><p>示例 1：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><br>       <span class="hljs-number">1</span><br>      / <span class="hljs-string">\</span><br>     <span class="hljs-number">2</span>   <span class="hljs-number">3</span><br><br>输出：<span class="hljs-number">6</span><br>示例 <span class="hljs-number">2</span>：<br><br>输入：[-<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br><br>   -<span class="hljs-number">10</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>    /  <span class="hljs-string">\</span><br>   <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br><br>输出：<span class="hljs-number">42</span><br></code></pre></td></tr></table></figure><p>解题思路</p><blockquote><p>后序递归遍历，判断其左右子树最大值，依此递归</p></blockquote><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ans = Integer.MIN_VALUE;<span class="hljs-comment">//记录结果</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        max(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">//后序遍历</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (Objects.isNull(root)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//递归结束</span><br>        <span class="hljs-keyword">int</span> left = Math.max(max(root.left), <span class="hljs-number">0</span>);<span class="hljs-comment">//左子树最大值</span><br>        <span class="hljs-keyword">int</span> right = Math.max(max(root.right), <span class="hljs-number">0</span>);<span class="hljs-comment">//右子树最大值</span><br>        ans = Math.max(ans, left + right + root.val);<span class="hljs-comment">//是否大于当前的最大值</span><br>        <span class="hljs-keyword">return</span> Math.max(left, right) + root.val;<span class="hljs-comment">//返回最大值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从前序与中序遍历序列构造二叉树(中等)</a></span></summary>  <br><blockquote><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p></blockquote><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>前序遍历 preorder =[3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]</p><p class="note note-primary">    采用递归</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs text">preorder = [3,9,20,15,7]<br>inorder = [9,3,15,20,7]<br>首先根据 preorder 找到根节点是 3<br>    <br>然后根据根节点将 inorder 分成左子树和右子树<br>左子树<br>inorder [9]<br><br>右子树<br>inorder [15,20,7]<br><br>把相应的前序遍历的数组也加进来<br>左子树<br>preorder[9] <br>inorder [9]<br><br>右子树<br>preorder[20 15 7] <br>inorder [15,20,7]<br><br>现在我们只需要构造左子树和右子树即可，成功把大问题化成了小问题<br>然后重复上边的步骤继续划分，直到 preorder 和 inorder 都为空，返回 null 即可<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<span class="hljs-comment">//存储值对应的下标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.length; i++)map.put(inorder[i], i);<span class="hljs-comment">//存入map</span><br>        <span class="hljs-keyword">return</span> buildTree(preorder,<span class="hljs-number">0</span>,preorder.length-<span class="hljs-number">1</span>,inorder,<span class="hljs-number">0</span>,inorder.length-<span class="hljs-number">1</span>,map);<span class="hljs-comment">//递归调用</span><br>    &#125;<br>    <span class="hljs-comment">//构建</span><br>    <span class="hljs-function">TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span> preStart, <span class="hljs-keyword">int</span> preEnd,<span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span> inStart, <span class="hljs-keyword">int</span> inEnd, Map&lt;Integer, Integer&gt; inMap)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(preStart &gt; preEnd || inStart &gt; inEnd) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<span class="hljs-comment">//下标超过则停止(递归结束条件)</span><br>        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(preorder[preStart]);<span class="hljs-comment">//构建结点</span><br>        <span class="hljs-keyword">int</span> inRoot = inMap.get(root.val);<span class="hljs-comment">//根结点下标</span><br>        <span class="hljs-keyword">int</span> numsLeft = inRoot - inStart;<span class="hljs-comment">//重新定义左边</span><br>        root.left = buildTree(preorder, preStart + <span class="hljs-number">1</span>, preStart + numsLeft,inorder, inStart, inRoot - <span class="hljs-number">1</span>, inMap);<span class="hljs-comment">//递归调用</span><br>        root.right = buildTree(preorder, preStart + numsLeft + <span class="hljs-number">1</span>, preEnd,inorder, inRoot + <span class="hljs-number">1</span>, inEnd, inMap);<span class="hljs-comment">//递归调用</span><br>        <span class="hljs-keyword">return</span> root;<span class="hljs-comment">//返回根节点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><blockquote><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p></blockquote><details>  <summary><span><a href="https://leetcode-cn.com/problems/combinations/">组合(中等)</a></span></summary>  <br><blockquote><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p></blockquote><p>示例:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">输入:n = 4, k = 2<br>输出:<br>[<br>    [2,4],<br>    [3,4],<br>    [2,3],<br>    [1,2],<br>    [1,3],<br>    [1,4],<br>]<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (k &lt;= <span class="hljs-number">0</span> || n &lt; k) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-comment">// 为了防止底层动态数组扩容，初始化的时候传入最大长度</span><br>        Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;(k);<br>        dfs(<span class="hljs-number">1</span>, n, k, path, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 基础版本的递归终止条件：if (begin == n + 1) &#123;</span><br>        <span class="hljs-keyword">if</span> (begin &gt; n - k + <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 不选当前考虑的数 begin，直接递归到下一层</span><br>        dfs(begin + <span class="hljs-number">1</span>, n, k, path, res);<br>        <span class="hljs-comment">// 不选当前考虑的数 begin，递归到下一层的时候 k - 1，这里 k 表示还需要选多少个数</span><br>        path.addLast(begin);<br>        dfs(begin + <span class="hljs-number">1</span>, n, k - <span class="hljs-number">1</span>, path, res);<br>        <span class="hljs-comment">// 深度优先遍历有回头的过程，因此需要撤销选择</span><br>        path.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/permutations/">全排列(中等)</a></span></summary>  <br><blockquote><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p></blockquote><p>示例:</p><p>输入: [1,2,3]<br>输出:<br>[<br>    [1,2,3],<br>    [1,3,2],<br>    [2,1,3],<br>    [2,3,1],<br>    [3,1,2],<br>    [3,2,1]<br>]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span>&#123;<br>    <span class="hljs-comment">//存储结果</span><br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-comment">//函数入口</span><br>    List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums)&#123;<br>        <span class="hljs-comment">//记录走过的路径</span><br>        LinkedList&lt;Integer&gt; integers = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-comment">//入口</span><br>        backtrack(nums,integers);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">//回溯函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span></span>&#123;<br>        <span class="hljs-comment">//如果走过的路径包含所有的选择则完成一轮</span><br>        <span class="hljs-keyword">if</span> (nums.length==track.size()) &#123;<br>            res.add(<span class="hljs-keyword">new</span> LinkedList(track));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;nums.length; i++) &#123;<br>            <span class="hljs-comment">//排除不合法的选择</span><br>            <span class="hljs-keyword">if</span> (track.contains(nums[i]))<span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//做选择</span><br>            track.add(nums[i]);<br>            <span class="hljs-comment">//进入下一层决策树</span><br>            backtrack(nums,track);<br>            <span class="hljs-comment">//撤销选择</span><br>            track.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/permutations-ii/">全排列II(中等)</a></span></summary>  <br><p>题目描述</p><blockquote><p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列</p></blockquote><p>示例 1：</p><p>输入：nums = [1,1,2]<br>输出：<br>[[1,1,2],<br>[1,2,1],<br>[2,1,1]]<br>示例 2：</p><p>输入：nums = [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">//从小到大排序，跳过重复项</span><br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[nums.length];<br>        backtrack(res, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(), nums, visited, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, <span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">boolean</span>[] visited, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//终止条件, 说明找到一组组合</span><br>        <span class="hljs-keyword">if</span>(n == nums.length) &#123;<br>            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(list));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(visited[i] == <span class="hljs-keyword">true</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; visited[i - <span class="hljs-number">1</span>] == <span class="hljs-keyword">false</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//选择当前值</span><br>            visited[i] = <span class="hljs-keyword">true</span>;<br>            list.add(nums[i]);<br>            <span class="hljs-comment">//递归</span><br>            backtrack(res, list, nums, visited, n + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//撤销选择</span><br>            list.remove(list.size() - <span class="hljs-number">1</span>);<br>            visited[i] = <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/powx-n/">Pow(x, n)(中等)</a></span></summary>  <br><blockquote><p>递归和迭代拆分进行计算</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">quickMul</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">long</span> N)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (N == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;<span class="hljs-comment">//0次幂</span><br>        <span class="hljs-keyword">double</span> y = quickMul(x, N / <span class="hljs-number">2</span>);<span class="hljs-comment">//折半计算</span><br>        <span class="hljs-keyword">return</span> N % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? y * y : y * y * x;<span class="hljs-comment">//减少计算</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> N = n;<br>        <span class="hljs-keyword">return</span> N &gt;= <span class="hljs-number">0</span> ? quickMul(x, N) : <span class="hljs-number">1.0</span> / quickMul(x, -N);<span class="hljs-comment">//处理负次方幂</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">quickMul</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">long</span> N)</span> </span>&#123;<br>        <span class="hljs-keyword">double</span> ans = <span class="hljs-number">1.0</span>;<br>        <span class="hljs-comment">// 贡献的初始值为 x</span><br>        <span class="hljs-keyword">double</span> x_contribute = x;<br>        <span class="hljs-comment">// 在对 N 进行二进制拆分的同时计算答案</span><br>        <span class="hljs-keyword">while</span> (N &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (N % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span><br>                ans *= x_contribute;<br>            &#125;<br>            <span class="hljs-comment">// 将贡献不断地平方</span><br>            x_contribute *= x_contribute;<br>            <span class="hljs-comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span><br>            N /= <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> N = n;<br>        <span class="hljs-keyword">return</span> N &gt;= <span class="hljs-number">0</span> ? quickMul(x, N) : <span class="hljs-number">1.0</span> / quickMul(x, -N);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/majority-element/">多数元素(简单)</a></span></summary>  <br><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素</p><p class="note note-primary">    哈希表,排序,摩尔投票</p><blockquote><p>Boyer-Moore 投票算法</p></blockquote><p>思路</p><p>如果我们把众数记为 +1，把其他数记为 −1，将它们全部加起来，显然和大于 0，从结果本身我们可以看出众数比其他数多。</p><p>算法</p><p>Boyer-Moore 算法的本质和方法四中的分治十分类似。我们首先给出 Boyer-Moore 算法的详细步骤：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；<br>我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：<br>如果 x 与 candidate 相等，那么计数器 count 的值增加 1；<br>如果 x 与 candidate 不等，那么计数器 count 的值减少 1。<br>在遍历完成后，candidate 即为整个数组的众数。<br></code></pre></td></tr></table></figure><p>我们举一个具体的例子，例如下面的这个数组：</p><p>[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</p><p>在遍历到数组中的第一个元素以及每个在 | 之后的元素时，candidate 都会因为 count 的值变为 0 而发生改变。最后一次 candidate 的值从 5 变为 7，也就是这个数组中的众数。</p><p>Boyer-Moore 算法的正确性较难证明，这里给出一种较为详细的用例子辅助证明的思路，供读者参考：</p><p>首先我们根据算法步骤中对 count 的定义，可以发现：在对整个数组进行遍历的过程中，count 的值一定非负。这是因为如果 count 的值为 0，那么在这一轮遍历的开始时刻，我们会将 x 的值赋予 candidate 并在接下来的一步中将 count 的值增加 1。因此 count 的值在遍历的过程中一直保持非负。</p><p>那么 count 本身除了计数器之外，还有什么更深层次的意义呢？我们还是以数组</p><p>[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</p><p>作为例子，首先写下它在每一步遍历时 candidate 和 count 的值：</p><p>nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]<br>candidate:  7  7  7  7  7  7   5  5   5  5  5  5   7  7  7  7<br>count:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4</p><p>我们再定义一个变量 value，它和真正的众数 maj 绑定。在每一步遍历时，如果当前的数 x 和 maj 相等，那么 value 的值加 1，否则减 1。value 的实际意义即为：到当前的这一步遍历为止，众数出现的次数比非众数多出了多少次。我们将 value 的值也写在下方：</p><p>nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]<br>value:      1  2  1  2  1  0  -1  0  -1 -2 -1  0   1  2  3  4</p><p>有没有发现什么？我们将 count 和 value 放在一起：</p><p>nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]<br>count:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4<br>value:      1  2  1  2  1  0  -1  0  -1 -2 -1  0   1  2  3  4</p><p>发现在每一步遍历中，count 和 value 要么相等，要么互为相反数！并且在候选众数 candidate 就是 maj 时，它们相等，candidate 是其它的数时，它们互为相反数！</p><p>为什么会有这么奇妙的性质呢？这并不难证明：我们将候选众数 candidate 保持不变的连续的遍历称为「一段」。在同一段中，count 的值是根据 candidate == x 的判断进行加减的。那么如果 candidate 恰好为 maj，那么在这一段中，count 和 value 的变化是同步的；如果 candidate 不为 maj，那么在这一段中 count 和 value 的变化是相反的。因此就有了这样一个奇妙的性质。</p><p>这样以来，由于：</p><p>我们证明了 count 的值一直为非负，在最后一步遍历结束后也是如此；</p><p>由于 value 的值与真正的众数 maj 绑定，并且它表示「众数出现的次数比非众数多出了多少次」，那么在最后一步遍历结束后，value 的值为正数；</p><p>在最后一步遍历结束后，count 非负，value 为正数，所以它们不可能互为相反数，只可能相等，即 count == value。因此在最后「一段」中，count 的 value 的变化是同步的，也就是说，candidate 中存储的候选众数就是真正的众数 maj。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        Integer candidate = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>                candidate = num;<br>            &#125;<br>            count += (num == candidate) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> candidate;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">电话号码的字母组合(中等)</a></span>    </summary><blockquote><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法入口</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> digits</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(String digits)</span> </span>&#123;<br>        List&lt;String&gt; combinations = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        <span class="hljs-keyword">if</span> (digits.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> combinations;<br>        &#125;<br>        Map&lt;Character, String&gt; phoneMap = <span class="hljs-keyword">new</span> HashMap&lt;Character, String&gt;() &#123;&#123;<br>            put(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&quot;abc&quot;</span>);<br>            put(<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&quot;def&quot;</span>);<br>            put(<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&quot;ghi&quot;</span>);<br>            put(<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&quot;jkl&quot;</span>);<br>            put(<span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&quot;mno&quot;</span>);<br>            put(<span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>);<br>            put(<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&quot;tuv&quot;</span>);<br>            put(<span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>);<br>        &#125;&#125;;<br>        backtrack(combinations, phoneMap, digits, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> StringBuffer());<br>        <span class="hljs-keyword">return</span> combinations;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 回溯</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> combinations</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> phoneMap</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> digits</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> combination</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(List&lt;String&gt; combinations, Map&lt;Character, String&gt; phoneMap, String digits, <span class="hljs-keyword">int</span> index, StringBuffer combination)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index == digits.length()) &#123;<span class="hljs-comment">//结束条件</span><br>            combinations.add(combination.toString());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">char</span> digit = digits.charAt(index);<span class="hljs-comment">//获取当前数字</span><br>            String letters = phoneMap.get(digit);<span class="hljs-comment">//获取当前数字对应的字符串</span><br>            <span class="hljs-keyword">int</span> lettersCount = letters.length();<span class="hljs-comment">//字符串长度</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; lettersCount; i++) &#123;<span class="hljs-comment">//遍历字符串</span><br>                combination.append(letters.charAt(i));<span class="hljs-comment">//追加字符到字符串末尾</span><br>                backtrack(combinations, phoneMap, digits, index + <span class="hljs-number">1</span>, combination);<br>                combination.deleteCharAt(index);<span class="hljs-comment">//移除追加的字符串</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/n-queens/">N皇后(困难)</a></span>    </summary><blockquote><p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<br> 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。<br> 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p></blockquote><p><code>后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</code></p><blockquote><p>结题思路、回溯</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span>&#123;<br>        <span class="hljs-comment">//存放结果</span><br>        List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">public</span>  List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="hljs-keyword">int</span> n) &#123;<br><br>            <span class="hljs-comment">//用二维char数组初始化棋盘</span><br>            <span class="hljs-keyword">char</span>[][] board = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n][n];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>                Arrays.fill(board[i],<span class="hljs-string">&#x27;.&#x27;</span>);<br>            &#125;<br>            backtrack(<span class="hljs-number">0</span>,board);<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row,<span class="hljs-keyword">char</span>[][] board)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(board.length == row)&#123;<br>                res.add(charArraysToList(board));<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">int</span> n = board[row].length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt;= n; col++)&#123;<br>             <span class="hljs-comment">//排除不合法的选项</span><br>             <span class="hljs-keyword">if</span> (!isValid(board,row,col))<br>                 <span class="hljs-keyword">continue</span>;<br>             <span class="hljs-comment">//做选择</span><br>                board[row][col]=<span class="hljs-string">&#x27;Q&#x27;</span>;<br>             <span class="hljs-comment">//进入下一行决策</span><br>                backtrack(row+<span class="hljs-number">1</span>,board);<br>             <span class="hljs-comment">//撤销选择</span><br>                board[row][col]=<span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board,<span class="hljs-keyword">int</span> row , <span class="hljs-keyword">int</span> col)</span></span>&#123;<br>            <span class="hljs-keyword">int</span> n = board.length;<br>            <span class="hljs-comment">//注意由于我们是从上往下的来一个一个排列 所以不用检查下方的棋盘</span><br>            <span class="hljs-comment">//检查正上方有没有冲突(列冲突)</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r&lt; n;r++)&#123;<br>               <span class="hljs-keyword">if</span> ( board[r][col] ==<span class="hljs-string">&#x27;Q&#x27;</span>)<br>                   <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-comment">//检查左上方</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row-<span class="hljs-number">1</span>,j=col-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>&amp;&amp;j&gt;=<span class="hljs-number">0</span>;i--,j--)&#123;<br>                <span class="hljs-keyword">if</span> (board[i][j]==<span class="hljs-string">&#x27;Q&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-comment">//检查右上方</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row-<span class="hljs-number">1</span>,j=col+<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>&amp;&amp;j&lt;board[i].length;i--,j++)&#123;<br>                <span class="hljs-keyword">if</span> (board[i][j]==<span class="hljs-string">&#x27;Q&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">charArraysToList</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span></span>&#123;<br>            <span class="hljs-comment">//将char数组变成list&lt;String&gt;</span><br>            List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>[] c : board)&#123;<br>                String str = <span class="hljs-keyword">new</span> String(c);<br>                list.add(str);<br>            &#125;<br>            <span class="hljs-keyword">return</span> list;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/minimum-genetic-mutation/">最小基因变化(中等)</a></span>    </summary><blockquote><p>回溯思想、广度优先遍历</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minMutation</span><span class="hljs-params">(String start, String end, String[] bank)</span> </span>&#123;<br>        HashSet&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(Arrays.asList(bank));<br>        <span class="hljs-comment">//不包含结果直接返回-1</span><br>        <span class="hljs-keyword">if</span> (!set.contains(end)) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//</span><br>        <span class="hljs-keyword">char</span>[] four = &#123;<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;T&#x27;</span>&#125;;<br>        Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        queue.offer(start);<span class="hljs-comment">//</span><br>        set.remove(start);<span class="hljs-comment">//集合中移除</span><br>        <span class="hljs-keyword">int</span> step = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (queue.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            step++;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> count = queue.size(); count &gt; <span class="hljs-number">0</span>; --count) &#123;<br>                <span class="hljs-keyword">char</span>[] temStringChars = queue.poll().toCharArray();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, len = temStringChars.length; i &lt; len; ++i) &#123;<br>                    <span class="hljs-keyword">char</span> oldChar = temStringChars[i];<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; ++j) &#123;<br>                        temStringChars[i] = four[j];<br>                        String newGenetic = <span class="hljs-keyword">new</span> String(temStringChars);<br>                        <span class="hljs-keyword">if</span> (end.equals(newGenetic)) &#123;<br>                            <span class="hljs-keyword">return</span> step;<br>                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (set.contains(newGenetic)) &#123;<br>                            set.remove(newGenetic);<br>                            queue.offer(newGenetic);<br>                        &#125;<br>                    &#125;<br>                    temStringChars[i] = oldChar;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>回溯思想、深度优先遍历</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> minStepCount = Integer.MAX_VALUE;<span class="hljs-comment">//设置默认值</span><br>    <span class="hljs-comment">//函数入口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minMutation</span><span class="hljs-params">(String start, String end, String[] bank)</span> </span>&#123;<br>        dfs(<span class="hljs-keyword">new</span> HashSet&lt;String&gt;(), <span class="hljs-number">0</span>, start, end, bank);<br>        <span class="hljs-keyword">return</span> (minStepCount == Integer.MAX_VALUE) ? -<span class="hljs-number">1</span> : minStepCount;<br>    &#125;<br>    <span class="hljs-comment">//深度优先遍历</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span> <span class="hljs-params">(HashSet&lt;String&gt; step, <span class="hljs-keyword">int</span> stepCount,String current, String end, String[] bank)</span> </span>&#123;<br>        <span class="hljs-comment">//满足条件进行比较赋值</span><br>        <span class="hljs-keyword">if</span> (current.equals(end))  minStepCount = Math.min(stepCount, minStepCount);<br>        <span class="hljs-comment">//遍历基因库</span><br>        <span class="hljs-keyword">for</span> (String str: bank) &#123;<br>            <span class="hljs-comment">//遍历</span><br>            <span class="hljs-keyword">int</span> diff = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length(); i++) <br>                <span class="hljs-keyword">if</span> (current.charAt(i) != str.charAt(i)) <span class="hljs-keyword">if</span> (++diff &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//记录基因不同的位置</span><br>            <span class="hljs-comment">//当前有基因不同 &amp;&amp; 基因库中不包含当前基因序列(已使用过处理)</span><br>            <span class="hljs-keyword">if</span> (diff == <span class="hljs-number">1</span> &amp;&amp; !step.contains(str)) &#123;<br>                step.add(str);<span class="hljs-comment">//添加当前序列</span><br>                dfs(step, stepCount + <span class="hljs-number">1</span>, str, end, bank);<span class="hljs-comment">//进入下一层遍历,步数+1,并且使用当前序列作为current</span><br>                step.remove(str);<span class="hljs-comment">//移除当前序列</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></details><details>    <summary>        <span><a href="">在每个树行中找最大值(中等)</a></span>    </summary><blockquote><p>广度优先</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">largestValues</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        LinkedList&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(!Objects.isNull(root))queue.add(root);<br><br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-keyword">int</span> size = queue.size();<br>            <span class="hljs-keyword">int</span> max = queue.getFirst().val;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>                TreeNode node = queue.poll();<br>                <span class="hljs-keyword">if</span>(node.val&gt;max)max=node.val;<br>                <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-keyword">null</span>)queue.add(node.left);<br>                <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-keyword">null</span>)queue.add(node.right);<br>            &#125;<br>            ans.add(max);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><h1 id="贪心类型"><a href="#贪心类型" class="headerlink" title="贪心类型"></a>贪心类型</h1><blockquote><p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解 [1]  。 贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择。也就是说，不从整体最优上加以考虑，做出的只是在某种意义上的局部最优解 [1]  。</p></blockquote><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/lemonade-change/">柠檬水找零(简单)</a></span>    </summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lemonadeChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] bills)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> five = <span class="hljs-number">0</span>, ten = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> bill : bills) &#123;<br>            <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">5</span>) &#123;<br>                five++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">10</span>) &#123;<br>                <span class="hljs-keyword">if</span> (five == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                five--;<br>                ten++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (five &gt; <span class="hljs-number">0</span> &amp;&amp; ten &gt; <span class="hljs-number">0</span>) &#123;<br>                    five--;<br>                    ten--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (five &gt;= <span class="hljs-number">3</span>) &#123;<br>                    five -= <span class="hljs-number">3</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/number-of-islands/solution/">岛屿数量(中等)</a></span>    </summary><blockquote><p>广度优先遍历</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] visit ;<span class="hljs-comment">//记录已经走过的坐标</span><br>    <span class="hljs-keyword">char</span>[][] arr;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        arr = grid;<br>        visit = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[grid.length][grid[<span class="hljs-number">0</span>].length];<span class="hljs-comment">//记录已经走过的坐标</span><br>        <span class="hljs-comment">//深度优先搜索</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;grid.length;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; grid[i].length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j]==<span class="hljs-string">&#x27;1&#x27;</span>&amp;&amp;visit[i][j]==<span class="hljs-number">0</span>)&#123;<br>                    bfs(i,j);<br>                    ans+=<span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>        visit[x][y]=<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//上</span><br>        <span class="hljs-keyword">if</span>(x-<span class="hljs-number">1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;visit[x-<span class="hljs-number">1</span>][y]==<span class="hljs-number">0</span>&amp;&amp;arr[x-<span class="hljs-number">1</span>][y]==<span class="hljs-string">&#x27;1&#x27;</span>)bfs(x-<span class="hljs-number">1</span>,y);<br>        <span class="hljs-comment">//下</span><br>        <span class="hljs-keyword">if</span>(x+<span class="hljs-number">1</span>&lt;arr.length&amp;&amp;visit[x+<span class="hljs-number">1</span>][y]==<span class="hljs-number">0</span>&amp;&amp;arr[x+<span class="hljs-number">1</span>][y]==<span class="hljs-string">&#x27;1&#x27;</span>)bfs(x+<span class="hljs-number">1</span>,y);<br>        <span class="hljs-comment">//左</span><br>        <span class="hljs-keyword">if</span>(y-<span class="hljs-number">1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;visit[x][y-<span class="hljs-number">1</span>]==<span class="hljs-number">0</span>&amp;&amp;arr[x][y-<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;1&#x27;</span>)bfs(x,y-<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//右</span><br>        <span class="hljs-keyword">if</span>(y+<span class="hljs-number">1</span>&lt;arr[x].length&amp;&amp;visit[x][y+<span class="hljs-number">1</span>]==<span class="hljs-number">0</span>&amp;&amp;arr[x][y+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;1&#x27;</span>)bfs(x,y+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II(简单)</a></span>    </summary><blockquote><p>贪心算法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n = prices.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            ans += Math.max(<span class="hljs-number">0</span>, prices[i] - prices[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/jump-game/">跳跃游戏(中等)</a></span>    </summary><p class="note note-primary">给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: [2,3,1,1,4]<br>输出: true<br>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。<br></code></pre></td></tr></table></figure><blockquote></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<span class="hljs-comment">//数字长度</span><br>        <span class="hljs-keyword">int</span> rightmost = <span class="hljs-number">0</span>;<span class="hljs-comment">//可以到达最远位置</span><br>        <span class="hljs-comment">//迭代</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-comment">//当前下标小于可达最远下标则更新</span><br>            <span class="hljs-keyword">if</span> (i &lt;= rightmost) &#123;<br>                rightmost = Math.max(rightmost, i + nums[i]);<span class="hljs-comment">//更新可达最远位置</span><br>                <span class="hljs-keyword">if</span> (rightmost &gt;= n - <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//如果最远可达大于等于末尾下标返回true</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/jump-game-ii/">跳跃游戏 II(困难)</a></span>    </summary><p class="note note-primary">给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。<br></code></pre></td></tr></table></figure><blockquote></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//正向</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> position = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> steps = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (position &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; position; i++) &#123;<br>                <span class="hljs-keyword">if</span> (i + nums[i] &gt;= position) &#123;<br>                    position = i;<br>                    steps++;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> steps;<br>    &#125;<br>    <span class="hljs-comment">//反向</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = nums.length;<br>        <span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> maxPosition = <span class="hljs-number">0</span>; <br>        <span class="hljs-keyword">int</span> steps = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length - <span class="hljs-number">1</span>; i++) &#123;<br>            maxPosition = Math.max(maxPosition, i + nums[i]); <br>            <span class="hljs-keyword">if</span> (i == end) &#123;<br>                end = maxPosition;<br>                steps++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> steps;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><h1 id="窗口滑动"><a href="#窗口滑动" class="headerlink" title="窗口滑动"></a>窗口滑动</h1><blockquote></blockquote><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串(中等)</a></span>    </summary><p>解题思路</p><blockquote><p>窗口滑动，</p></blockquote><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-comment">//双指针窗口滑动</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;<br>            String str = s.substring(left, right + <span class="hljs-number">1</span>);<br>            length = length &gt; str.length() ? length : str.length();<span class="hljs-comment">//记录长度</span><br>            right++;<span class="hljs-comment">//增大窗口</span><br>            <span class="hljs-keyword">while</span> (right &lt; s.length() &amp;&amp; str.indexOf(s.charAt(right)) != -<span class="hljs-number">1</span>) &#123;<br>                left++;<span class="hljs-comment">//缩小窗口</span><br>                str = s.substring(left, right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p><a href="/2020/11/09/algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">先复习一波</a></p><details>  <summary><span><a href="https://leetcode-cn.com/problems/smallest-k-lcci/solution/">TopK问题(中等)</a></span></summary>  <br><blockquote><p>top-k问题 主要解法：排序、堆、随机快速选择、BFPRT 排序方法：时间复杂度O(NlogN)， 因为本题数据特殊性 可以使用计数排序 时间复杂度O(N)<br>堆：维护一个大小为k的堆， 不太建议使用priority_queue, 额外空间和数据拷贝，可以原地操作数组，使用make_heap + pop_heap、push_heap 或 覆盖堆顶，自实现堆顶下沉 时间复杂度O(Nlogk)<br>随机快速选择：平均时间复杂度 O(N)<br>BFPRT：最坏时间复杂度 O(N)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 小顶堆（min-heap）有个重要的性质——每个结点的值均不大于其左右孩子结点的值，则堆顶元素即为整个堆的最小值。JDK中PriorityQueue实现了数据结构堆，通过指定comparator字段来表示小顶堆或大顶堆，默认为null，表示自然序（natural ordering）。</span><br><span class="hljs-comment">     * 小顶堆解决Top K问题的思路：小顶堆维护当前扫描到的最大100个数，其后每一次的扫描到的元素，若大于堆顶，则入堆，然后删除堆顶；依此往复，直至扫描完所有元素。Java实现第K大整数代码如下：</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> k</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        PriorityQueue&lt;Integer&gt; minQueue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(k);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (minQueue.size() &lt; k || num &gt; minQueue.peek())<br>                minQueue.offer(num);<br>            <span class="hljs-keyword">if</span> (minQueue.size() &gt; k)<br>                minQueue.poll();<br>        &#125;<br>        <span class="hljs-keyword">return</span> minQueue.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>BFPRT算法思路(O(n))</p><blockquote><p>BFPRT算法又称中位数的中位数算法，可以用于在O(n)的时间复杂度内找到第k小的数。对于本题，我们可以用BFPRT算法找到第k小的数O(n)，然后遍历一遍原数组O(n)，将小于第k小的数的元素加入到答案数组，即得正确解(时间复杂度也是O(n))。</p></blockquote><p>BFPRT算法的主要步骤如下：</p><ul><li>将 [公式] 个元素划为 [公式] 组，每组5个，至多只有一组由 [公式] 个元素组成。</li><li>寻找这 [公式] 个组中每一个组的中位数，这个过程可以用插入排序。</li><li>对步骤2中的 [公式] 个中位数，重复步骤1和步骤2，递归下去，直到剩下一个数字。</li><li>最终剩下的数字即为pivot，把大于它的数全放左边，小于等于它的数全放右边。</li><li>判断pivot的位置与k的大小，有选择的对左边或右边递归。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/bfprt.png" alt="avatar"></p><p><a href="https://segmentfault.com/a/1190000008322873">中位数的中位数算法</a></p><p>代码实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetPivotIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> pivot_index)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">BFPRT</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> k)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">8</span>; <span class="hljs-comment">// 1 &lt;= k &lt;= array.size</span><br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">20</span>] = &#123; <span class="hljs-number">11</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">1</span>,<span class="hljs-number">13</span>,<span class="hljs-number">8</span>,<span class="hljs-number">15</span>,<span class="hljs-number">0</span>,<span class="hljs-number">16</span>,<span class="hljs-number">2</span>,<span class="hljs-number">17</span>,<span class="hljs-number">5</span>,<span class="hljs-number">14</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">18</span>,<span class="hljs-number">12</span>,<span class="hljs-number">7</span>,<span class="hljs-number">19</span>,<span class="hljs-number">4</span> &#125;;<br><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;原数组：&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">array</span>[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-comment">// 因为是以 k 为划分，所以还可以求出第 k 小值</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;第 &quot;</span> &lt;&lt; k &lt;&lt; <span class="hljs-string">&quot; 小值为：&quot;</span> &lt;&lt; <span class="hljs-built_in">array</span>[BFPRT(<span class="hljs-built_in">array</span>, <span class="hljs-number">0</span>, <span class="hljs-number">19</span>, k)] &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;变换后的数组：&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">array</span>[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 对数组 array[left, right] 进行插入排序，并返回 [left, right]</span><br><span class="hljs-comment"> * 的中位数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> temp;<br>    <span class="hljs-keyword">int</span> j;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left + <span class="hljs-number">1</span>; i &lt;= right; i++)<br>    &#123;<br>        temp = <span class="hljs-built_in">array</span>[i];<br>        j = i - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (j &gt;= left &amp;&amp; <span class="hljs-built_in">array</span>[j] &gt; temp)<br>        &#123;<br>            <span class="hljs-built_in">array</span>[j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">array</span>[j];<br>            j--;<br>        &#125;<br><br>        <span class="hljs-built_in">array</span>[j + <span class="hljs-number">1</span>] = temp;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ((right - left) &gt;&gt; <span class="hljs-number">1</span>) + left;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 数组 array[left, right] 每五个元素作为一组，并计算每组的中位数，</span><br><span class="hljs-comment"> * 最后返回这些中位数的中位数下标（即主元下标）。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @attention 末尾返回语句最后一个参数多加一个 1 的作用其实就是向上取整的意思，</span><br><span class="hljs-comment"> * 这样可以始终保持 k 大于 0。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetPivotIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (right - left &lt; <span class="hljs-number">5</span>)<br>        <span class="hljs-keyword">return</span> InsertSort(<span class="hljs-built_in">array</span>, left, right);<br><br>    <span class="hljs-keyword">int</span> sub_right = left - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 每五个作为一组，求出中位数，并把这些中位数全部依次移动到数组左边</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left; i + <span class="hljs-number">4</span> &lt;= right; i += <span class="hljs-number">5</span>)<br>    &#123;<br>        <span class="hljs-keyword">int</span> index = InsertSort(<span class="hljs-built_in">array</span>, i, i + <span class="hljs-number">4</span>);<br>        swap(<span class="hljs-built_in">array</span>[++sub_right], <span class="hljs-built_in">array</span>[index]);<br>    &#125;<br><br>    <span class="hljs-comment">// 利用 BFPRT 得到这些中位数的中位数下标（即主元下标）</span><br>    <span class="hljs-keyword">return</span> BFPRT(<span class="hljs-built_in">array</span>, left, sub_right, ((sub_right - left + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 利用主元下标 pivot_index 进行对数组 array[left, right] 划分，并返回</span><br><span class="hljs-comment"> * 划分后的分界线下标。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> pivot_index)</span></span><br><span class="hljs-function"></span>&#123;<br>    swap(<span class="hljs-built_in">array</span>[pivot_index], <span class="hljs-built_in">array</span>[right]); <span class="hljs-comment">// 把主元放置于末尾</span><br><br>    <span class="hljs-keyword">int</span> partition_index = left; <span class="hljs-comment">// 跟踪划分的分界线</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left; i &lt; right; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>[i] &lt; <span class="hljs-built_in">array</span>[right])<br>        &#123;<br>            swap(<span class="hljs-built_in">array</span>[partition_index++], <span class="hljs-built_in">array</span>[i]); <span class="hljs-comment">// 比主元小的都放在左侧</span><br>        &#125;<br>    &#125;<br><br>    swap(<span class="hljs-built_in">array</span>[partition_index], <span class="hljs-built_in">array</span>[right]); <span class="hljs-comment">// 最后把主元换回来</span><br><br>    <span class="hljs-keyword">return</span> partition_index;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回数组 array[left, right] 的第 k 小数的下标</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">BFPRT</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> pivot_index = GetPivotIndex(<span class="hljs-built_in">array</span>, left, right); <span class="hljs-comment">// 得到中位数的中位数下标（即主元下标）</span><br>    <span class="hljs-keyword">int</span> partition_index = Partition(<span class="hljs-built_in">array</span>, left, right, pivot_index); <span class="hljs-comment">// 进行划分，返回划分边界</span><br>    <span class="hljs-keyword">int</span> num = partition_index - left + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> (num == k)<br>        <span class="hljs-keyword">return</span> partition_index;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &gt; k)<br>        <span class="hljs-keyword">return</span> BFPRT(<span class="hljs-built_in">array</span>, left, partition_index - <span class="hljs-number">1</span>, k);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> BFPRT(<span class="hljs-built_in">array</span>, partition_index + <span class="hljs-number">1</span>, right, k - num);<br>&#125;<br></code></pre></td></tr></table></figure><p>快排解题思路</p><blockquote><p>我们知道，经过快速排序算法中的一次划分后，基点左边的所有数小于基点，右边的所有数大于基点，基点位置pivot有三种情况：</p></blockquote><p>pivot == k 说明基点就是第k+1个小的元素，其左边的子数组就是最小的k个数。此时的子数组[0, k) 就是答案 pivot &gt; k 说明基点”偏大”了，对其左子数组继续进行划分 pivot &lt; k 说明基点”偏小”<br>了，对其右子数组继续进行划分</p><p>快排代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    Random random = <span class="hljs-keyword">new</span> Random();<span class="hljs-comment">//随机</span><br><br>    <span class="hljs-comment">//方法入口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> quickSelect(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>, nums.length - k);<br>    &#125;<br>    <span class="hljs-comment">//快速选择</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">quickSelect</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> q = randomPartition(a, l, r);<br>        <span class="hljs-keyword">if</span> (q == index) &#123;<br>            <span class="hljs-keyword">return</span> a[q];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> q &lt; index ? quickSelect(a, q + <span class="hljs-number">1</span>, r, index) : quickSelect(a, l, q - <span class="hljs-number">1</span>, index);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">randomPartition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = random.nextInt(r - l + <span class="hljs-number">1</span>) + l;<br>        swap(a, i, r);<br>        <span class="hljs-keyword">return</span> partition(a, l, r);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> x = a[r], i = l - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = l; j &lt; r; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (a[j] &lt;= x) &#123;<br>                swap(a, ++i, j);<br>            &#125;<br>        &#125;<br>        swap(a, i + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> temp = a[i];<br>        a[i] = a[j];<br>        a[j] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/en-heng/p/6336625.html">Top K问题的两种解决思路</a></p></details><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">数组中的逆序对(困难)</a></span>    </summary><p>解题思路</p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/array-nxd-1.png" alt="image.png"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/array-nxd-2.png" alt="image.png"></p></blockquote><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//先来一段归并排序的代码</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (start == end) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">int</span> mid = (start + end) / <span class="hljs-number">2</span>;<br>        merge(arr, start, mid);<br>        merge(arr, mid + <span class="hljs-number">1</span>, end);<br><br>        <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[end - start + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span> i = start, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= end)<br>            temp[k++] = arr[i] &lt; arr[j] ? arr[i++] : arr[j++];<br>        <span class="hljs-keyword">while</span> (i &lt;= mid)<br>            temp[k++] = arr[i++];<br>        <span class="hljs-keyword">while</span> (j &lt;= end)<br>            temp[k++] = arr[j++];<br>        System.arraycopy(temp, <span class="hljs-number">0</span>, arr, start, end);<br>    &#125;<br><br>    <span class="hljs-comment">//再看一下这道题的题解</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> merge(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (start == end) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> mid = (start + end) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> count = merge(arr, start, mid) + merge(arr, mid + <span class="hljs-number">1</span>, end);<span class="hljs-comment">//计算两个区间的逆序个数</span><br><br>        <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[end - start + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span> i = start, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= end) &#123;<br>            count += arr[i] &lt;= arr[j] ? j - (mid + <span class="hljs-number">1</span>) : <span class="hljs-number">0</span>;<span class="hljs-comment">//关键</span><br>            temp[k++] = arr[i] &lt;= arr[j] ? arr[i++] : arr[j++];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;<br>            count += j - (mid + <span class="hljs-number">1</span>);<span class="hljs-comment">//关键</span><br>            temp[k++] = arr[i++];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (j &lt;= end) temp[k++] = arr[j++];<br>        System.arraycopy(temp, <span class="hljs-number">0</span>, arr, start, end - start + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/subsets/">子集(中等)</a></span></summary>  <br><blockquote><p>给你一个整数数组 nums ，返回该数组所有可能的子集（幂集）。解集不能包含重复的子集。</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">示例 1：<br>输入：nums = [1,2,3]<br>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]<br><br>示例 2：<br>输入：nums = [0]<br>输出：[[],[0]]<br></code></pre></td></tr></table></figure><blockquote><p>字典排序(二进制排序)</p></blockquote><p>nums=[5,2,9]</p><table><thead><tr><th>0/1 序列</th><th>子集    0/1</th><th>0/1 序列对应的二进制数</th></tr></thead><tbody><tr><td>000</td><td>{}</td><td>0</td></tr><tr><td>001</td><td>{9}</td><td>1</td></tr><tr><td>010</td><td>{2}</td><td>2</td></tr><tr><td>011</td><td>{2,9}</td><td>3</td></tr><tr><td>100</td><td>{5}</td><td>4</td></tr><tr><td>101</td><td>{5,9}</td><td>5</td></tr><tr><td>110</td><td>{5,2}</td><td>6</td></tr><tr><td>111</td><td>{5,2,9}</td><td>7</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;Integer&gt; t = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> mask = <span class="hljs-number">0</span>; mask &lt; (<span class="hljs-number">1</span> &lt;&lt; n); ++mask) &#123;<span class="hljs-comment">//左移乘2</span><br>            t.clear();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-comment">//i为数组长度</span><br>                <span class="hljs-comment">//mask为二进制对应的数 0-2^n</span><br>                <span class="hljs-comment">//1&lt;&lt;i左移位数　并且按位与(&amp;) 当为1时证明当前数=mask</span><br>                <span class="hljs-keyword">if</span> ((mask &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) != <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//判断是否已经存在子集当中</span><br>                    t.add(nums[i]);<br>                &#125;<br>            &#125;<br>            ans.add(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(t));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递归回溯，深度优先遍历</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//存储</span><br>    List&lt;Integer&gt; t = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>    <span class="hljs-comment">//方法入口</span><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        dfs(<span class="hljs-number">0</span>, nums);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">//深度遍历</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur == nums.length) &#123;<span class="hljs-comment">//递归结束条件</span><br>            ans.add(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(t));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        t.add(nums[cur]);<span class="hljs-comment">//添加到当前记录结果</span><br>        dfs(cur + <span class="hljs-number">1</span>, nums);<span class="hljs-comment">//递归调用</span><br>        t.remove(t.size() - <span class="hljs-number">1</span>);<span class="hljs-comment">//移除当前末尾元素</span><br>        dfs(cur + <span class="hljs-number">1</span>, nums);<span class="hljs-comment">//递归调用</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><blockquote><p>动态规划</p></blockquote><details>  <summary><span><a href="https://leetcode-cn.com/problems/coin-change/">零钱兑换(中等)</a></span></summary>  <br><blockquote><p>动态规划、状态转移方程　F(S)=F(S-C)+1</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/coin-change.jpeg"></p><p>例子2：假设</p><p>coins = [1, 2, 3], amount = 6</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/coin-change-1.jpeg"></p><p>在上图中，可以看到：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">F(3)=min(F(3−c1),F(3−c2),F(3−c3))+1<br>    =min(F(3−1),F(3−2),F(3−3))+1  <br>    =min(F(2),F(1),F(0))+1  <br>    =min(1,1,0)+1  <br>    =1<br></code></pre></td></tr></table></figure><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> max = amount + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount + <span class="hljs-number">1</span>];<br>        Arrays.fill(dp, max);<span class="hljs-comment">//填充</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//basecase</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= amount; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; coins.length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (coins[j] &lt;= i) &#123;<br>                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount] &gt; amount ? -<span class="hljs-number">1</span> : dp[amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">斐波那契数列(简单)</a></span></summary>  <br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>            dp[i] %= <span class="hljs-number">1000000007</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof">礼物的最大价值(中等)</a></span></summary>  <br><p>礼物的最大价值</p><p>题目描述</p><blockquote><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p></blockquote><pre><code>   </code></pre><p>示例</p><p>输入:</p><blockquote><p>[   &emsp;[1,3,1],<br>  &emsp;[1,5,1],<br>  &emsp;[4,2,1]<br>]</p></blockquote><p>输出: 12 解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</p><p>解题思路</p><p>动态规划+dp数组，自底向上，状态转移方程 <code>f(i, j) = max&#123;f(i - 1, j), f(i, j - 1)&#125; + grid[i][j]</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = grid.length, n = grid[<span class="hljs-number">0</span>].length;<span class="hljs-comment">//获取数组长度</span><br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<span class="hljs-comment">//dp数组 最长长度为n+1 用于存放</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<span class="hljs-comment">//两层循环</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                dp[j] = Math.max(dp[j], dp[j - <span class="hljs-number">1</span>]) + grid[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<span class="hljs-comment">//结合状态转移方程</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></details><details>  <summary><a href="https://leetcode-cn.com/problems/chou-shu-lcof"><span>丑数(中等)</span></a></summary>  <br><p>丑数</p><blockquote><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p></blockquote><p>示例</p><blockquote><p>输入: n = 10 输出: 12 解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</p></blockquote><p>说明</p><blockquote><p>1是丑数。 n 不超过1690。</p></blockquote><p>解题思路</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">状态定义： 设动态规划列表 dp ，dp[i] 代表第 i + 1 个丑数。<br>转移方程：<br>当索引 a, b, c 满足以下条件时， dp[i] 为三种情况的最小值；<br>每轮计算 dp[i] 后，需要更新索引 a, b, c 的值，使其始终满足方程条件。<br>实现方法：分别独立判断 dp[i] 和 dp[a]×2 , dp[b]×3 , dp[c]×5 的大小关系，若相等则将对应索引 a , b , c 加 1 。<br><br>dp[a]×2&gt;dp[i−1]≥dp[a−1]×2  <br>dp[b]×3&gt;dp[i−1]≥dp[b−1]×3  <br>dp[c]×5&gt;dp[i−1]≥dp[c−1]×5  <br><br>得出公式=dp[i] = min(dp[a]×2,dp[b]×3,dp[c]×5)<br><br>初始状态： dp[0] = 1 ，即第一个丑数为 1.  <br>返回值： dp[n-1] ，即返回第 n 个丑数.<br></code></pre></td></tr></table></figure><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<span class="hljs-comment">//dp数组</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">int</span> n2 = dp[a] * <span class="hljs-number">2</span>, n3 = dp[b] * <span class="hljs-number">3</span>, n5 = dp[c] * <span class="hljs-number">5</span>;<span class="hljs-comment">//状态转移方程</span><br>            dp[i] = Math.min(n2, n3, n5);<br>            <span class="hljs-keyword">if</span> (dp[i] == n2) a++;<br>            <span class="hljs-keyword">if</span> (dp[i] == n3) b++;<br>            <span class="hljs-keyword">if</span> (dp[i] == n5) c++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof" >数组中的逆序对(困难)</a></span></summary>  <br><p>题目描述</p><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p> </p><p>示例</p><p>输入: [7,5,6,4]<br>输出: 5</p><p>解题思路</p><blockquote><p>通过对数组进行排序</p></blockquote></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">最长公共子序列(中等)</a></span></summary>  <br><p>给定两个字符串text1 和text2，返回这两个字符串的最长公共子序列的长度。</p><p>一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p><p>若这两个字符串没有公共子序列，则返回 0。</p><p>示例 1:</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">text1</span> = <span class="hljs-string">&quot;abcde&quot;</span>, <span class="hljs-attr">text2</span> = <span class="hljs-string">&quot;ace&quot;</span><br>输出：<span class="hljs-number">3</span>  <br>解释：最长公共子序列是 <span class="hljs-string">&quot;ace&quot;</span>，它的长度为 <span class="hljs-number">3</span>。<br>示例 <span class="hljs-number">2</span>:<br><br>输入：<span class="hljs-attr">text1</span> = <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-attr">text2</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：最长公共子序列是 <span class="hljs-string">&quot;abc&quot;</span>，它的长度为 <span class="hljs-number">3</span>。<br>示例 <span class="hljs-number">3</span>:<br><br>输入：<span class="hljs-attr">text1</span> = <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-attr">text2</span> = <span class="hljs-string">&quot;def&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：两个字符串没有公共子序列，返回 <span class="hljs-number">0</span>。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = text1.length(), n = text2.length();<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (text1.charAt(i - <span class="hljs-number">1</span>) == text2.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<br>                dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j]);<br>                dp[i][j] = Math.max(dp[i][j - <span class="hljs-number">1</span>], dp[i][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II(简单)</a></span>    </summary><blockquote><p>动态规划　dp[i][1]=max{dp[i−1][1],dp[i−1][0]−prices[i]}</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/best-time-to-buy-and-sell-stock-ii.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = prices.length;<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][<span class="hljs-number">2</span>];<br>        <span class="hljs-comment">//dp[i][j] 表示到下标为 i 的这一天，持股状态为 j 时，我们手上拥有的最大现金数。</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);<br>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-comment">//优化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = prices.length;<br>        <span class="hljs-keyword">int</span> dp0 = <span class="hljs-number">0</span>, dp1 = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">int</span> newDp0 = Math.max(dp0, dp1 + prices[i]);<br>            <span class="hljs-keyword">int</span> newDp1 = Math.max(dp1, dp0 - prices[i]);<br>            dp0 = newDp0;<br>            dp1 = newDp1;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp0;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>贪心解法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n = prices.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            ans += Math.max(<span class="hljs-number">0</span>, prices[i] - prices[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/unique-paths/">不同路径(中等)</a></span>    </summary><blockquote><p>dp方程 dp[i][j]=dp[i+1][j]+dp[i][j+1]</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][n-<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) dp[m-<span class="hljs-number">1</span>][i]=<span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m-<span class="hljs-number">2</span>; i &gt;=  <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n-<span class="hljs-number">2</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                dp[i][j]=dp[i+<span class="hljs-number">1</span>][j]+dp[i][j+<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/unique-paths-ii/">不同路径 II(中等)</a></span>    </summary><blockquote><p>一维数组压缩状态</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] obstacleGrid)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = obstacleGrid.length, m = obstacleGrid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m];<br>        f[<span class="hljs-number">0</span>] = obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    f[j] = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; obstacleGrid[i][j - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//且没有障碍的时候在推导</span><br>                    f[j] += f[j - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[m - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><ul><li>时间复杂度：O(nm)O(nm)，其中 nn 为网格的行数，mm 为网格的列数。我们只需要遍历所有网格一次即可。</li><li>空间复杂度：O(m)O(m)。利用滚动数组优化，我们可以只用 O(m)O(m) 大小的空间来记录当前行的 ff 值。</li></ul></details><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">最长公共子序列(中等)</a></span>    </summary><blockquote></blockquote><p>$$状态转移方程=\begin{cases} dp[i][j]=dp[i-1][j-1]+1 &amp; (str1[i]==str2[j])\\ dp[i][j]=max(dp[i-1][j],dp[i][j-1]) &amp; (str1[i]!=str2[j])\\ \end{cases}$$ </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>  <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> </span>&#123;<br>        <span class="hljs-keyword">char</span>[] t1 = text1.toCharArray();<br>        <span class="hljs-keyword">char</span>[] t2 = text2.toCharArray();<br>        <span class="hljs-keyword">int</span> length1 = t1.length;<br>        <span class="hljs-keyword">int</span> length2 = t2.length;<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length1+<span class="hljs-number">1</span>][length2+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//求dp</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; length1 +<span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; length2 +<span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (t1[i-<span class="hljs-number">1</span>] == t2[j-<span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-comment">// 这边找到一个 lcs 的元素，继续往前找</span><br>                    dp[i][j] = <span class="hljs-number">1</span>+ dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//谁能让 lcs 最长，就听谁的</span><br>                    dp[i][j] = Math.max(dp[i-<span class="hljs-number">1</span>][j],dp[i][j-<span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[length1][length2];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/triangle/">三角形最小路径和(中等)</a></span>    </summary><blockquote><p>由于每一步只能移动到下一行「相邻的节点」上，因此要想走到位置 (i, j)(i,j)，上一步就只能在位置 (i - 1, j - 1)(i−1,j−1) 或者位置 (i - 1, j)(i−1,j)</p></blockquote><blockquote><p>状态转移方程=f[i][j]=min(f[i−1][j−1],f[i−1][j])+c[i][j]      其中c[i][j] 表示位置 (i, j)(i,j) 对应的元素值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = triangle.size();<br>        <span class="hljs-keyword">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = triangle.get(<span class="hljs-number">0</span>).get(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            f[i][<span class="hljs-number">0</span>] = f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + triangle.get(i).get(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; i; ++j) &#123;<br>                f[i][j] = Math.min(f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], f[i - <span class="hljs-number">1</span>][j]) + triangle.get(i).get(j);<br>            &#125;<br>            f[i][i] = f[i - <span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>] + triangle.get(i).get(i);<br>        &#125;<br>        <span class="hljs-keyword">int</span> minTotal = f[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            minTotal = Math.min(minTotal, f[n - <span class="hljs-number">1</span>][i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> minTotal;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/maximum-subarray/">最大子序和(简单)</a></span>    </summary><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><blockquote><p>状态转移方程 f(i)=max{f(i−1)+nums[i],nums[i]}</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>, maxAns = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : nums) &#123;<br>            pre = Math.max(pre + x, x);<br>            maxAns = Math.max(maxAns, pre);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxAns;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/maximum-product-subarray/description/">乘积最大子数组(中等)</a></span>    </summary><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/maximum-product-subarray.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = nums.length;<br>        <span class="hljs-keyword">int</span>[] maxF = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length];<br>        <span class="hljs-keyword">int</span>[] minF = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length];<br>        System.arraycopy(nums, <span class="hljs-number">0</span>, maxF, <span class="hljs-number">0</span>, length);<br>        System.arraycopy(nums, <span class="hljs-number">0</span>, minF, <span class="hljs-number">0</span>, length);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; length; ++i) &#123;<br>            maxF[i] = Math.max(maxF[i - <span class="hljs-number">1</span>] * nums[i], Math.max(nums[i], minF[i - <span class="hljs-number">1</span>] * nums[i]));<br>            minF[i] = Math.min(minF[i - <span class="hljs-number">1</span>] * nums[i], Math.min(nums[i], maxF[i - <span class="hljs-number">1</span>] * nums[i]));<br>        &#125;<br>        <span class="hljs-keyword">int</span> ans = maxF[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; length; ++i) &#123;<br>            ans = Math.max(ans, maxF[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">//优化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> maxF = nums[<span class="hljs-number">0</span>], minF = nums[<span class="hljs-number">0</span>], ans = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> length = nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; length; ++i) &#123;<br>            <span class="hljs-keyword">int</span> mx = maxF, mn = minF;<br>            maxF = Math.max(mx * nums[i], Math.max(nums[i], mn * nums[i]));<br>            minF = Math.min(mn * nums[i], Math.min(nums[i], mx * nums[i]));<br>            ans = Math.max(maxF, ans);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><h1 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h1><blockquote><p>数组类型题目</p></blockquote><details>  <summary><span><a href="">大整数相加(简单)</a></span></summary>  <br><p class="note note-primary">解题思路： 使用数组存储</p><p>我们以 426 709 752 31 8 + 95481 253 129 为例,来看看大整数相加的详细步骤。</p><p>第1步, 创建两个整型数组,数组长度是较大整数的位数+1。把每一个整数倒序存储到数组中,整数的个位存于数组下标为0的位置,最高位存于数组的尾部。之所以倒序存储,是因为这样更符合从左到右访问数组的习惯。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/big-integer-1.png" alt="大整数相加"></p><p>第2步, 创建结果数组,结果数组的长度同样是较大整数的位数+1,+1的目的很明显,是给最高位进位预留的。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/big-integer-2.png" alt="大整数相加"></p><p>第3步, 遍历两个数组,从左到右按照对应下标把元素两两相加,就像小学生计算竖式一样。</p><p>在本示例中,最先相加的是数组A的第1个元素8和数组B的第1个元素9,结果是7,进位1。把7填充到result数组的对应下标位置,进位的1填充到下一个位置。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/big-integer-3.png" alt="大整数相加"></p><p>第2组相加的是数组A的第2个元素1和数组B的第2个元素2,结果是3, 再加上刚才的进位1,把4填充到result数组的对应下标位置。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/big-integer-4.png" alt="大整数相加"></p><p>第3组相加的是数组A的第3个元素3和数组B的第3个元素1,结果是4,把4填充到result数组的对应下标位置。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/big-integer-5.png" alt="大整数相加"></p><p>第4组相加的是数组A的第4个元素2和数组B的第4个元素3,结果是5,把5填充到result数组的对应下标位置。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/big-integer-6.png" alt="大整数相加"></p><p>以此类推……一直把数组的所有元素都相加完毕。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/big-integer-7.png" alt="大整数相加"></p><p>第4步, 把result数组的全部元素再次逆序,去掉首位的0,就是最终结果。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/big-integer-8.png" alt="大整数相加"></p><p>需要说明的是,为两个大整数建立临时数组,是一种直观的解决方案。若想节省内存空间,也可以不创建这两个临时数组。</p><p class="note note-danger">代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">bigNumberSum</span><span class="hljs-params">(String bigNumberA, String bigNumberB)</span> </span>&#123;<br>        <span class="hljs-comment">//1.把两个大整数用数组逆序存储，数组长度等于较大整数位数+1</span><br>        <span class="hljs-keyword">int</span> maxLength = bigNumberA.length() &gt; bigNumberB.length() ? bigNumberA.length() : bigNumberB.length();<br>        <span class="hljs-keyword">int</span>[] arrayA = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[maxLength + <span class="hljs-number">1</span>];<span class="hljs-comment">//+1是为了考虑到进位的问题</span><br>        <span class="hljs-comment">//逆序存储</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bigNumberA.length(); i++) &#123;<br>            arrayA[i] = bigNumberA.charAt(bigNumberA.length() - <span class="hljs-number">1</span> - i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span>[] arrayB = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[maxLength + <span class="hljs-number">1</span>];<span class="hljs-comment">//+1是为了考虑到进位的问题</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bigNumberB.length(); i++) &#123;<br>            arrayB[i] = bigNumberA.charAt(bigNumberB.length() - <span class="hljs-number">1</span> - i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-comment">//2.构建result数组，数组长度等于较大整数位置+1</span><br>        <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[maxLength + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//3.遍历数组按位相加</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; result.length; i++) &#123;<br>            <span class="hljs-keyword">int</span> temp = result[i];<br>            temp += arrayA[i];<br>            temp += arrayB[i];<br>            <span class="hljs-comment">//判断是否进位</span><br>            <span class="hljs-keyword">if</span> (temp &gt; <span class="hljs-number">10</span>) &#123;<br>                temp = temp - <span class="hljs-number">10</span>;<br>                result[i + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>            &#125;<br>            result[i] = temp;<br>        &#125;<br>        <span class="hljs-comment">//4.把数组再次逆序并转为字符串</span><br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-comment">//是否找到大整数的最高有效位</span><br>        <span class="hljs-keyword">boolean</span> findFirst = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = result.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (!findFirst) &#123;<br>                <span class="hljs-keyword">if</span> (result[i] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                findFirst = <span class="hljs-keyword">true</span>;<br>            &#125;<br>            sb.append(result[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/move-zeroes/">移动零(简单)</a></span></summary>  <br><p>题目</p><blockquote><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例:<br>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>说明:<br>必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。</p></blockquote><p>解题思路</p><blockquote><p>使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。 右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。 注意到以下性质：</p></blockquote><ol><li>左指针左边均为非零数；</li><li>右指针左边直到左指针处均为零。 因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length, left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (nums[right] != <span class="hljs-number">0</span>) &#123;<br>                swap(nums, left, right);<br>                left++;<br>            &#125;<br>            right++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> temp = nums[left];<br>        nums[left] = nums[right];<br>        nums[right] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/container-with-most-water/">盛最多水的容器(简单)</a></span></summary>  <br><p>解题思路</p><blockquote><p>1.采用两层循环，时间复杂度O(n^2)<br>2.双指针首尾比较,如果比当前的高度小直接跳过比较(过滤),否则进行运算比较</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = height.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-keyword">int</span> area = Math.min(height[l], height[r]) * (r - l);<br>            ans = Math.max(ans, area);<br>            <span class="hljs-keyword">if</span> (height[l] &lt;= height[r]) &#123;<br>                ++l;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                --r;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/3sum/">三数之和(中等)</a></span></summary>  <br><p>解题思路</p><blockquote><p>排序+指针移动</p></blockquote><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        Arrays.sort(nums);<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>        <span class="hljs-comment">// 枚举 a</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> first = <span class="hljs-number">0</span>; first &lt; n; ++first) &#123;<br>            <span class="hljs-comment">// 需要和上一次枚举的数不相同</span><br>            <span class="hljs-keyword">if</span> (first &gt; <span class="hljs-number">0</span> &amp;&amp; nums[first] == nums[first - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// c 对应的指针初始指向数组的最右端</span><br>            <span class="hljs-keyword">int</span> third = n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">int</span> target = -nums[first];<br>            <span class="hljs-comment">// 枚举 b</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> second = first + <span class="hljs-number">1</span>; second &lt; n; ++second) &#123;<br>                <span class="hljs-comment">// 需要和上一次枚举的数不相同</span><br>                <span class="hljs-keyword">if</span> (second &gt; first + <span class="hljs-number">1</span> &amp;&amp; nums[second] == nums[second - <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">// 需要保证 b 的指针在 c 的指针的左侧</span><br>                <span class="hljs-keyword">while</span> (second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) &#123;<br>                    --third;<br>                &#125;<br>                <span class="hljs-comment">// 如果指针重合，随着 b 后续的增加</span><br>                <span class="hljs-comment">// 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环</span><br>                <span class="hljs-keyword">if</span> (second == third) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (nums[second] + nums[third] == target) &#123;<br>                    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>                    list.add(nums[first]);<br>                    list.add(nums[second]);<br>                    list.add(nums[third]);<br>                    ans.add(list);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/rotate-array/">旋转数组(中等)</a></span></summary>  <br>解题思路><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//暴力破解</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">int</span> last = nums[nums.length - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = nums.length - <span class="hljs-number">1</span>; j &gt; <span class="hljs-number">0</span>; j--) &#123;<br>                nums[j] = nums[j - <span class="hljs-number">1</span>];<br>            &#125;<br>            nums[<span class="hljs-number">0</span>] = last;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//使用额外的数组</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            arr[(i + k) % nums.length] = nums[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) nums[i] = arr[i];<br>    &#125;<br><br>    <span class="hljs-comment">//反转</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        k %= nums.length;<br>        reverse(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>        reverse(nums, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);<br>        reverse(nums, k, nums.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//反转</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>            <span class="hljs-keyword">int</span> temp = nums[start];<br>            nums[start] = nums[end];<br>            nums[end] = temp;<br>            start++;<br>            end--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span>使用环状替换</span><br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/plus-one/">加一(简单)</a></span></summary>  <br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] plusOne(<span class="hljs-keyword">int</span>[] digits) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = digits.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            digits[i]++;<br>            digits[i] = digits[i] % <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span> (digits[i] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> digits;<br>        &#125;<br>        digits = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[digits.length + <span class="hljs-number">1</span>];<br>        digits[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> digits;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">删除排序数组中的重复项(简单)</a></span></summary>  <br><blockquote><blockquote><p>方法：双指针法</p></blockquote></blockquote><p>数组完成排序后，我们可以放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。只要 nums[i] = nums[j]，我们就增加 j 以跳过重复项。</p><p>当我们遇到 nums[j]!=nums[i] 时，跳过重复项的运行已经结束，因此我们必须把它（nums[j]）的值复制到 nums[i+1]。然后递增 i，接着我们将再次重复相同的过程，直到 j 到达数组的末尾为止。</p><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; nums.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] != nums[i]) &#123;<br>                i++;<br>                nums[i] = nums[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O(n)O(n)，假设数组的长度是 nn，那么 ii 和 jj 分别最多遍历 nn 步。</p><p>空间复杂度：O(1)O(1)。</p></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">柱状图中最大的矩形(困难)</a></span></summary>  <br><p>题目描述</p><blockquote><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。</p></blockquote><p>解题思路</p><blockquote></blockquote><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure></details><h1 id="栈结构型"><a href="#栈结构型" class="headerlink" title="栈结构型"></a>栈结构型</h1><details>  <summary><span><a href="https://leetcode-cn.com/problems/valid-parentheses/">有效的括号(简单)</a></span></summary>  <br>解题思路>通过使用栈结构，当为左括号压栈，右括号出栈判断<p>实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s.length() % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span> || c == <span class="hljs-string">&#x27;[&#x27;</span> || c == <span class="hljs-string">&#x27;&#123;&#x27;</span>) stack.push(c);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!stack.isEmpty()) &#123;<br>                Character pop = stack.pop();<br>                <span class="hljs-keyword">if</span> (check(pop, c)) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    stack.push(pop);<br>                    stack.push(c);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br><br>    <span class="hljs-comment">//检查</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">char</span> a, <span class="hljs-keyword">char</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> ((a == <span class="hljs-string">&#x27;&#123;&#x27;</span> &amp;&amp; b == <span class="hljs-string">&#x27;&#125;&#x27;</span>) || (a == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; b == <span class="hljs-string">&#x27;]&#x27;</span>) || (a == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; b == <span class="hljs-string">&#x27;)&#x27;</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">柱状图中最大的矩形(困难)</a></span></summary>  <br><blockquote><p>使用单调栈进行实现</p></blockquote><p>单调栈 单调栈分为单调递增栈和单调递减栈</p><pre><code>1. 单调递增栈即栈内元素保持单调递增的栈2. 同理单调递减栈即栈内元素保持单调递减的栈</code></pre><p>操作规则（下面都以单调递增栈为例）</p><pre><code>1. 如果新的元素比栈顶元素大，就入栈2. 如果新的元素较小，那就一直把栈内元素弹出来，直到栈顶比新元素小</code></pre><p>加入这样一个规则之后，会有什么效果</p><pre><code>1. 栈内的元素是递增的2. 当元素出栈时，说明这个新元素是出栈元素向后找第一个比其小的元素</code></pre><blockquote><p>举个例子，配合下图，现在索引在 6 ，栈里是 1 5 6 。 接下来新元素是 2 ，那么 6 需要出栈。 当 6 出栈时，右边 2 代表是 6 右边第一个比 6 小的元素。</p></blockquote><p>当元素出栈后，说明新栈顶元素是出栈元素向前找第一个比其小的元素</p><blockquote><p>当 6 出栈时，5 成为新的栈顶，那么 5 就是 6 左边第一个比 6 小的元素。</p></blockquote><p>代码模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; st;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++)<br>&#123;<br><span class="hljs-keyword">while</span>(!st.empty() &amp;&amp; st.top() &gt; nums[i])<br>&#123;<br>st.pop();<br>&#125;<br>st.push(nums[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p>画图理解</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/cfx.png"></p><p>思路</p><blockquote><p>对于一个高度，如果能得到向左和向右的边界 那么就能对每个高度求一次面积 遍历所有高度，即可得出最大面积<br><code>使用单调栈，在出栈操作时得到前后边界并计算面积</code></p></blockquote><p>答题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; heights)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; st;<br>    heights.insert(heights.begin(), <span class="hljs-number">0</span>);<br>    heights.push_back(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; heights.size(); i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (!st.empty() &amp;&amp; heights[st.back()] &gt; heights[i])<br>        &#123;<br>            <span class="hljs-keyword">int</span> cur = st.back();<br>            st.pop_back();<br>            <span class="hljs-keyword">int</span> left = st.back() + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">int</span> right = i - <span class="hljs-number">1</span>;<br>            ans = max(ans, (right - left + <span class="hljs-number">1</span>) * heights[cur]);<br>        &#125;<br>        st.push_back(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = heights.length;<br>        <span class="hljs-keyword">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">int</span>[] right = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        Arrays.fill(right, n);<br><br>        Stack&lt;Integer&gt; mono_stack = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (!mono_stack.isEmpty() &amp;&amp; heights[mono_stack.peek()] &gt;= heights[i]) &#123;<br>                right[mono_stack.peek()] = i;<br>                mono_stack.pop();<br>            &#125;<br>            left[i] = (mono_stack.isEmpty() ? -<span class="hljs-number">1</span> : mono_stack.peek());<br>            mono_stack.push(i);<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            ans = Math.max(ans, (right[i] - left[i] - <span class="hljs-number">1</span>) * heights[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/trapping-rain-water/">接雨水(困难)</a></span></summary>  <br><blockquote><p>暴力解法、优化、双指针、<a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-8/">单调栈</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jys.png" alt="单调栈"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap6</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-keyword">int</span> current = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (current &lt; height.length) &#123;<br>            <span class="hljs-comment">//如果栈不空并且当前指向的高度大于栈顶高度就一直循环</span><br>            <span class="hljs-keyword">while</span> (!stack.empty() &amp;&amp; height[current] &gt; height[stack.peek()]) &#123;<br>                <span class="hljs-keyword">int</span> h = height[stack.peek()]; <span class="hljs-comment">//取出要出栈的元素</span><br>                stack.pop(); <span class="hljs-comment">//出栈</span><br>                <span class="hljs-keyword">if</span> (stack.empty()) &#123; <span class="hljs-comment">// 栈空就出去</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">int</span> distance = current - stack.peek() - <span class="hljs-number">1</span>; <span class="hljs-comment">//两堵墙之前的距离。</span><br>                <span class="hljs-keyword">int</span> min = Math.min(height[stack.peek()], height[current]);<br>                sum = sum + distance * (min - h);<br>            &#125;<br>            stack.push(current); <span class="hljs-comment">//当前指向的墙入栈</span><br>            current++; <span class="hljs-comment">//指针后移</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary>        <span><a href="">每日温度(中等)</a></span>    </summary><blockquote><p>暴力解法 + 单调栈</p></blockquote></details><details>    <summary>        <span><a href="">下一个更大元素(简单)</a></span>    </summary><blockquote><p>暴力解法、单调栈</p></blockquote></details><details>    <summary>        <span><a href="">去除重复字母(困难)</a></span>    </summary><blockquote><p>栈 + 哨兵技巧（Java、C++、Python）</p></blockquote></details><details>    <summary>        <span><a href="">股票价格跨度(中等)</a></span>    </summary><blockquote><p>单调栈</p></blockquote></details><details>    <summary>        <span><a href="">移掉K位数字()</a></span>    </summary><blockquote></blockquote></details><details>    <summary>        <span><a href="">最短无序连续子数组()</a></span>    </summary></details><h1 id="队列类型"><a href="#队列类型" class="headerlink" title="队列类型"></a>队列类型</h1><details>  <summary><span><a href="http://leetcode-cn.com/problems/min-stack">最小栈(简单)</a></span></summary>  <br><p>解题思路</p><blockquote><p>使用辅助队列或者栈进行实现，入栈时判断当前是否小于最小栈或队列的值，小于则置于栈顶，否则插入相同栈顶元素，出栈队时两个都出</p></blockquote><p>代码实现１</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> </span>&#123;<br>    Stack&lt;Integer&gt; stackA;<br>    Stack&lt;Integer&gt; stackB;<br><br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.stackA = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-keyword">this</span>.stackB = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        stackB.push(Integer.MAX_VALUE);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        stackA.push(x);<br>        Integer peek = stackB.peek();<br>        <span class="hljs-keyword">if</span> (x &lt; peek) stackB.push(x);<br>        <span class="hljs-keyword">else</span> stackB.push(peek);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        stackA.pop();<br>        stackB.pop();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stackA.peek();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stackB.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现代码2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> </span>&#123;<br>    Deque&lt;Integer&gt; xStack;<br>    Deque&lt;Integer&gt; minStack;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;<br>        xStack = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        minStack = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        minStack.push(Integer.MAX_VALUE);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        xStack.push(x);<br>        minStack.push(Math.min(minStack.peek(), x));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        xStack.pop();<br>        minStack.pop();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> xStack.peek();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> minStack.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">滑动窗口最大值(困难)</a></span></summary>  <br><blockquote><p>暴力破解(时间超时),双向队列,动态规划</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">处理前 k 个元素，初始化双向队列。队列存储的是数组元素下标<br>遍历整个数组。在每一步 :<br>清理双向队列 :<br>  - 只保留当前滑动窗口中有的元素的索引。<br>  - 移除比当前元素小的所有元素，它们不可能是最大的。<br>将当前元素添加到双向队列中。<br>将 deque[0] 添加到输出中。<br>返回输出数组。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    ArrayDeque&lt;Integer&gt; deq = <span class="hljs-keyword">new</span> ArrayDeque&lt;Integer&gt;();<br>    <span class="hljs-keyword">int</span>[] nums;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clean_deque</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// remove indexes of elements not from sliding window</span><br>        <span class="hljs-keyword">if</span> (!deq.isEmpty() &amp;&amp; deq.getFirst() == i - k) deq.removeFirst();<span class="hljs-comment">//如果是队头直接移除</span><br>        <span class="hljs-comment">// remove from deq indexes of all elements </span><br>        <span class="hljs-comment">// which are smaller than current element nums[i]</span><br>        <span class="hljs-keyword">while</span> (!deq.isEmpty() &amp;&amp; nums[i] &gt; nums[deq.getLast()]) deq.removeLast();<span class="hljs-comment">//将小于num[i]的元素全部从尾部出队</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">if</span> (n * k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums;<br>        <span class="hljs-comment">// init deque and output</span><br>        <span class="hljs-keyword">this</span>.nums = nums;<br>        <span class="hljs-keyword">int</span> max_idx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<span class="hljs-comment">//先构建一个k长度的双端队列</span><br>            clean_deque(i, k);<br>            deq.addLast(i);<br>            <span class="hljs-comment">// compute max in nums[:k]</span><br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[max_idx]) max_idx = i;<br>        &#125;<br>        <span class="hljs-keyword">int</span>[] output = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n - k + <span class="hljs-number">1</span>];<br>        output[<span class="hljs-number">0</span>] = nums[max_idx];<span class="hljs-comment">//初始化第一个最大值</span><br>        <span class="hljs-comment">// build output</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k; i &lt; n; i++) &#123;<br>            clean_deque(i, k);<br>            deq.addLast(i);<br>            output[i - k + <span class="hljs-number">1</span>] = nums[deq.getFirst()];<span class="hljs-comment">//每次从对头获取最大值</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> output;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="">设计循环双端队列(中等)</a></span></summary>  <br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCircularDeque</span> </span>&#123;<br><br>    <span class="hljs-comment">// 1、不用设计成动态数组，使用静态数组即可</span><br>    <span class="hljs-comment">// 2、设计 head 和 tail 指针变量</span><br>    <span class="hljs-comment">// 3、head == tail 成立的时候表示队列为空</span><br>    <span class="hljs-comment">// 4、tail + 1 == head</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arr;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> front;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> rear;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Initialize your data structure here. Set the size of the deque to be k.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyCircularDeque</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        capacity = k + <span class="hljs-number">1</span>;<br>        arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[capacity];<br><br>        <span class="hljs-comment">// 头部指向第 1 个存放元素的位置</span><br>        <span class="hljs-comment">// 插入时，先减，再赋值</span><br>        <span class="hljs-comment">// 删除时，索引 +1（注意取模）</span><br>        front = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 尾部指向下一个插入元素的位置</span><br>        <span class="hljs-comment">// 插入时，先赋值，再加</span><br>        <span class="hljs-comment">// 删除时，索引 -1（注意取模）</span><br>        rear = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Adds an item at the front of Deque. Return true if the operation is successful.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">insertFront</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (isFull()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        front = (front - <span class="hljs-number">1</span> + capacity) % capacity;<br>        arr[front] = value;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Adds an item at the rear of Deque. Return true if the operation is successful.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">insertLast</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (isFull()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        arr[rear] = value;<br>        rear = (rear + <span class="hljs-number">1</span>) % capacity;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Deletes an item from the front of Deque. Return true if the operation is successful.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">deleteFront</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// front 被设计在数组的开头，所以是 +1</span><br>        front = (front + <span class="hljs-number">1</span>) % capacity;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Deletes an item from the rear of Deque. Return true if the operation is successful.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">deleteLast</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// rear 被设计在数组的末尾，所以是 -1</span><br>        rear = (rear - <span class="hljs-number">1</span> + capacity) % capacity;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Get the front item from the deque.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFront</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr[front];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Get the last item from the deque.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRear</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 当 rear 为 0 时防止数组越界</span><br>        <span class="hljs-keyword">return</span> arr[(rear - <span class="hljs-number">1</span> + capacity) % capacity];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Checks whether the circular deque is empty or not.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> front == rear;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Checks whether the circular deque is full or not.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 注意：这个设计是非常经典的做法</span><br>        <span class="hljs-keyword">return</span> (rear + <span class="hljs-number">1</span>) % capacity == front;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><h1 id="递归类型"><a href="#递归类型" class="headerlink" title="递归类型"></a>递归类型</h1><details>  <summary><span><a href="https://leetcode-cn.com/problems/generate-parentheses/">括号生成(中等)</a></span></summary>  <br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。<br><br> <br><br>示例：<br><br>输入：n = 3<br>输出：[<br>       &quot;((()))&quot;,<br>       &quot;(()())&quot;,<br>       &quot;(())()&quot;,<br>       &quot;()(())&quot;,<br>       &quot;()()()&quot;<br>     ]<br></code></pre></td></tr></table></figure><blockquote><p>递归</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/khsc.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<span class="hljs-comment">//存储结果</span><br>        generate(res, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n);<span class="hljs-comment">//函数入口</span><br>        <span class="hljs-keyword">return</span> res;<span class="hljs-comment">//返回结果</span><br>    &#125;<br>    <span class="hljs-comment">//count1统计“(”的个数，count2统计“)”的个数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">generate</span><span class="hljs-params">(List&lt;String&gt; res , String ans, <span class="hljs-keyword">int</span> count1, <span class="hljs-keyword">int</span> count2, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(count1 &gt; n || count2 &gt; n) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//递归结束条件</span><br>        <span class="hljs-keyword">if</span>(count1 == n &amp;&amp; count2 == n)  res.add(ans);<span class="hljs-comment">//相等返回</span><br>        <span class="hljs-keyword">if</span>(count1 &gt;= count2)&#123;<span class="hljs-comment">//左括号数量大于等于右括号</span><br>            String ans1 = <span class="hljs-keyword">new</span> String(ans);<br>            generate(res, ans+<span class="hljs-string">&quot;(&quot;</span>, count1+<span class="hljs-number">1</span>, count2, n);<span class="hljs-comment">//增加左边个数</span><br>            generate(res, ans1+<span class="hljs-string">&quot;)&quot;</span>, count1, count2+<span class="hljs-number">1</span>, n);<span class="hljs-comment">//增加右括号个数</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>回溯思想、</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        backtrack(ans, <span class="hljs-keyword">new</span> StringBuilder(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">//回溯函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(List&lt;String&gt; ans, StringBuilder cur, <span class="hljs-keyword">int</span> open, <span class="hljs-keyword">int</span> close, <span class="hljs-keyword">int</span> max)</span> </span>&#123;<br>        <span class="hljs-comment">//递归结束条件</span><br>        <span class="hljs-keyword">if</span> (cur.length() == max * <span class="hljs-number">2</span>) &#123;<br>            ans.add(cur.toString());<span class="hljs-comment">//添加入结果</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//</span><br>        <span class="hljs-keyword">if</span> (open &lt; max) &#123;<br>            cur.append(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            backtrack(ans, cur, open + <span class="hljs-number">1</span>, close, max);<br>            cur.deleteCharAt(cur.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">//</span><br>        <span class="hljs-keyword">if</span> (close &lt; open) &#123;<br>            cur.append(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            backtrack(ans, cur, open, close + <span class="hljs-number">1</span>, max);<br>            cur.deleteCharAt(cur.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/invert-binary-tree/">翻转二叉树(简单)</a></span></summary>  <br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//利用前序遍历</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>        <span class="hljs-comment">// 先序遍历--从顶向下交换</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            <span class="hljs-comment">// 保存右子树</span><br>            TreeNode rightTree = root.right;<br>            <span class="hljs-comment">// 交换左右子树的位置</span><br>            root.right = invertTree(root.left);<br>            root.left = invertTree(rightTree);<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">//利用中序遍历</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            invertTree(root.left); <span class="hljs-comment">// 递归找到左节点</span><br>            TreeNode rightNode= root.right; <span class="hljs-comment">// 保存右节点</span><br>            root.right = root.left;<br>            root.left = rightNode;<br>            <span class="hljs-comment">// 递归找到右节点 继续交换 : 因为此时左右节点已经交换了,所以此时的右节点为root.left</span><br>            invertTree(root.left); <br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//利用后序遍历</span><br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>            <span class="hljs-comment">// 后序遍历-- 从下向上交换</span><br>            <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            TreeNode leftNode = invertTree(root.left);<br>            TreeNode rightNode = invertTree(root.right);<br>            root.right = leftNode;<br>            root.left = rightNode;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">//利用层次遍历</span><br>   <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>            <span class="hljs-comment">// 层次遍历--直接左右交换即可</span><br>            <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>            queue.offer(root);<br>            <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>                TreeNode node = queue.poll();<br>                TreeNode rightTree = node.right;<br>                node.right = node.left;<br>                node.left = rightTree;<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    queue.offer(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    queue.offer(node.right);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">验证二叉搜索树(中等)</a></span></summary>  <br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> pre = Long.MIN_VALUE;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 访问左子树</span><br>        <span class="hljs-keyword">if</span> (!isValidBST(root.left)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回 false；否则继续遍历。</span><br>        <span class="hljs-keyword">if</span> (root.val &lt;= pre) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        pre = root.val;<br>        <span class="hljs-comment">// 访问右子树</span><br>        <span class="hljs-keyword">return</span> isValidBST(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">二叉树的最大深度(简单)</a></span></summary>  <br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> root == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">二叉树的最小深度(简单)</a></span></summary>  <br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// null节点不参与比较</span><br>    <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + minDepth(root.right);<br>    &#125;<br>    <span class="hljs-comment">// null节点不参与比较</span><br>    <span class="hljs-keyword">if</span> (root.right == <span class="hljs-keyword">null</span> &amp;&amp; root.left != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + minDepth(root.left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + Math.min(minDepth(root.left), minDepth(root.right));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="https://support.leetcode-cn.com/hc/kb/category/1018267/">二叉树的序列化与反序列化(困难)</a></span></summary>  <br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">rserialize</span><span class="hljs-params">(TreeNode root, String str)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            str += <span class="hljs-string">&quot;None,&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            str += str.valueOf(root.val) + <span class="hljs-string">&quot;,&quot;</span>;<br>            str = rserialize(root.left, str);<br>            str = rserialize(root.right, str);<br>        &#125;<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br>    <span class="hljs-comment">//序列化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> rserialize(root, <span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">rdeserialize</span><span class="hljs-params">(List&lt;String&gt; l)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l.get(<span class="hljs-number">0</span>).equals(<span class="hljs-string">&quot;None&quot;</span>)) &#123;<br>            l.remove(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(Integer.valueOf(l.get(<span class="hljs-number">0</span>)));<br>        l.remove(<span class="hljs-number">0</span>);<br>        root.left = rdeserialize(l);<br>        root.right = rdeserialize(l);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-comment">//反序列化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">deserialize</span><span class="hljs-params">(String data)</span> </span>&#123;<br>        String[] data_array = data.split(<span class="hljs-string">&quot;,&quot;</span>);<br>        List&lt;String&gt; data_list = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;(Arrays.asList(data_array));<br>        <span class="hljs-keyword">return</span> rdeserialize(data_list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/minesweeper/">扫雷游戏(中等)</a></span>    </summary><ul><li>当前点击的是「未挖出的地雷」，我们将其值改为 \text{X}X 即可。</li><li>当前点击的是「未挖出的空方块」，我们需要统计它周围相邻的方块里地雷的数量 \textit{cnt}cnt（即 \text{M}M 的数量）。如果 \textit{cnt}cnt 为零，即执行规则 22，此时需要将其改为 \text{B}B，且递归地处理周围的八个未挖出的方块，递归终止条件即为规则 44，没有更多方块可被揭露的时候。否则执行规则 33，将其修改为数字即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] dirX = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">int</span>[] dirY = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span>[][] updateBoard(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span>[] click) &#123;<br>        <span class="hljs-keyword">int</span> x = click[<span class="hljs-number">0</span>], y = click[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (board[x][y] == <span class="hljs-string">&#x27;M&#x27;</span>) &#123;<br>            <span class="hljs-comment">// 规则 1</span><br>            board[x][y] = <span class="hljs-string">&#x27;X&#x27;</span>;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            dfs(board, x, y);<br>        &#125;<br>        <span class="hljs-keyword">return</span> board;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; ++i) &#123;<br>            <span class="hljs-keyword">int</span> tx = x + dirX[i];<br>            <span class="hljs-keyword">int</span> ty = y + dirY[i];<br>            <span class="hljs-keyword">if</span> (tx &lt; <span class="hljs-number">0</span> || tx &gt;= board.length || ty &lt; <span class="hljs-number">0</span> || ty &gt;= board[<span class="hljs-number">0</span>].length) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 不用判断 M，因为如果有 M 的话游戏已经结束了</span><br>            <span class="hljs-keyword">if</span> (board[tx][ty] == <span class="hljs-string">&#x27;M&#x27;</span>) &#123;<br>                ++cnt;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cnt &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 规则 3</span><br>            board[x][y] = (<span class="hljs-keyword">char</span>) (cnt + <span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 规则 2</span><br>            board[x][y] = <span class="hljs-string">&#x27;B&#x27;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; ++i) &#123;<br>                <span class="hljs-keyword">int</span> tx = x + dirX[i];<br>                <span class="hljs-keyword">int</span> ty = y + dirY[i];<br>                <span class="hljs-comment">// 这里不需要在存在 B 的时候继续扩展，因为 B 之前被点击的时候已经被扩展过了</span><br>                <span class="hljs-keyword">if</span> (tx &lt; <span class="hljs-number">0</span> || tx &gt;= board.length || ty &lt; <span class="hljs-number">0</span> || ty &gt;= board[<span class="hljs-number">0</span>].length || board[tx][ty] != <span class="hljs-string">&#x27;E&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                dfs(board, tx, ty);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/word-ladder/">单词接龙(困难)</a></span>    </summary><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/word-jielong.png"></p><blockquote><p>图的广度优先遍历</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    Map&lt;String, Integer&gt; wordId = <span class="hljs-keyword">new</span> HashMap&lt;String, Integer&gt;();<br>    List&lt;List&lt;Integer&gt;&gt; edge = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>    <span class="hljs-keyword">int</span> nodeNum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (String word : wordList) &#123;<br>            addEdge(word);<br>        &#125;<br>        addEdge(beginWord);<br>        <span class="hljs-keyword">if</span> (!wordId.containsKey(endWord)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span>[] dis = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nodeNum];<br>        Arrays.fill(dis, Integer.MAX_VALUE);<br>        <span class="hljs-keyword">int</span> beginId = wordId.get(beginWord), endId = wordId.get(endWord);<br>        dis[beginId] = <span class="hljs-number">0</span>;<br><br>        Queue&lt;Integer&gt; que = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        que.offer(beginId);<br>        <span class="hljs-keyword">while</span> (!que.isEmpty()) &#123;<br>            <span class="hljs-keyword">int</span> x = que.poll();<br>            <span class="hljs-keyword">if</span> (x == endId) &#123;<br>                <span class="hljs-keyword">return</span> dis[endId] / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> it : edge.get(x)) &#123;<br>                <span class="hljs-keyword">if</span> (dis[it] == Integer.MAX_VALUE) &#123;<br>                    dis[it] = dis[x] + <span class="hljs-number">1</span>;<br>                    que.offer(it);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        addWord(word);<br>        <span class="hljs-keyword">int</span> id1 = wordId.get(word);<br>        <span class="hljs-keyword">char</span>[] array = word.toCharArray();<br>        <span class="hljs-keyword">int</span> length = array.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>            <span class="hljs-keyword">char</span> tmp = array[i];<br>            array[i] = <span class="hljs-string">&#x27;*&#x27;</span>;<br>            String newWord = <span class="hljs-keyword">new</span> String(array);<br>            addWord(newWord);<br>            <span class="hljs-keyword">int</span> id2 = wordId.get(newWord);<br>            edge.get(id1).add(id2);<br>            edge.get(id2).add(id1);<br>            array[i] = tmp;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addWord</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!wordId.containsKey(word)) &#123;<br>            wordId.put(word, nodeNum++);<br>            edge.add(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><h1 id="字典树型"><a href="#字典树型" class="headerlink" title="字典树型"></a>字典树型</h1><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">实现 Trie (前缀树)(中等)</a></span>    </summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;<br><br>    <span class="hljs-comment">// 构造Trie树节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span> </span>&#123;<br><br>        <span class="hljs-comment">// 标识该节点是否是字符串的结束节点</span><br>        <span class="hljs-keyword">boolean</span> isEnd = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">// 当前节点的孩子节点</span><br>        TrieNode[] next = <span class="hljs-keyword">new</span> TrieNode[<span class="hljs-number">26</span>];<br><br>        <span class="hljs-comment">// 设置当前节点为一个字符串的结束节点</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setIsEnd</span> <span class="hljs-params">(<span class="hljs-keyword">boolean</span> isEnd)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.isEnd = isEnd;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">// root为根节点</span><br>    TrieNode root;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span>  </span>&#123;<br>        root = <span class="hljs-keyword">new</span> TrieNode();<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Inserts a word into the trie. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">char</span>[] chs = word.toCharArray();<br>        <span class="hljs-comment">// 表示从根节点开始向下构建</span><br>        TrieNode node = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;<br>            <br>            <span class="hljs-keyword">int</span> u = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-comment">// 判断node的子节点集合中是否已经存在了chs[i], 不存在则创建</span><br>            <span class="hljs-keyword">if</span> (node.next[u] == <span class="hljs-keyword">null</span>) <br>                node.next[u] = <span class="hljs-keyword">new</span> TrieNode();<br>            <span class="hljs-comment">// 继续向下构建</span><br>            node = node.next[u];<br>        <br>        &#125;<br><br>        <span class="hljs-comment">// 当前TrieNode节点是一个字符串的结尾</span><br>        node.setIsEnd(<span class="hljs-keyword">true</span>);<br><br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns if the word is in the trie. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">char</span>[] chs = word.toCharArray();<br>        <span class="hljs-comment">// 表示从根节点开始向下构建</span><br>        TrieNode node = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;<br>            <br>            <span class="hljs-keyword">int</span> u = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-comment">// 判断node的子节点集合中是否已经存在了chs[i], 不存在则创建</span><br>            <span class="hljs-keyword">if</span> (node.next[u] == <span class="hljs-keyword">null</span>) <br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">// 继续向下构建</span><br>            node = node.next[u];<br>        <br>        &#125;<br><br>        <span class="hljs-comment">// 当前TrieNode节点是否一个字符串的结尾</span><br>        <span class="hljs-keyword">return</span> node.isEnd;<br><br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(String prefix)</span> </span>&#123;<br><br>        <span class="hljs-keyword">char</span>[] chs = prefix.toCharArray();<br>        <span class="hljs-comment">// 表示从根节点开始向下构建</span><br>        TrieNode node = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;<br>            <br>            <span class="hljs-keyword">int</span> u = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-comment">// 判断node的子节点集合中是否已经存在了chs[i], 不存在则创建</span><br>            <span class="hljs-keyword">if</span> (node.next[u] == <span class="hljs-keyword">null</span>) <br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">// 继续向下构建</span><br>            node = node.next[u];<br>        <br>        &#125;<br><br>        <span class="hljs-comment">// 前缀查找成功</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><h1 id="查并集类"><a href="#查并集类" class="headerlink" title="查并集类"></a>查并集类</h1><blockquote></blockquote><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/number-of-islands/">岛屿数量(中等)</a></span>    </summary><blockquote></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (grid == <span class="hljs-keyword">null</span> || grid.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> nr = grid.length;<br>        <span class="hljs-keyword">int</span> nc = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">int</span> num_islands = <span class="hljs-number">0</span>;<br>        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(grid);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; nr; ++r) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; nc; ++c) &#123;<br>                <span class="hljs-keyword">if</span> (grid[r][c] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    grid[r][c] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                    <span class="hljs-keyword">if</span> (r - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[r-<span class="hljs-number">1</span>][c] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                        uf.union(r * nc + c, (r-<span class="hljs-number">1</span>) * nc + c);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (r + <span class="hljs-number">1</span> &lt; nr &amp;&amp; grid[r+<span class="hljs-number">1</span>][c] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                        uf.union(r * nc + c, (r+<span class="hljs-number">1</span>) * nc + c);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (c - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[r][c-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                        uf.union(r * nc + c, r * nc + c - <span class="hljs-number">1</span>);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; nc &amp;&amp; grid[r][c+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                        uf.union(r * nc + c, r * nc + c + <span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uf.getCount();<br>    &#125;<br>    <span class="hljs-comment">//并查集</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> count;<br>        <span class="hljs-keyword">int</span>[] parent;<br>        <span class="hljs-keyword">int</span>[] rank;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid)</span> </span>&#123;<br>            count = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> m = grid.length;<br>            <span class="hljs-keyword">int</span> n = grid[<span class="hljs-number">0</span>].length;<br>            parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m * n];<br>            rank = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m * n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                    <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                        parent[i * n + j] = i * n + j;<br>                        ++count;<br>                    &#125;<br>                    rank[i * n + j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (parent[i] != i) parent[i] = find(parent[i]);<br>            <span class="hljs-keyword">return</span> parent[i];<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>            <span class="hljs-keyword">int</span> rootx = find(x);<br>            <span class="hljs-keyword">int</span> rooty = find(y);<br>            <span class="hljs-keyword">if</span> (rootx != rooty) &#123;<br>                <span class="hljs-keyword">if</span> (rank[rootx] &gt; rank[rooty]) &#123;<br>                    parent[rooty] = rootx;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rank[rootx] &lt; rank[rooty]) &#123;<br>                    parent[rootx] = rooty;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    parent[rooty] = rootx;<br>                    rank[rootx] += <span class="hljs-number">1</span>;<br>                &#125;<br>                --count;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> count;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/sqrtx/">x 的平方根(简单)</a></span>    </summary><blockquote><p>二分查找</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = x, ans = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-keyword">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">long</span>) mid * mid &lt;= x) &#123;<br>                ans = mid;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>牛顿迭代法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">double</span> C = x, x0 = x;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">double</span> xi = <span class="hljs-number">0.5</span> * (x0 + C / x0);<br>            <span class="hljs-keyword">if</span> (Math.abs(x0 - xi) &lt; <span class="hljs-number">1e-7</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            x0 = xi;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) x0;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/valid-perfect-square/">有效的完全平方数(简单)</a></span>    </summary><blockquote><p>二分查找</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPerfectSquare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = num, ans = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-keyword">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">long</span>) mid * mid == num) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">long</span>) mid * mid &lt;= num) &#123;<br>                ans = mid;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">搜索旋转排序数组(中等)</a></span>    </summary><blockquote></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-comment">// If the list has just one element then return that element.</span><br>    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-comment">// initializing left and right pointers.</span><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// if the last element is greater than the first element then there is no rotation.</span><br>    <span class="hljs-comment">// e.g. 1 &lt; 2 &lt; 3 &lt; 4 &lt; 5 &lt; 7. Already sorted array.</span><br>    <span class="hljs-comment">// Hence the smallest element is first element. A[0]</span><br>    <span class="hljs-keyword">if</span> (nums[right] &gt; nums[<span class="hljs-number">0</span>]) &#123;<br>      <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-comment">// Binary search way</span><br>    <span class="hljs-keyword">while</span> (right &gt;= left) &#123;<br>      <span class="hljs-comment">// Find the mid element</span><br>      <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>      <span class="hljs-comment">// if the mid element is greater than its next element then mid+1 element is the smallest</span><br>      <span class="hljs-comment">// This point would be the point of change. From higher to lower value.</span><br>      <span class="hljs-comment">// [4,5,6,7,0,1,2] mid=7的情况</span><br>      <span class="hljs-keyword">if</span> (nums[mid] &gt; nums[mid + <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">return</span> nums[mid + <span class="hljs-number">1</span>];<br>      &#125;<br>      <span class="hljs-comment">// if the mid element is lesser than its previous element then mid element is the smallest</span><br>      <span class="hljs-comment">// [4,5,6,7,0,1,2] mid=0的情况</span><br>      <span class="hljs-keyword">if</span> (nums[mid - <span class="hljs-number">1</span>] &gt; nums[mid]) &#123;<br>        <span class="hljs-keyword">return</span> nums[mid];<br>      &#125;<br>      <span class="hljs-comment">// if the mid elements value is greater than the 0th element this means</span><br>      <span class="hljs-comment">// the least value is still somewhere to the right as we are still dealing with elements</span><br>      <span class="hljs-comment">// greater than nums[0]</span><br>      <span class="hljs-keyword">if</span> (nums[mid] &gt; nums[<span class="hljs-number">0</span>]) &#123;<br>        left = mid + <span class="hljs-number">1</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// if nums[0] is greater than the mid value then this means the smallest value is somewhere to</span><br>        <span class="hljs-comment">// the left</span><br>        right = mid - <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/">搜索二维矩阵(中等)</a></span>    </summary><blockquote><p>二分查找，将其看做一个有序一维数组,<code>row = idx / n ， col = idx % n</code></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/search-matrix.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m = matrix.length;<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">int</span> n = matrix[<span class="hljs-number">0</span>].length;<br><br>    <span class="hljs-comment">// 二分查找</span><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = m * n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> pivotIdx, pivotElement;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>      pivotIdx = (left + right) / <span class="hljs-number">2</span>;<br>      pivotElement = matrix[pivotIdx / n][pivotIdx % n];<br>      <span class="hljs-keyword">if</span> (target == pivotElement) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>      <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (target &lt; pivotElement) right = pivotIdx - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> left = pivotIdx + <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">寻找旋转排序数组中的最小值(中等)</a></span>    </summary><blockquote></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>] == target ? <span class="hljs-number">0</span> : -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//二分查找</span><br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-keyword">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<span class="hljs-comment">//是目标值直接返回</span><br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] &lt;= nums[mid]) &#123;<span class="hljs-comment">//当前是单调递增区间</span><br>                <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;<span class="hljs-comment">//0-mid区间</span><br>                    r = mid - <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//mid-r区间</span><br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//当前不是单调递增区间</span><br>                <span class="hljs-keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - <span class="hljs-number">1</span>]) &#123;<span class="hljs-comment">//(mid)-(n-1)区间</span><br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//l-mid区间</span><br>                    r = mid - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><h1 id="位移运算"><a href="#位移运算" class="headerlink" title="位移运算"></a>位移运算</h1><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/number-of-1-bits/">位1的个数(简单)</a></span>    </summary><blockquote><p>位移</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> bits = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> mask = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> ((n &amp; mask) != <span class="hljs-number">0</span>) bits++;<br>            mask &lt;&lt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> bits;<br>    &#125;<br>    <span class="hljs-comment">//优化</span><br>    <span class="hljs-comment">//不断把数字最后一个 11 反转，并把答案加一</span><br>    <span class="hljs-comment">//在二进制表示中，数字 n 中最低位的 11 总是对应 n - 1 中的 0。因此，将 n 和 n - 1 与运算总是能把 n 中最低位的 1 变成 0 ，并保持其他位不变。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            sum++;<br>            n &amp;= (n - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure></details><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/power-of-two/">2的幂(简单)</a></span>    </summary><blockquote><p>(x &amp; (-x)) == x<br>(x &amp; (x - 1)) == 0</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-comment">//位运算：获取二进制中最右边的 1</span><br>  <span class="hljs-comment">//若 x 为 2 的幂，则它的二进制表示中只包含一个 1，则有 x &amp; (-x) = x</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">long</span> x = (<span class="hljs-keyword">long</span>) n;<br>    <span class="hljs-keyword">return</span> (x &amp; (-x)) == x;<br>  &#125;<br>  <span class="hljs-comment">//位运算：去除二进制中最右边的 1</span><br>  <span class="hljs-comment">//(x - 1) 代表了将 x 最右边的 1 设置为 0，并且将较低位设置为 1。</span><br>  <span class="hljs-comment">//2 的幂二进制表示只含有一个 1。</span><br>  <span class="hljs-comment">// x &amp; (x - 1) 操作会将 2 的幂设置为 0，因此判断是否为 2 的幂是：判断 x &amp; (x - 1) == 0</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">long</span> x = (<span class="hljs-keyword">long</span>) n;<br>    <span class="hljs-keyword">return</span> (x &amp; (x - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/reverse-bits/">颠倒二进制位(简单)</a></span>    </summary><blockquote><p>1011 &amp; 0001 = 0001 获取末尾二进制值</p></blockquote><blockquote></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverseBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>            result &lt;&lt;= <span class="hljs-number">1</span>;<br>            result += <span class="hljs-number">1</span> &amp; n;<br>            n &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-comment">//优化</span><br>    <span class="hljs-comment">//由于1 &amp; n的值为 0 或者 1，所以返回结果 result 直接加上（1 &amp; n）以更新最后一位数值。</span><br>    <span class="hljs-comment">//这里也可以使用或运算。参与或运算的两个元素，只要有一个为1，那么结果就为1，否则为0。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverseBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>            result &lt;&lt;= <span class="hljs-number">1</span>;<span class="hljs-comment">//左移一位进行进位</span><br>            result |= n &amp; <span class="hljs-number">1</span>;<span class="hljs-comment">//</span><br>            n &gt;&gt;= <span class="hljs-number">1</span>;<span class="hljs-comment">//n右移一位</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary>        <span><a href="https://leetcode-cn.com/problems/counting-bits/description/">比特位计数(中等)</a></span>    </summary><p>给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p><blockquote><p>x&gt;&gt;1右移1位(除以2)，x&amp;1取末位</p></blockquote><p>P(x)=P(x&amp;(x−1))+1;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] countBits(<span class="hljs-keyword">int</span> num) &#123;<br>      <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num + <span class="hljs-number">1</span>];<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; ++i)<br>        ans[i] = ans[i &gt;&gt; <span class="hljs-number">1</span>] + (i &amp; <span class="hljs-number">1</span>); <span class="hljs-comment">// x / 2 is x &gt;&gt; 1 and x % 2 is x &amp; 1</span><br>      <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode-cn.top/#/home">力扣前200高频题目</a><br><a href="https://ac.nowcoder.com/acm/skill/noip-pj">牛客网模块训练</a><br><a href="https://labuladong.gitbook.io/algo/">拉布拉多算法小抄</a><br><a href="https://www.toutiao.com/c/user/token/MS4wLjABAAAAUbAv6lV7flBtQQ985gWufzkO45WqoJdVL6KGJi--Mtg/">动画讲编程</a><br><a href="https://books.halfrost.com/leetcode/">LeetCode Cookbook</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试篇-MySQL</title>
    <link href="/2020/11/18/interview/%E9%9D%A2%E8%AF%95%E7%AF%87-MySQL/"/>
    <url>/2020/11/18/interview/%E9%9D%A2%E8%AF%95%E7%AF%87-MySQL/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="https://mp.weixin.qq.com/s/PvWAYwfeflWB3UxotxnduQ">原文链接</a></p><h1 id="1-MySQL索引使用有哪些注意事项呢？"><a href="#1-MySQL索引使用有哪些注意事项呢？" class="headerlink" title="1. MySQL索引使用有哪些注意事项呢？"></a>1. MySQL索引使用有哪些注意事项呢？</h1><blockquote><p>可以从三个维度回答这个问题：索引哪些情况会失效，索引不适合哪些场景，索引规则</p></blockquote><h2 id="索引哪些情况会失效"><a href="#索引哪些情况会失效" class="headerlink" title="索引哪些情况会失效"></a>索引哪些情况会失效</h2><ul><li><p>查询条件包含or，可能导致索引失效</p></li><li><p>如何字段类型是字符串，where时一定用引号括起来，否则索引失效</p></li><li><p>like通配符可能导致索引失效。</p></li><li><p>联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。</p></li><li><p>在索引列上使用mysql的内置函数，索引失效。</p></li><li><p>对索引列运算（如，+、-、*、/），索引失效。</p></li><li><p>索引字段上使用（！= 或者 &lt; &gt;，not in）时，可能会导致索引失效。</p></li><li><p>索引字段上使用is null， is not null，可能导致索引失效。</p></li><li><p>左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。</p></li><li><p>mysql估计使用全表扫描要比使用索引快,则不使用索引。</p></li></ul><h2 id="索引不适合哪些场景"><a href="#索引不适合哪些场景" class="headerlink" title="索引不适合哪些场景"></a>索引不适合哪些场景</h2><ul><li><p>数据量少的不适合加索引</p></li><li><p>更新比较频繁的也不适合加索引</p></li><li><p>区分度低的字段不适合加索引（如性别）</p></li></ul><h2 id="索引的一些潜规则"><a href="#索引的一些潜规则" class="headerlink" title="索引的一些潜规则"></a>索引的一些潜规则</h2><ul><li><p>覆盖索引</p></li><li><p>回表</p></li><li><p>索引数据结构（B+树）</p></li><li><p>最左前缀原则</p></li><li><p>索引下推</p></li></ul><h1 id="Explain-工具"><a href="#Explain-工具" class="headerlink" title="Explain 工具"></a>Explain 工具</h1><table>    <tr>        <td>id</td>        <td>select_type</td>        <td>table</td>        <td>partitions</td>        <td>type</td>        <td>possible_keys</td>        <td>key</td>        <td>key_len</td>        <td>ref</td>        <td>rows</td>        <td>filtered</td>        <td>extra</td>    </tr>        <tr>            <td>SELECT的查询序列号</td>            <td>查询类型</td>            <td>查询的表</td>            <td>分区</td>            <td>连接类型</td>            <td>查询时可能使用到的索引</td>            <td>实际使用索引长度</td>            <td>索引字段长度</td>            <td>列与索引的比较</td>            <td>查询出的行数</td>            <td>按照条件过滤的百分比</td>            <td>执行情况说明</td>        </tr></table><ul><li><p>id</p><blockquote><p>SELECT 序列号<br>SQL从大到小的执行,id相同时，执行顺序由上至下<br>如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行<br>id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行  </p></blockquote></li><li><p>select_type</p><blockquote><p>(1) SIMPLE(简单SELECT，不使用UNION或子查询等)<br>(2) PRIMARY(子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)<br>(3) UNION(UNION中的第二个或后面的SELECT语句)<br>(4) DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)<br>(5) UNION RESULT(UNION的结果，union语句中第二个select开始后面所有select)<br>(6) SUBQUERY(子查询中的第一个SELECT，结果不依赖于外部查询)<br>(7) DEPENDENT SUBQUERY(子查询中的第一个SELECT，依赖于外部查询)<br>(8) DERIVED(派生表的SELECT, FROM子句的子查询)<br>(9) UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)  </p></blockquote></li><li><p>table</p><blockquote><p>表名</p></blockquote></li><li><p>type</p><blockquote><p>ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行<br>index: Full Index Scan，index与ALL区别为index类型只遍历索引树<br>range:只检索给定范围的行，使用一个索引来选择行<br>ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值<br>eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件<br>const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system<br>NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。  </p></blockquote></li></ul><ul><li><p>possible_keys</p><blockquote><p>指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用（该查询可以利用的索引，如果没有任何索引显示 null）<br>该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。<br>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询  </p></blockquote></li><li><p>key_len</p><blockquote><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）<br>不损失精确性的情况下，长度越短越好   </p></blockquote></li><li><p>key</p><blockquote><p>key列显示MySQL实际决定使用的键（索引），必然包含在possible_keys中<br>如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。</p></blockquote></li><li><p>ref</p><blockquote><p>列与索引的比较，表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p></blockquote></li><li><p>rows</p><blockquote><p>估算出结果集行数，表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</p></blockquote></li><li><p>filtered</p><blockquote></blockquote></li><li><p>extra</p><blockquote><p>该列包含MySQL解决查询的详细信息,有以下几种情况：</p></blockquote><blockquote><p>Using where:不用读取表中所有信息，仅通过索引就可以获取所需数据，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤</p></blockquote><blockquote><p>Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询，常见 group by ; order by</p></blockquote><blockquote><p>Using filesort：当Query中包含 order by 操作，而且无法利用索引完成的排序操作称为“文件排序”</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">name</span>;<br></code></pre></td></tr></table></figure><blockquote><p>Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。</p></blockquote><blockquote><p>Impossible where：这个值强调了where语句会导致没有符合条件的行（通过收集统计信息不可能存在结果）。</p></blockquote><blockquote><p>Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行</p></blockquote><blockquote><p>No tables used：Query语句中使用from dual 或不含任何from子句</p></blockquote></li></ul><h1 id="2-MySQL遇到过死锁问题吗，你是如何解决的？"><a href="#2-MySQL遇到过死锁问题吗，你是如何解决的？" class="headerlink" title="2. MySQL遇到过死锁问题吗，你是如何解决的？"></a>2. MySQL遇到过死锁问题吗，你是如何解决的？</h1><p>我排查死锁的一般步骤是酱紫的：</p><ul><li><p>查看死锁日志   <code>show engine innodb status</code>;</p></li><li><p>找出死锁Sql</p></li><li><p>分析sql加锁情况</p></li><li><p>模拟死锁案发</p></li><li><p>分析死锁日志</p></li><li><p>分析死锁结果</p></li></ul><h1 id="3-你是怎么优化SQL的？"><a href="#3-你是怎么优化SQL的？" class="headerlink" title="3.你是怎么优化SQL的？"></a>3.你是怎么优化SQL的？</h1><p>可以从这几个维度回答这个问题：</p><ul><li><p>加索引</p></li><li><p>避免返回不必要的数据</p></li><li><p>适当分批量进行</p></li><li><p>优化sql结构</p></li><li><p>分库分表</p></li><li><p>读写分离</p></li></ul><h1 id="4-说说分库与分表的设计"><a href="#4-说说分库与分表的设计" class="headerlink" title="4. 说说分库与分表的设计"></a>4. 说说分库与分表的设计</h1><p>分库分表方案，分库分表中间件，分库分表可能遇到的问题</p><h2 id="分库分表方案"><a href="#分库分表方案" class="headerlink" title="分库分表方案:"></a>分库分表方案:</h2><ul><li><p>水平分库：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。</p></li><li><p>水平分表：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。</p></li><li><p>垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。</p></li><li><p>垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。</p></li></ul><h2 id="常用的分库分表中间件："><a href="#常用的分库分表中间件：" class="headerlink" title="常用的分库分表中间件："></a>常用的分库分表中间件：</h2><ul><li><p>sharding-jdbc（当当）</p></li><li><p>Mycat</p></li><li><p>TDDL（淘宝）</p></li><li><p>Oceanus(58同城数据库中间件)</p></li><li><p>vitess（谷歌开发的数据库中间件）</p></li><li><p>Atlas(Qihoo 360)</p></li></ul><h2 id="分库分表可能遇到的问题"><a href="#分库分表可能遇到的问题" class="headerlink" title="分库分表可能遇到的问题"></a>分库分表可能遇到的问题</h2><p>事务问题：需要用分布式事务啦</p><p>跨节点Join的问题：解决这一问题可以分两次查询实现</p><p>跨节点的count,order by,group by以及聚合函数问题：分别在各个节点上得到结果后在应用程序端进行合并。</p><p>数据迁移，容量规划，扩容等问题</p><p>ID问题：数据库被切分后，不能再依赖数据库自身的主键生成机制啦，最简单可以考虑UUID</p><p>跨分片的排序分页问题（后台加大pagesize处理？）</p><h1 id="5-InnoDB与MyISAM的区别"><a href="#5-InnoDB与MyISAM的区别" class="headerlink" title="5. InnoDB与MyISAM的区别"></a>5. InnoDB与MyISAM的区别</h1><p>InnoDB支持事务，MyISAM不支持事务</p><p>InnoDB支持外键，MyISAM不支持外键</p><p>InnoDB 支持 MVCC(多版本并发控制)，MyISAM 不支持</p><p>select count(*) from table时，MyISAM更快，因为它有一个变量保存了整个表的总行数，可以直接读取，InnoDB就需要全表扫描。</p><p>Innodb不支持全文索引，而MyISAM支持全文索引（5.7以后的InnoDB也支持全文索引）</p><p>InnoDB支持表、行级锁，而MyISAM支持表级锁。</p><p>InnoDB表必须有主键，而MyISAM可以没有主键</p><p>Innodb表需要更多的内存和存储，而MyISAM可被压缩，存储空间较小，。</p><p>Innodb按主键大小有序插入，MyISAM记录插入顺序是，按记录插入顺序保存。</p><p>InnoDB 存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全，与 MyISAM 比 InnoDB 写的效率差一些，并且会占用更多的磁盘空间以保留数据和索引</p><h1 id="6-数据库索引的原理，为什么要用B-树，为什么不用二叉树？"><a href="#6-数据库索引的原理，为什么要用B-树，为什么不用二叉树？" class="headerlink" title="6. 数据库索引的原理，为什么要用B+树，为什么不用二叉树？"></a>6. 数据库索引的原理，为什么要用B+树，为什么不用二叉树？</h1><p>可以从几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数，为什么不是二叉树，为什么不是平衡二叉树，为什么不是B树，而偏偏是B+树呢？</p><p>为什么不是一般二叉树？</p><p>如果二叉树特殊化为一个链表，相当于全表扫描。平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。</p><p>为什么不是平衡二叉树呢？</p><p>我们知道，在内存比在磁盘的数据，查询效率快得多。如果树这种数据结构作为索引，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的，如果是B树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快啦。</p><p>那为什么不是B树而是B+树呢？</p><p>1）B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。</p><p>2）B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。</p><h1 id="7-聚集索引与非聚集索引的区别"><a href="#7-聚集索引与非聚集索引的区别" class="headerlink" title="7. 聚集索引与非聚集索引的区别"></a>7. 聚集索引与非聚集索引的区别</h1><p>一个表中只能拥有一个聚集索引，而非聚集索引一个表可以存在多个。</p><p>聚集索引，索引中键值的逻辑顺序决定了表中相应行的物理顺序；非聚集索引，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。</p><p>索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。</p><p>聚集索引：物理存储按照索引排序；非聚集索引：物理存储不按照索引排序；</p><p>何时使用聚集索引或非聚集索引？</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jzsyhfzjsy.png" alt="avatar"></p><h1 id="8-limit-1000000加载很慢的话，你是怎么解决的呢？"><a href="#8-limit-1000000加载很慢的话，你是怎么解决的呢？" class="headerlink" title="8. limit 1000000加载很慢的话，你是怎么解决的呢？"></a>8. limit 1000000加载很慢的话，你是怎么解决的呢？</h1><p>方案一：如果id是连续的，可以这样，返回上次查询的最大记录(偏移量)，再往下limit</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> &gt; <span class="hljs-number">1000000</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>方案二：在业务允许的情况下限制页数：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">建议跟业务讨论，有没有必要查这么后的分页啦。因为绝大多数用户都不会往后翻太多页。<br></code></pre></td></tr></table></figure><p>方案三：order by + 索引（id为索引）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">id</span>  <span class="hljs-keyword">limit</span> <span class="hljs-number">1000000</span>,<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>方案四：利用延迟关联或者子查询优化超多分页场景。（先快速定位需要获取的id段，然后再关联）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> a.* <span class="hljs-keyword">FROM</span> employee a,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> 条件 <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1000000</span>,<span class="hljs-number">10</span>) b <span class="hljs-keyword">where</span> a.id=b.id<br></code></pre></td></tr></table></figure><h1 id="9-如何选择合适的分布式主键方案呢？"><a href="#9-如何选择合适的分布式主键方案呢？" class="headerlink" title="9. 如何选择合适的分布式主键方案呢？"></a>9. 如何选择合适的分布式主键方案呢？</h1><h2 id="数据库自增长序列或字段。"><a href="#数据库自增长序列或字段。" class="headerlink" title="数据库自增长序列或字段。"></a>数据库自增长序列或字段。</h2><ul><li><p>UUID。</p></li><li><p>Redis生成ID</p></li><li><p>Twitter的snowflake算法</p></li><li><p>利用zookeeper生成唯一ID</p></li><li><p>MongoDB的ObjectId</p></li></ul><h1 id="10-事务的隔离级别有哪些？MySQL的默认隔离级别是什么？"><a href="#10-事务的隔离级别有哪些？MySQL的默认隔离级别是什么？" class="headerlink" title="10. 事务的隔离级别有哪些？MySQL的默认隔离级别是什么？"></a>10. 事务的隔离级别有哪些？MySQL的默认隔离级别是什么？</h1><ul><li><p>读未提交（Read Uncommitted）</p></li><li><p>读已提交（Read Committed）</p></li><li><p>可重复读（Repeatable Read）</p></li><li><p>串行化（Serializable）</p></li></ul><p>Mysql默认的事务隔离级别是可重复读(Repeatable Read)</p><p>可以看我这篇文章哈：一文彻底读懂MySQL事务的四大隔离级别</p><h1 id="11-什么是幻读，脏读，不可重复读呢？"><a href="#11-什么是幻读，脏读，不可重复读呢？" class="headerlink" title="11. 什么是幻读，脏读，不可重复读呢？"></a>11. 什么是幻读，脏读，不可重复读呢？</h1><p>事务A、B交替执行，事务A被事务B干扰到了，因为事务A读取到事务B未提交的数据,这就是脏读</p><p>在一个事务范围内，两个相同的查询，读取同一条记录，却返回了不同的数据，这就是不可重复读。</p><p>事务A查询一个范围的结果集，另一个并发事务B往这个范围中插入/删除了数据，并静悄悄地提交，然后事务A再次查询相同的范围，两次读取得到的结果集不一样了，这就是幻读。</p><p>可以看我这篇文章哈：一文彻底读懂MySQL事务的四大隔离级别</p><h1 id="12-在高并发情况下，如何做到安全的修改同一行数据？"><a href="#12-在高并发情况下，如何做到安全的修改同一行数据？" class="headerlink" title="12. 在高并发情况下，如何做到安全的修改同一行数据？"></a>12. 在高并发情况下，如何做到安全的修改同一行数据？</h1><p>要安全的修改同一行数据，就要保证一个线程在修改时其它线程无法更新这行记录。一般有悲观锁和乐观锁两种方案~</p><h3 id="使用悲观锁"><a href="#使用悲观锁" class="headerlink" title="使用悲观锁"></a>使用悲观锁</h3><p>悲观锁思想就是，当前线程要进来修改数据时，别的线程都得拒之门外~</p><p>比如，可以使用<code>select…for update ~</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">User</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">&#x27;jay&#x27;</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span><br></code></pre></td></tr></table></figure><p>以上这条sql语句会锁定了User表中所有符合检索条件（name=‘jay’）的记录。本次事务提交之前，别的线程都无法修改这些记录。</p><h3 id="使用乐观锁"><a href="#使用乐观锁" class="headerlink" title="使用乐观锁"></a>使用乐观锁</h3><p>乐观锁思想就是，有线程过来，先放过去修改，如果看到别的线程没修改过，就可以修改成功，如果别的线程修改过，就修改失败或者重试。实现方式：乐观锁一般会使用版本号机制或CAS算法实现。</p><h1 id="13-数据库的乐观锁和悲观锁。"><a href="#13-数据库的乐观锁和悲观锁。" class="headerlink" title="13. 数据库的乐观锁和悲观锁。"></a>13. 数据库的乐观锁和悲观锁。</h1><p>悲观锁：<br>悲观锁她专一且缺乏安全感了，她的心只属于当前事务，每时每刻都担心着它心爱的数据可能被别的事务修改，所以一个事务拥有（获得）悲观锁后，其他任何事务都不能对数据进行修改啦，只能等待锁被释放才可以执行。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/bgs.png" alt="avatar"></p><p>乐观锁：<br>乐观锁的“乐观情绪”体现在，它认为数据的变动不会太频繁。因此，它允许多个事务同时对数据进行变动。实现方式：乐观锁一般会使用版本号机制或CAS算法实现。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/lgs.png" alt="avatar"></p><h1 id="14-SQL优化的一般步骤是什么，怎么看执行计划（explain），如何理解其中各个字段的含义。"><a href="#14-SQL优化的一般步骤是什么，怎么看执行计划（explain），如何理解其中各个字段的含义。" class="headerlink" title="14. SQL优化的一般步骤是什么，怎么看执行计划（explain），如何理解其中各个字段的含义。"></a>14. SQL优化的一般步骤是什么，怎么看执行计划（explain），如何理解其中各个字段的含义。</h1><p>show status 命令了解各种 sql 的执行频率</p><p>通过慢查询日志定位那些执行效率较低的 sql 语句</p><p>explain 分析低效 sql 的执行计划（这点非常重要，日常开发中用它分析Sql，会大大降低Sql导致的线上事故）</p><h1 id="15-select-for-update有什么含义，会锁表还是锁行还是其他。"><a href="#15-select-for-update有什么含义，会锁表还是锁行还是其他。" class="headerlink" title="15. select for update有什么含义，会锁表还是锁行还是其他。"></a>15. select for update有什么含义，会锁表还是锁行还是其他。</h1><p>select for update 含义</p><p>select查询语句是不会加锁的，但是select for update除了有查询的作用外，还会加锁呢，而且它是悲观锁哦。至于加了是行锁还是表锁，这就要看是不是用了索引/主键啦。</p><p>没用索引/主键的话就是表锁，否则就是是行锁。</p><p>select for update 加锁验证</p><p>表结构：</p><p>//id 为主键，name为唯一索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span>  <span class="hljs-string">`account`</span>(<br>  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,<br>  <span class="hljs-string">`name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-string">`balance`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,<br>  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>),<br>  <span class="hljs-keyword">KEY</span> <span class="hljs-string">`idx_name`</span>(<span class="hljs-string">`name`</span>) <span class="hljs-keyword">USING</span> BTREE<br>) <span class="hljs-keyword">ENGINE</span> = <span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">1570068</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8<br></code></pre></td></tr></table></figure><p>id为主键，select for update 1270070这条记录时，再开一个事务对该记录更新，发现更新阻塞啦，其实是加锁了。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/mysqljiasuo.png" alt="avatar"></p><p>我们再开一个事务对另外一条记录1270071更新，发现更新成功，因此，如果查询条件用了索引/主键，会加行锁~</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/mysql-row-lock.png" alt="avatar"></p><p>我们继续一路向北吧，换普通字段balance吧，发现又阻塞了。因此，没用索引/主键的话，select for update加的就是表锁</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/mysql-table-lock.png" alt="avatar"></p><h1 id="16-MySQL事务得四大特性以及实现原理"><a href="#16-MySQL事务得四大特性以及实现原理" class="headerlink" title="16. MySQL事务得四大特性以及实现原理"></a>16. MySQL事务得四大特性以及实现原理</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li><p>原子性：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</p></li><li><p>一致性：指在事务开始之前和事务结束以后，数据不会被破坏，假如A账户给B账户转10块钱，不管成功与否，A和B的总金额是不变的。</p></li><li><p>隔离性：多个事务并发访问时，事务之间是相互隔离的，即一个事务不影响其它事务运行效果。简言之，就是事务之间是进水不犯河水的。</p></li><li><p>持久性：表示事务完成以后，该事务对数据库所作的操作更改，将持久地保存在数据库之中。</p></li></ul><h2 id="事务ACID特性的实现思想"><a href="#事务ACID特性的实现思想" class="headerlink" title="事务ACID特性的实现思想"></a>事务ACID特性的实现思想</h2><ul><li><p>原子性：是使用 undo log来实现的，如果事务执行过程中出错或者用户执行了rollback，系统通过undo log日志返回事务开始的状态。</p></li><li><p>持久性：使用 redo log来实现，只要redo log日志持久化了，当系统崩溃，即可通过redo log把数据恢复。</p></li><li><p>隔离性：通过锁以及MVCC,使事务相互隔离开。</p></li><li><p>一致性：通过回滚、恢复，以及并发情况下的隔离性，从而实现一致性。</p></li></ul><h1 id="17-如果某个表有近千万数据，CRUD比较慢，如何优化。"><a href="#17-如果某个表有近千万数据，CRUD比较慢，如何优化。" class="headerlink" title="17. 如果某个表有近千万数据，CRUD比较慢，如何优化。"></a>17. 如果某个表有近千万数据，CRUD比较慢，如何优化。</h1><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>某个表有近千万数据，可以考虑优化表结构，分表（水平分表，垂直分表），当然，你这样回答，需要准备好面试官问你的分库分表相关问题呀，如</p><p>分表方案（水平分表，垂直分表，切分规则hash等）</p><p>分库分表中间件（Mycat，sharding-jdbc等）</p><p>分库分表一些问题（事务问题？跨节点Join的问题）</p><p>解决方案（分布式事务等）</p><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><p>除了分库分表，优化表结构，当然还有所以索引优化等方案~</p><h1 id="18-如何写sql能够有效的使用到复合索引。"><a href="#18-如何写sql能够有效的使用到复合索引。" class="headerlink" title="18. 如何写sql能够有效的使用到复合索引。"></a>18. 如何写sql能够有效的使用到复合索引。</h1><p>复合索引，也叫组合索引，用户可以在多个列上建立索引,这种索引叫做复合索引。</p><p>当我们创建一个组合索引的时候，如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> k1 = A <span class="hljs-keyword">AND</span> k2 = B <span class="hljs-keyword">AND</span> k3 = D<br></code></pre></td></tr></table></figure><p>有关于复合索引，我们需要关注查询Sql条件的顺序，确保最左匹配原则有效，同时可以删除不必要的冗余索引。</p><h1 id="19-mysql中in-和exists的区别。"><a href="#19-mysql中in-和exists的区别。" class="headerlink" title="19. mysql中in 和exists的区别。"></a>19. mysql中in 和exists的区别。</h1><p>这个，跟一下demo来看更刺激吧，啊哈哈</p><p>假设表A表示某企业的员工表，表B表示部门表，查询所有部门的所有员工，很容易有以下SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> deptId <span class="hljs-keyword">in</span>(<br>  <span class="hljs-keyword">select</span> deptId <span class="hljs-keyword">from</span> B<br>  );<br></code></pre></td></tr></table></figure><p>这样写等价于：</p><p>先查询部门表B</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> deptId <span class="hljs-keyword">from</span> B<br></code></pre></td></tr></table></figure><p>再由部门deptId，查询A的员工</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs `sql">select * from A where A.deptId &#x3D; B.deptId<br>&#96;&#96;&#96;&#96;&#96;<br><br>可以抽象成这样的一个循环：<br><br>&#96;&#96;&#96;java<br>List&lt;&gt; resultSet;<br><br>for( int i &#x3D; 0;i&lt;B.length;i++)&#123;<br>  for(int j&#x3D;0;j&lt;A.length;j++)&#123;<br>    if(A[i].id&#x3D;&#x3D;B[j].id)&#123;<br>      resultSet.add(A[i]);<br>      break;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然，除了使用in，我们也可以用exists实现一样的查询功能，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span> (<br>    <span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> B <span class="hljs-keyword">where</span> A.deptId = B.deptId<br>);<br></code></pre></td></tr></table></figure><p>因为exists查询的理解就是，先执行主查询，获得数据后，再放到子查询中做条件验证，根据验证结果（true或者false），来决定主查询的数据结果是否得意保留。</p><p>那么，这样写就等价于：</p><p>select * from A,先从A表做循环</p><p>select * from B where A.deptId = B.deptId,再从B表做循环.</p><p>同理，可以抽象成这样一个循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;&gt; resultSet;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;A.length;i++)&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;B.length;j++)&#123;<br>    <span class="hljs-keyword">if</span>(A[i].deptId==B[j].deptId)&#123;<br>        resultSet.add(A[i]);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>数据库最费劲的就是跟程序链接释放。假设链接了两次，每次做上百万次的数据集查询，查完就走，这样就只做了两次；相反建立了上百万次链接，申请链接释放反复重复，这样系统就受不了了。即mysql优化原则，就是小表驱动大表，小的数据集驱动大的数据集，从而让性能更优。</p><p>因此，我们要选择最外层循环小的，也就是，如果B的数据量小于A，适合使用in，如果B的数据量大于A，即适合选择exists，这就是in和exists的区别。</p><h1 id="20-数据库自增主键可能遇到什么问题。"><a href="#20-数据库自增主键可能遇到什么问题。" class="headerlink" title="20. 数据库自增主键可能遇到什么问题。"></a>20. 数据库自增主键可能遇到什么问题。</h1><p>使用自增主键对数据库做分库分表，可能出现诸如主键重复等的问题。解决方案的话，简单点的话可以考虑使用UUID哈</p><p>自增主键会产生表锁，从而引发问题</p><p>自增主键可能用完问题。</p><h1 id="21-MVCC熟悉吗，它的底层原理？"><a href="#21-MVCC熟悉吗，它的底层原理？" class="headerlink" title="21. MVCC熟悉吗，它的底层原理？"></a>21. MVCC熟悉吗，它的底层原理？</h1><ul><li><p>MVCC,多版本并发控制,它是通过读取历史版本的数据，来降低并发事务冲突，从而提高并发性能的一种机制。</p></li><li><p>MVCC需要关注这几个知识点：</p></li><li><p>事务版本号</p></li><li><p>表的隐藏列</p></li><li><p>undo log</p></li><li><p>read view</p></li></ul><h1 id="22-数据库中间件了解过吗，sharding-jdbc，mycat？"><a href="#22-数据库中间件了解过吗，sharding-jdbc，mycat？" class="headerlink" title="22. 数据库中间件了解过吗，sharding jdbc，mycat？"></a>22. 数据库中间件了解过吗，sharding jdbc，mycat？</h1><ul><li><p>sharding-jdbc目前是基于jdbc驱动，无需额外的proxy，因此也无需关注proxy本身的高可用。</p></li><li><p>Mycat 是基于 Proxy，它复写了 MySQL 协议，将 Mycat Server 伪装成一个 MySQL 数据库，而 Sharding-JDBC 是基于 JDBC 接口的扩展，是以 jar 包的形式提供轻量级服务的。</p></li></ul><h1 id="23-MYSQL的主从延迟，你怎么解决？"><a href="#23-MYSQL的主从延迟，你怎么解决？" class="headerlink" title="23. MYSQL的主从延迟，你怎么解决？"></a>23. MYSQL的主从延迟，你怎么解决？</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/mysql-master-salve.png" alt="avatar"></p><p>主从复制分了五个步骤进行：</p><ul><li><p>步骤一：主库的更新事件(update、insert、delete)被写到binlog</p></li><li><p>步骤二：从库发起连接，连接到主库。</p></li><li><p>步骤三：此时主库创建一个binlog dump thread，把binlog的内容发送到从库。</p></li><li><p>步骤四：从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log</p></li><li><p>步骤五：还会创建一个SQL线程，从relay log里面读取内容，从ExecMasterLog_Pos位置开始执行读取到的更新事件，将更新内容写入到slave的db</p></li></ul><h3 id="主从同步延迟的原因"><a href="#主从同步延迟的原因" class="headerlink" title="主从同步延迟的原因"></a>主从同步延迟的原因</h3><p>一个服务器开放Ｎ个链接给客户端来连接的，这样有会有大并发的更新操作, 但是从服务器的里面读取binlog的线程仅有一个，当某个SQL在从服务器上执行的时间稍长 或者由于某个SQL要进行锁表就会导致，主服务器的SQL大量积压，未被同步到从服务器里。这就导致了主从不一致， 也就是主从延迟。</p><h3 id="主从同步延迟的解决办法"><a href="#主从同步延迟的解决办法" class="headerlink" title="主从同步延迟的解决办法"></a>主从同步延迟的解决办法</h3><ul><li><p>主服务器要负责更新操作，对安全性的要求比从服务器要高，所以有些设置参数可以修改，比如syncbinlog=1，innodbflushlogattrxcommit = 1 之类的设置等。</p></li><li><p>选择更好的硬件设备作为slave。</p></li><li><p>把一台从服务器当度作为备份使用， 而不提供查询， 那边他的负载下来了， 执行relay log 里面的SQL效率自然就高了。</p></li><li><p>增加从服务器喽，这个目的还是分散读的压力，从而降低服务器负载。</p></li></ul><h1 id="24-说一下大表查询的优化方案"><a href="#24-说一下大表查询的优化方案" class="headerlink" title="24. 说一下大表查询的优化方案"></a>24. 说一下大表查询的优化方案</h1><p>优化shema、sql语句+索引；</p><p>可以考虑加缓存，memcached, redis，或者JVM本地缓存；</p><p>主从复制，读写分离；</p><p>分库分表；</p><h1 id="25-什么是数据库连接池-为什么需要数据库连接池呢"><a href="#25-什么是数据库连接池-为什么需要数据库连接池呢" class="headerlink" title="25. 什么是数据库连接池?为什么需要数据库连接池呢?"></a>25. 什么是数据库连接池?为什么需要数据库连接池呢?</h1><p>连接池基本原理：数据库连接池原理：在内部对象池中，维护一定数量的数据库连接，并对外暴露数据库连接的获取和返回方法。</p><p>应用程序和数据库建立连接的过程：</p><p>通过TCP协议的三次握手和数据库服务器建立连接</p><p>发送数据库用户账号密码，等待数据库验证用户身份</p><p>完成身份验证后，系统可以提交SQL语句到数据库执行</p><p>把连接关闭，TCP四次挥手告别。</p><p>数据库连接池好处：</p><p>资源重用 (连接复用)</p><p>更快的系统响应速度</p><p>新的资源分配手段</p><p>统一的连接管理，避免数据库连接泄漏</p><h1 id="26-一条SQL语句在MySQL中如何执行的？"><a href="#26-一条SQL语句在MySQL中如何执行的？" class="headerlink" title="26. 一条SQL语句在MySQL中如何执行的？"></a>26. 一条SQL语句在MySQL中如何执行的？</h1><p>先看一下Mysql的逻辑架构图吧~</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/mysql-jiagou.png" alt="avatar"></p><p>查询语句：</p><p>先检查该语句是否有权限</p><p>如果没有权限，直接返回错误信息</p><p>如果有权限，在 MySQL8.0 版本以前，会先查询缓存。</p><p>如果没有缓存，分析器进行词法分析，提取 sql 语句select等的关键元素。然后判断sql 语句是否有语法错误，比如关键词是否正确等等。</p><p>优化器进行确定执行方案</p><p>进行权限校验，如果没有权限就直接返回错误信息，如果有权限就会调用数据库引擎接口，返回执行结果。</p><h1 id="27-InnoDB引擎中的索引策略，了解过吗？"><a href="#27-InnoDB引擎中的索引策略，了解过吗？" class="headerlink" title="27. InnoDB引擎中的索引策略，了解过吗？"></a>27. InnoDB引擎中的索引策略，了解过吗？</h1><p>覆盖索引</p><p>最左前缀原则</p><p>索引下推</p><p>索引下推优化是 MySQL 5.6 引入的， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p><h1 id="28-数据库存储日期格式时，如何考虑时区转换问题？"><a href="#28-数据库存储日期格式时，如何考虑时区转换问题？" class="headerlink" title="28. 数据库存储日期格式时，如何考虑时区转换问题？"></a>28. 数据库存储日期格式时，如何考虑时区转换问题？</h1><p>datetime类型适合用来记录数据的原始的创建时间，修改记录中其他字段的值，datetime字段的值不会改变，除非手动修改它。</p><p>timestamp类型适合用来记录数据的最后修改时间，只要修改了记录中其他字段的值，timestamp字段的值都会被自动更新。</p><h1 id="29-一条sql执行过长的时间，你如何优化，从哪些方面入手？"><a href="#29-一条sql执行过长的时间，你如何优化，从哪些方面入手？" class="headerlink" title="29. 一条sql执行过长的时间，你如何优化，从哪些方面入手？"></a>29. 一条sql执行过长的时间，你如何优化，从哪些方面入手？</h1><p>查看是否涉及多表和子查询，优化Sql结构，如去除冗余字段，是否可拆表等</p><p>优化索引结构，看是否可以适当添加索引</p><p>数量大的表，可以考虑进行分离/分表（如交易流水表）</p><p>数据库主从分离，读写分离</p><p>explain分析sql语句，查看执行计划，优化sql</p><p>查看mysql执行日志，分析是否有其他方面的问题</p><h1 id="30-MYSQL数据库服务器性能分析的方法命令有哪些"><a href="#30-MYSQL数据库服务器性能分析的方法命令有哪些" class="headerlink" title="30. MYSQL数据库服务器性能分析的方法命令有哪些?"></a>30. MYSQL数据库服务器性能分析的方法命令有哪些?</h1><p>Show status, 一些值得监控的变量值：</p><p>Bytesreceived和Bytessent 和服务器之间来往的流量。</p><p>Com_*服务器正在执行的命令。</p><p>Created_*在查询执行期限间创建的临时表和文件。</p><p>Handler_*存储引擎操作。</p><p>Select_*不同类型的联接执行计划。</p><p>Sort_*几种排序信息。</p><p> Show profiles 是MySql用来分析当前会话SQL语句执行的资源消耗情况</p><h1 id="31-Blob和text有什么区别？"><a href="#31-Blob和text有什么区别？" class="headerlink" title="31. Blob和text有什么区别？"></a>31. Blob和text有什么区别？</h1><p>Blob用于存储二进制数据，而Text用于存储大字符串。</p><p>Blob值被视为二进制字符串（字节字符串）,它们没有字符集，并且排序和比较基于列值中的字节的数值。</p><p>text值被视为非二进制字符串（字符字符串）。它们有一个字符集，并根据字符集的排序规则对值进行排序和比较。</p><h1 id="32-mysql里记录货币用什么字段类型比较好？"><a href="#32-mysql里记录货币用什么字段类型比较好？" class="headerlink" title="32. mysql里记录货币用什么字段类型比较好？"></a>32. mysql里记录货币用什么字段类型比较好？</h1><p>货币在数据库中MySQL常用Decimal和Numric类型表示，这两种类型被MySQL实现为同样的类型。他们被用于保存与金钱有关的数据。</p><p>salary DECIMAL(9,2)，9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。存储在salary列中的值的范围是从-9999999.99到9999999.99。</p><p>DECIMAL和NUMERIC值作为字符串存储，而不是作为二进制浮点数，以便保存那些值的小数精度。</p><h1 id="33-Mysql中有哪几种锁，列举一下？"><a href="#33-Mysql中有哪几种锁，列举一下？" class="headerlink" title="33. Mysql中有哪几种锁，列举一下？"></a>33. Mysql中有哪几种锁，列举一下？</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/mysql-lock.png" alt="avatar"></p><p>如果按锁粒度划分，有以下3种：</p><ul><li><p>表锁：开销小，加锁快；锁定力度大，发生锁冲突概率高，并发度最低;不会出现死锁。</p></li><li><p>行锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。</p></li><li><p>页锁：开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般</p></li></ul><h1 id="34-Hash索引和B-树区别是什么？你在设计索引是怎么抉择的？"><a href="#34-Hash索引和B-树区别是什么？你在设计索引是怎么抉择的？" class="headerlink" title="34. Hash索引和B+树区别是什么？你在设计索引是怎么抉择的？"></a>34. Hash索引和B+树区别是什么？你在设计索引是怎么抉择的？</h1><p>B+树可以进行范围查询，Hash索引不能。</p><p>B+树支持联合索引的最左侧原则，Hash索引不支持。</p><p>B+树支持order by排序，Hash索引不支持。</p><p>Hash索引在等值查询上比B+树效率更高。</p><p>B+树使用like 进行模糊查询的时候，like后面（比如%开头）的话可以起到优化的作用，Hash索引根本无法进行模糊查询。</p><h1 id="35-mysql-的内连接、左连接、右连接有什么区别？"><a href="#35-mysql-的内连接、左连接、右连接有什么区别？" class="headerlink" title="35. mysql 的内连接、左连接、右连接有什么区别？"></a>35. mysql 的内连接、左连接、右连接有什么区别？</h1><p>Inner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集</p><p>left join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。</p><p>right join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。</p><h1 id="36-说说MySQL-的基础架构图"><a href="#36-说说MySQL-的基础架构图" class="headerlink" title="36. 说说MySQL 的基础架构图"></a>36. 说说MySQL 的基础架构图</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/mysql-jiagou.png" alt="avatar"></p><p>Mysql逻辑架构图主要分三层：</p><ul><li><p>第一层负责连接处理，授权认证，安全等等</p></li><li><p>第二层负责编译并优化SQL</p></li><li><p>第三层是存储引擎。</p></li></ul><h1 id="37-什么是内连接、外连接、交叉连接、笛卡尔积呢？"><a href="#37-什么是内连接、外连接、交叉连接、笛卡尔积呢？" class="headerlink" title="37. 什么是内连接、外连接、交叉连接、笛卡尔积呢？"></a>37. 什么是内连接、外连接、交叉连接、笛卡尔积呢？</h1><ul><li><p>内连接（inner join）：取得两张表中满足存在连接匹配关系的记录。</p></li><li><p>外连接（outer join）：取得两张表中满足存在连接匹配关系的记录，以及某张表（或两张表）中不满足匹配关系的记录。</p></li><li><p>交叉连接（cross join）：显示两张表所有记录一一对应，没有匹配关系进行筛选，也被称为：笛卡尔积。</p></li></ul><h1 id="38-说一下数据库的三大范式"><a href="#38-说一下数据库的三大范式" class="headerlink" title="38. 说一下数据库的三大范式"></a>38. 说一下数据库的三大范式</h1><ul><li><p>第一范式：数据表中的每一列（每个字段）都不可以再拆分。</p></li><li><p>第二范式：在第一范式的基础上，分主键列完全依赖于主键，而不能是依赖于主键的一部分。</p></li><li><p>第三范式：在满足第二范式的基础上，表中的非主键只依赖于主键，而不依赖于其他非主键。</p></li></ul><h1 id="39-mysql有关权限的表有哪几个呢？"><a href="#39-mysql有关权限的表有哪几个呢？" class="headerlink" title="39. mysql有关权限的表有哪几个呢？"></a>39. mysql有关权限的表有哪几个呢？</h1><p>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysqlinstalldb脚本初始化。这些权限表分别user，db，tablepriv，columnspriv和host。</p><p>user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</p><p>db权限表：记录各个帐号在各个数据库上的操作权限。</p><p>table_priv权限表：记录数据表级的操作权限。</p><p>columns_priv权限表：记录数据列级的操作权限。</p><p>host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</p><h1 id="40-Mysql的binlog有几种录入格式？分别有什么区别？"><a href="#40-Mysql的binlog有几种录入格式？分别有什么区别？" class="headerlink" title="40. Mysql的binlog有几种录入格式？分别有什么区别？"></a>40. Mysql的binlog有几种录入格式？分别有什么区别？</h1><p>有三种格式哈，statement，row和mixed。</p><ul><li><p>statement，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</p></li><li><p>row，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。</p></li><li><p>mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。</p></li></ul><h1 id="41-InnoDB引擎的4大特性，了解过吗"><a href="#41-InnoDB引擎的4大特性，了解过吗" class="headerlink" title="41. InnoDB引擎的4大特性，了解过吗"></a>41. InnoDB引擎的4大特性，了解过吗</h1><p>插入缓冲（insert buffer)</p><p>二次写(double write)</p><p>自适应哈希索引(ahi)</p><p>预读(read ahead)</p><h1 id="42-索引有哪些优缺点？"><a href="#42-索引有哪些优缺点？" class="headerlink" title="42. 索引有哪些优缺点？"></a>42. 索引有哪些优缺点？</h1><p>优点：</p><p>唯一索引可以保证数据库表中每一行的数据的唯一性</p><p>索引可以加快数据查询速度，减少查询时间</p><p>缺点：</p><p>创建索引和维护索引要耗费时间</p><p>索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间</p><p>以表中的数据进行增、删、改的时候，索引也要动态的维护。</p><h1 id="43-索引有哪几种类型？"><a href="#43-索引有哪几种类型？" class="headerlink" title="43. 索引有哪几种类型？"></a>43. 索引有哪几种类型？</h1><p>主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</p><p>唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</p><p>普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。</p><p>全文索引：是目前搜索引擎使用的一种关键技术，对文本的内容进行分词、搜索。</p><p>覆盖索引：查询列要被所建的索引覆盖，不必读取数据行</p><p>组合索引：多列值组成一个索引，用于组合搜索，效率大于索引合并</p><h1 id="44-创建索引有什么原则呢？"><a href="#44-创建索引有什么原则呢？" class="headerlink" title="44. 创建索引有什么原则呢？"></a>44. 创建索引有什么原则呢？</h1><p>最左前缀匹配原则</p><p>频繁作为查询条件的字段才去创建索引</p><p>频繁更新的字段不适合创建索引</p><p>索引列不能参与计算，不能有函数操作</p><p>优先考虑扩展索引，而不是新建索引，避免不必要的索引</p><p>在order by或者group by子句中，创建索引需要注意顺序</p><p>区分度低的数据列不适合做索引列(如性别）</p><p>定义有外键的数据列一定要建立索引。</p><p>对于定义为text、image数据类型的列不要建立索引。</p><p>删除不再使用或者很少使用的索引</p><h1 id="45-创建索引的三种方式"><a href="#45-创建索引的三种方式" class="headerlink" title="45. 创建索引的三种方式"></a>45. 创建索引的三种方式</h1><p>在执行CREATE TABLE时创建索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`employee`</span>(<br>    <span class="hljs-string">`id`</span><span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>    <span class="hljs-string">`name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,<br>    <span class="hljs-string">`age`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,<br>    <span class="hljs-string">`date`</span> datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,<br>    <span class="hljs-string">`sex`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>, <br>    PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>),<br>    <span class="hljs-keyword">KEY</span> <span class="hljs-string">`idx_name`</span>(<span class="hljs-string">`name`</span>) <span class="hljs-keyword">USING</span> BTREE<br>)<span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8;<br></code></pre></td></tr></table></figure><p>使用ALTER TABLE命令添加索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">INDEX</span> index_name (<span class="hljs-keyword">column</span>);<br></code></pre></td></tr></table></figure><p>使用CREATE INDEX命令创建</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> index_name <span class="hljs-keyword">ON</span> table_name <br>(<br><span class="hljs-keyword">column</span><br>);<br></code></pre></td></tr></table></figure><h1 id="46-百万级别或以上的数据，你是如何删除的？"><a href="#46-百万级别或以上的数据，你是如何删除的？" class="headerlink" title="46. 百万级别或以上的数据，你是如何删除的？"></a>46. 百万级别或以上的数据，你是如何删除的？</h1><p>我们想要删除百万数据的时候可以先删除索引</p><p>然后批量删除其中无用数据</p><p>删除完成后重新创建索引。</p><h1 id="47-什么是最左前缀原则？什么是最左匹配原则？"><a href="#47-什么是最左前缀原则？什么是最左匹配原则？" class="headerlink" title="47. 什么是最左前缀原则？什么是最左匹配原则？"></a>47. 什么是最左前缀原则？什么是最左匹配原则？</h1><p>最左前缀原则，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</p><p>当我们创建一个组合索引的时候，如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则。。</p><h1 id="48-B树和B-树的区别，数据库为什么使用B-树而不是B树？"><a href="#48-B树和B-树的区别，数据库为什么使用B-树而不是B树？" class="headerlink" title="48. B树和B+树的区别，数据库为什么使用B+树而不是B树？"></a>48. B树和B+树的区别，数据库为什么使用B+树而不是B树？</h1><p>在B树中，键和值即存放在内部节点又存放在叶子节点；在B+树中，内部节点只存键，叶子节点则同时存放键和值。</p><ul><li><p>B+树的叶子节点有一条链相连，而B树的叶子节点各自独立的。</p></li><li><p>B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。.</p></li><li><p>B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快.</p></li></ul><h1 id="49-覆盖索引、回表等这些，了解过吗？"><a href="#49-覆盖索引、回表等这些，了解过吗？" class="headerlink" title="49. 覆盖索引、回表等这些，了解过吗？"></a>49. 覆盖索引、回表等这些，了解过吗？</h1><ul><li><p>覆盖索引：查询列要被所建的索引覆盖，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。</p></li><li><p>回表：二级索引无法直接查询所有列的数据，所以通过二级索引查询到聚簇索引后，再查询到想要的数据，这种通过二级索引查询出来的过程，就叫做回表。</p></li></ul><h1 id="50-B-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据？"><a href="#50-B-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据？" class="headerlink" title="50. B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据？"></a>50. B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据？</h1><p>在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</p><p>当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。</p><h1 id="51-何时使用聚簇索引与非聚簇索引"><a href="#51-何时使用聚簇索引与非聚簇索引" class="headerlink" title="51. 何时使用聚簇索引与非聚簇索引"></a>51. 何时使用聚簇索引与非聚簇索引</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jzsyhfzjsy.png" alt="avatar"></p><h1 id="52-非聚簇索引一定会回表查询吗？"><a href="#52-非聚簇索引一定会回表查询吗？" class="headerlink" title="52. 非聚簇索引一定会回表查询吗？"></a>52. 非聚簇索引一定会回表查询吗？</h1><p>不一定，如果查询语句的字段全部命中了索引，那么就不必再进行回表查询（哈哈，覆盖索引就是这么回事）。</p><p>举个简单的例子，假设我们在学生表的上建立了索引，那么当进行select age from student where age &lt; 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。</p><h1 id="53-组合索引是什么？为什么需要注意组合索引中的顺序？"><a href="#53-组合索引是什么？为什么需要注意组合索引中的顺序？" class="headerlink" title="53. 组合索引是什么？为什么需要注意组合索引中的顺序？"></a>53. 组合索引是什么？为什么需要注意组合索引中的顺序？</h1><p>组合索引，用户可以在多个列上建立索引,这种索引叫做组合索引。</p><p>因为InnoDB引擎中的索引策略的最左原则，所以需要注意组合索引中的顺序。</p><h1 id="54-什么是数据库事务？"><a href="#54-什么是数据库事务？" class="headerlink" title="54. 什么是数据库事务？"></a>54. 什么是数据库事务？</h1><p>数据库事务（简称：事务），是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。</p><h1 id="55-隔离级别与锁的关系"><a href="#55-隔离级别与锁的关系" class="headerlink" title="55. 隔离级别与锁的关系"></a>55. 隔离级别与锁的关系</h1><p>回答这个问题，可以先阐述四种隔离级别，再阐述它们的实现原理。隔离级别就是依赖锁和MVCC实现的。</p><h1 id="56-按照锁的粒度分，数据库锁有哪些呢？锁机制与InnoDB锁算法"><a href="#56-按照锁的粒度分，数据库锁有哪些呢？锁机制与InnoDB锁算法" class="headerlink" title="56. 按照锁的粒度分，数据库锁有哪些呢？锁机制与InnoDB锁算法"></a>56. 按照锁的粒度分，数据库锁有哪些呢？锁机制与InnoDB锁算法</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/mysql-lock.png" alt="avatar"></p><p>按锁粒度分有：表锁，页锁，行锁</p><p>按锁机制分有：乐观锁，悲观锁</p><h1 id="57-从锁的类别角度讲，MySQL都有哪些锁呢？"><a href="#57-从锁的类别角度讲，MySQL都有哪些锁呢？" class="headerlink" title="57. 从锁的类别角度讲，MySQL都有哪些锁呢？"></a>57. 从锁的类别角度讲，MySQL都有哪些锁呢？</h1><p>从锁的类别上来讲，有共享锁和排他锁。</p><ul><li><p>共享锁: 又叫做读锁。当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</p></li><li><p>排他锁: 又叫做写锁。当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</p></li></ul><p>锁兼容性如下：</p><table>    <tr><td>兼容性</td><td>S</td><td>X</td></tr>    <tr><td>S</td><td>兼容</td><td>不兼容</td></tr>    <tr><td>X</td><td>不兼容</td><td>不兼容</td></tr></table><h1 id="58-MySQL中InnoDB引擎的行锁是怎么实现的？"><a href="#58-MySQL中InnoDB引擎的行锁是怎么实现的？" class="headerlink" title="58. MySQL中InnoDB引擎的行锁是怎么实现的？"></a>58. MySQL中InnoDB引擎的行锁是怎么实现的？</h1><p>基于索引来完成行锁的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> =<span class="hljs-number">666</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br>``````<br>for <span class="hljs-keyword">update</span> 可以根据条件来完成行锁锁定，并且 <span class="hljs-keyword">id</span> 是有索引键的列，如果 <span class="hljs-keyword">id</span> 不是索引键那么<span class="hljs-keyword">InnoDB</span>将实行表锁。<br><br><span class="hljs-comment"># 59. 什么是死锁？怎么解决？</span><br><br>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。看图形象一点，如下：<br><br>![avatar](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@<span class="hljs-keyword">master</span>/<span class="hljs-keyword">resource</span>/img/mysql-dead-lock.png)<br><br>死锁有四个必要条件：互斥条件，请求和保持条件，环路等待条件，不剥夺条件。<br><br>解决死锁思路，一般就是切断环路，尽量避免并发形成环路。<br><br>如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。<br><br>在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；<br><br>对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；<br><br>如果业务处理不好可以用分布式事务锁或者使用乐观锁<br><br>死锁与索引密不可分，解决索引问题，需要合理优化你的索引，<br><br><br><br><span class="hljs-comment"># 60. 为什么要使用视图？什么是视图？</span><br><br>为什么要使用视图？<br><br>为了提高复杂<span class="hljs-keyword">SQL</span>语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。<br><br>什么是视图？<br><br>视图是一个虚拟的表，是一个表中的数据经过某种筛选后的显示方式，视图由一个预定义的查询<span class="hljs-keyword">select</span>语句组成。<br><br><span class="hljs-comment"># 61. 视图有哪些特点？哪些使用场景？</span><br><br>视图特点：<br><br>- 视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。<br><br>- 视图是由基本表(实表)产生的表(虚表)。<br><br>- 视图的建立和删除不影响基本表。<br><br>- 对视图内容的更新(添加，删除和修改)直接影响基本表。<br><br>- 当视图来自多个基本表时，不允许添加和删除数据。<br><br>- 视图用途： 简化<span class="hljs-keyword">sql</span>查询，提高开发效率，兼容老的表结构。<br><br>视图的常见使用场景：<br><br>- 重用<span class="hljs-keyword">SQL</span>语句；<br><br>- 简化复杂的<span class="hljs-keyword">SQL</span>操作。<br><br>- 使用表的组成部分而不是整个表；<br><br>- 保护数据<br><br>- 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。<br><br><span class="hljs-comment"># 62. 视图的优点，缺点，讲一下？</span><br><br>查询简单化。视图能简化用户的操作<br><br>数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护<br><br>逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性<br><br><span class="hljs-comment"># 63. count(1)、count(*) 与 count(列名) 的区别？</span><br><br><span class="hljs-keyword">count</span>(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为<span class="hljs-literal">NULL</span><br><br><span class="hljs-keyword">count</span>(<span class="hljs-number">1</span>)包括了忽略所有列，用<span class="hljs-number">1</span>代表代码行，在统计结果的时候，不会忽略列值为<span class="hljs-literal">NULL</span><br><br><span class="hljs-keyword">count</span>(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者<span class="hljs-number">0</span>，而是表示<span class="hljs-literal">null</span>）的计数，即某个字段值为<span class="hljs-literal">NULL</span>时，不统计。<br><br><span class="hljs-comment"># 64. 什么是游标？</span><br><br>游标提供了一种对从表中检索出的数据进行操作的灵活手段，就本质而言，游标实际上是一种能从包括多条数据记录的结果集中每次提取一条记录的机制。<br><br><span class="hljs-comment"># 65. 什么是存储过程？有哪些优缺点？</span><br><br>存储过程，就是一些编译好了的<span class="hljs-keyword">SQL</span>语句，这些<span class="hljs-keyword">SQL</span>语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后给这些代码块取一个名字，在用到这个功能的时候调用即可。<br><br>优点：<br><br>- 存储过程是一个预编译的代码块，执行效率比较高<br><br>- 存储过程在服务器端运行，减少客户端的压力<br><br>- 允许模块化程序设计，只需要创建一次过程，以后在程序中就可以调用该过程任意次，类似方法的复用<br><br>- 一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率<br><br>- 可以一定程度上确保数据安全<br><br>缺点：<br><br>- 调试麻烦<br><br>- 可移植性不灵活<br><br>- 重新编译问题<br><br><span class="hljs-comment"># 66. 什么是触发器？触发器的使用场景有哪些？</span><br><br>触发器，指一段代码，当触发某个事件时，自动执行这些代码。<br><br>使用场景：<br><br>可以通过数据库中的相关表实现级联更改。<br><br>实时监控某张表中的某个字段的更改而需要做出相应的处理。<br><br>例如可以生成某些业务的编号。<br><br>注意不要滥用，否则会造成数据库及应用程序的维护困难。<br><br><span class="hljs-comment"># 67. MySQL中都有哪些触发器？</span><br><br>MySQL 数据库中有六种触发器：<br><br>- <span class="hljs-keyword">Before</span> <span class="hljs-keyword">Insert</span><br><br>- <span class="hljs-keyword">After</span> <span class="hljs-keyword">Insert</span><br><br>- <span class="hljs-keyword">Before</span> <span class="hljs-keyword">Update</span><br><br>- <span class="hljs-keyword">After</span> <span class="hljs-keyword">Update</span><br><br>- <span class="hljs-keyword">Before</span> <span class="hljs-keyword">Delete</span><br><br>- <span class="hljs-keyword">After</span> <span class="hljs-keyword">Delete</span><br><br><span class="hljs-comment"># 68. 超键、候选键、主键、外键分别是什么？</span><br><br>超键：在关系模式中，能唯一知标识元组的属性集称为超键。<br><br>候选键：是最小超键，即没有冗余元素的超键。<br><br>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（<span class="hljs-literal">Null</span>）。<br><br>外键：在一个表中存在的另一个表的主键称此表的外键。。<br><br><span class="hljs-comment"># 69. SQL 约束有哪几种呢？</span><br><br><span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>: 约束字段的内容一定不能为<span class="hljs-literal">NULL</span>。<br><br><span class="hljs-keyword">UNIQUE</span>: 约束字段唯一性，一个表允许有多个 <span class="hljs-keyword">Unique</span> 约束。<br><br>PRIMARY <span class="hljs-keyword">KEY</span>: 约束字段唯一，不可重复，一个表只允许存在一个。<br><br><span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span>: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键。<br><br><span class="hljs-keyword">CHECK</span>: 用于控制字段的值范围。<br><br><span class="hljs-comment"># 70. 谈谈六种关联查询，使用场景。</span><br><br>交叉连接<br><br>内连接<br><br>外连接<br><br>联合查询<br><br>全连接<br><br>交叉连接<br><br><span class="hljs-comment"># 71. varchar(50)中50的涵义</span><br><br>字段最多存放 <span class="hljs-number">50</span> 个字符<br><br>如 <span class="hljs-built_in">varchar</span>(<span class="hljs-number">50</span>) 和 <span class="hljs-built_in">varchar</span>(<span class="hljs-number">200</span>) 存储 <span class="hljs-string">&quot;jay&quot;</span> 字符串所占空间是一样的，后者在排序时会消耗更多内存<br><br><span class="hljs-comment"># 72. mysql中int(20)和char(20)以及varchar(20)的区别</span><br><br><span class="hljs-built_in">int</span>(<span class="hljs-number">20</span>) 表示字段是<span class="hljs-built_in">int</span>类型，显示长度是 <span class="hljs-number">20</span><br><br><span class="hljs-built_in">char</span>(<span class="hljs-number">20</span>)表示字段是固定长度字符串，长度为 <span class="hljs-number">20</span><br><br><span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) 表示字段是可变长度字符串，长度为 <span class="hljs-number">20</span><br><br><span class="hljs-comment"># 73. drop、delete与truncate的区别</span><br><br>&lt;<span class="hljs-keyword">table</span>&gt;<br>&lt;tr&gt;&lt;td&gt;\&lt;/td&gt;&lt;td&gt;<span class="hljs-keyword">delete</span>&lt;/td&gt;&lt;td&gt;<span class="hljs-keyword">truncate</span>&lt;/td&gt;&lt;td&gt;<span class="hljs-keyword">drop</span>&lt;/td&gt;&lt;/tr&gt;<br>&lt;tr&gt;&lt;td&gt;类型&lt;/td&gt;&lt;td&gt;DML&lt;/td&gt;&lt;td&gt;<span class="hljs-keyword">DDL</span>&lt;/td&gt;&lt;td&gt;<span class="hljs-keyword">DDL</span>&lt;/td&gt;&lt;/tr&gt;<br>&lt;tr&gt;&lt;td&gt;回滚&lt;/td&gt;&lt;td&gt;可回滚&lt;/td&gt;&lt;td&gt;不可回滚&lt;/td&gt;&lt;td&gt;不可回滚&lt;/td&gt;&lt;/tr&gt;<br>&lt;tr&gt;&lt;td&gt;删除内容&lt;/td&gt;&lt;td&gt;表结构还在，删除表的全部或者一部分数据行&lt;/td&gt;&lt;td&gt;表结构还在，删除表中的所有数据&lt;/td&gt;&lt;td&gt;从数据库中删除表，所有的数据行，索引和权限也会被删除&lt;/td&gt;&lt;/tr&gt;<br>&lt;tr&gt;&lt;td&gt;删除速度&lt;/td&gt;&lt;td&gt;删除速度慢，逐行删除&lt;/td&gt;&lt;td&gt;删除速度快&lt;/td&gt;&lt;td&gt;删除速度最快&lt;/td&gt;<br>&lt;/tr&gt;<br><br><span class="hljs-comment"># 74. UNION与UNION ALL的区别？</span><br><br><span class="hljs-keyword">Union</span>：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；<br><br><span class="hljs-keyword">Union</span> <span class="hljs-keyword">All</span>：对两个结果集进行并集操作，包括重复行，不进行排序；<br><br><span class="hljs-keyword">UNION</span>的效率高于 <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><br><br><span class="hljs-comment"># 75. SQL的生命周期？</span><br><br>服务器与数据库建立连接<br><br>数据库进程拿到请求<span class="hljs-keyword">sql</span><br><br>解析并生成执行计划，执行<br><br>读取数据到内存，并进行逻辑处理<br><br>通过步骤一的连接，发送结果到客户端<br><br>关掉连接，释放资源<br><br><span class="hljs-comment"># 76. 一条Sql的执行顺序？</span><br><br>![avatar](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@<span class="hljs-keyword">master</span>/<span class="hljs-keyword">resource</span>/img/<span class="hljs-keyword">sql</span>-zxsx.png)<br><br><span class="hljs-comment"># 77. 列值为NULL时，查询是否会用到索引？</span><br><br>列值为<span class="hljs-literal">NULL</span>也是可以走索引的<br><br>计划对列进行索引，应尽量避免把它设置为可空，因为这会让 MySQL 难以优化引用了可空列的查询，同时增加了引擎的复杂度<br><br><span class="hljs-comment"># 78. 关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</span><br><br>我们平时写<span class="hljs-keyword">Sql</span>时，都要养成用<span class="hljs-keyword">explain</span>分析的习惯。<br><br>慢查询的统计，运维会定期统计给我们<br><br>优化慢查询：<br><br>分析语句，是否加载了不必要的字段/数据。<br><br>分析<span class="hljs-keyword">SQl</span>执行句话，是否命中索引等。<br><br>如果<span class="hljs-keyword">SQL</span>很复杂，优化<span class="hljs-keyword">SQL</span>结构<br><br>如果表数据量太大，考虑分表<br><br>可以看我这篇文章哈：后端程序员必备：书写高质量<span class="hljs-keyword">SQL</span>的<span class="hljs-number">30</span>条建议<br><br><span class="hljs-comment"># 79. 主键使用自增ID还是UUID，为什么？</span><br><br>如果是单机的话，选择自增<span class="hljs-keyword">ID</span>；如果是分布式系统，优先考虑<span class="hljs-keyword">UUID</span>吧，但还是最好自己公司有一套分布式唯一<span class="hljs-keyword">ID</span>生产方案吧。<br><br>自增<span class="hljs-keyword">ID</span>：数据存储空间小，查询效率高。但是如果数据量过大,会超出自增长的值范围，多库合并，也有可能有问题。<br><br><span class="hljs-keyword">uuid</span>：适合大量数据的插入和更新操作，但是它无序的，插入数据效率慢，占用空间大。<br><br><span class="hljs-comment"># 80. mysql自增主键用完了怎么办？</span><br><br>自增主键一般用<span class="hljs-built_in">int</span>类型，一般达不到最大值，可以考虑提前分库分表的。<br><br><span class="hljs-comment"># 81. 字段为什么要求定义为not null？</span><br><br><span class="hljs-literal">null</span>值会占用更多的字节，并且<span class="hljs-literal">null</span>有很多坑的。<br><br><span class="hljs-comment"># 82. 如果要存储用户的密码散列，应该使用什么字段进行存储？</span><br><br>密码散列，盐，用户身份证号等固定长度的字符串，应该使用<span class="hljs-built_in">char</span>而不是<span class="hljs-built_in">varchar</span>来存储，这样可以节省空间且提高检索效率。<br><br><span class="hljs-comment"># 83. Mysql驱动程序是什么？</span><br><br>这个jar包：mysql-connector-<span class="hljs-keyword">java</span><span class="hljs-number">-5.1</span><span class="hljs-number">.18</span>.jar<br><br>Mysql驱动程序主要帮助编程语言与 MySQL服务端进行通信，如连接、传输数据、关闭等。<br><br><span class="hljs-comment"># 84. 如何优化长难的查询语句？有实战过吗？</span><br><br>将一个大的查询分为多个小的相同的查询<br><br>减少冗余记录的查询。<br><br>一个复杂查询可以考虑拆成多个简单查询<br><br>分解关联查询，让缓存的效率更高。<br><br><span class="hljs-comment"># 85. 优化特定类型的查询语句</span><br><br>平时积累吧：<br><br>比如使用<span class="hljs-keyword">select</span> 具体字段代替 <span class="hljs-keyword">select</span> *<br><br>使用<span class="hljs-keyword">count</span>(*) 而不是<span class="hljs-keyword">count</span>(列名)<br><br>在不影响业务的情况，使用缓存<br><br><span class="hljs-keyword">explain</span> 分析你的<span class="hljs-keyword">SQL</span><br><br><span class="hljs-comment"># 86. MySQL数据库cpu飙升的话，要怎么处理呢？</span><br><br>排查过程：<br><br>使用top 命令观察，确定是mysqld导致还是其他原因。<br><br>如果是mysqld导致的，<span class="hljs-keyword">show</span> <span class="hljs-keyword">processlist</span>，查看<span class="hljs-keyword">session</span>情况，确定是不是有消耗资源的<span class="hljs-keyword">sql</span>在运行。<br><br>找出消耗高的 <span class="hljs-keyword">sql</span>，看看执行计划是否准确， 索引是否缺失，数据量是否太大。<br><br>处理：<br><br><span class="hljs-keyword">kill</span> 掉这些线程(同时观察 cpu 使用率是否下降)，<br><br>进行相应的调整(比如说加索引、改 <span class="hljs-keyword">sql</span>、改内存参数)<br><br>重新跑这些 <span class="hljs-keyword">SQL</span>。<br><br>其他情况：<br><br>也有可能是每个 <span class="hljs-keyword">sql</span> 消耗资源并不多，但是突然之间，有大量的 <span class="hljs-keyword">session</span> 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等<br><br><span class="hljs-comment"># 87. 读写分离常见方案？</span><br><br>应用程序根据业务逻辑来判断，增删改等写操作命令发给主库，查询命令发给备库。<br><br>利用中间件来做代理，负责对数据库的请求识别出读还是写，并分发到不同的数据库中。（如：amoeba，mysql-proxy）<br><br><span class="hljs-comment"># 88. MySQL的复制原理以及流程</span><br><br>主从复制原理，简言之，就三步曲，如下：<br><br>主数据库有个<span class="hljs-keyword">bin</span>-<span class="hljs-keyword">log</span>二进制文件，纪录了所有增删改<span class="hljs-keyword">Sql</span>语句。（<span class="hljs-keyword">binlog</span>线程）<br><br>从数据库把主数据库的<span class="hljs-keyword">bin</span>-<span class="hljs-keyword">log</span>文件的<span class="hljs-keyword">sql</span>语句复制过来。（io线程）<br><br>从数据库的relay-<span class="hljs-keyword">log</span>重做日志文件中再执行一次这些<span class="hljs-keyword">sql</span>语句。（<span class="hljs-keyword">Sql</span>执行线程）<br><br>如下图所示：<br><br>![avatar](https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@<span class="hljs-keyword">master</span>/<span class="hljs-keyword">resource</span>/img/mysql-copy.png)<br><br>上图主从复制分了五个步骤进行：<br><br>步骤一：主库的更新事件(<span class="hljs-keyword">update</span>、<span class="hljs-keyword">insert</span>、<span class="hljs-keyword">delete</span>)被写到<span class="hljs-keyword">binlog</span><br><br>步骤二：从库发起连接，连接到主库。<br><br>步骤三：此时主库创建一个<span class="hljs-keyword">binlog</span> dump <span class="hljs-keyword">thread</span>，把<span class="hljs-keyword">binlog</span>的内容发送到从库。<br><br>步骤四：从库启动之后，创建一个I/O线程，读取主库传过来的<span class="hljs-keyword">binlog</span>内容并写入到relay <span class="hljs-keyword">log</span><br><br>步骤五：还会创建一个<span class="hljs-keyword">SQL</span>线程，从relay <span class="hljs-keyword">log</span>里面读取内容，从ExecMasterLog_Pos位置开始执行读取到的更新事件，将更新内容写入到<span class="hljs-keyword">slave</span>的db<br><br><span class="hljs-comment"># 89. MySQL中DATETIME和TIMESTAMP的区别</span><br><br>&gt;存储精度都为秒<br><br><span class="hljs-comment"># 区别：</span><br><br>- DATETIME 的日期范围是 <span class="hljs-number">1001</span>——<span class="hljs-number">9999</span> 年；<span class="hljs-built_in">TIMESTAMP</span> 的时间范围是 <span class="hljs-number">1970</span>——<span class="hljs-number">2038</span> 年<br><br>- DATETIME 存储时间与时区无关；<span class="hljs-built_in">TIMESTAMP</span> 存储时间与时区有关，显示的值也依赖于时区<br><br>- DATETIME 的存储空间为 <span class="hljs-number">8</span> 字节；<span class="hljs-built_in">TIMESTAMP</span> 的存储空间为 <span class="hljs-number">4</span> 字节<br><br>- DATETIME 的默认值为 <span class="hljs-literal">null</span>；<span class="hljs-built_in">TIMESTAMP</span> 的字段默认不为空(<span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>)，默认值为当前时间(<span class="hljs-keyword">CURRENT_TIMESTAMP</span>)<br><br><span class="hljs-comment"># 90. Innodb的事务实现原理？</span><br><br>原子性(Atomicity)：是使用 <span class="hljs-keyword">undo</span> <span class="hljs-keyword">log</span>来实现的，如果事务执行过程中出错或者用户执行了<span class="hljs-keyword">rollback</span>，系统通过<span class="hljs-keyword">undo</span> <span class="hljs-keyword">log</span>日志返回事务开始的状态。<br><br>一致性(Consistency)：通过回滚、恢复，以及并发情况下的隔离性，从而实现一致性。<br><br>持久性(Durability)：使用 <span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span>来实现，只要<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span>日志持久化了，当系统崩溃，即可通过<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span>把数据恢复。<br><br>隔离性(<span class="hljs-keyword">Isolation</span>)：通过锁以及MVCC,使事务相互隔离开。<br><br><span class="hljs-comment"># 91. 谈谈MySQL的Explain</span><br><br><span class="hljs-keyword">Explain</span> 执行计划包含字段信息如下：分别是 <span class="hljs-string">`id`</span>、<span class="hljs-string">`selecttype`</span>、<span class="hljs-string">`table`</span>、<span class="hljs-string">`partitions`</span>、<span class="hljs-string">`type`</span>、<span class="hljs-string">`possiblekeys`</span>、<span class="hljs-string">`key`</span>、<span class="hljs-string">`key_len`</span>、<span class="hljs-string">`ref`</span>、<span class="hljs-string">`rows`</span>、<span class="hljs-string">`filtered`</span>、<span class="hljs-string">`Extra`</span> 等<span class="hljs-number">12</span>个字段。<br><br>我们重点关注的是<span class="hljs-keyword">type</span>，它的属性排序如下：<br><br><span class="hljs-string">`system`</span>  &gt; <span class="hljs-string">`const`</span> &gt; <span class="hljs-string">`eq_ref`</span> &gt; <span class="hljs-string">`ref`</span> &gt; <span class="hljs-string">`ref_or_null`</span> &gt; <span class="hljs-string">`index_merge`</span> &gt; <span class="hljs-string">`unique_subquery`</span> &gt; <span class="hljs-string">`index_subquery`</span> &gt; <span class="hljs-string">`range`</span> &gt; <span class="hljs-string">`index`</span> &gt; <span class="hljs-string">`ALL`</span><br><br><br><br><span class="hljs-comment"># 92. Innodb的事务与日志的实现方式</span><br><br><span class="hljs-comment">## 有多少种日志</span><br><br><span class="hljs-keyword">innodb</span>两种日志<span class="hljs-keyword">redo</span>和<span class="hljs-keyword">undo</span>。<br><br><span class="hljs-comment">## 日志的存放形式</span><br><br>- <span class="hljs-keyword">redo</span>：在页修改的时候，先写到 <span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span> buffer 里面， 然后写到 <span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span> 的文件系统缓存里面(fwrite)，然后再同步到磁盘文件（ fsync）。<br><br>- <span class="hljs-keyword">Undo</span>：在 MySQL5<span class="hljs-number">.5</span> 之前， <span class="hljs-keyword">undo</span> 只能存放在 ibdata文件里面， <span class="hljs-number">5.6</span> 之后，可以通过设置 innodbundotablespaces 参数把 <span class="hljs-keyword">undo</span> <span class="hljs-keyword">log</span> 存放在 ibdata之外。<br><br><span class="hljs-comment">## 事务是如何通过日志来实现的</span><br><br>因为事务在修改页时，要先记 <span class="hljs-keyword">undo</span>，在记 <span class="hljs-keyword">undo</span> 之前要记 <span class="hljs-keyword">undo</span> 的 <span class="hljs-keyword">redo</span>， 然后修改数据页，再记数据页修改的 <span class="hljs-keyword">redo</span>。<span class="hljs-keyword">Redo</span>（里面包括 <span class="hljs-keyword">undo</span> 的修改） 一定要比数据页先持久化到磁盘。<br><br>当事务需要回滚时，因为有 <span class="hljs-keyword">undo</span>，可以把数据页回滚到前镜像的 状态，崩溃恢复时，如果 <span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span> 中事务没有对应的 <span class="hljs-keyword">commit</span> 记录，那么需要用 <span class="hljs-keyword">undo</span>把该事务的修改回滚到事务开始之前。<br><br>如果有 <span class="hljs-keyword">commit</span> 记录，就用 <span class="hljs-keyword">redo</span> 前滚到该事务完成时并提交掉。<br><br><span class="hljs-comment"># 93. MySQL中TEXT数据类型的最大长度</span><br><br>- TINYTEXT：<span class="hljs-number">256</span> <span class="hljs-keyword">bytes</span><br><br>- <span class="hljs-built_in">TEXT</span>：<span class="hljs-number">65</span>,<span class="hljs-number">535</span> <span class="hljs-keyword">bytes</span>(<span class="hljs-number">64</span>kb)<br><br>- MEDIUMTEXT：<span class="hljs-number">16</span>,<span class="hljs-number">777</span>,<span class="hljs-number">215</span> <span class="hljs-keyword">bytes</span>(<span class="hljs-number">16</span>MB)<br><br>- LONGTEXT：<span class="hljs-number">4</span>,<span class="hljs-number">294</span>,<span class="hljs-number">967</span>,<span class="hljs-number">295</span> <span class="hljs-keyword">bytes</span>(<span class="hljs-number">4</span>GB)<br><br><span class="hljs-comment"># 94. 500台db，在最快时间之内重启。</span><br><br>可以使用批量 ssh 工具 pssh 来对需要重启的机器执行重启命令。<br><br>也可以使用 <span class="hljs-keyword">salt</span>（前提是客户端有安装 <span class="hljs-keyword">salt</span>）或者 ansible（ ansible 只需要 ssh 免登通了就行）等多线程工具同时操作多台服务<br><br><span class="hljs-comment"># 95. 你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？</span><br><br>监控的工具有很多，例如zabbix，lepus，我这里用的是lepus<br><br><span class="hljs-comment"># 96. 你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？</span><br><br>主从一致性校验有多种工具 例如<span class="hljs-keyword">checksum</span>、mysqldiff、pt-<span class="hljs-keyword">table</span>-<span class="hljs-keyword">checksum</span>等<br><br><span class="hljs-comment"># 97. 你们数据库是否支持emoji表情存储，如果不支持，如何操作？</span><br><br>更换字符集utf8<span class="hljs-comment">--&gt;utf8mb4</span><br><br><span class="hljs-comment"># 98. MySQL如何获取当前日期？</span><br><br><span class="hljs-string">``</span><span class="hljs-string">`sql</span><br><span class="hljs-string">SELECT CURRENT_DATE();</span><br></code></pre></td></tr></table></figure><h1 id="99-一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。"><a href="#99-一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。" class="headerlink" title="99. 一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。"></a>99. 一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。</h1><p>1、如果A表TID是自增长,并且是连续的,B表的ID为索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> a,b <span class="hljs-keyword">where</span> a.tid = b.id <span class="hljs-keyword">and</span> a.tid&gt;<span class="hljs-number">500000</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">200</span>;<br></code></pre></td></tr></table></figure><p>2、如果A表的TID不是连续的,那么就需要使用覆盖索引.TID要么是主键,要么是辅助索引,B表ID也需要有索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> b , (<span class="hljs-keyword">select</span> tid <span class="hljs-keyword">from</span> a <span class="hljs-keyword">limit</span> <span class="hljs-number">50000</span>,<span class="hljs-number">200</span>) a <span class="hljs-keyword">where</span> b.id = a .tid;<br></code></pre></td></tr></table></figure><h1 id="100-Mysql一条SQL加锁分析"><a href="#100-Mysql一条SQL加锁分析" class="headerlink" title="100. Mysql一条SQL加锁分析"></a>100. Mysql一条SQL加锁分析</h1><p>一条SQL加锁，可以分9种情况进行哈：</p><ul><li><p>组合一：id列是主键，RC隔离级别</p></li><li><p>组合二：id列是二级唯一索引，RC隔离级别</p></li><li><p>组合三：id列是二级非唯一索引，RC隔离级别</p></li><li><p>组合四：id列上没有索引，RC隔离级别</p></li><li><p>组合五：id列是主键，RR隔离级别</p></li><li><p>组合六：id列是二级唯一索引，RR隔离级别</p></li><li><p>组合七：id列是二级非唯一索引，RR隔离级别</p></li><li><p>组合八：id列上没有索引，RR隔离级别</p></li><li><p>组合九：Serializable隔离级别</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法篇-学习笔记</title>
    <link href="/2020/11/14/algorithm/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/11/14/algorithm/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><blockquote><p>动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。</p></blockquote><blockquote><p>动态规划问题的一般形式就是<code>求最值</code>。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求最长递增子序列呀，最小编辑距离呀等等。既然是要求最值，核心问题是什么呢？求解动态规划的核心问题是<code>穷举</code>。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。首先，动态规划的穷举有点特别，因为这类问题存在「重叠子问题」，如果暴力穷举的话效率会极其低下，所以需要<code>「备忘录」</code>或者<code>「DP table」</code>来优化穷举过程，避免不必要计算。 而且，动态规划问题一定会具备「最优子结构」，才能通过子问题的最值得到原问题的最值。<br>另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出正确的<code>「状态转移方程」</code>才能正确地穷举。</p></blockquote><blockquote><p>以上提到的<code>重叠子问题</code>、<code>最优子结构</code>、<code>状态转移方程</code>就是动态规划三要素。</p></blockquote><h2 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">这个问题的base case(最简单情况)是什么？  <br>这个问题有什么&quot;状态&quot;？<br>对于每个状态可以做什么选择使得状态发生改变？<br>如何定义dp数组/函数的含义来表现状态和选择？<br></code></pre></td></tr></table></figure><h2 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h2><ul><li>最优子结构 opt[n]=best_of(opt[n-1],opt[n-2])</li><li>存储中间状态: opt[i]</li><li>递推公式(状态转移方程或者DP方程) FIB: opt[i]=opt[n-1]+opt[n-2]   二位路径: opt[i,j]=opt[i-1][j]+opt[i][j+1]</li></ul><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 初始化base <span class="hljs-keyword">case</span></span><br>dp[0][0][...]=base case<br><span class="hljs-meta">#</span><span class="bash"> 进行状态转移</span><br>for 状态1 in 状态1所有值:<br>    for 状态2 in 状态2所有值:<br>        for ...<br>            dp[状态1][状态2][...] = 求最值(选择1,选择2,...)<br></code></pre></td></tr></table></figure><blockquote><p>列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。</p></blockquote><h2 id="例子参考"><a href="#例子参考" class="headerlink" title="例子参考"></a>例子参考</h2><p><a href="http://mikeygithub.github.io/2020/11/19/interview/LeetCode-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">参考例子</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.zhihu.com/question/39948290/answer/612439961">如何理解动态规划？ - 牛岱的回答 - 知乎</a><br><a href=""></a></p><h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><h2 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h2><blockquote><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p></blockquote><blockquote><p>解决一个回溯问题，实际上就是一个决策树的遍历过程</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">路径：也就是已经做出的选择。<br>选择列表：也就是你当前可以做的选择。<br>结束条件：也就是到达决策树底层，无法再做选择的条件。<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/back.png" alt="回溯"></p><h2 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h2><details>  <summary><span>点击展开</span></summary><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">result = []<br>def backtrack(路径, 选择列表):<br>    if 满足结束条件:<br>        result.add(路径)<br>        return<br><br>    for 选择 in 选择列表:<br>        做选择<br>        backtrack(路径, 选择列表)<br>        撤销选择<br></code></pre></td></tr></table></figure></details><details>  <summary><span><a href="">全排列问题</a></span></summary>  <br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span>&#123;<br>    <span class="hljs-comment">//存储结果</span><br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-comment">//函数入口</span><br>    List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums)&#123;<br>        <span class="hljs-comment">//记录走过的路径</span><br>        LinkedList&lt;Integer&gt; integers = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-comment">//入口</span><br>        backtrack(nums,integers);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">//回溯函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span></span>&#123;<br>        <span class="hljs-comment">//如果走过的路径包含所有的选择则完成一轮</span><br>        <span class="hljs-keyword">if</span> (nums.length==track.size()) &#123;<br>            res.add(<span class="hljs-keyword">new</span> LinkedList(track));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;nums.length; i++) &#123;<br>            <span class="hljs-comment">//排除不合法的选择</span><br>            <span class="hljs-keyword">if</span> (track.contains(nums[i]))<span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//做选择</span><br>            track.add(nums[i]);<br>            <span class="hljs-comment">//进入下一层决策树</span><br>            backtrack(nums,track);<br>            <span class="hljs-comment">//撤销选择</span><br>            track.removeLast();<br>        &#125;<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure></details><h1 id="广度遍历"><a href="#广度遍历" class="headerlink" title="广度遍历"></a>广度遍历</h1><blockquote><p>BFS 的核心思想应该不难理解的，就是把一些问题抽象成图，从一个点开始，向四周开始扩散。一般来说，我们写 BFS 算法都是用「队列」这种数据结构，每次将一个节点周围的所有节点加入队列。</p></blockquote><h2 id="算法框架-1"><a href="#算法框架-1" class="headerlink" title="算法框架"></a>算法框架</h2><details>  <summary><span>点击展开</span></summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cgo">&#x2F;&#x2F; 计算从起点 start 到终点 target 的最近距离<br>int BFS(Node start, Node target) &#123;<br>    Queue&lt;Node&gt; q; &#x2F;&#x2F; 核心数据结构<br>    Set&lt;Node&gt; visited; &#x2F;&#x2F; 避免走回头路<br><br>    q.offer(start); &#x2F;&#x2F; 将起点加入队列<br>    visited.add(start);<br>    int step &#x3D; 0; &#x2F;&#x2F; 记录扩散的步数<br><br>    while (q not empty) &#123;<br>        int sz &#x3D; q.size();<br>        &#x2F;* 将当前队列中的所有节点向四周扩散 *&#x2F;<br>        for (int i &#x3D; 0; i &lt; sz; i++) &#123;<br>            Node cur &#x3D; q.poll();<br>            &#x2F;* 划重点：这里判断是否到达终点 *&#x2F;<br>            if (cur is target)<br>                return step;<br>            &#x2F;* 将 cur 的相邻节点加入队列 *&#x2F;<br>            for (Node x : cur.adj())<br>                if (x not in visited) &#123;<br>                    q.offer(x);<br>                    visited.add(x);<br>                &#125;<br>        &#125;<br>        &#x2F;* 划重点：更新步数在这里 *&#x2F;<br>        step++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><h1 id="深度遍历"><a href="#深度遍历" class="headerlink" title="深度遍历"></a>深度遍历</h1><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        stack.push(root);<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty())&#123;<br>            TreeNode tmp = stack.pop();<br>            list.add(tmp.val);<br>            <span class="hljs-keyword">if</span>(tmp.left!=<span class="hljs-keyword">null</span>)stack.push(tmp.left);<br>            <span class="hljs-keyword">if</span>(tmp.right!=<span class="hljs-keyword">null</span>)stack.push(tmp.right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="窗口滑动"><a href="#窗口滑动" class="headerlink" title="窗口滑动"></a>窗口滑动</h1><blockquote><p>一般采用队列来解决问题</p></blockquote><p>时间复杂度:  <code>T(n)=O(n)</code></p><h2 id="算法框架-2"><a href="#算法框架-2" class="headerlink" title="算法框架"></a>算法框架</h2><details>  <summary><span>点击展开</span></summary>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cgo">&#x2F;* 滑动窗口算法框架 *&#x2F;<br>void slidingWindow(string s, string t) &#123;<br>    unordered_map&lt;char, int&gt; need, window;<br>    for (char c : t) need[c]++;&#x2F;&#x2F;初始化<br>    int left &#x3D; 0, right &#x3D; 0;&#x2F;&#x2F;左右指针<br>    int valid &#x3D; 0;&#x2F;&#x2F;<br>    while (right &lt; s.size()) &#123;<br>        &#x2F;&#x2F; c 是将移入窗口的字符<br>        char c &#x3D; s[right];<br>        &#x2F;&#x2F; 右移窗口<br>        right++;<br>        &#x2F;&#x2F; 进行窗口内数据的一系列更新<br>        ...<br>        &#x2F;*** debug 输出的位置 ***&#x2F;<br>        printf(&quot;window: [%d, %d)\n&quot;, left, right);<br>        &#x2F;&#x2F; 判断左侧窗口是否要收缩<br>        while (window needs shrink) &#123;<br>            &#x2F;&#x2F; d 是将移出窗口的字符<br>            char d &#x3D; s[left];<br>            &#x2F;&#x2F; 左移窗口<br>            left++;<br>            &#x2F;&#x2F; 进行窗口内数据的一系列更新<br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><blockquote><p>贪心算法是在每一步选择中都采取当前状态下最好或最优(即最有利)的选择，从而希望导致结果是全局最好或最优的算法。</p></blockquote><blockquote><p>贪心法可以解决一些最优化问题，如:求图中的最小生成树、求哈夫曼树等。然而对于工程和生活中的问题，贪心法一般不能得到我们所求的答案。一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。由于贪心法的高效性已经其所求得的答案比较接近最优解，贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。</p></blockquote><p class="note note-primary">贪心、回溯、动态规划区别</p><p>贪心算法与动态规划的不同在于他对每个子问题的解决方案都做出选择，不能回退。动态规划会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。</p><p>贪心：<code>当下做局部最优判断</code><br>回溯:<code>能够回退</code><br>动态规划: <code>最优判断+回退</code></p><h2 id="参考例子"><a href="#参考例子" class="headerlink" title="参考例子"></a>参考例子</h2><details>  <summary><span><a href="">删除k个数后的最小值()</a></span></summary>  <br><p class="note note-primary">解题思路：1.从左向右遍历,找到比自己右侧数字大的数字并删除  2.如果没有找到要删除的数字,则删除最后一个数字  3.如果整数的所有数字都被删除了,直接返回0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 2. * 删除整数的k个数字,获得删除后的最小值</span><br><span class="hljs-comment">     * 3. * <span class="hljs-doctag">@param</span> num</span><br><span class="hljs-comment">     * 4. * <span class="hljs-doctag">@param</span> k</span><br><span class="hljs-comment">     * 5.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">removeKDigits</span><span class="hljs-params">(String num, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//新整数的最终长度 =原整数长度-k</span><br>        <span class="hljs-keyword">int</span> newLength = num.length() - k;<br>        <span class="hljs-comment">//创建一个栈,用于接收所有的数字</span><br>        <span class="hljs-keyword">char</span>[] stack = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[num.length()];<br>        <span class="hljs-keyword">int</span> top = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num.length(); ++i) &#123;<br>            <span class="hljs-comment">//遍历当前数字</span><br>            <span class="hljs-keyword">char</span> c = num.charAt(i);<br>            <span class="hljs-comment">//当栈顶数字大于遍历到的当前数字时,栈顶数字出栈(相当于删除数字</span><br>            <span class="hljs-keyword">while</span> (top &gt; <span class="hljs-number">0</span> &amp;&amp; stack[top - <span class="hljs-number">1</span>] &gt; c &amp;&amp; k &gt; <span class="hljs-number">0</span>) &#123;<br>                top -= <span class="hljs-number">1</span>;<br>                k -= <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">//遍历到的当前数字入栈</span><br>            stack[top++] = c;<br>        &#125;<br>        <span class="hljs-comment">// 找到栈中第1个非零数字的位置,以此构建新的整数字符串</span><br>        <span class="hljs-keyword">int</span> offset = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (offset &lt; newLength &amp;&amp; stack[offset] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>            offset++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> offset == newLength ? <span class="hljs-string">&quot;0&quot;</span> : <span class="hljs-keyword">new</span> String(stack, offset, newLength - offset);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(removeKDigits(<span class="hljs-string">&quot;1593212&quot;</span>, <span class="hljs-number">3</span>));<br>        System.out.println(removeKDigits(<span class="hljs-string">&quot;30200&quot;</span>, <span class="hljs-number">1</span>));<br>        System.out.println(removeKDigits(<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-number">2</span>));<br>        System.out.println(removeKDigits(<span class="hljs-string">&quot;541270936&quot;</span>, <span class="hljs-number">3</span>));<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure></details><h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><h1 id="字典算法"><a href="#字典算法" class="headerlink" title="字典算法"></a>字典算法</h1><h2 id="算法定义-1"><a href="#算法定义-1" class="headerlink" title="算法定义"></a>算法定义</h2><p class="note note-primary">    字典树，即Trie树，又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序的字符串（但不仅限于字符串），所以经常被搜索引擎用于文本词频率统计</p><p>优点:<code>最大限度的减少无谓的字符串比较，查询效率比　哈希表高。</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    T((Trie)) --t--&gt; B((t))<br>    T((Trie)) --A--&gt; A((A))<br>    T((Trie)) --i--&gt; I((i))<br>    <br>    B--O--&gt;TO((to))<br>    B--e--&gt;TE((te))<br>    <br>    TE((te))--a--&gt;TEA((tea))<br>    TE((te))--d--&gt;TED((ted))<br>    TE((te))--n--&gt;TEN((ten))<br>    <br>    I((i))--n--&gt;IN((in))<br> <br>    IN((in))--n--&gt;INN((inn))<br></code></pre></td></tr></table></figure><p class="note note-primary">性质</p><ul><li>节点本身不存在完整单词</li><li>从根节点到某一节点，路径上经过的字符串连接起来，为该结点对应的字符串</li><li>每个结点的所有子结点代表的字符都不相同</li></ul><p class="note note-primary">核心思想</p><ul><li>Trie树的核心思想是空间换时间</li><li>利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的</li></ul><h2 id="参考例子-1"><a href="#参考例子-1" class="headerlink" title="参考例子"></a>参考例子</h2><details>  <summary><span><a href="">寻找全排列的下一个数()</a></span></summary>  <br></details><h2 id="参考资料-2"><a href="#参考资料-2" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/darklights/p/5285598.html">字典序算法</a></p><h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><h2 id="算法定义-2"><a href="#算法定义-2" class="headerlink" title="算法定义"></a>算法定义</h2><p class="note note-primary">将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之</p><p class="note note-danger">    对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。</p><p>分治算法的适用情况</p><blockquote><p>分治法所能解决的问题一般具有以下几个特征：</p></blockquote><ol><li><p>该问题的规模缩小到一定的程度就可以容易地解决</p></li><li><p>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</p></li><li><p>利用该问题分解出的子问题的解可以合并为该问题的解；</p></li><li><p>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</p></li></ol><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">divide_conquer</span><span class="hljs-params">(Problem problem)</span> </span>&#123;<br>        <span class="hljs-comment">//recursion terminator</span><br>        <span class="hljs-keyword">if</span> (problem == NULL) &#123;    <br>            <span class="hljs-keyword">int</span> res = process_last_result();    <br>            <span class="hljs-keyword">return</span> res;       <br>        &#125;  <br>        <span class="hljs-comment">//prepare data</span><br>        subProblems = split_problem(problem);<br>        <span class="hljs-comment">//conquer subproblems</span><br>        res0 = divide_conquer(subProblems[<span class="hljs-number">0</span>]);  <br>        res1 = divide_conquer(subProblems[<span class="hljs-number">1</span>]);    <br>        <span class="hljs-comment">//process and generate the final result</span><br>        result = process_result(res0, res1);   <br>        <span class="hljs-comment">//revert the current level states</span><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="排序类型"><a href="#排序类型" class="headerlink" title="排序类型"></a>排序类型</h1><p><a href="https://mikeygithub.github.io/2020/11/09/algorithm/%E7%AE%97%E6%B3%95%E7%AF%87-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">算法篇-排序算法</a></p><blockquote><p>nlogn排序: 堆排序、快速排序、归并排序</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph LR<br>A(排序算法)--&gt;B(比较类排序)<br>A(排序算法)--&gt;C(非比较类排序)<br><br>B--&gt;D(交换排序)<br>D--&gt;E(冒泡排序)<br>D--&gt;F(快速排序)<br><br>B--&gt;G(插入排序)<br>G--&gt;H(简单插入排序)<br>G--&gt;I(希尔排序)<br><br>B--&gt;J(选择排序)<br>J--&gt;K(简单选择排序)<br>J--&gt;X(堆排序)<br><br>B--&gt;L(归并排序)<br>L--&gt;M(二路归并排序)<br>L--&gt;N(多路归并排序)<br><br>C--&gt;O(计数排序)<br>O--&gt;P(桶排序)<br>O--&gt;Q(基数排序)<br></code></pre></td></tr></table></figure><h2 id="初级排序"><a href="#初级排序" class="headerlink" title="初级排序"></a>初级排序</h2><blockquote><p><code>O(n^2)</code></p></blockquote><ul><li>选择排序(Select Sort)每次找最小值，然后放到待排序数组的起始位置。</li><li>插入排序(Insert Sort)从前到后逐步构建有序序列；对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</li><li>冒泡排序(Bubble Sort)嵌套循环，每次查看相邻的元素如果逆序，则交换。</li></ul><h2 id="高级排序"><a href="#高级排序" class="headerlink" title="高级排序"></a>高级排序</h2><blockquote><p><code>O(n*logn)</code></p></blockquote><ul><li>快速排序(Quick Sort)数组取标杆pivot，将小元素放pivot左边，大元素放右边，然后依次对右边和左边的子数组继续快排；以达到整个序列有序</li><li>归并排序(Merge Sort)<br>  1.把长度为n的输入序列分成两个长度位n/2的子序列;<br>  2.把这两个子序列分别采用归并排序;<br>  3.将两个排序好的子序列合并成一个最终的排序序列;</li></ul><p><code>归并排序和快速排序具有相似性，但步骤相反</code></p><blockquote><p>归并:先排序左右子数组，然后合并两个有序子数组</p></blockquote><blockquote><p>快排:先调出左右子数组，然后对于左右数组进行排序</p></blockquote><ul><li>对排序(heap Sort)　堆插入O(logN)，取最大最小值O(1)<br>  1.数组元素依次建立小堆顶<br>  2.依次取堆顶元素，并删除</li></ul><p>(满二叉搜索树进行实现)</p><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><blockquote><p>对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边&lt;u,v&gt;∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;q;<br><span class="hljs-comment">//priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;q;</span><br><span class="hljs-comment">//优先队列的话，会按照数值大小有顺序的输出</span><br><span class="hljs-comment">//此处为了理解，暂时就用简单队列</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">topo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(inti=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(indegree[i]==<span class="hljs-number">0</span>)<br>        &#123;<br>            q.push(i);<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">int</span> temp;<br>    <span class="hljs-keyword">while</span>(!q.empty())<br>    &#123;<br>        temp=q.front();<span class="hljs-comment">//如果是优先队列，这里可以是top()</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;&quot;</span>,temp);<br>        q.pop();<br>        <span class="hljs-keyword">for</span>(inti=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//遍历从temp出发的每一条边，入度--</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">map</span>[temp][i])<br>            &#123;<br>                indegree[i]--;<br>                <span class="hljs-keyword">if</span>(indegree[i]==<span class="hljs-number">0</span>)q.push(i);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法定义-3"><a href="#算法定义-3" class="headerlink" title="算法定义"></a>算法定义</h3><p class="note note-primary"></p><h1 id="并查集型"><a href="#并查集型" class="headerlink" title="并查集型"></a>并查集型</h1><p class="note note-primary">定义</p><blockquote><p>并查集是一种树型的数据结构，用于处理一些不相交集合（disjoint sets）的合并及查询问题。常常在使用中以森林来表示。</p></blockquote><ul><li>合并（Union）：把两个不相交的集合合并为一个集合。</li><li>查询（Find）：查询两个元素是否在同一个集合中。</li></ul><p class="note note-primary">适用场景</p><ul><li>组团、配对问题</li><li>Group or not ?</li></ul><p class="note note-primary">基本操作</p><ul><li>makeSet(s): 建立一个新的并查集，其中包含s个单元素集合。</li><li>unionSet(x,y): 把元素x和元素y所在的集合合并，要求x和y所在的集合不相交，如果相交则不合并。</li><li>find(x): 找到元素x所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将他们各自代表比较一下就可以了。</li></ul><h2 id="图示演示"><a href="#图示演示" class="headerlink" title="图示演示"></a>图示演示</h2><blockquote><p>查询、合并</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br><br>合并前<br>A((A))--&gt;A<br>A--&gt;B((B))<br>A--&gt;C((C))<br>B--&gt;D((D))<br><br>E((E))--&gt;E<br>E((E))--&gt;F((F))<br>F--&gt;G((G))<br><br>合并后<br><br>A1((A))--&gt;A1<br>A1--&gt;B1((B))<br>A1--&gt;C1((C))<br>B1--&gt;D1((D))<br><br>A1--&gt;E1<br><br>E1((E))--&gt;1F((F))<br>1F--&gt;1G((G))<br></code></pre></td></tr></table></figure><blockquote><p>调用find(d)时进行路劲压缩</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br><br>未压缩前<br>A((A))--&gt;A<br>A--&gt;B((B))<br>A--&gt;&#39;A右子树没有&#39;<br><br>B--&gt;C((C))<br>B--&gt;&#39;B右子树没有&#39;<br><br>C--&gt;D((D))<br>C--&gt;&#39;C右子树没有&#39;<br><br>路劲压缩<br><br>A1((A))--&gt;A1((A))<br>A1--&gt;B1((B))<br>A1--&gt;C1((C))<br>A1--&gt;D1((D))<br></code></pre></td></tr></table></figure><h2 id="代码模板-1"><a href="#代码模板-1" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-keyword">int</span>[] parent;<br>    <span class="hljs-keyword">int</span>[] rank;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid)</span> </span>&#123;<br>        count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> m = grid.length;<br>        <span class="hljs-keyword">int</span> n = grid[<span class="hljs-number">0</span>].length;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m * n];<br>        rank = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m * n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    parent[i * n + j] = i * n + j;<br>                    ++count;<br>                &#125;<br>                rank[i * n + j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (parent[i] != i) parent[i] = find(parent[i]);<br>        <span class="hljs-keyword">return</span> parent[i];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> rootx = find(x);<br>        <span class="hljs-keyword">int</span> rooty = find(y);<br>        <span class="hljs-keyword">if</span> (rootx != rooty) &#123;<br>            <span class="hljs-keyword">if</span> (rank[rootx] &gt; rank[rooty]) &#123;<br>                parent[rooty] = rootx;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rank[rootx] &lt; rank[rooty]) &#123;<br>                parent[rootx] = rooty;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                parent[rooty] = rootx;<br>                rank[rootx] += <span class="hljs-number">1</span>;<br>            &#125;<br>            --count;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考例子-2"><a href="#参考例子-2" class="headerlink" title="参考例子"></a>参考例子</h2><ul><li>朋友圈</li><li>岛屿数量</li></ul><h1 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h1><h2 id="算法定义-4"><a href="#算法定义-4" class="headerlink" title="算法定义"></a>算法定义</h2><p class="note note-primary">递归算法时间复杂度=子问题个数*解决一个子问题需要的时间</p><h2 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(<span class="hljs-keyword">int</span> level,<span class="hljs-keyword">int</span> param)</span></span>&#123;<br>       <span class="hljs-comment">//terminator</span><br>        <span class="hljs-keyword">if</span> (level&gt;MAX_LEVEL)&#123;<br>            <span class="hljs-comment">//procesws resutl</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//process current logic</span><br>        process(level,param);<br>        <span class="hljs-comment">//drill down</span><br>        recur(level:level+<span class="hljs-number">1</span>,newParam);<br>        <span class="hljs-comment">//restore current status</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><blockquote><p>有序、上下界、索引访问</p></blockquote><p class="note note-primary">代码模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySearch</span></span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] binarySearch(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> target)&#123; <br>       <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>,right = ...;<br>       <span class="hljs-keyword">while</span> (...)&#123;<br>           <span class="hljs-keyword">int</span> mid = left+(right-left)/<span class="hljs-number">2</span>;<br>           <span class="hljs-keyword">if</span> (nums[mid]==target)&#123;<br>               ...<br>           &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid]&lt;target)&#123;<br>               left = ...;<br>           &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid]&gt;target)&#123;<br>               right = ...;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> ...;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="高级搜索"><a href="#高级搜索" class="headerlink" title="高级搜索"></a>高级搜索</h1><h2 id="初级搜索"><a href="#初级搜索" class="headerlink" title="初级搜索"></a>初级搜索</h2><ul><li>朴素搜索</li><li>优化搜索：不重复(fibonacci)，剪枝(生成括号问题)</li><li>搜索放心 DFS、BFS、双向搜索、启发式搜索</li></ul><h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><ul><li>在回溯中将不满足的条件的直接过滤掉，提供算法的效率。</li></ul><h2 id="双向BFS"><a href="#双向BFS" class="headerlink" title="双向BFS"></a>双向BFS</h2><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/double-bfs.png" alt="双向BFS"></p><h2 id="启发式搜索-A"><a href="#启发式搜索-A" class="headerlink" title="启发式搜索(A*)"></a>启发式搜索(A*)</h2><p class="note note-primary">定义</p><blockquote><p>启发式搜索(Heuristically Search)又称为有信息搜索(Informed Search)，它是利用问题拥有的启发信息来引导搜索，达到减少搜索范围、降低问题复杂度的目的，这种利用启发信息的搜索过程称为启发式搜索。</p></blockquote><p class="note note-primary">估价函数</p><blockquote><p>启发式函数：　h(n),它用来评价哪些节点最有希望的是一个我们要找的结点，h(n)会返回一个非负实数，也可以认为是从结点n的目标结点路径的估计成本</p></blockquote><blockquote><p>启发式函数是一种告知搜索方向的方法。它提供了一种明智的方法来猜测哪个邻居结点会导向一个目标。</p></blockquote><h1 id="位移运算"><a href="#位移运算" class="headerlink" title="位移运算"></a>位移运算</h1><ul><li>位运算符</li></ul><blockquote><p>机器里的数字存储格式是二进制方式</p></blockquote><table><thead><tr><th>含义</th><th>运算符</th><th>示例</th></tr></thead><tbody><tr><td>左移</td><td>&lt;&lt;</td><td>0011 -&gt; 0110</td></tr><tr><td>右移</td><td>&gt;&gt;</td><td>0110 -&gt; 0011</td></tr><tr><td>按位或</td><td>|</td><td>0011|1011 -&gt; 1011</td></tr><tr><td>按位与</td><td>&amp;</td><td>0110 &amp; 0011 -&gt; 0010</td></tr><tr><td>按位取反</td><td>~</td><td>~0110 -&gt; 1001</td></tr><tr><td>按位异或(相同为0不同为1)</td><td>^</td><td>0011^0110 -&gt; 0101</td></tr></tbody></table><p>XOR-异或</p><blockquote><p>相同为0不同为1，也可以用”不进位加法来理解”</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">x^0=x<br>x^1s=~x //注意1s=~0<br>x^x=0<br>c=a^b -&gt; a^c=b , b^c=a //交换两个数<br>a^b^c=a^(b^c)=(a^b)^c //associative<br></code></pre></td></tr></table></figure><ul><li>算数位移与逻辑位移</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">将x最右边的n位清零: x&amp;(~0&lt;&lt;n)<br>获取x的第n位值(0或者1): (x&gt;&gt;n)&amp;1<br>获取x的第n位的幂值: x&amp;(1&lt;&lt;(n-1))<br>仅将第n位置为1: x|(1&lt;&lt;n)<br>仅将第n位置为0: x&amp;(~(1&lt;&lt;n))<br>将x最高位至第n位(含)清零: x&amp;((1&lt;&lt;n)-1)<br>将第n位至第0位(含)清零: x&amp;(~((1&lt;&lt;(n+1))-1))<br></code></pre></td></tr></table></figure><ul><li>位运算的应用</li></ul><p>判断奇偶性:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">x%2==1 --&gt; (x&amp;1)==1   <br>x%2==0 --&gt; (x&amp;1)==0   <br></code></pre></td></tr></table></figure><p>乘除2</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">x&gt;&gt;1 --&gt; x/2<br>x&lt;&lt;1 --&gt; x*2<br></code></pre></td></tr></table></figure><p>清零</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">x=x&amp;(x-1)清零最低位的1<br>x&amp;-x  得到最低位的1<br>x&amp;~x 等于0<br></code></pre></td></tr></table></figure><h1 id="参考资料-3"><a href="#参考资料-3" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="">漫画算法:小灰的算法之旅</a></p><p><a href="https://labuladong.gitbook.io/algo/">fucking-algorithm</a></p><p><a href="https://mikeygithub.github.io/2020/11/19/interview/%E9%9D%A2%E8%AF%95%E7%AF%87-LeetCode-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">LeetCode-刷题记录</a></p><p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">数据结构在线演示</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法篇-排序算法</title>
    <link href="/2020/11/09/algorithm/%E7%AE%97%E6%B3%95%E7%AF%87-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2020/11/09/algorithm/%E7%AE%97%E6%B3%95%E7%AF%87-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/pxsfsjfzd.jpeg" alt="img"></p><p>稳定性：当序列中存在两个或两个以上的关键字相等的时候，如果排序前序列中1领先于2,那么排序后1如果仍旧领先2的话，则是稳定的。（相等的元素排序后相对位置不变）</p><p>不稳定性：当序列中存在两个或两个以上的关键字相等的时候，如果排序前序列中1领先于2,那么排序后1如果落后2的话，则是不稳定的。（相等的元素排序后相对位置发生改变）</p><hr><p>时间复杂度：<code>T(n)=O(f(n))</code></p><p>渐进时间复杂度（asymptotic time complexity）的概念，官方的定义如下：<br>若存在函数 f（n），使得当n趋近于无穷大时，T（n）/ f（n）的极限值为不等于零的常数，则称 f（n）是T（n）的同数量级函数。<br>记作 T（n）= O（f（n）），称O（f（n）） 为算法的渐进时间复杂度，简称时间复杂度。</p><p>如何推导出时间复杂度呢？有如下几个原则：<br> 1.如果运行时间是常数量级，用常数1表示；<br> 2.只保留时间函数中的最高阶项；<br> 3.如果最高阶项存在，则省去最高阶项前面的系数。  </p><blockquote><p>常数阶O(1) &lt; 对数阶O(logN) &lt; 线性阶O(n) &lt; 线性对数阶O(nlogN) &lt; 平方阶O(n²) &lt; 立方阶O(n³) &lt; K次方阶O(n^k) &lt; 指数阶(2^n)</p></blockquote><h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><blockquote><p>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。</p></blockquote><p> 空间复杂度比较常用的有：<code>O(1)</code>、<code>O(n)</code>、<code>O(n²)</code></p><h2 id="空间复杂度-O-1"><a href="#空间复杂度-O-1" class="headerlink" title="空间复杂度 O(1)"></a>空间复杂度 O(1)</h2><p>如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>;<br>        ++i;<br>        j++;<br>        <span class="hljs-keyword">int</span> m = i + j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)</p><h2 id="空间复杂度-O-n"><a href="#空间复杂度-O-n" class="headerlink" title="空间复杂度 O(n)"></a>空间复杂度 <code>O(n)</code></h2><h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><p>我们先看一个代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] m = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; ++i)<br>        &#123;<br>            j = i;<br>            j++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)</p><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p class="note note-primary">思路：</p><details>  <summary><span>代码实现</span></summary>  <br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure></details><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><blockquote><p>1.选择基准(一般取第一个)<br>2.从右往左查找比基准小的数，进行位置交换<br>3.从左往右查找比基准大的数，进行位置交换<br>4.重复执行2、3直到比较完成<br>5.分别对两边重复执行1-4</p></blockquote><details>  <summary><span>双边循环排序法</span></summary>  <br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sort</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">int</span> low = left, height = right, x = arr[left];<br>            <span class="hljs-keyword">while</span> (low &lt; height)<br>            &#123;<br>                <span class="hljs-keyword">while</span>(low &lt; height &amp;&amp; arr[height] &gt;= x) <span class="hljs-comment">// 从右向左找第一个小于x的数</span><br>                    height--;<br>                <span class="hljs-keyword">if</span>(low &lt; height)<br>                    arr[low++] = arr[height];<br><br>                <span class="hljs-keyword">while</span>(low &lt; height &amp;&amp; arr[low] &lt; x) <span class="hljs-comment">// 从左向右找第一个大于等于x的数</span><br>                    low++;<br>                <span class="hljs-keyword">if</span>(low &lt; height)<br>                    arr[height--] = arr[low];<br>            &#125;<br>            arr[low] = x;<br>            quicksort(arr, left, low - <span class="hljs-number">1</span>); <span class="hljs-comment">// 递归调用</span><br>            quicksort(arr, low + <span class="hljs-number">1</span>, right);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details>  <summary><span>单边循环排序法</span></summary>  <br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//<span class="hljs-doctag">TODO:</span></span><br></code></pre></td></tr></table></figure></details><details>  <summary><span>非递归方式实现</span></summary>  <br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//<span class="hljs-doctag">TODO:</span></span><br></code></pre></td></tr></table></figure></details><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><blockquote><p>1.分为有序和无序两段数组<br>2.从无序中取第一个数插入有序半段中的适合位置<br>3.重复执行2步骤直到无序数组为长度为零</p></blockquote><p><code>T(n)=O(n^2)</code></p><details>  <summary><span>展开代码</span></summary>  <br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sort</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">straightInsertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i]&lt;arr[i-<span class="hljs-number">1</span>])&#123;<span class="hljs-comment">//插入i-1前面</span><br>                tmp = arr[i];<br>                <span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; tmp &lt; arr[j]; j--) &#123;<br>                    arr[j+<span class="hljs-number">1</span>] = arr[j];<br>                &#125;<br>                arr[j+<span class="hljs-number">1</span>] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><blockquote><p>1.在长度为N的无序数组中，第一次遍历n-1个数，找到最小的数值与第一个元素交换；</p></blockquote><blockquote><p>2.第二次遍历n-2个数，找到最小的数值与第二个元素交换；</p></blockquote><blockquote><p>3.第n-1次遍历，找到最小的数值与第n-1个元素交换，排序完成。</p></blockquote><details>  <summary><span>展开代码</span></summary>  <br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sort</span></span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>            <span class="hljs-keyword">int</span> min;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>                min=arr[i];<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j &lt;arr.length; j++) &#123;<br>                    <span class="hljs-keyword">if</span> (arr[j]&lt;min)&#123;<br>                        <span class="hljs-keyword">int</span> tmp = arr[i];<br>                        min=arr[j];<br>                        arr[i]=arr[j];<br>                        arr[j]=tmp;<br>                    &#125;<br>            &#125;<br>       &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>基本思想：<br>    在要排序的一组数中，根据某一增量分为若干子序列，并对子序列分别进行插入排序。<br>    然后逐渐将增量减小,并重复上述过程。直至增量为1,此时数据序列基本有序,最后进行插入排序。</p><p>数据序列1： 13-17-20-42-28 利用插入排序，13-17-20-28-42. Number of swap:1;<br>数据序列2： 13-17-20-42-14 利用插入排序，13-14-17-20-42. Number of swap:3;<br>如果数据序列基本有序，使用插入排序会更加高效。</p><details>  <summary><span>展开代码</span></summary>  <br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sort</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br><br>        <span class="hljs-keyword">int</span> incre = arr.length;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>            incre = incre&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; incre; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt;arr.length ; j+=incre) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = j; k &gt;i ; k-=incre) &#123;<br>                        <span class="hljs-keyword">if</span> (arr[k]&lt;arr[k-incre])&#123;<br>                            <span class="hljs-keyword">int</span> tmp = arr[k];<br>                            arr[k-incre]=arr[k];<br>                            arr[k]=tmp;<br>                        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (incre==<span class="hljs-number">1</span>)<span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br>``` <br>&lt;/details&gt;<br><br># 冒泡排序<br><br>基本思想：两个数比较大小，较大的数下沉，较小的数冒起来。<br><br>过程：<br><br>&gt;比较相邻的两个数据，如果第二个数小，就交换位置。<br>从后向前两两比较，一直到比较最前两个数据。最终最小数被交换到起始的位置，这样第一个最小数的位置就排好了。<br>继续重复上述过程，依次将第<span class="hljs-number">2.3</span>...n-<span class="hljs-number">1</span>个最小数排好位置。<br><br>时间复杂度: `T(n)=O(n^<span class="hljs-number">2</span>)`<br><br><br>&lt;details&gt;<br>  &lt;summary&gt;&lt;span&gt;展开代码&lt;/span&gt;&lt;/summary&gt;<br>  &lt;br&gt;<br>  <br>```java<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sort</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] arr)</span></span>&#123;<br><br>     <span class="hljs-keyword">int</span> temp;<span class="hljs-comment">//临时变量</span><br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;arr.length-<span class="hljs-number">1</span>; i++)&#123;   <span class="hljs-comment">//表示趟数，一共arr.length-1次。</span><br>         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=arr.length-<span class="hljs-number">1</span>; j&gt;i; j--)&#123;<br><br>             <span class="hljs-keyword">if</span>(arr[j] &lt; arr[j-<span class="hljs-number">1</span>])&#123;<br>                 temp = arr[j];<br>                 arr[j] = arr[j-<span class="hljs-number">1</span>];<br>                 arr[j-<span class="hljs-number">1</span>] = temp;<br>             &#125;<br>         &#125;<br>     &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>平均时间复杂度：<code>O(NlogN)</code></p><p>基本思路:</p><blockquote><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p></blockquote><blockquote><p>首先考虑下如何将将二个有序数列合并。这个非常简单，只要从比较二个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。</p></blockquote><blockquote><blockquote><p>归并排序的效率是比较高的，设数列长为 N，将数列分开成小数列一共要 logN 步，每步都是一个合并有序数列的过程，时间复杂度可以记为 O(N)，故一共为 O(N<em>logN)。因为归并排序每次都是在相邻的数据中进行操作，所以归并排序在 O(N</em>logN) 的几种排序方法（快速排序，归并排序，希尔排序，堆排序）也是效率比较高的。</p></blockquote></blockquote><details>  <summary><span>展开代码</span></summary>  <br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sort</span></span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    *程序入口</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>        <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length];<br>        mergeSort(arr,<span class="hljs-number">0</span>,arr.length-<span class="hljs-number">1</span>,temp);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 递归</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> a</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> first</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> last</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> temp</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last, <span class="hljs-keyword">int</span>[] temp)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (first &lt; last) &#123;<br>            <span class="hljs-keyword">int</span> mid = (first + last) / <span class="hljs-number">2</span>;<br>            mergeSort(a, first, mid, temp);<br>            mergeSort(a, mid + <span class="hljs-number">1</span>, last, temp);<br>            mergeArray(a, first, mid, last, temp);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 合并数组</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> a</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> first</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> mid</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> last</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> temp</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> last, <span class="hljs-keyword">int</span>[] temp)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = first, j = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> m = mid, n = last;<br>        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt;= m &amp;&amp; j &lt;= n) &#123;<br>            <span class="hljs-keyword">if</span> (a[i] &lt;= a[j]) temp[k++] = a[i++];<br>            <span class="hljs-keyword">else</span> temp[k++] = a[j++];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i &lt;= m) temp[k++] = a[i++];<br>        <span class="hljs-keyword">while</span> (j &lt;= n) temp[k++] = a[j++];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>; l &lt; k; l++) a[first + i] = temp[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><h1 id="堆外排序"><a href="#堆外排序" class="headerlink" title="堆外排序"></a>堆外排序</h1><blockquote><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p></blockquote><details>  <summary><span><a href="https://www.cnblogs.com/chengxiao/p/6129630.html">原文链接</a></span></summary>  <br><p>预备知识</p><p><strong>堆排序</strong></p><p>　　堆排序是利用<strong>堆</strong>这种数据结构而设计的一种排序算法，堆排序是一种<strong>选择排序，</strong>它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。</p><p><strong>堆</strong></p><p>　　<strong>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/heap-1.png" alt="img"></p><p>同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/heap-2.png" alt="img"></p><p>该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：</p><p><strong>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</strong>  </p><p><strong>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</strong>  </p><p>ok，了解了这些定义。接下来，我们来看看堆排序的基本思想及基本步骤：</p><p>堆排序基本思想及步骤</p><blockquote><p>　　<strong>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</strong></p></blockquote><p><strong>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。</strong></p><p>　　a.假设给定无序序列结构如下</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/heap-3.png" alt="img"></p><p>2.此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/heap-4.png" alt="img"></p><p>4.找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/heap-5.png" alt="img"></p><p>这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/heap-6.png" alt="img"></p><p>此时，我们就将一个无需序列构造成了一个大顶堆。</p><p><strong>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</strong></p><p>a.将堆顶元素9和末尾元素4进行交换</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/heap-7.png" alt="img"></p><p>b.重新调整结构，使其继续满足堆定义</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/heap-8.png" alt="img"></p><p>c.再将堆顶元素8与末尾元素5进行交换，得到第二大元素8.</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/heap-9.png" alt="img"></p><p>后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/heap-10.png" alt="img"></p><p>再简单总结下堆排序的基本思路：</p><p>　　<strong>a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong></p><p>　　<strong>b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</strong></p><p>　　<strong>c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</strong></p></details><p>代码实现</p><details>  <summary><span>展开代码</span></summary>  <br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> sortdemo;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 堆排序demo</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapSort</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String []args)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> []arr = &#123;<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<br>        sort(arr);<br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> []arr)</span></span>&#123;<br>        <span class="hljs-comment">//1.构建大顶堆</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=arr.length/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-comment">//从第一个非叶子结点从下至上，从右至左调整结构</span><br>            adjustHeap(arr,i,arr.length);<br>        &#125;<br>        <span class="hljs-comment">//2.调整堆结构+交换堆顶元素与末尾元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=arr.length-<span class="hljs-number">1</span>;j&gt;<span class="hljs-number">0</span>;j--)&#123;<br>            swap(arr,<span class="hljs-number">0</span>,j);<span class="hljs-comment">//将堆顶元素与末尾元素进行交换</span><br>            adjustHeap(arr,<span class="hljs-number">0</span>,j);<span class="hljs-comment">//重新对堆进行调整</span><br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> i</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> length</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">adjustHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> []arr,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> length)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> temp = arr[i];<span class="hljs-comment">//先取出当前元素i</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;k&lt;length;k=k*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//从i结点的左子结点开始，也就是2i+1处开始</span><br>            <span class="hljs-keyword">if</span>(k+<span class="hljs-number">1</span>&lt;length &amp;&amp; arr[k]&lt;arr[k+<span class="hljs-number">1</span>])&#123;<span class="hljs-comment">//如果左子结点小于右子结点，k指向右子结点</span><br>                k++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(arr[k] &gt;temp)&#123;<span class="hljs-comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span><br>                arr[i] = arr[k];<br>                i = k;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        arr[i] = temp;<span class="hljs-comment">//将temp值放到最终的位置</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 交换元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> a</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> b</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> []arr,<span class="hljs-keyword">int</span> a ,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> temp=arr[a];<br>        arr[a] = arr[b];<br>        arr[b] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><br><p>结果</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><p>最后</p><p>　　堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。其中构建初始堆经推导复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)…1]逐步递减，近似为nlogn。所以堆排序时间复杂度一般认为就是O(nlogn)级。</p><h1 id="桶外排序"><a href="#桶外排序" class="headerlink" title="桶外排序"></a>桶外排序</h1><p>桶排序的基本思想是: 把数组 arr 划分为 n 个大小相同子区间(桶),每个子区间各自排序,最后合并 。计数排序是桶排序的一种特殊情况,可以把计数排序当成每个桶里只有一个元素的情况。</p><p>1.找出待排序数组中的最大值 max、最小值 min</p><p>2.我们使用 动态数组 ArrayList 作为桶,桶里放的元素也用 ArrayList 存储。桶的数量为(max-min)/arr.length+1</p><p>3.遍历数组 arr,计算每个元素 arr[i] 放的桶</p><p>4.每个桶各自排序</p><details>  <summary><span>展开代码</span></summary>  <br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 桶排序</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bucketSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;<br>        <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++)&#123;<br>            max = Math.max(max, arr[i]);<br>            min = Math.min(min, arr[i]);<br>        &#125;<br>        <span class="hljs-comment">//创建桶</span><br>        <span class="hljs-keyword">int</span> bucketNum = (max - min) / arr.length + <span class="hljs-number">1</span>;<br>        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(bucketNum);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bucketNum; i++)&#123;<br>            bucketArr.add(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;());<br>        &#125;<br>        <span class="hljs-comment">//将每个元素放入桶</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++)&#123;<br>            <span class="hljs-keyword">int</span> num = (arr[i] - min) / (arr.length);<br>            bucketArr.get(num).add(arr[i]);<br>        &#125;<br>        <span class="hljs-comment">//对每个桶进行排序</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bucketArr.size(); i++)&#123;<br>            Collections.sort(bucketArr.get(i));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>将所有待比较数值(正整数)统一为同样的数位长度,数位较短的数前面补零。然后,从最低位开始,依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。</p><details>  <summary><span>展开代码</span></summary>  <br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[])</span> </span>&#123;<br>        sort(a);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i++) &#123;<br>            System.out.println(a[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array)</span> </span>&#123;<br>        <span class="hljs-comment">//首先确定排序的趟数;</span><br>        <span class="hljs-keyword">int</span> max = array[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; array.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (array[i] &gt; max) &#123;<br>                max = array[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> time = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//判断位数;</span><br>        <span class="hljs-keyword">while</span> (max &gt; <span class="hljs-number">0</span>) &#123;<br>            max /= <span class="hljs-number">10</span>;<br>            time++;<br>        &#125;<br>        <span class="hljs-comment">//建立 10 个队列;</span><br>        List&lt;ArrayList&gt; queue = <span class="hljs-keyword">new</span> ArrayList&lt;ArrayList&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            ArrayList&lt;Integer&gt; queue1 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>            queue.add(queue1);<br>        &#125;<br>        <span class="hljs-comment">//进行 time 次分配和收集;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; time; i++) &#123;<br>        <span class="hljs-comment">//分配数组元素;</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; array.length; j++) &#123;<br>        <span class="hljs-comment">//得到数字的第 time+1 位数;</span><br>                <span class="hljs-keyword">int</span> x = array[j] % (<span class="hljs-keyword">int</span>) Math.pow(<span class="hljs-number">10</span>, i + <span class="hljs-number">1</span>) / (<span class="hljs-keyword">int</span>) Math.pow(<span class="hljs-number">10</span>, i);<br>                ArrayList&lt;Integer&gt; queue2 = queue.get(x);<br>                queue2.add(array[j]);<br>                queue.set(x, queue2);<br>            &#125;<br>            <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<span class="hljs-comment">//元素计数器;</span><br>            <span class="hljs-comment">//收集队列元素;</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">10</span>; k++) &#123;<br>                <span class="hljs-keyword">while</span> (queue.get(k).size() &gt; <span class="hljs-number">0</span>) &#123;<br>                    ArrayList&lt;Integer&gt; queue3 = queue.get(k);<br>                    array[count] = queue3.get(<span class="hljs-number">0</span>);<br>                    queue3.remove(<span class="hljs-number">0</span>);<br>                    count++;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://baijiahao.baidu.com/s?id=1631316781107113184&wfr=spider&for=pc">经典排序算法全攻略</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试篇-计算机网络</title>
    <link href="/2020/10/23/interview/%E9%9D%A2%E8%AF%95%E7%AF%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2020/10/23/interview/%E9%9D%A2%E8%AF%95%E7%AF%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/five-network.png" alt="avatar"></p><table><thead><tr><th>体系结构</th><th>协议</th></tr></thead><tbody><tr><td>物理层</td><td>RJ45、CLOCK、IEEE802.3（中继器、集线器）</td></tr><tr><td>数据链路</td><td>PPP、FR、HDLC、VLAN、MAC（网桥、交换机）</td></tr><tr><td>网络层</td><td>IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器）</td></tr><tr><td>传输层</td><td>TCP（HTTP/S、FTP、POP3、SMTP、TENET、SSH）、UDP（BOOTP、NTP、DHCP）、SPX</td></tr><tr><td>会话层</td><td>NFS、SQL、NETBIOS、RPC</td></tr><tr><td>表示层</td><td>JPEG、MPEG、ASII</td></tr><tr><td>应用层</td><td>FTP、DNS、Telenet、SMTP、HTTP、WWW、NFS</td></tr></tbody></table><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><blockquote><p>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP协议等等。我们把应用层交互的数据单元称为报文。</p></blockquote><p>域名系统</p><blockquote><p>域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 <a href="http://www.ibm.com、oracle/">www.ibm.com、Oracle</a> 公司的域名是 <a href="http://www.oracle.com、cisco公司的域名是/">www.oracle.com、Cisco公司的域名是</a> <a href="http://www.cisco.com/">www.cisco.com</a> 等。</p></blockquote><p>HTTP协议</p><blockquote><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）</p></blockquote><h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><blockquote><p>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p></blockquote><p>运输层主要使用以下两种协议:</p><ul><li>传输控制协议 TCP（Transmission Control Protocol）–提供面向连接的，可靠的数据传输服务。</li><li>用户数据协议 UDP（User Datagram Protocol）–提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</li></ul><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><blockquote><p>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。<br>这里要注意：不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。<br>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.<br>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Protocol）和许多路由选择协议，因此互联网的网络层也叫做网际层或IP层。</p></blockquote><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><blockquote><p>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。<br>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。 控制信息还使接收端能够检测到所收到的帧中有无差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p></blockquote><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><blockquote><p>在物理层上所传送的数据单位是比特。<br>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异， 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。<br>在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的TCP/IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整个TCP/IP协议族。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/pc-network.png" alt="avatar"></p><h1 id="TCP-UDP-协议的区别"><a href="#TCP-UDP-协议的区别" class="headerlink" title="TCP UDP 协议的区别"></a>TCP UDP 协议的区别</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/tcp-vs-udp.jpg" alt="avatar"></p><h1 id="HTTP三次握手-四次挥手"><a href="#HTTP三次握手-四次挥手" class="headerlink" title="HTTP三次握手/四次挥手"></a>HTTP三次握手/四次挥手</h1><table>    <tr><td>字段</td><td>含义</td></tr>    <tr><td>URG</td><td>紧急指针是否有效。为１，表示某一位需要被优先处理</td></tr>    <tr><td>ACK</td><td>确认号是否有效，一般置为１</td></tr>    <tr><td>PSH</td><td>提示接收端应用程序立即从TCP缓冲区把数据读走</td></tr>    <tr><td>RST</td><td>对方要求重新建立连接，复位</td></tr>    <tr><td>SYN</td><td>请求建立连接标识，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为１</td></tr>    <tr><td>F I N</td><td>请求断开链接标识</td></tr></table><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/three-hand-1.png" alt="三次握手"><br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/four-hand.png" alt="四次挥手"></p><p><a href="https://www.cnblogs.com/kindnull/p/10307333.html">参考资料</a><br><a href="https://blog.csdn.net/qq_38950316/article/details/81087809">参考资料</a></p><h1 id="在浏览器中输入url地址到显示主页的过程"><a href="#在浏览器中输入url地址到显示主页的过程" class="headerlink" title="在浏览器中输入url地址到显示主页的过程"></a>在浏览器中输入url地址到显示主页的过程</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/url-flow.jpg" alt="avatar"></p><h1 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/ztm.png" alt="avatar"></p><blockquote><p>常见状态码</p></blockquote><ul><li>200 OK //客户端请求成功</li><li>400 Bad Request //客户端请求有语法错误，不能被服务器所理解</li><li>401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</li><li>403 Forbidden //服务器收到请求，但是拒绝提供服务</li><li>404 Not Found //请求资源不存在，eg：输入了错误的URL</li><li>500 Internal Server Error //服务器发生不可预期的错误</li><li>503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="">OSI七层模型与5G协议</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试篇-面试面经</title>
    <link href="/2020/10/17/interview/%E9%9D%A2%E8%AF%95%E7%AF%87-%E9%9D%A2%E8%AF%95%E9%9D%A2%E7%BB%8F/"/>
    <url>/2020/10/17/interview/%E9%9D%A2%E8%AF%95%E7%AF%87-%E9%9D%A2%E8%AF%95%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><details>  <summary><span>讯龙创威</span></summary>  <br><p><strong>一面(一个小时)</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs text">浏览器输入网址整个流程<br>DNS寻址<br>Http三次握手/四次挥手<br>Http/Https区别<br>TCP/IP<br>Nginx：ssl端口<br>跨域:原因+解决方案<br>Mysql引擎<br>Int(1)和Int(10)<br>MySQL然后提升性能<br>SQL基本操作<br>SQL执行顺序<br>数据库事务是什么<br>事务隔离级别:<br>事务的特性:ACID<br>面向对象编程思想:封装,继承,多态<br>设计模式:种类,作用<br></code></pre></td></tr></table></figure><p><strong>二面(半个小时)</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs text">MySQL索引<br>如何协调团队开发<br>能不能开发php<br>手撕代码:求一个递增数组中两个数和为target数的方法，返回对应的下标<br>public class Solution&#123;<br>    public static int[] method(int[] nums,int target)&#123;<br>       Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();<br>         for (int i = 0; i &lt; nums.length; i++) &#123;<br>           int complement = target - nums[i];<br>             if (map.containsKey(complement)) &#123;<br>                  return new int[] &#123; map.get(complement), i &#125;;<br>              &#125;<br>              map.put(nums[i], i);<br>           &#125;<br>           throw new IllegalArgumentException(&quot;No two sum solution&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>三面(半个小时)</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">问项目<br>家庭情况<br>项目中遇到的困难<br>自己的缺点<br>朋友的评价<br>打游戏不<br>所获奖项        <br></code></pre></td></tr></table></figure></details><details>  <summary><span>掌上先机</span></summary>  <br><p><strong>一面</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs text">手撕代码：1-100缺的数<br>基本数据类型、Void<br>Mvcc、快照读，当前读<br>synchronized和reetenlock<br>I++是不是原子操作<br>数据库索引、B+tree、失效、写SQL判断是否走索引<br>数据库引擎myIsan和innodb<br>排序算法时间复杂度O (nlogn)<br>Springmvc常用注解<br>Mybaits和hibernate区别<br>#&#123;&#125;和$&#123;&#125;<br>反射<br>深拷贝浅拷贝<br>String、StringBuffer、StringBuilder<br>==和equal<br>重写hashcode原因<br>类加载器<br>多线程上传文件记录成功失败<br>并发注意事项<br>CAS手写思路<br>IOC和AOP<br>Spring bean scope<br>Spring bean注入怎么保证线程安全<br>动态代理<br>使用实现了来代替接口注入会出现什么问题<br>Servlet生命周期、Jsp<br>Mybatis分页、缓存、一级缓存、二级缓存<br>mysql的char和varchar<br>数据库事务ACID<br>我们采取ID自增作为主键<br>共享锁、排它锁<br>```        <br>        <br>&lt;/details&gt;<br><br>&lt;details&gt;<br>  &lt;summary&gt;&lt;span&gt;同盾科技&lt;/span&gt;&lt;/summary&gt;<br>  &lt;br&gt;<br><br>**一面**<br>```text<br>stringbuff和stringbuilde<br></code></pre></td></tr></table></figure><p><strong>二面</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">手撕代码：斐波拉切+快排‘<br>项目相关<br></code></pre></td></tr></table></figure><p><strong>HR面</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">自我介绍<br>实习经历<br>职业发展<br>期望薪资<br>有无女友<br>有无offer(怎么选择地点、薪资)<br>接受加班强度<br>对公司了解情况<br>投递渠道<br></code></pre></td></tr></table></figure></details><details>  <summary><span>映客直播</span></summary>  <br><p><strong>一面</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">自我介绍<br>进程线程区别<br>进程通信方式<br>LRU算法<br>线程死锁条件<br>事务传播<br>tcp/udp<br>MySQL索引<br>Redis<br>ACID<br></code></pre></td></tr></table></figure><p><strong>二面</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">自我介绍<br>事务隔离级别<br>redis<br>操作系统<br>浏览器输入网址流程<br>手撕代码“给定一个排序数组求其平衡二叉树”<br>Hashmap扩容、优化<br>DNS协议<br></code></pre></td></tr></table></figure></details><details>  <summary><span>闪电快车</span></summary>  <br><p><strong>一面</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">自我介绍(说我逻辑有问题?我直接好家伙)<br>挑一个项目问<br>tcp/udp<br>两个数组取交集<br>自己平时怎么学习的<br>QQ使用的是什么协议<br>技术发展方向<br>etcd<br>分布式事务<br></code></pre></td></tr></table></figure></details><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/xiaoxu123/">面试面筋-IT小旭</a></p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式缓存</title>
    <link href="/2020/09/07/note/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"/>
    <url>/2020/09/07/note/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p>缓存雪崩我们可以简单的理解为:由于原有缓存失效,新缓存未到期间所有原本应该访问缓存的请求都去查询数据库了,而对数据库 CPU 和内存造成巨大压力,严重的会造成数据库宕机。从而形成一系列连锁反应,造成整个系统崩溃。一般有三种处理办法:</p><ol><li>一般并发量不是特别多的时候,使用最多的解决方案是加锁排队。</li><li>给每一个缓存数据增加相应的缓存标记,记录缓存的是否失效,如果缓存标记失效,则更新数据缓存。</li><li>为 key 设置不同的缓存失效时间。</li></ol><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>缓存穿透是指用户查询数据,在数据库没有,自然在缓存中也不会有。这样就导致用户查询的时候,在缓存中找不到,每次都要去数据库再查询一遍,然后返回空(相当于进行了两次无用的查询)。这样请求就绕过缓存直接查数据库,这也是经常提的缓存命中率问题。<br>有很多种方法可以有效地解决缓存穿透问题,最常见的则是采用布隆过滤器,将所有可能存在的数据哈希到一个足够大的 bitmap 中,一个一定不存在的数据会被这个 bitmap 拦截掉,从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法,如果一个查询返回的数据为空(不管是数据不存在,还是系统故障),我们仍然把这个空结果进行缓存,但它的过期时间会很短,最长不超过五分钟。通过这个直接设置的默认值存放到缓存,这样第二次到缓冲中获取就有值了,而不会继续访问数据库。</p><h1 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h1><p>缓存预热就是系统上线后,将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候,先查询数据库,然后再将数据缓存的问题!用户直接查询事先被预热的缓存数据!</p><h1 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h1><p>缓存更新除了缓存服务器自带的缓存失效策略之外(Redis 默认的有 6 中策略可供选择),我们还可以根据具体的业务需求进行自定义的缓存淘汰,常见的策略有两种:</p><p>(1)定时去清理过期的缓存;<br>(2)当有用户请求过来时,再判断这个请求所用到的缓存是否过期,过期的话就去底层系统得到新数据并更新缓存。</p><h1 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h1><p>当访问量剧增、服务出现问题(如响应时间慢或不响应)或非核心服务影响到核心流程的性能时,仍然需要保证服务还是可用的,即使是有损服务。系统可以根据一些关键数据进行自动降级,也可以配置开关实现人工降级。降级的最终目的是保证核心服务可用,即使是有损的。而且有些服务是无法降级的(如加入购物车、结算)。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法篇-加密算法</title>
    <link href="/2020/09/06/algorithm/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    <url>/2020/09/06/algorithm/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h1><p>高级加密标准(AES,Advanced Encryption Standard)为最常见的对称加密算法(微信小程序加密传输就是用这个加密算法的)。对称加密算法也就是加密和解密用相同的密钥,具体的加密流程如下图:</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/aes.png" alt="avatar"></p><h1 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h1><p>RSA 加密算法是一种典型的非对称加密算法,它基于大数的因式分解数学难题,它也是应用最广泛的非对称加密算法。非对称加密是通过两个密钥(公钥-私钥)来实现对数据的加密和解密的。公钥用于加密,私钥用于解密。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/rsa.png" alt="avatar"></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/rsa-1.png" alt="avatar"></p><h1 id="CRC"><a href="#CRC" class="headerlink" title="CRC"></a>CRC</h1><p>循环冗余校验(Cyclic Redundancy Check, CRC)是一种根据网络数据包或电脑文件等数据产生简短固定位数校验码的一种散列函数,主要用来检测或校验数据传输或者保存后可能出现的错误。<br>它是利用除法及余数的原理来作错误侦测的。</p><h1 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h1><p>MD5 常常作为文件的签名出现,我们在下载文件的时候,常常会看到文件页面上附带一个扩展名为.MD5 的文本或者一行字符,这行字符就是就是把整个文件当作原数据通过 MD5 计算后的值,我们下载文件后,可以用检查文件 MD5 信息的软件对下载到的文件在进行一次计算。两次结果对比就可以确保下载到文件的准确性。 另一种常见用途就是网站敏感信息加密,比如用户名密码,支付签名等等。随着 https 技术的普及,现在的网站广泛采用前台明文传输到后台,MD5 加密(使用偏移量)的方式保护敏感数据保护站点和数据安全。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>加密算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法篇-基础算法</title>
    <link href="/2020/09/06/algorithm/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    <url>/2020/09/06/algorithm/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>又叫折半查找,要求待查找的序列有序。每次取中间位置的值与待查关键字比较,如果中间位置的值比待查关键字大,则在前半部分循环这个查找的过程,如果中间位置的值比待查关键字小,则在后半部分循环这个查找的过程。直到查找到了为止,否则序列中没有待查的关键字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 二分查找</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> array</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> a</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">biSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> []array,<span class="hljs-keyword">int</span> a)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> lo = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> hi = array.length-<span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">int</span> mid;<br>        <br>        <span class="hljs-keyword">while</span> (lo&lt;hi)&#123;<br>            mid = (lo+hi)/<span class="hljs-number">2</span>;<span class="hljs-comment">//中间位置</span><br>            <span class="hljs-keyword">if</span> (array[mid] == a)&#123;<br>                <span class="hljs-keyword">return</span> mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (array[mid]&lt;a)&#123;<br>                lo = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                hi = mid -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="剪枝算法"><a href="#剪枝算法" class="headerlink" title="剪枝算法"></a>剪枝算法</h1><p>在搜索算法中优化中,剪枝,就是通过某种判断,避免一些不必要的遍历过程,形象的说,就是剪去了搜索树中的某些“枝条”,故称剪枝。应用剪枝优化的核心问题是设计剪枝判断方法,即确定哪些枝条应当舍弃,哪些枝条应当保留的方法。</p><h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>回溯算法实际上一个类似枚举的搜索尝试过程,主要是在搜索尝试过程中寻找问题的解,当发现已不满足求解条件时,就“回溯”返回,尝试别的路径。</p><h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><p>从某顶点出发,沿图的边到达另一顶点所经过的路径中,各边上权值之和最小的一条路径叫做最短路径。解决最短路的问题有以下算法,Dijkstra 算法,Bellman-Ford 算法,Floyd 算法和 SPFA算法等。</p><h1 id="最大子数组算法"><a href="#最大子数组算法" class="headerlink" title="最大子数组算法"></a>最大子数组算法</h1><h1 id="最长公共子序算法"><a href="#最长公共子序算法" class="headerlink" title="最长公共子序算法"></a>最长公共子序算法</h1><h1 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h1><p>现在假设有一个很实际的问题:我们要在 n 个城市中建立一个通信网络,则连通这 n 个城市需要布置 n-1 一条通信线路,这个时候我们需要考虑如何在成本最低的情况下建立这个通信网?于是我们就可以引入连通图来解决我们遇到的问题,n 个城市就是图上的 n 个顶点,然后,边表示两个城市的通信线路,每条边上的权重就是我们搭建这条线路所需要的成本,所以现在我们有 n 个顶点的连通网可以建立不同的生成树,每一颗生成树都可以作为一个通信网,当我们构造这个连通网所花的成本最小时,搭建该连通网的生成树,就称为最小生成树。</p><p>构造最小生成树有很多算法,但是他们都是利用了最小生成树的同一种性质:MST 性质(假设N=(V,{E})是一个连通网,U 是顶点集 V 的一个非空子集,如果(u,v)是一条具有最小权值的边,其中 u 属于 U,v 属于 V-U,则必定存在一颗包含边(u,v)的最小生成树),下面就介绍两种使用 MST 性质生成最小生成树的算法:普里姆算法和克鲁斯卡尔算法。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/min-tree.png" alt="avatar"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法篇-一致性算法</title>
    <link href="/2020/09/06/algorithm/%E7%AE%97%E6%B3%95%E7%AF%87-%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    <url>/2020/09/06/algorithm/%E7%AE%97%E6%B3%95%E7%AF%87-%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h1><p>Paxos 算法解决的问题是一个分布式系统如何就某个值(决议)达成一致。一个典型的场景是,在一个分布式数据库系统中,如果各节点的初始状态一致,每个节点执行相同的操作序列,那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列,需要在每一条指令上执行一个“一致性算法”以保证每个节点看到的指令一致。zookeeper 使用的 zab 算法是该算法的一个实现。 在 Paxos 算法中,有三种角色:Proposer,Acceptor,Learners</p><p>Paxos 三种角色:Proposer,Acceptor,Learners</p><p>Proposer :<br>只要 Proposer 发的提案被半数以上 Acceptor 接受,Proposer 就认为该提案里的 value 被选定了。</p><p>Acceptor :<br>只要 Acceptor 接受了某个提案,Acceptor 就认为该提案里的 value 被选定了。</p><p>Learner :<br>Acceptor 告诉 Learner 哪个 value 被选定,Learner 就认为那个 value 被选定。</p><p>Paxos 算法分为两个阶段。具体如下:</p><p>阶段一(准 leader 确定 ):<br>(a) Proposer 选择一个提案编号 N,然后向半数以上的 Acceptor 发送编号为 N 的 Prepare 请求。<br>(b) 如果一个 Acceptor 收到一个编号为 N 的 Prepare 请求,且 N 大于该 Acceptor 已经响应过的所有 Prepare 请求的编号,那么它就会将它已经接受过的编号最大的提案(如果有的话)作为响应反馈给 Proposer,同时该 Acceptor 承诺不再接受任何编号小于 N 的提案。</p><p>阶段二( leader 确认):<br>(a) 如果 Proposer 收到半数以上 Acceptor 对其发出的编号为 N 的 Prepare 请求的响应,那么它就会发送一个针对[N,V]提案的 Accept 请求给半数以上的 Acceptor。注意:V 就是收到的响应中编号最大的提案的 value,如果响应中不包含任何提案,那么 V 就由 Proposer 自己决定。<br>(b) 如果 Acceptor 收到一个针对编号为 N 的提案的 Accept 请求,只要该 Acceptor 没有对编号大于 N 的 Prepare 请求做出过响应,它就接受该提案。</p><h1 id="Zab"><a href="#Zab" class="headerlink" title="Zab"></a>Zab</h1><p>ZAB( ZooKeeper Atomic Broadcast , ZooKeeper 原子消息广播协议)协议包括两种基本的模式:崩溃恢复和消息广播</p><p>1.当整个服务框架在启动过程中,或是当 Leader 服务器出现网络中断崩溃退出与重启等异常情况时,ZAB 就会进入恢复模式并选举产生新的 Leader 服务器。<br>2.当选举产生了新的 Leader 服务器,同时集群中已经有过半的机器与该 Leader 服务器完成了状态同步之后,ZAB 协议就会退出崩溃恢复模式,进入消息广播模式。<br>3.当有新的服务器加入到集群中去,如果此时集群中已经存在一个 Leader 服务器在负责进行消息广播,那么新加入的服务器会自动进入数据恢复模式,找到 Leader 服务器,并与其进行数据同步,然后一起参与到消息广播流程中去。</p><p>以上其实大致经历了三个步骤:</p><ol><li>崩溃恢复:主要就是 Leader 选举过程</li><li>数据同步: Leader 服务器与其他服务器进行数据同步</li><li>消息广播: Leader 服务器将数据发送给其他服务器</li></ol><p>说明:zookeeper 章节对该协议有详细描述。</p><h1 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h1><p>与 Paxos 不同 Raft 强调的是易懂(Understandability),Raft 和 Paxos 一样只要保证 n/2+1 节点正常就能够提供服务;raft 把算法流程分为三个子问题:选举(Leader election)、日志复制(Log replication)、安全性(Safety)三个子问题。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p>Raft 把集群中的节点分为三种状态:Leader、 Follower 、Candidate,理所当然每种状态负责的任务也是不一样的,Raft 运行时提供服务的时候只存在 Leader 与 Follower 两种状态;</p><p>Leader (领导者 - 日志管理)<br>负责日志的同步管理,处理来自客户端的请求,与 Follower 保持这 heartBeat 的联系;</p><p>Follower (追随者 - 日志同步)<br>刚启动时所有节点为 Follower 状态,响应 Leader 的日志同步请求,响应 Candidate 的请求,</p><p>把请求到 Follower 的事务转发给 Leader;<br>Candidate (候选者 - 负责选票)<br>负责选举投票,Raft 刚启动时由一个节点从 Follower 转为 Candidate 发起选举,选举出Leader 后从 Candidate 转为 Leader 状态;</p><h2 id="Term-任期"><a href="#Term-任期" class="headerlink" title="Term(任期)"></a>Term(任期)</h2><p>在 Raft 中使用了一个可以理解为周期(第几届、任期)的概念,用 Term 作为一个周期,每个 Term 都是一个连续递增的编号,每一轮选举都是一个 Term 周期,在一个 Term 中只能产生一个 Leader;当某节点收到的请求中 Term 比当前 Term 小时则拒绝该请求。</p><h1 id="选举-Election"><a href="#选举-Election" class="headerlink" title="选举(Election)"></a>选举(Election)</h1><p>选举定时器</p><p>Raft 的选举由定时器来触发,每个节点的选举定时器时间都是不一样的,开始时状态都为Follower 某个节点定时器触发选举后 Term 递增,状态由 Follower 转为 Candidate,向其他节点发起 RequestVote RPC 请求,这时候有三种可能的情况发生:</p><p>1:该 RequestVote 请求接收到 n/2+1(过半数)个节点的投票,从 Candidate 转为 Leader,向其他节点发送 heartBeat 以保持 Leader 的正常运转。</p><p>2:在此期间如果收到其他节点发送过来的 AppendEntries RPC 请求,如该节点的 Term 大则当前节点转为 Follower,否则保持 Candidate 拒绝该请求。</p><p>3:Election timeout 发生则 Term 递增,重新发起选举在一个 Term 期间每个节点只能投票一次,所以当有多个 Candidate 存在时就会出现每个Candidate 发起的选举都存在接收到的投票数都不过半的问题,这时每个 Candidate 都将 Term递增、重启定时器并重新发起选举,由于每个节点中定时器的时间都是随机的,所以就不会多次存在有多个 Candidate 同时发起投票的问题。</p><blockquote><p>在 Raft 中当接收到客户端的日志(事务请求)后先把该日志追加到本地的 Log 中,然后通过heartbeat 把该 Entry 同步给其他 Follower,Follower 接收到日志后记录日志然后向 Leader 发送ACK,当 Leader 收到大多数(n/2+1)Follower 的 ACK 信息后将该日志设置为已提交并追加到本地磁盘中,通知客户端并在下个 heartbeat 中 Leader 将通知所有的 Follower 将该日志存储在自己的本地磁盘中。</p></blockquote><h2 id="安全性-Safety"><a href="#安全性-Safety" class="headerlink" title="安全性(Safety)"></a>安全性(Safety)</h2><p>安全性是用于保证每个节点都执行相同序列的安全机制如当某个 Follower 在当前 Leader commit Log 时变得不可用了,稍后可能该 Follower 又会倍选举为 Leader,这时新 Leader 可能会用新的 Log 覆盖先前已 committed 的 Log,这就是导致节点执行不同序列;Safety 就是用于保证选举出来的 Leader 一定包含先前 commited Log 的机制;</p><p>选举安全性(Election Safety):每个 Term 只能选举出一个 Leader</p><p>Leader 完整性(Leader Completeness):这里所说的完整性是指 Leader 日志的完整性,</p><p>Raft 在选举阶段就使用 Term 的判断用于保证完整性:当请求投票的该 Candidate 的 Term 较大或 Term 相同 Index 更大则投票,该节点将容易变成 leader。</p><h2 id="raft-协议和-zab-协议区别"><a href="#raft-协议和-zab-协议区别" class="headerlink" title="raft 协议和 zab 协议区别"></a>raft 协议和 zab 协议区别</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><p>采用 quorum 来确定整个系统的一致性,这个 quorum 一般实现是集群中半数以上的服务器,zookeeper 里还提供了带权重的 quorum 实现.都由 leader 来发起写操作.都采用心跳检测存活性</p><p>leader election 都采用先到先得的投票方式</p><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><p>zab 用的是 epoch 和 count 的组合来唯一表示一个值, 而 raft 用的是 term 和 index<br>zab 的 follower 在投票给一个 leader 之前必须和 leader 的日志达成一致,而 raft 的 follower<br>则简单地说是谁的 term 高就投票给谁<br>raft 协议的心跳是从 leader 到 follower, 而 zab 协议则相反<br>raft 协议数据只有单向地从 leader 到 follower(成为 leader 的条件之一就是拥有最新的 log),而 zab 协议在 discovery 阶段, 一个 prospective leader 需要将自己的 log 更新为 quorum 里面最新的 log,然后才好在 synchronization 阶段将 quorum 里的其他机器的 log 都同步到一致.</p><h3 id="NWR"><a href="#NWR" class="headerlink" title="NWR"></a>NWR</h3><p>N :在分布式存储系统中,有多少份备份数据<br>W :代表一次成功的更新操作要求至少有 w 份数据写入成功<br>R : 代表一次成功的读数据操作要求至少有 R 份数据成功读取<br>NWR 值的不同组合会产生不同的一致性效果,当 W+R&gt;N 的时候,整个系统对于客户端来讲能保证强一致性。而如果 R+W&lt;=N,则无法保证数据的强一致性。以常见的 N=3、W=2、R=2 为例:<br>N=3,表示,任何一个对象都必须有三个副本( Replica),W=2 表示,对数据的修改操作(Write)只需要在 3 个 Replica 中的 2 个上面完成就返回,R=2 表示,从三个对象中要读取到 2个数据对象,才能返回。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/nwr.png" alt="avatar"></p><h1 id="Gossip"><a href="#Gossip" class="headerlink" title="Gossip"></a>Gossip</h1><p>Gossip 算法又被称为反熵(Anti-Entropy),熵是物理学上的一个概念,代表杂乱无章,而反熵就是在杂乱无章中寻求一致,这充分说明了 Gossip 的特点:在一个有界网络中,每个节点都随机地与其他节点通信,经过一番杂乱无章的通信,最终所有节点的状态都会达成一致。每个节点可能知道所有其他节点,也可能仅知道几个邻居节点,只要这些节可以通过网络连通,最终他们的状态都是一致的,当然这也是疫情传播的特点。</p><h1 id="一致性-Hash"><a href="#一致性-Hash" class="headerlink" title="一致性 Hash"></a>一致性 Hash</h1><p>一 致 性 哈 希 算 法 (Consistent Hashing Algorithm) 是 一 种 分 布 式 算 法 , 常 用 于 负 载 均 衡 。<br>Memcached client 也选择这种算法,解决将 key-value 均匀分配到众多 Memcached server 上的问题。它可以取代传统的取模操作,解决了取模操作无法应对增删 Memcached Server 的问题(增删 server 会导致同一个 key,在 get 操作时分配不到数据真正存储的 server,命中率会急剧下降)。</p><p>一致性 Hash 特性<br>平衡性(Balance):平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去,这样可以使得<br>所有的缓冲空间都得到利用。<br>单调性(Monotonicity):单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中,<br>又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到新的缓<br>冲中去,而不会被映射到旧的缓冲集合中的其他缓冲区。容易看到,上面的简单求余算法<br>hash(object)%N 难以满足单调性要求。<br>平滑性(Smoothness):平滑性是指缓存服务器的数目平滑改变和缓存对象的平滑改变是一致<br>的。<br>20.1.6.2.<br>一致性 Hash 原理</p><ol><li>建构环形 hash 空间:</li><li>考虑通常的 hash 算法都是将 value 映射到一个 32 为的 key 值,也即是 0~2^32-1 次方的<br>数值空间;我们可以将这个空间想象成一个首( 0 )尾( 2^32-1 )相接的圆环。</li><li>把需要缓存的内容 ( 对象 ) 映射到 hash 空间</li><li>接下来考虑 4 个对象 object1~object4 ,通过 hash 函数计算出的 hash 值 key 在环上的分<br>布</li><li>把服务器 ( 节点 ) 映射到 hash 空间</li><li>Consistent hashing 的基本思想就是将对象和 cache 都映射到同一个 hash 数值空间中,并<br>且使用相同的 hash 算法。一般的方法可以使用 服务器(节点) 机器的 IP 地址或者机器名作为<br>hash 输入。</li><li>把对象映射到服务节点</li><li>现在服务节点和对象都已经通过同一个 hash 算法映射到 hash 数值空间中了,首先确定对象<br>hash 值在环上的位置,从此位置沿环顺时针“行走”,第一台遇到的服务器就是其应该定位<br>到的服务器。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/con-hash.png" alt="avatar"><br>考察 cache 的变动<br>5.<br>通过 hash 然后求余的方法带来的最大问题就在于不能满足单调性,当 cache 有所变动时,<br>cache 会失效。<br>5.1 移除 cache:考虑假设 cache B 挂掉了,根据上面讲到的映射方法,这时受影响的将仅是<br>那些沿 cache B 逆时针遍历直到下一个 cache ( cache C )之间的对象。<br>5.2 添加 cache:再考虑添加一台新的 cache D 的情况,这时受影响的将仅是那些沿 cache<br>D 逆时针遍历直到下一个 cache 之间的对象,将这些对象重新映射到 cache D 上即可。<br>虚拟节点<br>hash 算法并不是保证绝对的平衡,如果 cache 较少的话,对象并不能被均匀的映射到 cache 上,<br>为了解决这种情况, consistent hashing 引入了“虚拟节点”的概念,它可以如下定义:<br>虚拟节点( virtual node )是实际节点在 hash 空间的复制品( replica ),一实际个节点对应了<br>若干个“虚拟节点”,这个对应个数也成为“复制个数”,“虚拟节点”在 hash 空间中以 hash<br>值排列。<br>仍以仅部署 cache A 和 cache C 的情况为例。现在我们引入虚拟节点,并设置“复制个数”为 2 ,<br>这就意味着一共会存在 4 个“虚拟节点”, cache A1, cache A2 代表了 cache A; cache C1,<br>cache C2 代表了 cache C 。此时,对象到“虚拟节点”的映射关系为:<br>objec1-&gt;cache A2 ; objec2-&gt;cache A1 ; objec3-&gt;cache C1 ; objec4-&gt;cache C2 ;<br>因此对象 object1 和 object2 都被映射到了 cache A 上,而 object3 和 object4 映射到了 cache<br>C 上;平衡性有了很大提高。<br>引入“虚拟节点”后,映射关系就从 { 对象 -&gt; 节点 } 转换到了 { 对象 -&gt; 虚拟节点 } 。查询物体所<br>在 cache 时的映射关系如下图 所示。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/hash-cache.png" alt="avatar"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>一致性算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Load Balancing</title>
    <link href="/2020/08/26/note/Load-Balancing/"/>
    <url>/2020/08/26/note/Load-Balancing/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><blockquote><p>负载均衡 建立在现有网络结构之上,它提供了一种廉价有效透明的方法扩展 网络设备 和 服务器 的带宽、增加 吞吐量 、加强网络数据处理能力、提高网络的灵活性和可用性。</p></blockquote><h2 id="四层负载均衡-vs-七层负载均衡"><a href="#四层负载均衡-vs-七层负载均衡" class="headerlink" title="四层负载均衡 vs 七层负载均衡"></a>四层负载均衡 vs 七层负载均衡</h2><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/4-layer-vs-7-layer.png" alt="avatar"></p><p>四层负载均衡(目标地址和端口交换)<br>主要通过报文中的目标地址和端口,再加上负载均衡设备设置的服务器选择方式,决定最终选择的内部服务器。</p><p>以常见的 TCP 为例,负载均衡设备在接收到第一个来自客户端的 SYN 请求时,即通过上述方式选择一个最佳的服务器,并对报文中目标 IP 地址进行修改(改为后端服务器 IP),直接转发给该服务器。TCP 的连接建立,即三次握手是客户端和服务器直接建立的,负载均衡设备只是起到一个类似路由器的转发动作。在某些部署情况下,为保证服务器回包可以正确返回给负载均衡设备,在转发报文的同时可能还会对报文原来的源地址进行修改。实现四层负载均衡的软件有:</p><ul><li>F5 :硬件负载均衡器,功能很好,但是成本很高。</li><li>lvs :重量级的四层负载软件。</li><li>nginx :轻量级的四层负载软件,带缓存功能,正则表达式较灵活。</li><li>haproxy :模拟四层转发,较灵活。</li></ul><h1 id="七层负载均衡-内容交换"><a href="#七层负载均衡-内容交换" class="headerlink" title="七层负载均衡(内容交换)"></a>七层负载均衡(内容交换)</h1><blockquote><p>所谓七层负载均衡,也称为“内容交换”,也就是主要通过报文中的真正有意义的应用层内容,再加上负载均衡设备设置的服务器选择方式,决定最终选择的内部服务器。<br>七层应用负载的好处,是使得整个网络更智能化。例如访问一个网站的用户流量,可以通过七层的方式,将对图片类的请求转发到特定的图片服务器并可以使用缓存技术;将对文字类的请求可<br>以转发到特定的文字服务器并可以使用压缩技术。</p></blockquote><p>实现七层负载均衡的软件有:</p><ul><li>haproxy :天生负载均衡技能,全面支持七层代理,会话保持,标记,路径转移;</li><li>nginx :只在 http 协议和 mail 协议上功能比较好,性能与 haproxy 差不多;</li><li>apache :功能较差</li><li>Mysql proxy :功能尚可。</li></ul><h1 id="负载均衡算法-策略"><a href="#负载均衡算法-策略" class="headerlink" title="负载均衡算法/策略"></a>负载均衡算法/策略</h1><h2 id="轮循均衡-Round-Robin"><a href="#轮循均衡-Round-Robin" class="headerlink" title="轮循均衡(Round Robin)"></a>轮循均衡(Round Robin)</h2><blockquote><p>每一次来自网络的请求轮流分配给内部中的服务器,从 1 至 N 然后重新开始。此种均衡算法适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。</p></blockquote><h2 id="权重轮循均衡-Weighted-Round-Robin"><a href="#权重轮循均衡-Weighted-Round-Robin" class="headerlink" title="权重轮循均衡(Weighted Round Robin)"></a>权重轮循均衡(Weighted Round Robin)</h2><blockquote><p>根据服务器的不同处理能力,给每个服务器分配不同的权值,使其能够接受相应权值数的服务请求。例如:服务器 A 的权值被设计成 1,B 的权值是 3,C 的权值是 6,则服务器 A、B、C 将分别接受到 10%、30%、60%的服务请求。此种均衡算法能确保高性能的服务器得到更多的使用率,避免低性能的服务器负载过重。</p></blockquote><h2 id="随机均衡-Random"><a href="#随机均衡-Random" class="headerlink" title="随机均衡(Random)"></a>随机均衡(Random)</h2><blockquote><p>把来自网络的请求随机分配给内部中的多个服务器。</p></blockquote><h2 id="权重随机均衡-Weighted-Random"><a href="#权重随机均衡-Weighted-Random" class="headerlink" title="权重随机均衡(Weighted Random)"></a>权重随机均衡(Weighted Random)</h2><blockquote><p>此种均衡算法类似于权重轮循算法,不过在处理请求分担时是个随机选择的过程。</p></blockquote><h2 id="响应速度均衡-Response-Time-探测时间"><a href="#响应速度均衡-Response-Time-探测时间" class="headerlink" title="响应速度均衡(Response Time 探测时间)"></a>响应速度均衡(Response Time 探测时间)</h2><blockquote><p>负载均衡设备对内部各服务器发出一个探测请求(例如 Ping),然后根据内部中各服务器对探测请求的最快响应时间来决定哪一台服务器来响应客户端的服务请求。此种均衡算法能较好的反映服务器的当前运行状态,但这最快响应时间仅仅指的是负载均衡设备与服务器间的最快响应时间,而不是客户端与服务器间的最快响应时间。</p></blockquote><h2 id="最少连接数均衡-Least-Connection"><a href="#最少连接数均衡-Least-Connection" class="headerlink" title="最少连接数均衡(Least Connection)"></a>最少连接数均衡(Least Connection)</h2><blockquote><p>最少连接数均衡算法对内部中需负载的每一台服务器都有一个数据记录,记录当前该服务器正在处理的连接数量,当有新的服务连接请求时,将把当前请求分配给连接数最少的服务器,使均衡更加符合实际情况,负载更加均衡。此种均衡算法适合长时处理的请求服务,如 FTP。</p></blockquote><h2 id="处理能力均衡-CPU、内存"><a href="#处理能力均衡-CPU、内存" class="headerlink" title="处理能力均衡(CPU、内存)"></a>处理能力均衡(CPU、内存)</h2><blockquote><p>此种均衡算法将把服务请求分配给内部中处理负荷(根据服务器 CPU 型号、CPU 数量、内存大小及当前连接数等换算而成)最轻的服务器,由于考虑到了内部服务器的处理能力及当前网络运行状况,所以此种均衡算法相对来说更加精确,尤其适合运用到第七层(应用层)负载均衡的情况下。</p></blockquote><h2 id="DNS-响应均衡-Flash-DNS"><a href="#DNS-响应均衡-Flash-DNS" class="headerlink" title="DNS 响应均衡(Flash DNS)"></a>DNS 响应均衡(Flash DNS)</h2><blockquote><p>在此均衡算法下,分处在不同地理位置的负载均衡设备收到同一个客户端的域名解析请求,并在同一时间内把此域名解析成各自相对应服务器的 IP 地址并返回给客户端,则客户端将以最先收到的域名解析 IP 地址来继续请求服务,而忽略其它的 IP 地址响应。在种均衡策略适合应用在全局负载均衡的情况下,对本地负载均衡是没有意义的。</p></blockquote><h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><blockquote><p>一致性哈希一致性 Hash,相同参数的请求总是发到同一提供者。当某一台提供者挂时,原本发往该提供者的请求,基于虚拟节点,平摊到其它提供者,不会引起剧烈变动。</p></blockquote><h2 id="IP-地址散列-保证客户端服务器对应关系稳定"><a href="#IP-地址散列-保证客户端服务器对应关系稳定" class="headerlink" title="IP 地址散列(保证客户端服务器对应关系稳定)"></a>IP 地址散列(保证客户端服务器对应关系稳定)</h2><blockquote><p>通过管理发送方 IP 和目的地 IP 地址的散列,将来自同一发送方的分组(或发送至同一目的地的分组)统一转发到相同服务器的算法。当客户端有一系列业务需要处理而必须和一个服务器反复通信时,该算法能够以流(会话)为单位,保证来自相同客户端的通信能够一直在同一服务器中进行处理。</p></blockquote><h2 id="URL-散列"><a href="#URL-散列" class="headerlink" title="URL 散列"></a>URL 散列</h2><blockquote><p>通过管理客户端请求 URL 信息的散列,将发送至相同 URL 的请求转发至同一服务器的算法。</p></blockquote><h1 id="LVS"><a href="#LVS" class="headerlink" title="LVS"></a>LVS</h1><h2 id="LVS-原理"><a href="#LVS-原理" class="headerlink" title="LVS 原理"></a>LVS 原理</h2><h3 id="IPVS"><a href="#IPVS" class="headerlink" title="IPVS"></a>IPVS</h3><p>LVS 的 IP 负载均衡技术是通过 IPVS 模块来实现的,IPVS 是 LVS 集群系统的核心软件,它的主要作用是:安装在 Director Server 上,同时在 Director Server 上虚拟出一个 IP 地址,用户必须通过这个虚拟的 IP 地址访问服务器。这个虚拟 IP 一般称为 LVS 的 VIP,即 Virtual IP。访问的请求首先经过 VIP 到达负载调度器,然后由负载调度器从 Real Server 列表中选取一个服务节点响应用户的请求。 在用户的请求到达负载调度器后,调度器如何将请求发送到提供服务的 Real Server 节点,而 Real Server 节点如何返回数据给用户,是 IPVS 实现的重点技术。</p><blockquote><p>ipvs : 工作于内核空间,主要用于使用户定义的策略生效</p></blockquote><blockquote><p>ipvsadm : 工作于用户空间,主要用于用户定义和管理集群服务的工具</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/lvs.png" alt="avatar"></p><p>ipvs 工作于内核空间的 INPUT 链上,当收到用户请求某集群服务时,经过 PREROUTING 链,经检查本机路由表,送往 INPUT 链;在进入 netfilter 的 INPUT 链时,ipvs 强行将请求报文通过ipvsadm 定义的集群服务策略的路径改为 FORWORD 链,将报文转发至后端真实提供服务的主机。</p><p>LVS NAT 模式</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/lvs-nat.png" alt="avatar"></p><p>1.客户端将请求发往前端的负载均衡器,请求报文源地址是 CIP(客户端 IP),后面统称为 CIP),目标地址为 VIP(负载均衡器前端地址,后面统称为 VIP)。<br>2.负载均衡器收到报文后,发现请求的是在规则里面存在的地址,那么它将客户端请求报文的目标地址改为了后端服务器的 RIP 地址并将报文根据算法发送出去。<br>3.报文送到 Real Server 后,由于报文的目标地址是自己,所以会响应该请求,并将响应报文返还给 LVS。<br>4.然后 lvs 将此报文的源地址修改为本机并发送给客户端。</p><p>[注意]:在 NAT 模式中,Real Server 的网关必须指向 LVS,否则报文无法送达客户端</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h4><p>1、NAT 技术将请求的报文和响应的报文都需要通过 LB 进行地址改写,因此网站访问量比较大的时候 LB 负载均衡调度器有比较大的瓶颈,一般要求最多之能 10-20 台节点<br>2、只需要在 LB 上配置一个公网 IP 地址就可以了。<br>3、每台内部的 realserver 服务器的网关地址必须是调度器 LB 的内网地址。<br>4、NAT 模式支持对 IP 地址和端口进行转换。即用户请求的端口和真实服务器的端口可以不一致。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><p>集群中的物理服务器可以使用任何支持 TCP/IP 操作系统,只有负载均衡器需要一个合法的 IP 地址。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h4><p>扩展性有限。当服务器节点(普通 PC 服务器)增长过多时,负载均衡器将成为整个系统的瓶颈,因为所有的请求包和应答包的流向都经过负载均衡器。当服务器节点过多时,大量的数据包都交汇在负载均衡器那,速度就会变慢!</p><h2 id="LVS-DR-模式-局域网改写-mac-地址"><a href="#LVS-DR-模式-局域网改写-mac-地址" class="headerlink" title="LVS DR 模式(局域网改写 mac 地址)"></a>LVS DR 模式(局域网改写 mac 地址)</h2><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/lvs-dr.png" alt="avatar"></p><p>1.客户端将请求发往前端的负载均衡器,请求报文源地址是 CIP,目标地址为 VIP。<br>2.负载均衡器收到报文后,发现请求的是在规则里面存在的地址,那么它将客户端请求报文的源MAC 地址改为自己 DIP 的 MAC 地址,目标 MAC 改为了 RIP 的 MAC 地址,并将此包发送给 RS。<br>3.RS 发现请求报文中的目的 MAC 是自己,就会将次报文接收下来,处理完请求报文后,将响应报文通过 lo 接口送给 eth0 网卡直接发送给客户端。<br>注意:需要设置 lo 接口的 VIP 不能响应本地网络内的 arp 请求。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h4><p>1、通过在调度器 LB 上修改数据包的目的 MAC 地址实现转发。注意源地址仍然是 CIP,目的地址仍然是 VIP 地址。<br>2、请求的报文经过调度器,而 RS 响应处理后的报文无需经过调度器 LB,因此并发访问量大时使用效率很高(和 NAT 模式比)<br>3、因为 DR 模式是通过 MAC 地址改写机制实现转发,因此所有 RS 节点和调度器 LB 只能在一个局域网里面<br>4、RS 主机需要绑定 VIP 地址在 LO 接口(掩码 32 位)上,并且需要配置 ARP 抑制。<br>5、RS 节点的默认网关不需要配置成 LB,而是直接配置为上级路由的网关,能让 RS 直接出网就可以。<br>6、由于 DR 模式的调度器仅做 MAC 地址的改写,所以调度器 LB 就不能改写目标端口,那么 RS服务器就得使用和 VIP 相同的端口提供服务。<br>7、直接对外的业务比如 WEB 等,RS 的 IP 最好是使用公网 IP。对外的服务,比如数据库等最好使用内网 IP。</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点:"></a>优点:</h4><p>和 TUN(隧道模式)一样,负载均衡器也只是分发请求,应答包通过单独的路由方法返回给客户端。与 VS-TUN 相比,VS-DR 这种实现方式不需要隧道结构,因此可以使用大多数操作系统做为物理服务器。DR 模 式 的 效 率 很 高 , 但 是 配 置 稍 微 复 杂 一 点 , 因 此 对 于 访 问 量 不 是 特 别 大 的 公 司 可 以 用haproxy/nginx 取代。日 1000-2000W PV 或者并发请求 1 万一下都可以考虑用 haproxy/nginx。</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点:"></a>缺点:</h4><p>所有 RS 节点和调度器 LB 只能在一个局域网里面</p><h2 id="LVS-TUN-模式-IP-封装、跨网段"><a href="#LVS-TUN-模式-IP-封装、跨网段" class="headerlink" title="LVS TUN 模式(IP 封装、跨网段)"></a>LVS TUN 模式(IP 封装、跨网段)</h2><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/lvs-tun.png" alt="avatar"></p><p>1.客户端将请求发往前端的负载均衡器,请求报文源地址是 CIP,目标地址为 VIP。<br>2.负载均衡器收到报文后,发现请求的是在规则里面存在的地址,那么它将在客户端请求报文的首部再封装一层 IP 报文,将源地址改为 DIP,目标地址改为 RIP,并将此包发送给 RS。<br>3.RS 收到请求报文后,会首先拆开第一层封装,然后发现里面还有一层 IP 首部的目标地址是自己lo 接口上的 VIP,所以会处理次请求报文,并将响应报文通过 lo 接口送给 eth0 网卡直接发送给客户端。</p><p>注意:需要设置 lo 接口的 VIP 不能在共网上出现。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结:"></a>总结:</h4><p>1.TUNNEL 模式必须在所有的 realserver 机器上面绑定 VIP 的 IP 地址<br>2.TUNNEL 模式的 vip ——&gt;realserver 的包通信通过 TUNNEL 模式,不管是内网和外网都能通信,所以不需要 lvs vip 跟 realserver 在同一个网段内。<br>3.TUNNEL 模式 realserver 会把 packet 直接发给 client 不会给 lvs 了<br>4.TUNNEL 模式走的隧道模式,所以运维起来比较难,所以一般不用。</p><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点:"></a>优点:</h5><p>负载均衡器只负责将请求包分发给后端节点服务器,而 RS 将应答包直接发给用户。所以,减少了负载均衡器的大量数据流动,负载均衡器不再是系统的瓶颈,就能处理很巨大的请求量,这种方式,一台负载均衡器能够为很多 RS 进行分发。而且跑在公网上就能进行不同地域的分发。</p><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点:"></a>缺点:</h5><p>隧 道 模 式 的 RS 节 点 需 要 合 法 IP , 这 种 方 式 需 要 所 有 的 服 务 器 支 持 ” IP Tunneling ” (IPEncapsulation)协议,服务器可能只局限在部分 Linux 系统上。</p><h1 id="LVS-FULLNAT-模式"><a href="#LVS-FULLNAT-模式" class="headerlink" title="LVS FULLNAT 模式"></a>LVS FULLNAT 模式</h1><p>无论是 DR 还是 NAT 模式,不可避免的都有一个问题:LVS 和 RS 必须在同一个 VLAN 下,否则LVS 无法作为 RS 的网关。这引发的两个问题是:<br>1、同一个 VLAN 的限制导致运维不方便,跨 VLAN 的 RS 无法接入。<br>2、LVS 的水平扩展受到制约。当 RS 水平扩容时,总有一天其上的单点 LVS 会成为瓶颈。</p><p>Full-NAT 由此而生,解决的是 LVS 和 RS 跨 VLAN 的问题,而跨 VLAN 问题解决后,LVS 和 RS不再存在 VLAN 上的从属关系,可以做到多个 LVS 对应多个 RS,解决水平扩容的问题。<br>Full-NAT 相比 NAT 的主要改进是,在 SNAT/DNAT 的基础上,加上另一种转换,转换过程如下:</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/lvs-full-nat.png" alt="avatar"></p><p>1.在包从 LVS 转到 RS 的过程中,源地址从客户端 IP 被替换成了 LVS 的内网 IP。内网 IP 之间可以通过多个交换机跨 VLAN 通信。目标地址从 VIP 修改为 RS IP.<br>2.当 RS 处理完接受到的包,处理完成后返回时,将目标地址修改为 LVS ip,原地址修改为 RSIP,最终将这个包返回给 LVS 的内网 IP,这一步也不受限于 VLAN。<br>3.LVS 收到包后,在 NAT 模式修改源地址的基础上,再把 RS 发来的包中的目标地址从 LVS 内网 IP 改为客户端的 IP,并将原地址修改为 VIP。</p><p>Full-NAT 主要的思想是把网关和其下机器的通信,改为了普通的网络通信,从而解决了跨 VLAN 的问题。采用这种方式,LVS 和 RS 的部署在 VLAN 上将不再有任何限制,大大提高了运维部署的便利性。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ol><li>FULL NAT 模式不需要 LBIP 和 realserver ip 在同一个网段;</li><li>full nat 因为要更新 sorce ip 所以性能正常比 nat 模式下降 10%</li></ol><h1 id="Keepalive"><a href="#Keepalive" class="headerlink" title="Keepalive"></a>Keepalive</h1><p>keepalive 起初是为 LVS 设计的,专门用来监控 lvs 各个服务节点的状态,后来加入了 vrrp 的功能,因此除了 lvs,也可以作为其他服务(nginx,haproxy)的高可用软件。VRRP 是 virtualrouter redundancy protocal(虚拟路由器冗余协议)的缩写。VRRP 的出现就是为了解决静态路由出现的单点故障,它能够保证网络可以不间断的稳定的运行。所以 keepalive 一方面具有 LVScluster node healthcheck 功能,另一方面也具有 LVS director failover。</p><h2 id="Nginx-反向代理负载均衡"><a href="#Nginx-反向代理负载均衡" class="headerlink" title="Nginx 反向代理负载均衡"></a>Nginx 反向代理负载均衡</h2><p>普通的负载均衡软件,如 LVS,其实现的功能只是对请求数据包的转发、传递,从负载均衡下的节点服务器来看,接收到的请求还是来自访问负载均衡器的客户端的真实用户;而反向代理就不一样了,反向代理服务器在接收访问用户请求后,会代理用户 重新发起请求代理下的节点服务器,最后把数据返回给客户端用户。在节点服务器看来,访问的节点服务器的客户端用户就是反向代理服务器,而非真实的网站访问用户。</p><h2 id="upstream-module-和健康检测"><a href="#upstream-module-和健康检测" class="headerlink" title="upstream_module 和健康检测"></a>upstream_module 和健康检测</h2><p>ngx_http_upstream_module 是负载均衡模块,可以实现网站的负载均衡功能即节点的健康检查,upstream 模块允许 Nginx 定义一组或多组节点服务器组,使用时可通过 proxy_pass 代理方式把网站的请求发送到事先定义好的对应 Upstream 组 的名字上。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/nginx-table.png" alt="avatar"></p><p>proxy_pass 请求转发<br>proxy_pass 指令属于 ngx_http_proxy_module 模块,此模块可以将请求转发到另一台服务器,在实际的反向代理工作中,会通过 location 功能匹配指定的 URI,然后把接收到服务匹配 URI 的<br>请求通过 proyx_pass 抛给定义好的 upstream 节点池。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jshelllanguage">location &#x2F;download&#x2F; &#123;<br>    proxy_pass http:&#x2F;&#x2F;download&#x2F;vedio&#x2F;;<br>&#125;<br>&#x2F;&#x2F;这是前端代理节点的设置<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/proxy-model-param.png" alt="avatar"></p><h1 id="HAProxy"><a href="#HAProxy" class="headerlink" title="HAProxy"></a>HAProxy</h1>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
    </categories>
    
    
    <tags>
      
      <tag>负载均衡</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2020/08/26/design-pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/08/26/design-pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><ul><li>设计原则</li><li>工厂方法模式</li><li>抽象工厂模式</li><li>单例模式</li><li>建造者模式</li><li>原型模式</li><li>适配器模式</li><li>装饰器模式</li><li>代理模式</li><li>外观模式</li><li>桥接模式</li><li>组合模式</li><li>享元模式</li><li>策略模式</li><li>模板方法模式</li><li>观察者模式</li><li>迭代子模式</li><li>责任链模式</li><li>命令模式</li><li>备忘录模式</li><li>状态模式</li><li>访问者模式</li><li>中介者模式</li><li>解释器模式</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程思想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库篇-Cassandra数据库</title>
    <link href="/2020/08/26/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87-Cassandra%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2020/08/26/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87-Cassandra%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><blockquote><p>Apache Cassandra 是高度可扩展的,高性能的分布式 NoSQL 数据库。 Cassandra 旨在处理许多商品服务器上的大量数据,提供高可用性而无需担心单点故障。Cassandra 具有能够处理大量数据的分布式架构。 数据放置在具有多个复制因子的不同机器上,以获得高可用性,而无需担心单点故障。</p></blockquote><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>Key Space(对应 SQL 数据库中的 database)</p><p>1.一个 Key Space 中可包含若干个 CF,如同 SQL 数据库中一个 database 可包含多个 table</p><p>Key(对应 SQL 数据库中的主键)</p><p>2.在 Cassandra 中,每一行数据记录是以 key/value 的形式存储的,其中 key 是唯一标识。</p><p>column(对应 SQL 数据库中的列)</p><p>3.Cassandra 中每个 key/value 对中的 value 又称为 column,它是一个三元组,即:name,value 和 timestamp,其中 name 需要是唯一的。super column(SQL 数据库不支持)</p><p>4.cassandra 允许 key/value 中的 value 是一个 map(key/value_list),即某个 column 有多个子列。Standard Column Family(相对应 SQL 数据库中的 table)</p><p>5.每个 CF 由一系列 row 组成,每个 row 包含一个 key 以及其对应的若干 column。</p><p>Super Column Family(SQL 数据库不支持)</p><p>6.每个 SCF 由一系列 row 组成,每个 row 包含一个 key 以及其对应的若干 super column。</p><p>Cassandra 一致 Hash 和虚拟节点</p><h2 id="一致性-Hash-多米诺-down-机"><a href="#一致性-Hash-多米诺-down-机" class="headerlink" title="一致性 Hash(多米诺 down 机)"></a>一致性 Hash(多米诺 down 机)</h2><p>为每个节点分配一个 token,根据这个 token 值来决定节点在集群中的位置以及这个节点所存储的数据范围。</p><h2 id="虚拟节点-down-机多节点托管"><a href="#虚拟节点-down-机多节点托管" class="headerlink" title="虚拟节点(down 机多节点托管)"></a>虚拟节点(down 机多节点托管)</h2><p>由于这种方式会造成数据分布不均的问题,在 Cassandra1.2 以后采用了虚拟节点的思想:不需要为每个节点分配 token,把圆环分成更多部分,让每个节点负责多个部分的数据,这样一个节点移除后,它所负责的多个 token 会托管给多个节点处理,这种思想解决了数据分布不均的问题。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/Cassandra-node.png" alt="avatar"></p><p>如图所示,上面部分是标准一致性哈希,每个节点负责圆环中连续的一段,如果 Node2 突然down 掉,Node2 负责的数据托管给 Node1,即 Node1 负责 EFAB 四段,如果 Node1 里面有<br>很多热点用户产生的数据导致 Node1 已经有点撑不住了,恰巧 B 也是热点用户产生的数据,这样一来 Node1 可能会接着 down 机,Node1down 机,Node6 还 hold 住吗?<br>下面部分是虚拟节点实现,每个节点不再负责连续部分,且圆环被分为更多的部分。如果 Node2突然 down 掉,Node2 负责的数据不全是托管给 Node1,而是托管给多个节点。而且也保持了一<br>致性哈希的特点。</p><h1 id="Gossip-协议"><a href="#Gossip-协议" class="headerlink" title="Gossip 协议"></a>Gossip 协议</h1><p>Gossip 算法如其名,灵感来自办公室八卦,只要一个人八卦一下,在有限的时间内所有的人都会知道该八卦的信息,这种方式也与病毒传播类似,因此 Gossip 有众多的别名“闲话算法”、“疫情传播算法”、“病毒感染算法”、“谣言传播算法”。 Gossip 的特点:在一个有界网络中,每个节点都随机地与其他节点通信,经过一番杂乱无章的通信,最终所有节点的状态都会达成一致。因为 Gossip 不要求节点知道所有其他节点,因此又具有去中心化的特点,节点之间完全对等,不需要任何的中心节点。实际上 Gossip 可以用于众多能接受“最终一致性”的领域:失败检测、路由同步、Pub/Sub、动态负载均衡。</p><h2 id="Gossip-节点的通信方式及收敛性"><a href="#Gossip-节点的通信方式及收敛性" class="headerlink" title="Gossip 节点的通信方式及收敛性"></a>Gossip 节点的通信方式及收敛性</h2><p>Gossip 两个节点( A 、 B )之间存在三种通信方式( push 、 pull 、 push&amp;pull )</p><p>1.push: A 节点将数据(key,value,version)及对应的版本号推送给 B 节点,B 节点更新 A 中比自己新的数据。<br>2.pull:A 仅将数据 key,version 推送给 B,B 将本地比 A 新的数据(Key,value,version)推送给 A,A 更新本地。<br>3.push/pull:与 pull 类似,只是多了一步,A 再将本地比 B 新的数据推送给 B,B 更新本地。</p><p>如果把两个节点数据同步一次定义为一个周期,则在一个周期内,push 需通信 1 次,pull 需 2 次,push/pull 则需 3 次,从效果上来讲,push/pull 最好,理论上一个周期内可以使两个节点完全一致。直观上也感觉,push/pull 的收敛速度是最快的。</p><h3 id="gossip-的协议和-seed-list-防止集群分列"><a href="#gossip-的协议和-seed-list-防止集群分列" class="headerlink" title="gossip 的协议和 seed list (防止集群分列)"></a>gossip 的协议和 seed list (防止集群分列)</h3><p>cassandra 使用称为 gossip 的协议来发现加入 C 集群中的其他节点的位置和状态信息。gossip 进程每秒都在进行,并与至多三个节点交换状态信息。节点交换他们自己和所知道的信息,于是所有的节点很快就能学习到整个集群中的其他节点的信息。gossip 信息有一个相关的版本号,于是在一次 gossip 信息交换中,旧的信息会被新的信息覆盖重写。要阻止分区进行 gossip 交流,那么在集群中的所有节点中使用相同的 seed list,种子节点的指定除了启动起 gossip 进程外,没有其他的目的。种子节点不是一个单点故障,他们在集群操作中也没有其他的特殊目的,除了引导节点以外</p><h1 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h1><p>Partitioners(计算 primary key token 的 hash 函数)</p><p>在 Cassandra 中,table 的每行由唯一的 primarykey 标识,partitioner 实际上为一 hash 函数用以计算 primary key 的 token。Cassandra 依据这个 token 值在集群中放置对应的行</p><h3 id="两种可用的复制策略"><a href="#两种可用的复制策略" class="headerlink" title="两种可用的复制策略:"></a>两种可用的复制策略:</h3><p>SimpleStrategy :仅用于单数据中心,将第一个 replica 放在由 partitioner 确定的节点中,其余的 replicas 放在上述节点顺时针方向的后续节点中。<br>NetworkTopologyStrategy :可用于较复杂的多数据中心。</p><p>可以指定在每个数据中心分别存储多少份 replicas。<br>复制策略在创建 keyspace 时指定,如</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">KEYSPACE</span> Excelsior <span class="hljs-keyword">WITH</span> REPLICATION = &#123; <span class="hljs-string">&#x27;class&#x27;</span> :<span class="hljs-string">&#x27;SimpleStrategy&#x27;</span>,<span class="hljs-string">&#x27;replication_factor&#x27;</span> : <span class="hljs-number">3</span> &#125;;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">KEYSPACE</span> Excalibur <span class="hljs-keyword">WITH</span> REPLICATION = &#123;<span class="hljs-string">&#x27;class&#x27;</span> :<span class="hljs-string">&#x27;NetworkTopologyStrategy&#x27;</span>,<span class="hljs-string">&#x27;dc1&#x27;</span> : <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;dc2&#x27;</span> : <span class="hljs-number">2</span>&#125;;<br></code></pre></td></tr></table></figure><h1 id="数据写请求和协调者"><a href="#数据写请求和协调者" class="headerlink" title="数据写请求和协调者"></a>数据写请求和协调者</h1><h3 id="协调者-coordinator"><a href="#协调者-coordinator" class="headerlink" title="协调者(coordinator)"></a>协调者(coordinator)</h3><p>协调者(coordinator)将 write 请求发送到拥有对应 row 的所有 replica 节点,只要节点可用便获取并执行写请求。写一致性级别(write consistency level)确定要有多少个 replica 节点必须返回成功的确认信息。成功意味着数据被正确写入了 commit log 和 memtable。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/cassandra-coordinator.png" alt="avatar"></p><p>其中 dc1、dc2 这些数据中心名称要与 snitch 中配置的名称一致.上面的拓扑策略表示在 dc1 配置3 个副本,在 dc2 配置 2 个副本</p><h2 id="数据读请求和后台修复"><a href="#数据读请求和后台修复" class="headerlink" title="数据读请求和后台修复"></a>数据读请求和后台修复</h2><ol><li>协调者首先与一致性级别确定的所有 replica 联系,被联系的节点返回请求的数据。</li><li>若多个节点被联系,则来自各 replica 的 row 会在内存中作比较,若不一致,则协调者使用含最新数据的 replica 向 client 返回结果。那么比较操作过程中只需要传递时间戳就可以,因为要比较的只是哪个副本数据是最新的。</li><li>协调者在后台联系和比较来自其余拥有对应 row 的 replica 的数据,若不一致,会向过时的replica 发写请求用最新的数据进行更新 read repair。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/cassandra-coordinator-2.png" alt="avatar"></p><h1 id="数据存储-CommitLog、MemTable、SSTable"><a href="#数据存储-CommitLog、MemTable、SSTable" class="headerlink" title="数据存储( CommitLog、MemTable、SSTable )"></a>数据存储( CommitLog、MemTable、SSTable )</h1><p>写请求分别到 CommitLog 和 MemTable, 并且 MemTable 的数据会刷写到磁盘 SSTable 上. 除了写数据,还有索引也会保存到磁盘上.先将数据写到磁盘中的 commitlog,同时追加到中内存中的数据结构 memtable 。这个时候就会返回客户端状态,memtable内容超出指定容量后会被放进将被刷入磁盘的队列<br>(memtable_flush_queue_size 配置队列长度)。若将被刷入磁盘的数据超出了队列长度,将内存数据刷进磁盘中的 SSTable,之后 commit log 被清空。<br>SSTable 文件构成(BloomFilter、index、data、static)<br>SSTable 文件有 fileer(判断数据 key 是否存在,这里使用了 BloomFilter 提高效率),index(寻找对应 column 值所在 data 文件位置)文件,data(存储真实数据)文件,static(存储和统计column 和 row 大小)文件。</p><h2 id="二级索引-对要索引的-value-摘要-生成-RowKey"><a href="#二级索引-对要索引的-value-摘要-生成-RowKey" class="headerlink" title="二级索引(对要索引的 value 摘要,生成 RowKey)"></a>二级索引(对要索引的 value 摘要,生成 RowKey)</h2><p>在 Cassandra 中,数据都是以 Key-value 的形式保存的。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/cassandra-columfamily.png" alt="avatar"></p><p>KeysIndex 所创建的二级索引也被保存在一张 ColumnFamily 中。在插入数据时,对需要进行索引的 value 进行摘要,生成独一无二的 key,将其作为 RowKey 保存在索引的 ColumnFamily 中;同时在 RowKey 上添加一个 Column,将插入数据的 RowKey 作为 name 域的值,value 域则赋空值,timestamp 域则赋为插入数据的时间戳。</p><p>如果有相同的 value 被索引了,则会在索引 ColumnFamily 中相同的 RowKey 后再添加新的Column。如果有新的 value 被索引,则会在索引 ColumnFamily 中添加新的 RowKey 以及对应新的 Column。</p><p>当对 value 进行查询时,只需计算该 value 的 RowKey,在索引 ColumnFamily 中的查找该RowKey,对其 Columns 进行遍历就能得到该 value 所有数据的 RowKey。</p><h1 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h1><p>数据写入和更新(数据追加)</p><p>Cassandra 的设计思路与这些系统不同,无论是 insert 还是 remove 操作,都是在已有的数据后面进行追加,而不修改已有的数据。这种设计称为 Log structured 存储,顾名思义就是系统中的<br>数据是以日志的形式存在的,所以只会将新的数据追加到已有数据的后面。Log structured 存储系统有两个主要优点:<code>数据的写和删除效率极高</code>传统的存储系统需要更新元信息和数据,因此磁盘的磁头需要反复移动,这是一个比较耗时的操作,而 Log structured 的系统则是顺序写,可以充分利用文件系统的 cache,所以效率很高。</p><p><code>错误恢复简单</code></p><p>由于数据本身就是以日志形式保存,老的数据不会被覆盖,所以在设计 journal 的时候不需要考虑 undo,简化了错误恢复。</p><p><code>读的复杂度高</code></p><p>但是,Log structured 的存储系统也引入了一个重要的问题:读的复杂度和性能。理论上说,读操作需要从后往前扫描数据,以找到某个记录的最新版本。相比传统的存储系统,这是比较耗时的。</p><p><a href="https://blog.csdn.net/fs1360472174/article/details/55005335">参考</a></p><h3 id="数据删除-column-的墓碑"><a href="#数据删除-column-的墓碑" class="headerlink" title="数据删除(column 的墓碑)"></a>数据删除(column 的墓碑)</h3><p>如果一次删除操作在一个节点上失败了(总共 3 个节点,副本为 3, RF=3).整个删除操作仍然被认为成功的(因为有两个节点应答成功,使用 CL.QUORUM 一致性)。接下来如果读发生在该节点上就会变的不明确,因为结果返回是空,还是返回数据,没有办法确定哪一种是正确的。</p><p>Cassandra 总是认为返回数据是对的,那就会发生删除的数据又出现了的事情,这些数据可以叫”僵尸”,并且他们的表现是不可预见的。</p><h1 id="墓碑"><a href="#墓碑" class="headerlink" title="墓碑"></a>墓碑</h1><p>删除一个 column 其实只是插入一个关于这个 column 的墓碑(tombstone),并不直接删除原有的 column。该墓碑被作为对该 CF 的一次修改记录在 Memtable 和 SSTable 中。墓碑的内容是删除请求被执行的时间,该时间是接受客户端请求的存储节点在执行该请求时的本地时间(local delete time),称为本地删除时间。需要注意区分本地删除时间和时间戳,每个 CF 修改记录都有一个时间戳,这个时间戳可以理解为该 column 的修改时间,是由客户端给定的。</p><h2 id="垃圾回收-compaction"><a href="#垃圾回收-compaction" class="headerlink" title="垃圾回收 compaction"></a>垃圾回收 compaction</h2><p>由于被删除的 column 并不会立即被从磁盘中删除,所以系统占用的磁盘空间会越来越大,这就需要有一种垃圾回收的机制,定期删除被标记了墓碑的 column。垃圾回收是在 compaction 的过程中完成的。</p><h2 id="数据读取-memtable-SStables"><a href="#数据读取-memtable-SStables" class="headerlink" title="数据读取( memtable+SStables )"></a>数据读取( memtable+SStables )</h2><p>为了满足读 cassandra 读取的数据是 memtable 中的数据和 SStables 中数据的合并结果。读取SSTables 中的数据就是查找到具体的哪些的 SSTables 以及数据在这些 SSTables 中的偏移量(SSTables 是按主键排序后的数据块)。首先如果 row cache enable 了话,会检测缓存。缓存命中直接返回数据,没有则查找 Bloom filter,查找可能的 SSTable。然后有一层 Partition key cache,找 partition key 的位置。如果有根据找到的 partition 去压缩偏移量映射表找具体的数据块。如果缓存没有,则要经过 Partition summary,Partition index 去找 partition key。然后经过压缩偏移量映射表找具体的数据块。</p><ol><li>检查 memtable</li><li>如果 enabled 了,检查 row cache</li><li>检查 Bloom filter</li><li>如果 enable 了,检查 partition key 缓存</li><li>如果在 partition key 缓存中找到了 partition key,直接去 compression offset 命中,如果没有,检查 partition summary</li><li>根据 compression offset map 找到数据位置</li><li>从磁盘的 SSTable 中取出数据</li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/cassandra-row-cache.png" alt="avatar"></p><p>行缓存和键缓存请求流程图</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/cassandra-key-cache.png" alt="avatar"></p><p>MemTable:如果 memtable 有目标分区数据,这个数据会被读出来并且和从 SSTables 中读出来的数据进行合并。SSTable 的数据访问如下面所示的步骤。Row Cache ( SSTables 中频繁被访问的数据)在 Cassandra2.2+,它们被存储在堆外内存,使用全新的实现避免造成垃圾回收对 JVM 造成压力。存在在 row cache 的子集数据可以在特定的一段时间内配置一定大小的内存。row cache 使用LRU(least-recently-userd)进行回收在申请内存。存储在 row cache 中的数据是 SSTables 中频繁被访问的数据。存储到 row cache 中后,数据就可以被后续的查询访问。row cache 不是写更新。如果写某行了,这行的缓存就会失效,并且不会被继续缓存,直到这行被读到。类似的,如果一个 partition 更新了,整个 partition 的 cache 都会被移除,但目标的数据在 row cache 中找不到,就会去检查 Bloom filter。</p><h2 id="Bloom-Filter-查找数据可能对应的-SSTable"><a href="#Bloom-Filter-查找数据可能对应的-SSTable" class="headerlink" title="Bloom Filter (查找数据可能对应的 SSTable )"></a>Bloom Filter (查找数据可能对应的 SSTable )</h2><blockquote><p>首先,Cassandra 检查 Bloom filter 去发现哪个 SSTables 中有可能有请求的分区数据。Bloomfilter 是存储在堆外内存。每个 SSTable 都有一个关联的 Bloom filter。一个 Bloom filter 可以建立一个 SSTable 没有包含的特定的分区数据。同样也可以找到分区数据存在 SSTable 中的可能性。它可以加速查找 partition key 的查找过程。然而,因为 Bloom filter 是一个概率函数,所以可能会得到错误的结果,并不是所有的 SSTables 都可以被 Bloom filter 识别出是否有数据。如果Bloom filter 不能够查找到 SSTable,Cassandra 会检查 partition key cache。Bloom filter 大小增长很适宜,每 10 亿数据 1~2GB。在极端情况下,可以一个分区一行。都可以很轻松的将数十亿的 entries 存储在单个机器上。Bloom filter 是可以调节的,如果你愿意用内存来换取性能。</p></blockquote><h2 id="Partition-Key-Cache-查找数据可能对应的-Partition-key"><a href="#Partition-Key-Cache-查找数据可能对应的-Partition-key" class="headerlink" title="Partition Key Cache (查找数据可能对应的 Partition key )"></a>Partition Key Cache (查找数据可能对应的 Partition key )</h2><blockquote><p>partition key 缓存如果开启了,将 partition index 存储在堆外内存。key cache 使用一小块可配置大小的内存。在读的过程中,每个”hit”保存一个检索。如果在 key cache 中找到了 partitionkey。就直接到 compression offset map 中招对应的块。partition key cache 热启动后工作的更好,相比较冷启动,有很大的性能提升。如果一个节点上的内存非常受限制,可能的话,需要限制保存在 key cache 中的 partition key 数目。如果一个在 key cache 中没有找到 partition key。就会去 partition summary 中去找。partition key cache 大小是可以配置的,意义就是存储在 keycache 中的 partition keys 数目。</p></blockquote><h2 id="Partition-Summary-内存中存储一些-partition-index-的样本"><a href="#Partition-Summary-内存中存储一些-partition-index-的样本" class="headerlink" title="Partition Summary (内存中存储一些 partition index 的样本)"></a>Partition Summary (内存中存储一些 partition index 的样本)</h2><blockquote><p>partition summary 是存储在堆外内存的结构,存储一些 partition index 的样本。如果一个partition index 包含所有的 partition keys。鉴于一个 partition summary 从每 X 个 keys 中取样,然后将每 X 个 key map 到 index 文件中。例如,如果一个 partition summary 设置了 20keys进行取样。它就会存储 SSTable file 开始的一个 key,20th 个 key,以此类推。尽管并不知道artition key 的具体位置,partition summary 可以缩短找到 partition 数据位置。当找到了partition key 值可能的范围后,就会去找 partition index。通过配置取样频率,你可以用内存来换取性能,当 partition summary 包含的数据越多,使用的内存越多。可以通过表定义的 indexinterval 属性来改变样本频率。固定大小的内存可以通过 index_summary_capacity_in_mb 属性来设置,默认是堆大小的 5%。</p></blockquote><h2 id="Partition-Index-磁盘中"><a href="#Partition-Index-磁盘中" class="headerlink" title="Partition Index (磁盘中)"></a>Partition Index (磁盘中)</h2><blockquote><p>partition index 驻扎在磁盘中,索引所有 partition keys 和偏移量的映射。如果 partitionsummary 已经查到 partition keys 的范围,现在的检索就是根据这个范围值来检索目标 partitionkey。需要进行单次检索和顺序读。根据找到的信息。然后去 compression offset map 中去找磁盘中有这个数据的块。如果 partition index 必须要被检索,则需要检索两次磁盘去找到目标数据。Compression offset map (磁盘中)compression offset map 存储磁盘数据准确位置的指针。存储在堆外内存,可以被 partition keycache 或者 partition index 访问。一旦 compression offset map 识别出来磁盘中的数据位置,就会从正确的 SStable(s)中取出数据。查询就会收到结果集。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cassandra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库篇-MongoDb</title>
    <link href="/2020/08/26/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87-MongoDb/"/>
    <url>/2020/08/26/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87-MongoDb/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>MongoDB 是由 C++语言编写的,是一个基于分布式文件存储的开源数据库系统。在高负载的情况下,添加更多的节点,可以保证服务器性能。MongoDB 旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。<br>MongoDB 将数据存储为一个文档,数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档,数组及文档数组。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/column-based.png" alt="avatar"></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li><p>MongoDB 是一个面向文档存储的数据库,操作起来比较简单和容易。</p></li><li><p>你可以在 MongoDB 记录中设置任何属性的索引 (如:FirstName=”Sameer”,Address=”8 Gandhi Road”)来实现更快的排序。</p></li><li><p>你可以通过本地或者网络创建数据镜像,这使得 MongoDB 有更强的扩展性。</p></li><li><p>如果负载的增加(需要更多的存储空间和更强的处理能力) ,它可以分布在计算机网络中的其他节点上这就是所谓的分片。</p></li><li><p>Mongo 支持丰富的查询表达式。查询指令使用 JSON 形式的标记,可轻易查询文档中内嵌的对象及数组。</p></li><li><p>MongoDb 使用 update()命令可以实现替换完成的文档(数据)或者一些指定的数据字段 。</p></li><li><p>Mongodb 中的 Map/reduce 主要是用来对数据进行批量处理和聚合操作。</p></li><li><p>Map 和 Reduce。Map 函数调用 emit(key,value)遍历集合中所有的记录,将 key 与 value 传给 Reduce 函数进行处理。</p></li><li><p>Map 函数和 Reduce 函数是使用 Javascript 编写的,并可以通过 db.runCommand 或 mapreduce 命令来执行 MapReduce 操作。</p></li><li><p>GridFS 是 MongoDB 中的一个内置功能,可以用于存放大量小文件。</p></li><li><p>MongoDB 允许在服务端执行脚本,可以用 Javascript 编写某个函数,直接在服务端执行,也可以把函数的定义存储在服务端,下次直接调用即可。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库篇-Hbase</title>
    <link href="/2020/08/19/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87-Hbase/"/>
    <url>/2020/08/19/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87-Hbase/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>base 是分布式、面向列的开源数据库(其实准确的说是面向列族)。HDFS 为 Hbase 提供可靠的底层数据存储服务,MapReduce 为 Hbase 提供高性能的计算能力,Zookeeper 为 Hbase 提供稳定服务和 Failover 机制,因此我们说 Hbase 是一个通过大量廉价的机器解决海量数据的高速存储和读取的分布式数据库解决方案。</p><h1 id="列式存储"><a href="#列式存储" class="headerlink" title="列式存储"></a>列式存储</h1><p>列方式所带来的重要好处之一就是,由于查询中的选择规则是通过列来定义的,因此整个数据库是自动索引化的。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/column-based.png" alt="avatar"></p><p>这里的列式存储其实说的是列族存储,Hbase 是根据列族来存储数据的。列族下面可以有非常多的列,列族在创建表的时候就必须指定。为了加深对 Hbase 列族的理解,下面是一个简单的关系型数据库的表和 Hbase 数据库的表:</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/hbase-table.png" alt="avatar"></p><h1 id="Hbase-核心概念"><a href="#Hbase-核心概念" class="headerlink" title="Hbase 核心概念"></a>Hbase 核心概念</h1><h2 id="Column-Family-列族"><a href="#Column-Family-列族" class="headerlink" title="Column Family 列族"></a>Column Family 列族</h2><p>Column Family 又叫列族,Hbase 通过列族划分数据的存储,列族下面可以包含任意多的列,实现灵活的数据存取。Hbase 表的创建的时候就必须指定列族。就像关系型数据库创建的时候必须指定具体的列是一样的。Hbase 的列族不是越多越好,官方推荐的是列族最好小于或者等于 3。我们使用的场景一般是 1 个列族。</p><h2 id="Rowkey-Rowkey-查询-Rowkey-范围扫描-全表扫描"><a href="#Rowkey-Rowkey-查询-Rowkey-范围扫描-全表扫描" class="headerlink" title="Rowkey( Rowkey 查询,Rowkey 范围扫描,全表扫描)"></a>Rowkey( Rowkey 查询,Rowkey 范围扫描,全表扫描)</h2><p>Rowkey 的概念和 mysql 中的主键是完全一样的,Hbase 使用 Rowkey 来唯一的区分某一行的数据。Hbase 只支持 3 中查询方式:基于 Rowkey 的单行查询,基于 Rowkey 的范围扫描,全表扫描。</p><h2 id="Region-分区"><a href="#Region-分区" class="headerlink" title="Region 分区"></a>Region 分区</h2><p>Region:Region 的概念和关系型数据库的分区或者分片差不多。Hbase 会将一个大表的数据基于 Rowkey 的不同范围分配到不通的 Region 中,每个 Region 负责一定范围的数据访问和存储。这样即使是一张巨大的表,由于被切割到不通的 region,访问起来的时延也很低。</p><h2 id="TimeStamp-多版本"><a href="#TimeStamp-多版本" class="headerlink" title="TimeStamp 多版本"></a>TimeStamp 多版本</h2><p>TimeStamp 是实现 Hbase 多版本的关键。在 Hbase 中使用不同的 timestame 来标识相同rowkey 行对应的不通版本的数据。在写入数据的时候,如果用户没有指定对应的timestamp,Hbase 会自动添加一个 timestamp,timestamp 和服务器时间保持一致。在Hbase 中,相同 rowkey 的数据按照 timestamp 倒序排列。默认查询的是最新的版本,用户可同指定 timestamp 的值来读取旧版本的数据。</p><h1 id="Hbase-核心架构"><a href="#Hbase-核心架构" class="headerlink" title="Hbase 核心架构"></a>Hbase 核心架构</h1><p>Hbase 是由 Client、Zookeeper、Master、HRegionServer、HDFS 等几个组建组成。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/hbase-core.png" alt="avatar"></p><h3 id="Client"><a href="#Client" class="headerlink" title="Client:"></a>Client:</h3><p>Client 包含了访问 Hbase 的接口,另外 Client 还维护了对应的 cache 来加速 Hbase 的访问,比如 cache 的.META.元数据的信息。</p><h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper:"></a>Zookeeper:</h3><p>Hbase 通过 Zookeeper 来做 master 的高可用、RegionServer 的监控、元数据的入口以及集群配置的维护等工作。具体工作如下:</p><p>1.通过 Zoopkeeper 来保证集群中只有 1 个 master 在运行,如果 master 异常,会通过竞争机制产生新的 master 提供服务<br>2.通过 Zoopkeeper 来监控 RegionServer 的状态,当 RegionSevrer 有异常的时候,通过回调的形式通知 Master RegionServer 上下限的信息<br>3.通过 Zoopkeeper 存储元数据的统一入口地址。</p><h3 id="Hmaster"><a href="#Hmaster" class="headerlink" title="Hmaster"></a>Hmaster</h3><p>master 节点的主要职责如下:</p><ol><li>为 RegionServer 分配 Region</li><li>维护整个集群的负载均衡</li><li>维护集群的元数据信息发现失效的 Region,并将失效的 Region 分配到正常RegionServer 上当 RegionSever 失效的时候,协调对应 Hlog 的拆分</li></ol><h3 id="HregionServer"><a href="#HregionServer" class="headerlink" title="HregionServer"></a>HregionServer</h3><p>HregionServer 直接对接用户的读写请求,是真正的“干活”的节点。它的功能概括如下:</p><p>1.管理 master 为其分配的 Region</p><ol start="2"><li><p>处理来自客户端的读写请求</p></li><li><p>负责和底层 HDFS 的交互,存储数据到 HDFS</p></li><li><p>负责 Region 变大以后的拆分</p></li><li><p>负责 Storefile 的合并工作</p></li></ol><h3 id="Region-寻址方式-通过-zookeeper-META"><a href="#Region-寻址方式-通过-zookeeper-META" class="headerlink" title="Region 寻址方式(通过 zookeeper .META)"></a>Region 寻址方式(通过 zookeeper .META)</h3><p>第 1 步:Client 请求 ZK 获取.META.所在的 RegionServer 的地址。<br>第 2 步:Client 请求.META.所在的 RegionServer 获取访问数据所在的 RegionServer 地址,client 会将.META.的相关信息 cache 下来,以便下一次快速访问。<br>第 3 步:Client 请求数据所在的 RegionServer,获取所需要的数据。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/hbase-region.png" alt="avatar"></p><h3 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h3><p>HDFS 为 Hbase 提供最终的底层数据存储服务,同时为 Hbase 提供高可用(Hlog 存储在HDFS)的支持。</p><h1 id="Hbase-的写逻辑"><a href="#Hbase-的写逻辑" class="headerlink" title="Hbase 的写逻辑"></a>Hbase 的写逻辑</h1><blockquote><p>Hbase 的写入流程</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/hbase-write.png" alt="avatar"></p><p>从上图可以看出氛围 3 步骤:</p><p>获取 RegionServer</p><blockquote><p>第 1 步:Client 获取数据写入的 Region 所在的 RegionServer</p></blockquote><p>请求写 Hlog</p><blockquote><p>第 2 步:请求写 Hlog, Hlog 存储在 HDFS,当 RegionServer 出现异常,需要使用 Hlog 来</p></blockquote><p>恢复数据。</p><p>请求写 MemStore</p><blockquote><p>第 3 步:请求写 MemStore,只有当写 Hlog 和写 MemStore 都成功了才算请求写入完成。</p></blockquote><p>MemStore 后续会逐渐刷到 HDFS 中。</p><h1 id="MemStore-刷盘"><a href="#MemStore-刷盘" class="headerlink" title="MemStore 刷盘"></a>MemStore 刷盘</h1><p>为了提高 Hbase 的写入性能,当写请求写入 MemStore 后,不会立即刷盘。而是会等到一定的时候进行刷盘的操作。具体是哪些场景会触发刷盘的操作呢?总结成如下的几个场景:</p><h3 id="全局内存控制"><a href="#全局内存控制" class="headerlink" title="全局内存控制"></a>全局内存控制</h3><p>1.这个全局的参数是控制内存整体的使用情况,当所有 memstore 占整个 heap 的最大比例的时候,会触发刷盘的操作。这个参数是hbase.regionserver.global.memstore.upperLimit,默认为整个 heap 内存的 40%。但这并不意味着全局内存触发的刷盘操作会将所有的 MemStore 都进行输盘,而是通过另外一个参数 hbase.regionserver.global.memstore.lowerLimit 来控制,默认是整个heap 内存的 35%。当 flush 到所有 memstore 占整个 heap 内存的比率为 35%的时候,就停止刷盘。这么做主要是为了减少刷盘对业务带来的影响,实现平滑系统负载的目的。</p><h3 id="MemStore-达到上限"><a href="#MemStore-达到上限" class="headerlink" title="MemStore 达到上限"></a>MemStore 达到上限</h3><p>2.当 MemStore 的大小达到 hbase.hregion.memstore.flush.size 大小的时候会触发刷盘,默认 128M 大小</p><h3 id="RegionServer-的-Hlog-数量达到上限"><a href="#RegionServer-的-Hlog-数量达到上限" class="headerlink" title="RegionServer 的 Hlog 数量达到上限"></a>RegionServer 的 Hlog 数量达到上限</h3><p>3.前面说到 Hlog 为了保证 Hbase 数据的一致性,那么如果 Hlog 太多的话,会导致故障恢复的时间太长,因此 Hbase 会对 Hlog 的最大个数做限制。当达到 Hlog 的最大个数的时候,会强制刷盘。这个参数是 hase.regionserver.max.logs,默认是 32 个。</p><h3 id="手工触发"><a href="#手工触发" class="headerlink" title="手工触发"></a>手工触发</h3><p>4.可以通过 hbase shell 或者 java api 手工触发 flush 的操作。</p><h3 id="关闭-RegionServer-触发"><a href="#关闭-RegionServer-触发" class="headerlink" title="关闭 RegionServer 触发"></a>关闭 RegionServer 触发</h3><p>5.在正常关闭 RegionServer 会触发刷盘的操作,全部数据刷盘后就不需要再使用 Hlog 恢复数据。</p><h3 id="Region-使用-HLOG-恢复完数据后触发"><a href="#Region-使用-HLOG-恢复完数据后触发" class="headerlink" title="Region 使用 HLOG 恢复完数据后触发"></a>Region 使用 HLOG 恢复完数据后触发</h3><p>6.当 RegionServer 出现故障的时候,其上面的 Region 会迁移到其他正常的RegionServer 上,在恢复完 Region 的数据后,会触发刷盘,当刷盘完成后才会提供给业务访问。</p><h1 id="HBase-vs-Cassandra"><a href="#HBase-vs-Cassandra" class="headerlink" title="HBase vs Cassandra"></a>HBase vs Cassandra</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/hbase-vs-cassandra-1.png" alt="avatar"></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/hbase-vs-cassandra-2.png" alt="avatar"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hbase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ</title>
    <link href="/2020/08/18/middleware/RabbitMQ/"/>
    <url>/2020/08/18/middleware/RabbitMQ/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。</p><p>AMQP :Advanced Message Queue,高级消息队列协议。它是应用层协议的一个开放标准,为面向消息的中间件设计,基于此协议的客户端与消息中间件可传递消息,并不受产品、开发语言等条件的限制。</p><p>RabbitMQ 最初起源于金融系统,用于在分布式系统中存储转发消息,在易用性、扩展性、高可用性等方面表现不俗。具体特点包括:</p><p>1.可靠性(Reliability):RabbitMQ 使用一些机制来保证可靠性,如持久化、传输确认、发布确认。</p><p>2.灵活的路由(Flexible Routing):在消息进入队列之前,通过 Exchange 来路由消息的。对于典型的路由功能,RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能,可以将多个 Exchange 绑定在一起,也通过插件机制实现自己的 Exchange 。</p><ol start="3"><li><p>消息集群(Clustering):多个 RabbitMQ 服务器可以组成一个集群,形成一个逻辑 Broker 。</p></li><li><p>高可用(Highly Available Queues):队列可以在集群中的机器上进行镜像,使得在部分节点出问题的情况下队列仍然可用。</p></li></ol><p>5.多种协议(Multi-protocol):RabbitMQ 支持多种消息队列协议,比如 STOMP、MQTT等等。</p><p>6.多语言客户端(Many Clients):RabbitMQ 几乎支持所有常用语言,比如 Java、.NET、Ruby 等等。</p><p>7.管理界面(Management UI):RabbitMQ 提供了一个易用的用户界面,使得用户可以监控和管理消息 Broker 的许多方面。</p><p>8.跟踪机制(Tracing):如果消息异常,RabbitMQ 提供了消息跟踪机制,使用者可以找出发生了什么。</p><p>9.插件机制(Plugin System):RabbitMQ 提供了许多插件,来从多方面进行扩展,也可以编写自己的插件。</p><h1 id="RabbitMQ-架构"><a href="#RabbitMQ-架构" class="headerlink" title="RabbitMQ 架构"></a>RabbitMQ 架构</h1><p> <img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/rabbitmq-sturts.png" alt="avatar"></p><h1 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h1><p> 消息,消息是不具名的,它由消息头和消息体组成。消息体是不透明的,而消息头则由一系列的可选属性组成,这些属性包括 routing-key(路由键)、priority(相对于其他消息的优先权)、delivery-mode(指出该消息可能需要持久性存储)等。</p><h1 id="Publisher"><a href="#Publisher" class="headerlink" title="Publisher"></a>Publisher</h1><p> 1.消息的生产者,也是一个向交换器发布消息的客户端应用程序。</p><h1 id="Exchange-将消息路由给队列"><a href="#Exchange-将消息路由给队列" class="headerlink" title="Exchange(将消息路由给队列 )"></a>Exchange(将消息路由给队列 )</h1><p> 2.交换器,用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</p><h1 id="Binding-消息队列和交换器之间的关联"><a href="#Binding-消息队列和交换器之间的关联" class="headerlink" title="Binding(消息队列和交换器之间的关联)"></a>Binding(消息队列和交换器之间的关联)</h1><ol start="3"><li>绑定,用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则,所以可以将交换器理解成一个由绑定构成的路由表。</li></ol><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p> 4.消息队列,用来保存消息直到发送给消费者。它是消息的容器,也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面,等待消费者连接到这个队列将其取走。</p><h1 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h1><p> 5.网络连接,比如一个 TCP 连接。</p><h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><p> 6.信道,多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的 TCP 连接内地虚拟连接,AMQP 命令都是通过信道发出去的,不管是发布消息、订阅队列还是接收消息,这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销,所以引入了信道的概念,以复用一条 TCP 连接。</p><h1 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h1><p> 7.消息的消费者,表示一个从消息队列中取得消息的客户端应用程序。</p><h1 id="Virtual-Host"><a href="#Virtual-Host" class="headerlink" title="Virtual Host"></a>Virtual Host</h1><p> 8.虚拟主机,表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。</p><h1 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h1><p> 9.表示消息队列服务器实体。</p><h1 id="Exchange-类型"><a href="#Exchange-类型" class="headerlink" title="Exchange 类型"></a>Exchange 类型</h1><p> Exchange 分发消息时根据类型的不同分发策略有区别,目前共四种类型:direct、fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键,此外 headers 交换器和direct 交换器完全一致,但性能差很多,目前几乎用不到了,所以直接看另外三种类型:</p><h1 id="Direct-键-routing-key-分布"><a href="#Direct-键-routing-key-分布" class="headerlink" title="Direct 键(routing key)分布:"></a>Direct 键(routing key)分布:</h1><p> 1.Direct:消息中的路由键(routing key)如果和 Binding 中的 binding key 一致,交换器就将消息发到对应的队列中。它是完全匹配、单播的模式。</p><p>  <img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/direct-exchange.png" alt="avatar"></p><h1 id="Fanout-广播分发"><a href="#Fanout-广播分发" class="headerlink" title="Fanout(广播分发)"></a>Fanout(广播分发)</h1><p> 2.Fanout:每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。很像子网广播,每台子网内的主机都获得了一份复制的消息。fanout 类型转发消息是最快的。</p><p>  <img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/fanout-exchange.png" alt="avatar"></p><h1 id="topic-交换器-模式匹配"><a href="#topic-交换器-模式匹配" class="headerlink" title="topic 交换器(模式匹配)"></a>topic 交换器(模式匹配)</h1><p> 3.topic 交换器:topic 交换器通过模式匹配分配消息的路由键属性,将路由键和某个模式进行匹配,此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词,这些单词之间用点隔开。它同样也会识别两个通配符:符号“#”和符号“”。#匹配 0 个或多个单词,匹配不多不少一个单词。</p><p>  <img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/topic-exchange.png" alt="avatar"></p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rabbitmq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka学习笔记</title>
    <link href="/2020/08/12/middleware/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/08/12/middleware/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Kafka-概念"><a href="#Kafka-概念" class="headerlink" title="Kafka 概念"></a>Kafka 概念</h1><p>Kafka 是一种高吞吐量、分布式、基于发布/订阅的消息系统,最初由 LinkedIn 公司开发,使用Scala 语言编写,目前是 Apache 的开源项目。</p><ol><li><p><code>Broker</code>: Kafka 服务器,负责消息存储和转发</p></li><li><p><code>Topic</code>: 消息类别,Kafka 按照 topic 来分类消息</p></li><li><p><code>Partition</code>: topic 的分区,一个 topic 可以包含多个 partition,topic 消息保存在各个partition 上</p></li><li><p><code>Offset</code>: 消息在日志中的位置,可以理解是消息在 partition 上的偏移量,也是代表该消息的唯一序号</p></li><li><p><code>Producer</code>: 消息生产者</p></li><li><p><code>Consumer</code>: 消息消费者</p></li><li><p><code>Consumer</code> Group: 消费者分组,每个 Consumer 必须属于一个 group</p></li><li><p><code>Zookeeper</code>: 保存着集群 broker、topic、partition 等 meta 数据;另外,还负责 broker 故障发现,partition leader 选举,负载均衡等功能</p></li></ol><p> <img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/kafka.png" alt="kafka"></p><h1 id="Kafka-数据存储设计"><a href="#Kafka-数据存储设计" class="headerlink" title="Kafka 数据存储设计"></a>Kafka 数据存储设计</h1><h2 id="partition-的数据文件-offset-MessageSize-data"><a href="#partition-的数据文件-offset-MessageSize-data" class="headerlink" title="partition 的数据文件( offset,MessageSize,data )"></a>partition 的数据文件( offset,MessageSize,data )</h2><p>partition 中的每条 Message 包含了以下三个属性:offset,MessageSize,data,其中 offset 表示 Message 在这个 partition 中的偏移量,offset 不是该 Message 在 partition 数据文件中的实</p><p>际存储位置,而是逻辑上一个值,它唯一确定了 partition 中的一条 Message,可以认为 offset 是partition 中 Message 的 id;MessageSize 表示消息内容 data 的大小;data 为 Message 的具体内容。</p><h2 id="数据文件分段-segment-顺序读写、分段命令、二分查找"><a href="#数据文件分段-segment-顺序读写、分段命令、二分查找" class="headerlink" title="数据文件分段 segment(顺序读写、分段命令、二分查找)"></a>数据文件分段 segment(顺序读写、分段命令、二分查找)</h2><p>partition 物理上由多个 segment 文件组成,每个 segment 大小相等,顺序读写。每个 segment数据文件以该段中最小的 offset 命名,文件扩展名为.log。这样在查找指定 offset 的 Message 的时候,用二分查找就可以定位到该 Message 在哪个 segment 数据文件中。</p><h2 id="数据文件索引-分段索引、稀疏存储"><a href="#数据文件索引-分段索引、稀疏存储" class="headerlink" title="数据文件索引(分段索引、稀疏存储)"></a>数据文件索引(分段索引、稀疏存储)</h2><p>Kafka 为每个分段后的数据文件建立了索引文件,文件名与数据文件的名字是一样的,只是文件扩展名为.index。index 文件中并没有为数据文件中的每条 Message 建立索引,而是采用了稀疏存储的方式,每隔一定字节的数据建立一条索引。这样避免了索引文件占用过多的空间,从而可以将索引文件保留在内存中。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/kafka-data-file-index.png" alt="avatar"></p><p>生产者设计</p><p>负载均衡(partition 会均衡分布到不同 broker 上)</p><p>由于消息 topic 由多个 partition 组成,且 partition 会均衡分布到不同 broker 上,因此,为了有效利用 broker 集群的性能,提高消息的吞吐量,producer 可以通过随机或者 hash 等方式,将消息平均发送到多个 partition 上,以实现负载均衡。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/kafka-loadblance.png" alt="avatar"></p><h2 id="批量发送"><a href="#批量发送" class="headerlink" title="批量发送"></a>批量发送</h2><p>是提高消息吞吐量重要的方式,Producer 端可以在内存中合并多条消息后,以一次请求的方式发送了批量的消息给 broker,从而大大减少 broker 存储消息的 IO 操作次数。但也一定程度上影响了消息的实时性,相当于以时延代价,换取更好的吞吐量。</p><h2 id="压缩-GZIP-或-Snappy"><a href="#压缩-GZIP-或-Snappy" class="headerlink" title="压缩( GZIP 或 Snappy )"></a>压缩( GZIP 或 Snappy )</h2><p>Producer 端可以通过 GZIP 或 Snappy 格式对消息集合进行压缩。Producer 端进行压缩之后,在Consumer 端需进行解压。压缩的好处就是减少传输的数据量,减轻对网络传输的压力,在对大数据处理上,瓶颈往往体现在网络上而不是 CPU(压缩和解压会耗掉部分 CPU 资源)。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/kafka-gzip.png" alt="avatar"></p><h2 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h2><p>同一 Consumer Group 中的多个 Consumer 实例,不同时消费同一个 partition,等效于队列模式。partition 内消息是有序的,Consumer 通过 pull 方式消费消息。Kafka 不删除已消费的消息对于 partition,顺序读写磁盘数据,以时间复杂度 O(1)方式提供消息持久化能力。</p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper</title>
    <link href="/2020/08/12/middleware/Zookeeper/"/>
    <url>/2020/08/12/middleware/Zookeeper/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Zookeeper-概念"><a href="#Zookeeper-概念" class="headerlink" title="Zookeeper 概念"></a>Zookeeper 概念</h1><p>Zookeeper 是一个分布式协调服务,可用于服务发现,分布式锁,分布式领导选举,配置管理等。<br>Zookeeper 提供了一个类似于 Linux 文件系统的树形结构(可认为是轻量级的内存文件系统,但只适合存少量信息,完全不适合存储大量文件或者大文件),同时提供了对于每个节点的监控与通知机制。</p><h1 id="Zookeeper-角色"><a href="#Zookeeper-角色" class="headerlink" title="Zookeeper 角色"></a>Zookeeper 角色</h1><p>Zookeeper 集群是一个基于主从复制的高可用集群,每个服务器承担如下三种角色中的一种</p><p>Leader</p><p>1.一个 Zookeeper 集群同一时间只会有一个实际工作的 Leader,它会发起并维护与各 Follwer及 Observer 间的心跳。<br>2.所有的写操作必须要通过 Leader 完成再由 Leader 将写操作广播给其它服务器。只要有超过半数节点(不包括 observeer 节点)写入成功,该写请求就会被提交(类 2PC 协议)。</p><p>Follower</p><ol><li>一个 Zookeeper 集群可能同时存在多个 Follower,它会响应 Leader 的心跳,</li><li>Follower 可直接处理并返回客户端的读请求,同时会将写请求转发给 Leader 处理,</li><li>并且负责在 Leader 处理写请求时对请求进行投票。</li></ol><p>Observer</p><p>角色与 Follower 类似,但是无投票权。Zookeeper 需保证高可用和强一致性,为了支持更多的客户端,需要增加更多 Server;Server 增多,投票阶段延迟增大,影响性能;引入 Observer,Observer 不参与投票; Observers 接受客户端的连接,并将写请求转发给 leader 节点; 加入更多 Observer 节点,提高伸缩性,同时不影响吞吐率。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/elk.png" alt="avatar"></p><h1 id="ZAB-协议"><a href="#ZAB-协议" class="headerlink" title="ZAB 协议"></a>ZAB 协议</h1><h2 id="事务编号-Zxid-事务请求计数器-epoch"><a href="#事务编号-Zxid-事务请求计数器-epoch" class="headerlink" title="事务编号 Zxid (事务请求计数器 + epoch )"></a>事务编号 Zxid (事务请求计数器 + epoch )</h2><p>在 ZAB ( ZooKeeper Atomic Broadcast , ZooKeeper 原子消息广播协议) 协议的事务编号 Zxid设计中,Zxid 是一个 64 位的数字,其中低 32 位是一个简单的单调递增的计数器,针对客户端每一个事务请求,计数器加 1;而高 32 位则代表 Leader 周期 epoch 的编号,每个当选产生一个新<br>的 Leader 服务器,就会从这个 Leader 服务器上取出其本地日志中最大事务的 ZXID,并从中读取epoch 值,然后加 1,以此作为新的 epoch,并将低 32 位从 0 开始计数。<br>Zxid(Transaction id)类似于 RDBMS 中的事务 ID,用于标识一次更新操作的 Proposal(提议)ID。为了保证顺序性,该 zkid 必须单调递增。</p><h2 id="epoch"><a href="#epoch" class="headerlink" title="epoch"></a>epoch</h2><p>epoch:可以理解为当前集群所处的年代或者周期,每个 leader 就像皇帝,都有自己的年号,所以每次改朝换代,leader 变更之后,都会在前一个年代的基础上加 1。这样就算旧的 leader 崩溃恢复之后,也没有人听他的了,因为 follower 只听从当前年代的 leader 的命令。<br>Zab 协议有两种模式 - 恢复模式(选主)、广播模式(同步)<br>Zab 协议有两种模式,它们分别是恢复模式(选主)和广播模式(同步)。当服务启动或者在领导者崩溃后,Zab 就进入了恢复模式,当领导者被选举出来,且大多数 Server 完成了和 leader 的状态同步以后,恢复模式就结束了。状态同步保证了 leader 和 Server 具有相同的系统状态。</p><h2 id="ZAB-协议-4-阶段"><a href="#ZAB-协议-4-阶段" class="headerlink" title="ZAB 协议 4 阶段"></a>ZAB 协议 4 阶段</h2><h3 id="Leader-election-选举阶段-选出准-Leader"><a href="#Leader-election-选举阶段-选出准-Leader" class="headerlink" title="Leader election (选举阶段 - 选出准 Leader )"></a>Leader election (选举阶段 - 选出准 Leader )</h3><p>1.Leader election(选举阶段):节点在一开始都处于选举阶段,只要有一个节点得到超半数节点的票数,它就可以当选准 leader。只有到达 广播阶段(broadcast) 准 leader 才会成为真正的 leader。这一阶段的目的是就是为了选出一个准 leader,然后进入下一个阶段。</p><h2 id="Discovery-发现阶段-接受提议、生成-epoch-、接受-epoch"><a href="#Discovery-发现阶段-接受提议、生成-epoch-、接受-epoch" class="headerlink" title="Discovery (发现阶段 - 接受提议、生成 epoch 、接受 epoch )"></a>Discovery (发现阶段 - 接受提议、生成 epoch 、接受 epoch )</h2><p>2.Discovery(发现阶段):在这个阶段,followers 跟准 leader 进行通信,同步 followers最近接收的事务提议。这个一阶段的主要目的是发现当前大多数节点接收的最新提议,并且准 leader 生成新的 epoch,让 followers 接受,更新它们的 accepted Epoch一个 follower 只会连接一个 leader,如果有一个节点 f 认为另一个 follower p 是 leader,f在尝试连接 p 时会被拒绝,f 被拒绝之后,就会进入重新选举阶段。</p><h2 id="Synchronization-同步阶段-同步-follower-副本"><a href="#Synchronization-同步阶段-同步-follower-副本" class="headerlink" title="Synchronization (同步阶段 - 同步 follower 副本)"></a>Synchronization (同步阶段 - 同步 follower 副本)</h2><p>3.Synchronization(同步阶段):同步阶段主要是利用 leader 前一阶段获得的最新提议历史,同步集群中所有的副本。只有当 大多数节点都同步完成,准 leader 才会成为真正的 leader。follower 只会接收 zxid 比自己的 lastZxid 大的提议。</p><h2 id="Broadcast-广播阶段-leader-消息广播"><a href="#Broadcast-广播阶段-leader-消息广播" class="headerlink" title="Broadcast (广播阶段 -leader 消息广播)"></a>Broadcast (广播阶段 -leader 消息广播)</h2><p>4.Broadcast(广播阶段):到了这个阶段,Zookeeper 集群才能正式对外提供事务服务,并且 leader 可以进行消息广播。同时如果有新的节点加入,还需要对新节点进行同步。<br>ZAB 提交事务并不像 2PC 一样需要全部 follower 都 ACK,只需要得到超过半数的节点的 ACK 就可以了。</p><h2 id="ZAB-协议-JAVA-实现-FLE-发现阶段和同步合并为-Recovery-Phase-恢复阶段"><a href="#ZAB-协议-JAVA-实现-FLE-发现阶段和同步合并为-Recovery-Phase-恢复阶段" class="headerlink" title="ZAB 协议 JAVA 实现( FLE-发现阶段和同步合并为 Recovery Phase(恢复阶段) )"></a>ZAB 协议 JAVA 实现( FLE-发现阶段和同步合并为 Recovery Phase(恢复阶段) )</h2><p>协议的 Java 版本实现跟上面的定义有些不同,选举阶段使用的是 Fast Leader Election(FLE),<br>它包含了 选举的发现职责。因为 FLE 会选举拥有最新提议历史的节点作为 leader,这样就省去了<br>发现最新提议的步骤。实际的实现将 发现阶段 和 同步合并为 Recovery Phase(恢复阶段)。所<br>以,ZAB 的实现只有三个阶段:Fast Leader Election;Recovery Phase;Broadcast Phase。</p><h1 id="投票机制"><a href="#投票机制" class="headerlink" title="投票机制"></a>投票机制</h1><p>每个 sever 首先给自己投票,然后用自己的选票和其他 sever 选票对比,权重大的胜出,使用权重较大的更新自身选票箱。具体选举过程如下:</p><ol><li><p>每个 Server 启动以后都询问其它的 Server 它要投票给谁。对于其他 server 的询问,server 每次根据自己的状态都回复自己推荐的 leader 的 id 和上一次处理事务的 zxid(系统启动时每个 server 都会推荐自己)</p></li><li><p>收到所有 Server 回复以后,就计算出 zxid 最大的哪个 Server,并将这个 Server 相关信息设置成下一次要投票的 Server。</p></li><li><p>计算这过程中获得票数最多的的 sever 为获胜者,如果获胜者的票数超过半数,则改server 被选为 leader。否则,继续这个过程,直到 leader 被选举出来</p></li><li><p>leader 就会开始等待 server 连接</p></li><li><p>Follower 连接 leader,将最大的 zxid 发送给 leader</p></li><li><p>Leader 根据 follower 的 zxid 确定同步点,至此选举阶段完成。</p></li><li><p>选举阶段完成 Leader 同步后通知 follower 已经成为 uptodate 状态</p></li><li><p>Follower 收到 uptodate 消息后,又可以重新接受 client 的请求进行服务了</p></li></ol><p>目前有 5 台服务器,每台服务器均没有数据,它们的编号分别是 1,2,3,4,5,按编号依次启动,它们的选择举过程如下:</p><ol><li><p>服务器 1 启动,给自己投票,然后发投票信息,由于其它机器还没有启动所以它收不到反馈信息,服务器 1 的状态一直属于 Looking。</p></li><li><p>服务器 2 启动,给自己投票,同时与之前启动的服务器 1 交换结果,由于服务器 2 的编号大所以服务器 2 胜出,但此时投票数没有大于半数,所以两个服务器的状态依然是LOOKING。</p></li><li><p>服务器 3 启动,给自己投票,同时与之前启动的服务器 1,2 交换信息,由于服务器 3 的编号最大所以服务器 3 胜出,此时投票数正好大于半数,所以服务器 3 成为领导者,服务器1,2 成为小弟。</p></li><li><p>服务器 4 启动,给自己投票,同时与之前启动的服务器 1,2,3 交换信息,尽管服务器 4 的编号大,但之前服务器 3 已经胜出,所以服务器 4 只能成为小弟。</p></li><li><p>服务器 5 启动,后面的逻辑同服务器 4 成为小弟。</p></li></ol><h1 id="Zookeeper-工作原理-原子广播"><a href="#Zookeeper-工作原理-原子广播" class="headerlink" title="Zookeeper 工作原理(原子广播)"></a>Zookeeper 工作原理(原子广播)</h1><ol><li><p>Zookeeper 的核心是原子广播,这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式,它们分别是恢复模式和广播模式。</p></li><li><p>当服务启动或者在领导者崩溃后,Zab 就进入了恢复模式,当领导者被选举出来,且大多数 server 的完成了和 leader 的状态同步以后,恢复模式就结束了。</p></li><li><p>状态同步保证了 leader 和 server 具有相同的系统状态</p></li><li><p>一旦 leader 已经和多数的 follower 进行了状态同步后,他就可以开始广播消息了,即进入广播状态。这时候当一个 server 加入 zookeeper 服务中,它会在恢复模式下启动,发现 leader,并和 leader 进行状态同步。待到同步结束,它也参与消息广播。Zookeeper服务一直维持在 Broadcast 状态,直到 leader 崩溃了或者 leader 失去了大部分的followers 支持。</p></li></ol><p>5.广播模式需要保证 proposal 被按顺序处理,因此 zk 采用了递增的事务 id 号(zxid)来保证。所有的提议(proposal)都在被提出的时候加上了 zxid。</p><ol start="6"><li><p>实现中 zxid 是一个 64 为的数字,它高 32 位是 epoch 用来标识 leader 关系是否改变,每次一个 leader 被选出来,它都会有一个新的 epoch。低 32 位是个递增计数。</p></li><li><p>当 leader 崩溃或者 leader 失去大多数的 follower,这时候 zk 进入恢复模式,恢复模式需要重新选举出一个新的 leader,让所有的 server 都恢复到一个正确的状态。</p></li></ol><h1 id="Znode-有四种形式的目录节点"><a href="#Znode-有四种形式的目录节点" class="headerlink" title="Znode 有四种形式的目录节点"></a>Znode 有四种形式的目录节点</h1><ol><li><p>PERSISTENT:持久的节点。</p></li><li><p>EPHEMERAL:暂时的节点。</p></li><li><p>PERSISTENT_SEQUENTIAL:持久化顺序编号目录节点。</p></li><li><p>EPHEMERAL_SEQUENTIAL:暂时化顺序编号目录节点。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日志管理</title>
    <link href="/2020/08/12/note/%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/"/>
    <url>/2020/08/12/note/%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Slf4j"><a href="#Slf4j" class="headerlink" title="Slf4j"></a>Slf4j</h1><p>slf4j 的全称是 Simple Loging Facade For Java,即它仅仅是一个为 Java 程序提供日志输出的统一接<br>口,并不是一个具体的日志实现方案,就比如 JDBC 一样,只是一种规则而已。所以单独的 slf4j 是不<br>能工作的,必须搭配其他具体的日志实现方案,比如 apache 的 org.apache.log4j.Logger,jdk 自带<br>的 java.util.logging.Logger 等。</p><h1 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h1><p>Log4j 是 Apache 的一个开源项目,通过使用 Log4j,我们可以控制日志信息输送的目的地是控制台、<br>文件、GUI 组件,甚至是套接口服务器、NT 的事件记录器、UNIX Syslog 守护进程等;我们也可以控<br>制每一条日志的输出格式;通过定义每一条日志信息的级别,我们能够更加细致地控制日志的生成过程。<br>Log4j 由三个重要的组成构成:日志记录器(Loggers),输出端(Appenders)和日志格式化器(Layout)。<br>1.Logger:控制要启用或禁用哪些日志记录语句,并对日志信息进行级别限制<br>2.Appenders : 指定了日志将打印到控制台还是文件中<br>3.Layout : 控制日志信息的显示格式<br>Log4j 中将要输出的 Log 信息定义了 5 种级别,依次为 DEBUG、INFO、WARN、ERROR 和 FATAL,<br>当输出时,只有级别高过配置中规定的 级别的信息才能真正的输出,这样就很方便的来配置不同情况<br>下要输出的内容,而不需要更改代码。</p><h1 id="LogBack"><a href="#LogBack" class="headerlink" title="LogBack"></a>LogBack</h1><p>简单地说,Logback 是一个 Java 领域的日志框架。它被认为是 Log4J 的继承人。<br>Logback 主要由三个模块组成:logback-core,logback-classic。logback-access<br>logback-core 是其它模块的基础设施,其它模块基于它构建,显然,logback-core 提供了一些关键的<br>通用机制。<br>logback-classic 的地位和作用等同于 Log4J,它也被认为是 Log4J 的一个改进版,并且它实现了简单<br>日志门面 SLF4J;<br>logback-access 主要作为一个与 Servlet 容器交互的模块,比如说 tomcat 或者 jetty,提供一些与<br>HTTP 访问相关的功能。</p><h2 id="Logback-优点"><a href="#Logback-优点" class="headerlink" title="Logback 优点"></a>Logback 优点</h2><p>同样的代码路径,Logback 执行更快更充分的测试原生实现了 SLF4J API(Log4J 还需要有一个中间转换层)内容更丰富的文档支持 XML 或者 Groovy 方式配置配置文件自动热加载</p><p>从 IO 错误中优雅恢复自动删除日志归档自动压缩日志成为归档文件支持 Prudent 模式,使多个 JVM 进程能记录同一个日志文件支持配置文件中加入条件判断来适应不同的环境更强大的过滤器支持 SiftingAppender(可筛选 Appender)异常栈信息带有包信息</p><h1 id="ELK"><a href="#ELK" class="headerlink" title="ELK"></a>ELK</h1><p>ELK 是软件集合 Elasticsearch、Logstash、Kibana 的简称,由这三个软件及其相关的组件可以打造大规模日志实时处理系统。<br>Elasticsearch 是一个基于 Lucene 的、支持全文索引的分布式存储和索引引擎,主要负责将日志索引并存储起来,方便业务方检索查询。<br>Logstash 是一个日志收集、过滤、转发的中间件,主要负责将各条业务线的各类日志统一收集、过滤后,转发给 Elasticsearch 进行下一步处理。<br>Kibana 是一个可视化工具,主要负责查询 Elasticsearch 的数据并以可视化的方式展现给业务方,比如各类饼图、直方图、区域图等。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/elk.png" alt="avatar"></p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Log4j</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络协议</title>
    <link href="/2020/08/12/network/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/08/12/network/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="网络-7-层架构"><a href="#网络-7-层架构" class="headerlink" title="网络 7 层架构"></a>网络 7 层架构</h1><h2 id="7-层模型主要包括"><a href="#7-层模型主要包括" class="headerlink" title="7 层模型主要包括:"></a>7 层模型主要包括:</h2><p>1.物理层:主要定义物理设备标准,如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流(就是由 1、0 转化为电流强弱来进行传输,到达目的地后在转化为1、0,也就是我们常说的模数转换与数模转换)。这一层的数据叫做比特。</p><p>2.数据链路层:主要将从物理层接收的数据进行 MAC 地址(网卡的地址)的封装与解封装。常把这一层的数据叫做帧。在这一层工作的设备是交换机,数据通过交换机来传输。</p><p>3.网络层:主要将从下层接收到的数据进行 IP 地址(例 192.168.0.1)的封装与解封装。在这一层工作的设备是路由器,常把这一层的数据叫做数据包。</p><p>4.传输层:定义了一些传输数据的协议和端口号(WWW 端口 80 等),如:TCP(传输控制协议,传输效率低,可靠性强,用于传输可靠性要求高,数据量大的数据),UDP(用户数据报协议,与 TCP 特性恰恰相反,用于传输可靠性要求不高,数据量小的数据,如 QQ 聊天数据就是通过这种方式传输的)。 主要是将从下层接收的数据进行分段进行传输,到达目的地址后在进行重组。常常把这一层数据叫做段。</p><p>5.会话层:通过传输层(端口号:传输端口与接收端口)建立数据传输的通路。主要在你的系统之间发起会话或或者接受会话请求(设备之间需要互相认识可以是 IP 也可以是 MAC 或者是主机名)</p><p>6.表示层:主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等(也就是把计算机能够识别的东西转换成人能够能识别的东西(如图片、声音等))</p><p>7.应用层 主要是一些终端的应用,比如说 FTP(各种文件下载),WEB(IE 浏览),QQ 之类的(你就把它理解成我们在电脑屏幕上可以看到的东西.就 是终端应用)。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/seven-network-protocol.png" alt="avatar"></p><h1 id="TCP-IP-原理"><a href="#TCP-IP-原理" class="headerlink" title="TCP/IP 原理"></a>TCP/IP 原理</h1><p>TCP/IP 协议不是 TCP 和 IP 这两个协议的合称,而是指因特网整个 TCP/IP 协议族。从协议分层模型方面来讲,TCP/IP 由四个层次组成:网络接口层、网络层、传输层、应用层。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/tcp-ip.png" alt="avatar"></p><p>1.网络访问层(Network Access Layer)</p><blockquote><p>网络访问层(Network Access Layer)在 TCP/IP 参考模型中并没有详细描述,只是指出主机必须使用某种协议与网络相连。</p></blockquote><p>2.网络层(Internet Layer)</p><blockquote><p>网络层(Internet Layer)是整个体系结构的关键部分,其功能是使主机可以把分组发往任何网络,并使分组独立地传向目标。这些分组可能经由不同的网络,到达的顺序和发送的顺序也可能不同。高层如果需要顺序收发,那么就必须自行处理对分组的排序。互联网层使用因特网协议(IP,Internet Protocol)。</p></blockquote><p>3.传输层(Tramsport Layer-TCP/UDP)</p><blockquote><p>传输层(Tramsport Layer)使源端和目的端机器上的对等实体可以进行会话。在这一层定义了两个端到端的协议:传输控制协议(TCP,Transmission Control Protocol)和用户数据报协议(UDP,User Datagram Protocol)。TCP 是面向连接的协议,它提供可靠的报文传输和对上层应用的连接服务。为此,除了基本的数据传输外,它还有可靠性保证、流量控制、多路复用、优先权和安全性控制等功能。UDP 是面向无连接的不可靠传输的协议,主要用于不需要 TCP 的排序和流量控制等功能的应用程序。</p></blockquote><p>4.应用层(Application Layer)</p><blockquote><p>应用层(Application Layer)包含所有的高层协议,包括:虚拟终端协议(TELNET,TELecommunications NETwork)、文件传输协议(FTP,File Transfer Protocol)、电子邮件传输协议(SMTP,Simple Mail Transfer Protocol)、域名服务(DNS,Domain NameService)、网上新闻传输协议(NNTP,Net News Transfer Protocol)和超文本传送协议(HTTP,HyperText Transfer Protocol)等。</p></blockquote><h1 id="TCP-三次握手-四次挥手"><a href="#TCP-三次握手-四次挥手" class="headerlink" title="TCP 三次握手/四次挥手"></a>TCP 三次握手/四次挥手</h1><blockquote><p>TCP 在传输之前会进行三次沟通,一般称为“三次握手”,传完数据断开的时候要进行四次沟通,一般称为“四次挥手”。</p></blockquote><h1 id="数据包说明"><a href="#数据包说明" class="headerlink" title="数据包说明"></a>数据包说明</h1><ol><li>源端口号( 16 位):它(连同源主机 IP 地址)标识源主机的一个应用进程。</li><li>目的端口号( 16 位):它(连同目的主机 IP 地址)标识目的主机的一个应用进程。这两个值加上 IP 报头中的源主机 IP 地址和目的主机 IP 地址唯一确定一个 TCP 连接。</li><li>顺序号 seq( 32 位):用来标识从 TCP 源端向 TCP 目的端发送的数据字节流,它表示在这个报文段中的第一个数据字节的顺序号。如果将字节流看作在两个应用程序间的单向流动,则TCP 用顺序号对每个字节进行计数。序号是 32bit 的无符号数,序号到达 2 的 32 次方 - 1 后又从 0 开始。当建立一个新的连接时, SYN 标志变 1 ,顺序号字段包含由这个主机选择的该连接的初始顺序号 ISN ( Initial Sequence Number )。</li><li>确认号 ack( 32 位):包含发送确认的一端所期望收到的下一个顺序号。因此,确认序号应当是上次已成功收到数据字节顺序号加 1 。只有 ACK 标志为 1 时确认序号字段才有效。 TCP 为应用层提供全双工服务,这意味数据能在两个方向上独立地进行传输。因此,连接的每一端必须保持每个方向上的传输数据顺序号。</li><li>TCP 报头长度( 4 位):给出报头中 32bit 字的数目,它实际上指明数据从哪里开始。需要这个值是因为任选字段的长度是可变的。这个字段占 4bit ,因此 TCP 最多有 60 字节的首部。然而,没有任选字段,正常的长度是 20 字节。</li><li>保留位( 6 位):保留给将来使用,目前必须置为 0 。</li><li>控制位( control flags , 6 位):在 TCP 报头中有 6 个标志比特,它们中的多个可同时被设置为 1 。</li></ol><p>依次为:</p><blockquote><p>URG :为 1 表示紧急指针有效,为 0 则忽略紧急指针值。<br>ACK :为 1 表示确认号有效,为 0 表示报文中不包含确认信息,忽略确认号字段。<br>PSH :为 1 表示是带有 PUSH 标志的数据,指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满。<br>RST :用于复位由于主机崩溃或其他原因而出现错误的连接。它还可以用于拒绝非法的报文段和拒绝连接请求。一般情况下,如果收到一个 RST 为 1 的报文,那么一定发生了某些问题。<br>SYN :同步序号,为 1 表示连接请求,用于建立连接和使顺序号同步( synchronize )。<br>FIN :用于释放连接,为 1 表示发送方已经没有数据发送了,即关闭本方数据流。</p></blockquote><p>8.窗口大小( 16 位):数据字节数,表示从确认号开始,本报文的源方可以接收的字节数,即源方接收窗口大小。窗口大小是一个 16bit 字段,因而窗口大小最大为 65535 字节。<br>9.校验和( 16 位):此校验和是对整个的 TCP 报文段,包括 TCP 头部和 TCP 数据,以 16 位字进行计算所得。这是一个强制性的字段,一定是由发送端计算和存储,并由接收端进行验证。<br>10. 紧急指针( 16 位):只有当 URG 标志置 1 时紧急指针才有效。TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。</p><ol start="11"><li>选项:最常见的可选字段是最长报文大小,又称为 MSS(Maximum Segment Size) 。每个连接方通常都在通信的第一个报文段(为建立连接而设置 SYN 标志的那个段)中指明这个选项,它指明本端所能接收的最大长度的报文段。选项长度不一定是 32 位字的整数倍,所以要加填充位,使得报头长度成为整字数。</li><li>数据: TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时,双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送,也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中,也会发送不带任何数据的报文段。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/three-hand.png" alt="avatar"></p><h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><p>第一次握手:主机 A 发送位码为 syn=1,随机产生 seq number=1234567 的数据包到服务器,主机 B由 SYN=1 知道,A 要求建立联机;<br>第二次握手: 主 机 B 收 到 请 求 后 要 确 认 联 机 信 息 , 向 A 发 送 ack number=( 主 机 A 的seq+1),syn=1,ack=1,随机产生 seq=7654321 的包<br>第三次握手:主机 A 收到后检查 ack number 是否正确,即第一次发送的 seq number+1,以及位码ack 是否为 1,若正确,主机 A 会再发送 ack number=(主机 B 的 seq+1),ack=1,主机 B 收到后确认seq 值与 ack=1 则连接建立成功。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/three-hand-1.png" alt="avatar"></p><h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><p>TCP 建立连接要进行三次握手,而断开连接要进行四次。这是由于 TCP 的半关闭造成的。因为 TCP 连接是全双工的(即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭。这个单方向的关闭就叫半关闭。当一方完成它的数据发送任务,就发送一个 FIN 来向另一方通告将要终止这个方向的连接。</p><ol><li>关闭客户端到服务器的连接:首先客户端 A 发送一个 FIN,用来关闭客户到服务器的数据传送,然后等待服务器的确认。其中终止标志位 FIN=1,序列号 seq=u</li><li>服务器收到这个 FIN,它发回一个 ACK,确认号 ack 为收到的序号加 1。</li><li>关闭服务器到客户端的连接:也是发送一个 FIN 给客户端。</li><li>客户段收到 FIN 后,并发回一个 ACK 报文确认,并将确认序号 seq 设置为收到序号加 1。首先进行关闭的一方将执行主动关闭,而另一方执行被动关闭。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/four-hand.png" alt="avatar"></p><p>主机 A 发送 FIN 后,进入终止等待状态, 服务器 B 收到主机 A 连接释放报文段后,就立即给主机 A 发送确认,然后服务器 B 就进入 close-wait 状态,此时 TCP 服务器进程就通知高层应用进程,因而从 A 到 B 的连接就释放了。此时是“半关闭”状态。即 A 不可以发送给B,但是 B 可以发送给 A。此时,若 B 没有数据报要发送给 A 了,其应用进程就通知 TCP 释放连接,然后发送给 A 连接释放报文段,并等待确认。A 发送确认后,进入 time-wait,注意,此时 TCP 连接还没有释放掉,然后经过时间等待计时器设置的 2MSL 后,A 才进入到close 状态。</p><h1 id="HTTP-原理"><a href="#HTTP-原理" class="headerlink" title="HTTP 原理"></a>HTTP 原理</h1><p>HTTP 是一个无状态的协议。无状态是指客户机(Web 浏览器)和服务器之间不需要建立持久的连接,这意味着当一个客户端向服务器端发出请求,然后服务器返回响应(response),连接就被关闭了,在服务器端不保留连接的有关信息.HTTP 遵循请求(Request)/应答(Response)模型。客户机(浏览器)向服务器发送请求,服务器处理请求并返回适当的应答。所有 HTTP 连接都被构造成一套请求和应答。</p><h1 id="传输流程"><a href="#传输流程" class="headerlink" title="传输流程"></a>传输流程</h1><p>1 :地址解析</p><p>如用客户端浏览器请求这个页面:<a href="http://localhost.com:8080/index.htm">http://localhost.com:8080/index.htm</a> 从中分解出协议名、主机名、端口、对象路径等部分,对于我们的这个地址,解析得到的结果如下:</p><p>协议名:http<br>主机名:localhost.com<br>端口:8080<br>对象路径:/index.htm</p><p>在这一步,需要域名系统 DNS 解析域名 localhost.com,得主机的 IP 地址。</p><p>2 :封装 HTTP 请求数据包把以上部分结合本机自己的信息,封装成一个 HTTP 请求数据包</p><p>3 :封装成 TCP 包并建立连接封装成 TCP 包,建立 TCP 连接(TCP 的三次握手)</p><p>4 :客户机发送请求命<br>4)客户机发送请求命令:建立连接后,客户机发送一个请求给服务器,请求方式的格式为:统一资源标识符(URL)、协议版本号,后边是 MIME 信息包括请求修饰符、客户机信息和可内容。</p><p>5 :服务器响应服务器接到请求后,给予相应的响应信息,其格式为一个状态行,包括信息的协议版本号、一个成功或错误的代码,后边是 MIME 信息包括服务器信息、实体信息和可能的内容。</p><p>6 :服务器关闭 TCP 连接服务器关闭 TCP 连接:一般情况下,一旦 Web 服务器向浏览器发送了请求数据,它就要关闭 TCP 连接,然后如果浏览器或者服务器在其头信息加入了这行代码 Connection:keep-alive,TCP 连接在发送后将仍然保持打开状态,于是,浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间,还节约了网络带宽。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/tcp-layer.png" alt="avatar"></p><table border="1px" class="reference"><caption>HTTP状态码列表</caption><tbody><tr><th>状态码</th><th>状态码英文名称</th><th>中文描述</th></tr><tr><td>100</td><td>Continue</td><td>继续。<a href="http://www.dreamdu.com/webbuild/client_vs_server/">客户端</a>应继续其请求</td></tr><tr><td>101</td><td>Switching Protocols</td><td>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td colspan="3"></td></tr><tr><td>200</td><td>OK</td><td>请求成功。一般用于GET与POST请求</td></tr><tr><td>201</td><td>Created</td><td>已创建。成功请求并创建了新的资源</td></tr><tr><td>202</td><td>Accepted</td><td>已接受。已经接受请求，但未处理完成</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td>204</td><td>No Content</td><td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td>205</td><td>Reset Content</td><td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td>206</td><td>Partial Content</td><td>部分内容。服务器成功处理了部分GET请求</td></tr><tr><td colspan="3"></td></tr><tr><td>300</td><td>Multiple Choices</td><td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td>302</td><td>Found</td><td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td>303</td><td>See Other</td><td>查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td>305</td><td>Use Proxy</td><td>使用代理。所请求的资源必须通过代理访问</td></tr><tr><td>306</td><td>Unused</td><td>已经被废弃的HTTP状态码</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td colspan="3"></td></tr><tr><td>400</td><td>Bad Request</td><td>客户端请求的语法错误，服务器无法理解</td></tr><tr><td>401</td><td>Unauthorized</td><td>请求要求用户的身份认证</td></tr><tr><td>402</td><td>Payment Required</td><td>保留，将来使用</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>客户端请求中的方法被禁止</td></tr><tr><td>406</td><td>Not Acceptable</td><td>服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td>407</td><td>Proxy Authentication Required</td><td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td>408</td><td>Request Time-out</td><td>服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td>409</td><td>Conflict</td><td>服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td>410</td><td>Gone</td><td>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td>411</td><td>Length Required</td><td>服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td>412</td><td>Precondition Failed</td><td>客户端请求信息的先决条件错误</td></tr><tr><td>413</td><td>Request Entity Too Large</td><td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td>414</td><td>Request-URI Too Large</td><td>请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td>415</td><td>Unsupported Media Type</td><td>服务器无法处理请求附带的媒体格式</td></tr><tr><td>416</td><td>Requested range not satisfiable</td><td>客户端请求的范围无效</td></tr><tr><td>417</td><td>Expectation Failed</td><td>服务器无法满足Expect的请求头信息</td></tr><tr><td colspan="3"></td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能，无法完成请求</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td>504</td><td>Gateway Time-out</td><td>充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td>505</td><td>HTTP Version not supported</td><td>服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>HTTPS(全称:Hypertext Transfer Protocol over Secure Socket Layer),是以安全为目标的</p><p>HTTP 通道,简单讲是 HTTP 的安全版。即 HTTP 下加入 SSL 层,HTTPS 的安全基础是 SSL。</p><p>其所用的端口号是 443。 过程大致如下:</p><h2 id="建立连接获取证书"><a href="#建立连接获取证书" class="headerlink" title="建立连接获取证书"></a>建立连接获取证书</h2><ol><li>SSL 客户端通过 TCP 和服务器建立连接之后(443 端口),并且在一般的 tcp 连接协商(握手)过程中请求证书。即客户端发出一个消息给服务器,这个消息里面包含了自己可实现的算法列表和其它一些需要的消息,SSL 的服务器端会回应一个数据包,这里面确定了这次通信所需要的算法,然后服务器向客户端返回证书。(证书里面包含了服务器信息:域名。申请证书的公司,公共秘钥)。证书验证</li><li>Client 在收到服务器返回的证书后,判断签发这个证书的公共签发机构,并使用这个机构的公共秘钥确认签名是否有效,客户端还会确保证书中列出的域名就是它正在连接的域名。数据加密和传输</li><li>如果确认证书有效,那么生成对称秘钥并使用服务器的公共秘钥进行加密。然后发送给服务器,服务器使用它的私钥对它进行解密,这样两台计算机可以开始进行对称加密进行通信。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/https.png" alt="avatar"></p><h1 id="CDN-原理"><a href="#CDN-原理" class="headerlink" title="CDN 原理"></a>CDN 原理</h1><p>CND 一般包含分发服务系统、负载均衡系统和管理系统</p><h2 id="分发服务系统"><a href="#分发服务系统" class="headerlink" title="分发服务系统"></a>分发服务系统</h2><p>其基本的工作单元就是各个 Cache 服务器。负责直接响应用户请求,将内容快速分发到用户;同时还负责内容更新,保证和源站内容的同步。</p><p>根据内容类型和服务种类的不同,分发服务系统分为多个子服务系统,如:网页加速服务、流媒体加速服务、应用加速服务等。每个子服务系统都是一个分布式的服务集群,由功能类似、地域接近的分布部署的 Cache 集群组成。在承担内容同步、更新和响应用户请求之外,分发服务系统还需要向上层的管理调度系统反馈各个Cache 设备的健康状况、响应情况、内容缓存状况等,以便管理调度系统能够根据设定的策略决定由哪个 Cache 设备来响应用户的请求。</p><h1 id="负载均衡系统"><a href="#负载均衡系统" class="headerlink" title="负载均衡系统:"></a>负载均衡系统:</h1><p>负载均衡系统是整个 CDN 系统的中枢。负责对所有的用户请求进行调度,确定提供给用户的最终访问地址。<br>使用分级实现。最基本的两极调度体系包括全局负载均衡(GSLB)和本地负载均衡(SLB)。<br>GSLB 根据用户地址和用户请求的内容,主要根据就近性原则,确定向用户服务的节点。一般通过 DNS解析或者应用层重定向(Http 3XX 重定向)的方式实现。<br>SLB 主要负责节点内部的负载均衡。当用户请求从 GSLB 调度到 SLB 时,SLB 会根据节点内各个Cache 设备的工作状况和内容分布情况等对用户请求重定向。SLB 的实现有四层调度(LVS)、七层调度(Nginx)和链路负载调度等。</p><h1 id="管理系统"><a href="#管理系统" class="headerlink" title="管理系统:"></a>管理系统:</h1><p>分为运营管理和网络管理子系统。<br>网络管理系统实现对 CDN 系统的设备管理、拓扑管理、链路监控和故障管理,为管理员提供对全网资源的可视化的集中管理,通常用 web 方式实现。<br>运营管理是对 CDN 系统的业务管理,负责处理业务层面的与外界系统交互所必须的一些收集、整理、交付工作。包括用户管理、产品管理、计费管理、统计分析等。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/system.png" alt="avatar"></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React 快速入门</title>
    <link href="/2020/08/12/front/React-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2020/08/12/front/React-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li> React is a JavaScript library - one of the most popular ones, with over 100,000 stars on GitHub.</li><li> React is not a framework (unlike Angular, which is more opinionated).</li><li> React is an open-source project created by Facebook.</li><li> React is used to build user interfaces (UI) on the front end.</li><li> React is the view layer of an MVC application (Model View Controller)<blockquote><p> One of the most important aspects of React is the fact that you can create components, which are like custom, reusable HTML elements, to quickly and efficiently build user interfaces. React also streamlines how data is stored and handled, using state and props.</p></blockquote></li></ul><h1 id="JSX简介"><a href="#JSX简介" class="headerlink" title="JSX简介"></a>JSX简介</h1><p><code>const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;</code></p><p>这个有趣的标签语法既不是字符串也不是 HTML。</p><p>它被称为 JSX，是一个 JavaScript 的语法扩展。我们建议在 React 中配合使用 JSX，JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。JSX 可能会使人联想到模版语言，但它具有 JavaScript 的全部功能。</p><h2 id="为什么使用-JSX？"><a href="#为什么使用-JSX？" class="headerlink" title="为什么使用 JSX？"></a>为什么使用 JSX？</h2><p>React 认为渲染逻辑本质上与其他 UI 逻辑内在耦合，比如，在 UI 中需要绑定处理事件、在某些时刻状态发生变化时需要通知到 UI，以及需要在 UI 中展示准备好的数据。</p><p>React 并没有采用将标记与逻辑进行分离到不同文件这种人为地分离方式，而是通过将二者共同存放在称之为“组件”的松散耦合单元之中，来实现关注点分离。我们将在后面章节中深入学习组件。如果你还没有适应在 JS 中使用标记语言，这个会议讨论应该可以说服你。</p><p>React 不强制要求使用 JSX，但是大多数人发现，在 JavaScript 代码中将 JSX 和 UI 放在一起时，会在视觉上有辅助作用。它还可以使 React 显示更多有用的错误和警告消息。</p><p>搞清楚这个问题后，我们就开始学习 JSX 吧！</p><h2 id="在-JSX-中嵌入表达式"><a href="#在-JSX-中嵌入表达式" class="headerlink" title="在 JSX 中嵌入表达式"></a>在 JSX 中嵌入表达式</h2><p>在下面的例子中，我们声明了一个名为 name 的变量，然后在 JSX 中使用它，并将它包裹在大括号中：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;Josh Perez&#x27;</span>;<br><span class="hljs-keyword">const</span> element = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br><br>ReactDOM.render(<br>  element,<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><p>在 JSX 语法中</p><h1 id="元素渲染"><a href="#元素渲染" class="headerlink" title="元素渲染"></a>元素渲染</h1><h1 id="组件-amp-Props"><a href="#组件-amp-Props" class="headerlink" title="组件 &amp; Props"></a>组件 &amp; Props</h1><h1 id="State-amp-生命周期"><a href="#State-amp-生命周期" class="headerlink" title="State &amp; 生命周期"></a>State &amp; 生命周期</h1><h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><h1 id="列表-amp-Key"><a href="#列表-amp-Key" class="headerlink" title="列表 &amp; Key"></a>列表 &amp; Key</h1><h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><h1 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h1><h1 id="组合-vs-继承"><a href="#组合-vs-继承" class="headerlink" title="组合 vs 继承"></a>组合 vs 继承</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.taniarascia.com/">官网</a></p><p><a href="https://www.taniarascia.com/getting-started-with-react/">快速开始</a></p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty 与 RPC</title>
    <link href="/2020/08/10/note/Netty-%E4%B8%8E-RPC/"/>
    <url>/2020/08/10/note/Netty-%E4%B8%8E-RPC/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Netty-原理"><a href="#Netty-原理" class="headerlink" title="Netty 原理"></a>Netty 原理</h1><blockquote><p>Netty 是一个高性能、异步事件驱动的 NIO 框架,基于 JAVA NIO 提供的 API 实现。它提供了对<br>TCP、UDP 和文件传输的支持,作为一个异步 NIO 框架,Netty 的所有 IO 操作都是异步非阻塞<br>的,通过 Future-Listener 机制,用户可以方便的主动获取或者通过通知机制获得 IO 操作结果。<br>8.1.2. Netty 高性能<br>在 IO 编程过程中,当需要同时处理多个客户端接入请求时,可以利用多线程或者 IO 多路复用技术<br>进行处理。IO 多路复用技术通过把多个 IO 的阻塞复用到同一个 select 的阻塞上,从而使得系统在<br>单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型比,I/O 多路复用的<br>最大优势是系统开销小,系统不需要创建新的额外进程或者线程,也不需要维护这些进程和线程<br>的运行,降低了系统的维护工作量,节省了系统资源。<br>与 Socket 类和 ServerSocket 类相对应,NIO 也提供了 SocketChannel 和 ServerSocketChannel<br>两种不同的套接字通道实现。</p></blockquote><h1 id="多路复用通讯方式"><a href="#多路复用通讯方式" class="headerlink" title="多路复用通讯方式"></a>多路复用通讯方式</h1><p>Netty 架构按照 Reactor 模式设计和实现,它的服务端通信序列图如下:</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-reactor.png" alt="avatar"></p><p>客户端通信</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-reactor-client.png" alt="avatar"></p><p>Netty 的 IO 线程 NioEventLoop 由于聚合了多路复用器 Selector,可以同时并发处理成百上千个客户端 Channel,由于读写操作都是非阻塞的,这就可以充分提升 IO 线程的运行效率,避免由于频繁 IO 阻塞导致的线程挂起。</p><h1 id="异步通讯-NIO"><a href="#异步通讯-NIO" class="headerlink" title="异步通讯 NIO"></a>异步通讯 NIO</h1><p>由于 Netty 采用了异步通信模式,一个 IO 线程可以并发处理 N 个客户端连接和读写操作,这从根本上解决了传统同步阻塞 IO 一连接一线程模型,架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</p><p>零拷贝(DIRECT BUFFERS 使用堆外直接内存)</p><p>1.</p><blockquote><p>Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS,使用堆外直接内存进行 Socket 读写,不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存(HEAP BUFFERS)进行 Socket 读写,JVM 会将堆内存 Buffer 拷贝一份到直接内存中,然后才写入 Socket 中。相比于堆外直接内存,消息在发送过程中多了一次缓冲区的内存拷贝。</p></blockquote><p>2.</p><blockquote><p>Netty 提供了组合 Buffer 对象,可以聚合多个 ByteBuffer 对象,用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作,避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的Buffer。</p></blockquote><p>3.</p><blockquote><p>Netty 的文件传输采用了 transferTo 方法,它可以直接将文件缓冲区的数据发送到目标 Channel,避免了传统通过循环 write 方式导致的内存拷贝问题</p></blockquote><h2 id="内存池-基于内存池的缓冲区重用机制"><a href="#内存池-基于内存池的缓冲区重用机制" class="headerlink" title="内存池(基于内存池的缓冲区重用机制)"></a>内存池(基于内存池的缓冲区重用机制)</h2><p>随着 JVM 虚拟机和 JIT 即时编译技术的发展,对象的分配和回收是个非常轻量级的工作。但是对于缓冲区 Buffer,情况却稍有不同,特别是对于堆外直接内存的分配和回收,是一件耗时的操作。为了尽量重用缓冲区,Netty 提供了基于内存池的缓冲区重用机制。</p><h2 id="高效的-Reactor-线程模型"><a href="#高效的-Reactor-线程模型" class="headerlink" title="高效的 Reactor 线程模型"></a>高效的 Reactor 线程模型</h2><p>常用的 Reactor 线程模型有三种,Reactor 单线程模型, Reactor 多线程模型, 主从 Reactor 多线程模型。</p><h3 id="Reactor-单线程模型"><a href="#Reactor-单线程模型" class="headerlink" title="Reactor 单线程模型"></a>Reactor 单线程模型</h3><blockquote><p>Reactor 单线程模型,指的是所有的 IO 操作都在同一个 NIO 线程上面完成,NIO 线程的职责如下:</p></blockquote><ol><li>作为 NIO 服务端,接收客户端的 TCP 连接;</li><li>作为 NIO 客户端,向服务端发起 TCP 连接;</li><li>读取通信对端的请求或者应答消息;</li><li>向通信对端发送消息请求或者应答消息。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/reactor-more-thread.png" alt="avatar"></p><p>由于 Reactor 模式使用的是异步非阻塞 IO,所有的 IO 操作都不会导致阻塞,理论上一个线程可以独立处理所有 IO 相关的操作。从架构层面看,一个 NIO 线程确实可以完成其承担的职责。例如,通过Acceptor 接收客户端的 TCP 连接请求消息,链路建立成功之后,通过 Dispatch 将对应的 ByteBuffer派发到指定的 Handler 上进行消息解码。用户 Handler 可以通过 NIO 线程将消息发送给客户端。</p><h3 id="Reactor-多线程模型"><a href="#Reactor-多线程模型" class="headerlink" title="Reactor 多线程模型"></a>Reactor 多线程模型</h3><p>Rector 多线程模型与单线程模型最大的区别就是有一组 NIO 线程处理 IO 操作。 有专门一个NIO 线程-Acceptor 线程用于监听服务端,接收客户端的 TCP 连接请求; 网络 IO 操作-读、写等由一个 NIO 线程池负责,线程池可以采用标准的 JDK 线程池实现,它包含一个任务队列和 N个可用的线程,由这些 NIO 线程负责消息的读取、解码、编码和发送;</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/master-slave-reactor-thread.png" alt="avatar"></p><p>主从 Reactor 多线程模型</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/master-slave-reactor-thread-2.png" alt="avatar"></p><blockquote><p>服务端用于接收客户端连接的不再是个 1 个单独的 NIO 线程,而是一个独立的 NIO 线程池。<br>Acceptor 接收到客户端 TCP 连接请求处理完成后(可能包含接入认证等),将新创建的SocketChannel 注册到 IO 线程池(sub reactor 线程池)的某个 IO 线程上,由它负责SocketChannel 的读写和编解码工作。Acceptor 线程池仅仅只用于客户端的登陆、握手和安全认证,一旦链路建立成功,就将链路注册到后端 subReactor 线程池的 IO 线程上,由 IO 线程负责后续的 IO 操作。</p></blockquote><h3 id="无锁设计、线程绑定"><a href="#无锁设计、线程绑定" class="headerlink" title="无锁设计、线程绑定"></a>无锁设计、线程绑定</h3><p>Netty 采用了串行无锁化设计,在 IO 线程内部进行串行操作,避免多线程竞争导致的性能下降。<br>表面上看,串行化设计似乎 CPU 利用率不高,并发程度不够。但是,通过调整 NIO 线程池的线程参数,可以同时启动多个串行化的线程并行运行,这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优。<br>Netty 的 NioEventLoop 读取到消息之后,直接调用 ChannelPipeline 的fireChannelRead(Object msg),只要用户不主动切换线程,一直会由 NioEventLoop 调用到用户的 Handler,期间不进行线程切换,这种串行化处理方式避免了多线程操作导致的锁的竞争,从性能角度看是最优的。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/no-block-thread.png" alt="avatar"></p><h3 id="高性能的序列化框架"><a href="#高性能的序列化框架" class="headerlink" title="高性能的序列化框架"></a>高性能的序列化框架</h3><p>Netty 默认提供了对 Google Protobuf 的支持,通过扩展 Netty 的编解码接口,用户可以实现其它的高性能序列化框架,例如 Thrift 的压缩二进制编解码框架。</p><p>1.SO_RCVBUF 和 SO_SNDBUF:通常建议值为 128K 或者 256K。小包封大包,防止网络阻塞</p><p>2.SO_TCPNODELAY:NAGLE 算法通过将缓冲区内的小封包自动相连,组成较大的封包,阻止大量小封包的发送阻塞网络,从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法。软中断 Hash 值和 CPU 绑定</p><p>3.软中断:开启 RPS 后可以实现软中断,提升网络吞吐量。RPS 根据数据包的源地址,目的地址以及目的和源端口,计算出一个 hash 值,然后根据这个 hash 值来选择软中断运行的 cpu,从上层来看,也就是说将每个连接和 cpu 绑定,并通过这个 hash 值,来均衡软中断在多个 cpu 上,提升网络并行处理性能。</p><h1 id="Netty-RPC-实现"><a href="#Netty-RPC-实现" class="headerlink" title="Netty RPC 实现"></a>Netty RPC 实现</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>RPC,即 Remote Procedure Call(远程过程调用),调用远程计算机上的服务,就像调用本地服务一样。RPC 可以很好的解耦系统,如 WebService 就是一种基于 Http 协议的 RPC。这个 RPC 整体框架</p><p>如下:</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/netty-rpc.png" alt="avatar"></p><h2 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h2><p>1  服务发布与订阅:服务端使用 Zookeeper 注册服务地址,客户端从 Zookeeper 获取可用的服务地址。<br>2. 通信:使用 Netty 作为通信框架。<br>3. Spring:使用 Spring 配置服务,加载 Bean,扫描注解。<br>4. 动态代理:客户端使用代理模式透明化服务调用。<br>5. 消息编解码:使用 Protostuff 序列化和反序列化消息。</p><p>1.核心流程服务消费方(client)调用以本地调用方式调用服务;<br>2. client stub 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体;<br>3. client stub 找到服务地址,并将消息发送到服务端;<br>4. server stub 收到消息后进行解码;<br>5. server stub 根据解码结果调用本地的服务;<br>6. 本地服务执行并将结果返回给 server stub;<br>7. server stub 将返回结果打包成消息并发送至消费方;<br>8. client stub 接收到消息,并进行解码;<br>9. 服务消费方得到最终结果。</p><blockquote><p>RPC 的目标就是要 2~8 这些步骤都封装起来,让用户对这些细节透明。JAVA 一般使用动态代理方式实现远程调用。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/rpc-proxy.png" alt="avatar"></p><h2 id="消息编解码"><a href="#消息编解码" class="headerlink" title="消息编解码"></a>消息编解码</h2><p>息数据结构(接口名称 + 方法名 + 参数类型和参数值 + 超时时间 + requestID )<br>客户端的请求消息结构一般需要包括以下内容:</p><p>1.接口名称:在我们的例子里接口名是“HelloWorldService”,如果不传,服务端就不知道调用哪个接口了;<br>2. 方法名:一个接口内可能有很多方法,如果不传方法名服务端也就不知道调用哪个方法;<br>3. 参数类型和参数值:参数类型有很多,比如有 bool、int、long、double、string、map、list,甚至如 struct(class);以及相应的参数值;<br>4. 超时时间:<br>5. requestID,标识唯一请求 id,在下面一节会详细描述 requestID 的用处。<br>6. 服务端返回的消息 : 一般包括以下内容。返回值+状态 code+requestID</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>目前互联网公司广泛使用 Protobuf、Thrift、Avro 等成熟的序列化解决方案来搭建 RPC 框架,这些都是久经考验的解决方案。</p><h2 id="通讯过程"><a href="#通讯过程" class="headerlink" title="通讯过程"></a>通讯过程</h2><p>核心问题 ( 线程暂停、消息乱序 )<br>如果使用 netty 的话,一般会用 channel.writeAndFlush()方法来发送消息二进制串,这个方法调用后对于整个远程调用(从发出请求到接收到结果)来说是一个异步的,即对于当前线程来说,将请求发送出来后,线程就可以往后执行了,至于服务端的结果,是服务端处理完成后,再以消息的形式发送给客户端的。于是这里出现以下两个问题:</p><ol><li>怎么让当前线程“暂停”,等结果回来后,再向后执行?</li><li>如果有多个线程同时进行远程方法调用,这时建立在 client server 之间的 socket 连接上会有很多双方发送的消息传递,前后顺序也可能是随机的,server 处理完结果后,将结果消息发送给 client,client 收到很多消息,怎么知道哪个消息结果是原先哪个线程调用的?如下图所示,线程 A 和线程 B 同时向 client socket 发送请求 requestA 和 requestB,socket 先后将 requestB 和 requestA 发送至 server,而 server 可能将 responseB 先返回, 尽管 requestB 请 求 到达 时 间 更晚 。 我 们需 要 一种 机 制 保证 responseA 丢给ThreadA,responseB 丢给 ThreadB。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/rpc-proxy.png" alt="avatar"></p><h2 id="通讯流程"><a href="#通讯流程" class="headerlink" title="通讯流程"></a>通讯流程</h2><p>requestID 生成 -AtomicLong</p><p>1.client 线程每次通过 socket 调用一次远程接口前,生成一个唯一的 ID,即 requestID(requestID 必需保证在一个 Socket 连接里面是唯一的),一般常常使用 AtomicLong从 0 开始累计数字生成唯一 ID;存放回调对象 callback 到全局 ConcurrentHashMap</p><p>2.将 处 理 结 果 的 回 调 对 象 callback , 存 放 到 全 局 ConcurrentHashMap 里 面put(requestID, callback);synchronized 获取回调对象 callback 的锁并自旋 wait</p><p>3.当线程调用 channel.writeAndFlush()发送消息后,紧接着执行 callback 的 get()方法试图获取远程返回的结果。在 get()内部,则使用 synchronized 获取回调对象 callback 的锁,再先检测是否已经获取到结果,如果没有,然后调用 callback 的 wait()方法,释放callback 上的锁,让当前线程处于等待状态。监听消息的线程收到消息,找到 callback 上的锁并唤醒</p><p>4.服务端接收到请求并处理后,将 response 结果(此结果中包含了前面的 requestID)发送给客户端,客户端 socket 连接上专门监听消息的线程收到消息,分析结果,取到requestID , 再 从 前 面 的 ConcurrentHashMap 里 面 get(requestID) , 从 而 找 到callback 对象,再用 synchronized 获取 callback 上的锁,将方法调用结果设置到callback 对象里,再调用 callback.notifyAll()唤醒前面处于等待状态的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123; <span class="hljs-comment">// 旋锁</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123; <span class="hljs-comment">// 是否有结果了</span><br>            If (!isDone)&#123;<br>                wait(); <span class="hljs-comment">//没结果释放锁,让当前线程处于等待状态</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//获取数据并处理</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDone</span><span class="hljs-params">(Response res)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.res = res;<br>    isDone = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123; <span class="hljs-comment">//获取锁,因为前面 wait()已经释放了 callback 的锁了</span><br>        notifyAll(); <span class="hljs-comment">// 唤醒处于等待的线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="RMI-实现方式"><a href="#RMI-实现方式" class="headerlink" title="RMI 实现方式"></a>RMI 实现方式</h2><p>Java 远程方法调用,即 Java RMI(Java Remote Method Invocation)是 Java 编程语言里,一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使 Java 编程人员能够在网络环境中分布操作。RMI 全部的宗旨就是尽可能简化远程接口对象的使用。</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol><li>编写远程服务接口,该接口必须继承 java.rmi.Remote 接口,方法必须抛出java.rmi.RemoteException 异常;</li><li>编写远程接口实现类,该实现类必须继承 java.rmi.server.UnicastRemoteObject 类;</li><li>运行 RMI 编译器(rmic),创建客户端 stub 类和服务端 skeleton 类;</li><li>启动一个 RMI 注册表,以便驻留这些服务;</li><li>在 RMI 注册表中注册服务;</li><li>客户端查找远程对象,并调用远程方法;</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1:创建远程接口,继承 java.rmi.Remote 接口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GreetService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">java</span>.<span class="hljs-title">rmi</span>.<span class="hljs-title">Remote</span> </span>&#123;<br>        <span class="hljs-function">String <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> RemoteException</span>;<br>    &#125;<br><span class="hljs-comment">//2:实现远程接口,继承 java.rmi.server.UnicastRemoteObject 类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreetServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">java</span>.<span class="hljs-title">rmi</span>.<span class="hljs-title">server</span>.<span class="hljs-title">UnicastRemoteObject</span></span><br><span class="hljs-class">            <span class="hljs-keyword">implements</span> <span class="hljs-title">GreetService</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">3434060152387200042L</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GreetServiceImpl</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;<br>            <span class="hljs-keyword">super</span>();<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello &quot;</span> + name;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//3:生成 Stub 和 Skeleton;</span><br><span class="hljs-comment">//4:执行 rmiregistry 命令注册服务</span><br><span class="hljs-comment">//5:启动服务</span><br>LocateRegistry.createRegistry(<span class="hljs-number">1098</span>);<br>Naming.bind(<span class="hljs-string">&quot;rmi://10.108.1.138:1098/GreetService&quot;</span>, <span class="hljs-keyword">new</span> GreetServiceImpl());<br><span class="hljs-comment">//6.客户端调用</span><br>GreetService greetService=(GreetService)Naming.lookup(<span class="hljs-string">&quot;rmi://10.108.1.138:1098/GreetService&quot;</span>);<br>System.out.println(greetService.sayHello(<span class="hljs-string">&quot;Jobs&quot;</span>));<br></code></pre></td></tr></table></figure><h1 id="Protocol-Buffer"><a href="#Protocol-Buffer" class="headerlink" title="Protocol Buffer"></a>Protocol Buffer</h1><blockquote><p>protocol buffer 是 google 的一个开源项目,它是用于结构化数据串行化的灵活、高效、自动的方法,例如 XML,不过它比 xml 更小、更快、也更简单。你可以定义自己的数据结构,然后使用代码生成器生成的代码来读写这个数据结构。你甚至可以在无需重新部署程序的情况下更新数据结构。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/protocol-buffer.png" alt="avatar"></p><p>Protocol Buffer 的序列化 &amp; 反序列化简单 &amp; 速度快的原因是:</p><ol><li>编码 / 解码 方式简单(只需要简单的数学运算 = 位移等等)</li><li>采用 Protocol Buffer 自身的框架代码 和 编译器 共同完成</li></ol><p>Protocol Buffer 的数据压缩效果好(即序列化后的数据量体积小)的原因是:</p><ol><li>a. 采用了独特的编码方式,如 Varint、Zigzag 编码方式等等</li><li>b. 采用 T - L - V 的数据存储方式:减少了分隔符的使用 &amp; 数据存储得紧凑</li></ol><h1 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h1><p>Apache Thrift 是 Facebook 实现的一种高效的、支持多种编程语言的远程服务调用的框架。本文将从Java 开发人员角度详细介绍 Apache Thrift 的架构、开发和部署,并且针对不同的传输协议和服务类型给出相应的 Java 实例,同时详细介绍 Thrift 异步客户端的实现,最后提出使用 Thrift 需要注意的事项。<br>目前流行的服务调用方式有很多种,例如基于 SOAP 消息格式的 Web Service,基于 JSON 消息格式的 RESTful 服务等。其中所用到的数据传输方式包括 XML,JSON 等,然而 XML 相对体积太大,传输效率低,JSON 体积较小,新颖,但还不够完善。本文将介绍由 Facebook 开发的远程服务调用框架<br>Apache Thrift,它采用接口描述语言定义并创建服务,支持可扩展的跨语言服务开发,所包含的代码生成引擎可以在多种语言中,如 <code>C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa,Smalltalk</code> 等创建高效的、无缝的服务,其传输数据采用二进制格式,相对 XML 和 JSON 体积更小,<br>对于高并发、大数据量和多语言的环境更有优势。本文将详细介绍 Thrift 的使用,并且提供丰富的实例代码加以解释说明,帮助使用者快速构建服务。</p><h2 id="为什么要-Thrift"><a href="#为什么要-Thrift" class="headerlink" title="为什么要 Thrift:"></a>为什么要 Thrift:</h2><p>1、多语言开发的需要 2、性能问题</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/thrift.png" alt="avatar"></p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务</title>
    <link href="/2020/07/30/microservice/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AF%87-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2020/07/30/microservice/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AF%87-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="服务注册发现"><a href="#服务注册发现" class="headerlink" title="服务注册发现"></a>服务注册发现</h1><p>服务注册就是维护一个登记簿,它管理系统内所有的服务地址。当新的服务启动后,它会向登记<br>簿交待自己的地址信息。服务的依赖方直接向登记簿要 Service Provider 地址就行了。当下用于服<br>务注册的工具非常多 ZooKeeper,Consul,Etcd, 还有 Netflix 家的 eureka 等。服务注册有两种<br>形式:客户端注册和第三方注册。</p><h1 id="客户端注册-zookeeper"><a href="#客户端注册-zookeeper" class="headerlink" title="客户端注册(zookeeper)"></a>客户端注册(zookeeper)</h1><p>客户端注册是服务自身要负责注册与注销的工作。当服务启动后向注册中心注册自身,当服务下<br>线时注销自己。期间还需要和注册中心保持心跳。心跳不一定要客户端来做,也可以由注册中心<br>负责(这个过程叫探活)。这种方式的缺点是注册工作与服务耦合在一起,不同语言都要实现一<br>套注册逻辑。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/service-discovery.png" alt="avatar"></p><h3 id="第三方注册-独立的服务-Registrar"><a href="#第三方注册-独立的服务-Registrar" class="headerlink" title="第三方注册( 独立的服务 Registrar )"></a>第三方注册( 独立的服务 Registrar )</h3><p>第三方注册由一个独立的服务 Registrar 负责注册与注销。当服务启动后以某种方式通知 Registrar,<br>然后 Registrar 负责向注册中心发起注册工作。同时注册中心要维护与服务之间的心跳,当服务不<br>可用时,向注册中心注销服务。这种方式的缺点是 Registrar 必须是一个高可用的系统,否则注册<br>工作没法进展。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/simple-register.png" alt="avatar"></p><h3 id="客户端发现"><a href="#客户端发现" class="headerlink" title="客户端发现"></a>客户端发现</h3><p>客户端发现是指客户端负责查询可用服务地址,以及负载均衡的工作。这种方式最方便直接,而<br>且也方便做负载均衡。再者一旦发现某个服务不可用立即换另外一个,非常直接。缺点也在于多<br>语言时的重复工作,每个语言实现相同的逻辑。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/client-discovery.png" alt="avatar"></p><h3 id="服务端发现"><a href="#服务端发现" class="headerlink" title="服务端发现"></a>服务端发现</h3><p>服务端发现需要额外的 Router 服务,请求先打到 Router,然后 Router 负责查询服务与负载均衡。<br>这种方式虽然没有客户端发现的缺点,但是它的缺点是保证 Router 的高可用。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/server-discovery.png" alt="avatar"></p><p>7.1.1.5. Consul<br>7.1.1.6. Eureka<br>7.1.1.7. SmartStack<br>7.1.1.8. Etcd</p><h2 id="Api-网关"><a href="#Api-网关" class="headerlink" title="Api 网关"></a>Api 网关</h2><p>API Gateway 是一个服务器,也可以说是进入系统的唯一节点。这跟面向对象设计模式中的<br>Facade 模式很像。API Gateway 封装内部系统的架构,并且提供 API 给各个客户端。它还可能有<br>其他功能,如授权、监控、负载均衡、缓存、请求分片和管理、静态响应处理等。下图展示了一<br>个适应当前架构的 API Gateway。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/gateway.png" alt="avatar"></p><p><code>API Gateway 负责请求转发、合成和协议转换。</code>所有来自客户端的请求都要先经过 API Gateway,然后路由这些请求到对应的微服务。API Gateway 将经常通过调用多个微服务来处理一个请求以及聚合多个服务的结果。它可以在 web 协议与内部使用的非 Web 友好型协议间进行转换,如HTTP 协议、WebSocket 协议。</p><p>请求转发</p><blockquote><p>服务转发主要是对客户端的请求安装微服务的负载转发到不同的服务上</p></blockquote><p>响应合并</p><blockquote><p>把业务上需要调用多个服务接口才能完成的工作合并成一次调用对外统一提供服务。</p></blockquote><p>协议转换</p><blockquote><p>重点是支持 SOAP,JMS,Rest 间的协议转换。</p></blockquote><p>数据转换</p><blockquote><p>重点是支持 XML 和 Json 之间的报文格式转换能力(可选)</p></blockquote><p>安全认证</p><blockquote><ol><li>基于 Token 的客户端访问控制和安全策略</li><li>传输数据和报文加密,到服务端解密,需要在客户端有独立的 SDK 代理包</li><li>基于 Https 的传输加密,客户端和服务端数字证书支持</li><li>基于 OAuth2.0 的服务安全认证(授权码,客户端,密码模式等)</li></ol></blockquote><h1 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h1><p>配置中心一般用作系统的参数配置,它需要满足如下几个要求:高效获取、实时感知、分布式访问。</p><h2 id="zookeeper-配置中心"><a href="#zookeeper-配置中心" class="headerlink" title="zookeeper 配置中心"></a>zookeeper 配置中心</h2><p>实现的架构图如下所示,采取数据加载到内存方式解决高效获取的问题,借助 zookeeper 的节点监听机制来实现实时感知。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/zookeeper.png" alt="avatar"></p><p>配置中心数据分类<br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/config-center-data-type.png" alt="avatar"></p><p>事件调度(kafka)</p><blockquote><p>消息服务和事件的统一调度,常用用 kafka ,activemq 等。</p></blockquote><p>服务跟踪( starter-sleuth )</p><blockquote><p>随着微服务数量不断增长,需要跟踪一个请求从一个微服务到下一个微服务的传播过程, SpringCloud Sleuth 正是解决这个问题,它在日志中引入唯一 ID,以保证微服务调用之间的一致性,这样你就能跟踪某个请求是如何从一个微服务传递到下一个。</p></blockquote><p>1.<br>为了实现请求跟踪,当请求发送到分布式系统的入口端点时,只需要服务跟踪框架为该请求<br>创建一个唯一的跟踪标识,同时在分布式系统内部流转的时候,框架始终保持传递该唯一标<br>识,直到返回给请求方为止,这个唯一标识就是前文中提到的 Trace ID。通过 Trace ID 的记<br>录,我们就能将所有请求过程日志关联起来。<br>2.<br>为了统计各处理单元的时间延迟,当请求达到各个服务组件时,或是处理逻辑到达某个状态<br>时,也通过一个唯一标识来标记它的开始、具体过程以及结束,该标识就是我们前文中提到<br>的 Span ID,对于每个 Span 来说,它必须有开始和结束两个节点,通过记录开始 Span 和结<br>束 Span 的时间戳,就能统计出该 Span 的时间延迟,除了时间戳记录之外,它还可以包含一<br>些其他元数据,比如:事件名称、请求信息等。<br>3.<br>在快速入门示例中,我们轻松实现了日志级别的跟踪信息接入,这完全归功于 spring-cloud-<br>starter-sleuth 组件的实现。在 Spring Boot 应用中,通过在工程中引入 spring-cloud-<br>starter-sleuth 依赖之后, 它会自动的为当前应用构建起各通信通道的跟踪机制,比如:<br>通过诸如 RabbitMQ、Kafka(或者其他任何 Spring Cloud Stream 绑定器实现的消息<br>中间件)传递的请求。<br>通过 Zuul 代理传递的请求。<br>通过 RestTemplate 发起的请求。</p><h1 id="服务熔断-Hystrix"><a href="#服务熔断-Hystrix" class="headerlink" title="服务熔断(Hystrix)"></a>服务熔断(Hystrix)</h1><p>在微服务架构中通常会有多个服务层调用,基础服务的故障可能会导致级联故障,进而造成整个<br>系统不可用的情况,这种现象被称为服务雪崩效应。服务雪崩效应是一种因“服务提供者”的不<br>可用导致“服务消费者”的不可用,并将不可用逐渐放大的过程。</p><p>熔断器的原理很简单,如同电力过载保护器。它可以实现快速失败,如果它在一段时间内侦测到<br>许多类似的错误,会强迫其以后的多个调用快速失败,不再访问远程服务器,从而防止应用程序<br>不断地尝试执行可能会失败的操作,使得应用程序继续执行而不用等待修正错误,或者浪费 CPU<br>时间去等到长时间的超时产生。熔断器也可以使应用程序能够诊断错误是否已经修正,如果已经<br>修正,应用程序会再次尝试调用操作。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/config.png" alt="avatar"></p><h2 id="Hystrix-断路器机制"><a href="#Hystrix-断路器机制" class="headerlink" title="Hystrix 断路器机制"></a>Hystrix 断路器机制</h2><p>断路器很好理解, 当 Hystrix Command 请求后端服务失败数量超过一定比例(默认 50%), 断路器会<br>切换到开路状态(Open). 这时所有请求会直接失败而不会发送到后端服务. 断路器保持在开路状态<br>一段时间后(默认 5 秒), 自动切换到半开路状态(HALF-OPEN). 这时会判断下一次请求的返回情况,<br>如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN). Hystrix 的断路器<br>就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效<br>请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力。</p><h2 id="API-管理"><a href="#API-管理" class="headerlink" title="API 管理"></a>API 管理</h2><p>SwaggerAPI 管理工具。</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 原理</title>
    <link href="/2020/07/27/java/Spring-%E5%8E%9F%E7%90%86/"/>
    <url>/2020/07/27/java/Spring-%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Spring-原理"><a href="#Spring-原理" class="headerlink" title="Spring 原理"></a>Spring 原理</h1><blockquote><p>它是一个全面的、企业应用开发一站式的解决方案,贯穿表现层、业务层、持久层。但是 Spring仍然可以和其他的框架无缝整合。</p></blockquote><h1 id="Spring-特点"><a href="#Spring-特点" class="headerlink" title="Spring 特点"></a>Spring 特点</h1><ul><li>轻量级<blockquote><p>从大小与开销两方面而言Spring都是轻量的，完整的Spring框架可以在一个大小只有1M多的JAR文件里发布，并且Spring所需的处理开销也是微不足道的。<br>此外Spring是非入侵式的：典型的Spring应用的对象不依赖Spring的特定类</p></blockquote></li><li>控制反转<blockquote><p>Spring通过一种称为控制反转IOC的技术促进了低耦合。当应用了IOC一个对象依赖的其他对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。</p></blockquote></li><li>面向切面<blockquote><p>Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开</p></blockquote></li><li>容器<blockquote><p>Spring包含并管理应用对象的配置和生命周期，在这个意义上是一种容器，你可以配置你的每个bean如何被创建—–基于一个可配置的原型，你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例—以及他们是如何关联的。</p></blockquote></li><li>框架集合<blockquote><p>Spring可以将简单的组件配置，组合成为复杂的应用，在Spring中应用对象被声明式的组合，典型的是在一个XML文件里，Spring也提供了很多基础功能(事物管理，持久化框架集成等)，将应用逻辑的开发留给开发者。</p></blockquote></li></ul><h1 id="Spring-核心组件"><a href="#Spring-核心组件" class="headerlink" title="Spring 核心组件"></a>Spring 核心组件</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/spring-core.png" alt="avatar"></p><h1 id="Spring-常用模块"><a href="#Spring-常用模块" class="headerlink" title="Spring 常用模块"></a>Spring 常用模块</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/spring-model.png" alt="avatar"></p><h1 id="Spring-主要包"><a href="#Spring-主要包" class="headerlink" title="Spring 主要包"></a>Spring 主要包</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/spring-package.png" alt="avatar"></p><h1 id="Spring-常用注解"><a href="#Spring-常用注解" class="headerlink" title="Spring 常用注解"></a>Spring 常用注解</h1><blockquote><p>bean 注入与装配的的方式有很多种,可以通过 xml,get set 方式,构造函数或者注解等。简单易用的方式就是使用 Spring 的注解了,Spring 提供了大量的注解方式。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/spring-annotation.png" alt="avatar"></p><h1 id="Spring-第三方结合"><a href="#Spring-第三方结合" class="headerlink" title="Spring 第三方结合"></a>Spring 第三方结合</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/spring-another.png" alt="avatar"></p><h1 id="Spring-IOC-原理"><a href="#Spring-IOC-原理" class="headerlink" title="Spring IOC 原理"></a>Spring IOC 原理</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>Spring 通过一个配置文件描述 Bean 及 Bean 之间的依赖关系,利用 Java 语言的反射功能实例化<br> Bean 并建立 Bean 之间的依赖关系。 Spring 的 IoC 容器在完成这些底层工作的基础上,还提供<br> 了 Bean 实例缓存、生命周期管理、 Bean 实例代理、事件发布、资源装载等高级服务。</p></blockquote><h2 id="Spring-容器高层视图"><a href="#Spring-容器高层视图" class="headerlink" title="Spring 容器高层视图"></a>Spring 容器高层视图</h2><blockquote><p>Spring 启动时读取应用程序提供的 Bean 配置信息,并在 Spring 容器中生成一份相应的 Bean 配<br>置注册表,然后根据这张注册表实例化 Bean,装配好 Bean 之间的依赖关系,为上层应用提供准<br>备就绪的运行环境。其中 Bean 缓存池为 HashMap 实现</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/spring-ioc.png" alt="avatar"></p><h1 id="IOC-容器实现"><a href="#IOC-容器实现" class="headerlink" title="IOC 容器实现"></a>IOC 容器实现</h1><h2 id="BeanFactory-框架基础设施"><a href="#BeanFactory-框架基础设施" class="headerlink" title="BeanFactory- 框架基础设施"></a>BeanFactory- 框架基础设施</h2><blockquote><p>BeanFactory 是 Spring 框架的基础设施,面向 Spring 本身;ApplicationContext 面向使用<br>Spring 框架的开发者,几乎所有的应用场合我们都直接使用 ApplicationContext 而非底层<br>的 BeanFactory。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/spring-ioc-beanfactory.png" alt="avatar"></p><h3 id="1-BeanDefinitionRegistry-注册表"><a href="#1-BeanDefinitionRegistry-注册表" class="headerlink" title="1.BeanDefinitionRegistry 注册表"></a>1.BeanDefinitionRegistry 注册表</h3><p>Spring 配置文件中每一个节点元素在 Spring 容器里都通过一个 BeanDefinition 对象表示,<br>它 描 述 了 Bean 的 配 置 信 息 。 而 BeanDefinitionRegistry 接 口 提 供 了 向 容 器 手 工 注 册<br>BeanDefinition 对象的方法。</p><h3 id="2-BeanFactory-顶层接口"><a href="#2-BeanFactory-顶层接口" class="headerlink" title="2.BeanFactory 顶层接口"></a>2.BeanFactory 顶层接口</h3><p>位于类结构树的顶端 ,它最主要的方法就是 getBean(String beanName),该方法从容器中<br>返回特定名称的 Bean,BeanFactory 的功能通过其他的接口得到不断扩展:</p><h3 id="3-ListableBeanFactory"><a href="#3-ListableBeanFactory" class="headerlink" title="3.ListableBeanFactory"></a>3.ListableBeanFactory</h3><p>该接口定义了访问容器中 Bean 基本信息的若干方法,如查看 Bean 的个数、获取某一类型<br>Bean 的配置名、查看容器中是否包括某一 Bean 等方法;</p><h3 id="4-HierarchicalBeanFactory-父子级联"><a href="#4-HierarchicalBeanFactory-父子级联" class="headerlink" title="4.HierarchicalBeanFactory 父子级联"></a>4.HierarchicalBeanFactory 父子级联</h3><p>父子级联 IoC 容器的接口,子容器可以通过接口方法访问父容器; 通过<br>HierarchicalBeanFactory 接口, Spring 的 IoC 容器可以建立父子层级关联的容器体系,子<br>容器可以访问父容器中的 Bean,但父容器不能访问子容器的 Bean。Spring 使用父子容器实<br>现了很多功能,比如在 Spring MVC 中,展现层 Bean 位于一个子容器中,而业务层和持久<br>层的 Bean 位于父容器中。这样,展现层 Bean 就可以引用业务层和持久层的 Bean,而业务<br>层和持久层的 Bean 则看不到展现层的 Bean。</p><h3 id="5-ConfigurableBeanFactory"><a href="#5-ConfigurableBeanFactory" class="headerlink" title="5.ConfigurableBeanFactory"></a>5.ConfigurableBeanFactory</h3><p>是一个重要的接口,增强了 IoC 容器的可定制性,它定义了设置类装载器、属性编辑器、容<br>器初始化后置处理器等方法;</p><h3 id="AutowireCapableBeanFactory-自动装配"><a href="#AutowireCapableBeanFactory-自动装配" class="headerlink" title="AutowireCapableBeanFactory 自动装配"></a>AutowireCapableBeanFactory 自动装配</h3><p>6.定义了将容器中的 Bean 按某种规则(如按名字匹配、按类型匹配等)进行自动装配的方法;SingletonBeanRegistry 运行期间注册单例 Bean</p><p>7.定义了允许在运行期间向容器注册单实例 Bean 的方法;对于单实例( singleton)的 Bean<br>来说,BeanFactory 会缓存 Bean 实例,所以第二次使用 getBean() 获取 Bean 时将直接从<br>IoC 容器的缓存中获取 Bean 实例。Spring 在 DefaultSingletonBeanRegistry 类中提供了一<br>个用于缓存单实例 Bean 的缓存器,它是一个用 HashMap 实现的缓存器,单实例的 Bean 以<br>beanName 为键保存在这个 HashMap 中。<br>依赖日志框框</p><p>8.在初始化 BeanFactory 时,必须为其提供一种日志框架,比如使用 Log4J, 即在类路径下提供 Log4J 配置文件,这样启动 Spring 容器才不会报错。</p><h2 id="ApplicationContext-面向开发应用"><a href="#ApplicationContext-面向开发应用" class="headerlink" title="ApplicationContext 面向开发应用"></a>ApplicationContext 面向开发应用</h2><p>ApplicationContext 由 BeanFactory 派 生 而 来 , 提 供 了 更 多 面 向 实 际 应 用 的 功 能 。<br>ApplicationContext 继承了 HierarchicalBeanFactory 和 ListableBeanFactory 接口,在此基础上,还通过多个其他的接口扩展了 BeanFactory 的功能:</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/beanfactory.png" alt="avatar"></p><ol><li>ClassPathXmlApplicationContext:默认从类路径加载配置文件</li><li>FileSystemXmlApplicationContext:默认从文件系统中装载配置文件</li><li>ApplicationEventPublisher:让容器拥有发布应用上下文事件的功能,包括容器启动事件、关闭事件等。</li><li>MessageSource:为应用提供 i18n 国际化消息访问的功能;</li><li>ResourcePatternResolver : 所 有 ApplicationContext 实 现 类 都 实 现 了 类 似 于PathMatchingResourcePatternResolver 的功能,可以通过带前缀的 Ant 风格的资源文件路径装载 Spring 的配置文件。</li><li>LifeCycle:该接口是 Spring 2.0 加入的,该接口提供了 start()和 stop()两个方法,主要用于控制异步处理过程。在具体使用时,该接口同时被 ApplicationContext 实现及具体Bean 实现, ApplicationContext 会将 start/stop 的信息传递给容器中所有实现了该接口的 Bean,以达到管理和控制 JMX、任务调度等目的。</li><li>ConfigurableApplicationContext 扩展于 ApplicationContext,它新增加了两个主要的方法: refresh()和 close(),让 ApplicationContext 具有启动、刷新和关闭应用上下文的能力。在应用上下文关闭的情况下调用 refresh()即可启动应用上下文,在已经启动的状态下,调用 refresh()则清除缓存并重新装载配置信息,而调用 close()则可关闭应用上下文。</li></ol><h1 id="WebApplication-体系架构"><a href="#WebApplication-体系架构" class="headerlink" title="WebApplication 体系架构"></a>WebApplication 体系架构</h1><blockquote><p>WebApplicationContext 是专门为 Web 应用准备的,它允许从相对于 Web 根目录的<br>路 径 中 装 载 配 置 文 件 完 成 初 始 化 工 作 。 从 WebApplicationContext 中 可 以 获 得<br>ServletContext 的引用,整个 Web 应用上下文对象将作为属性放置到 ServletContext<br>中,以便 Web 应用环境可以访问 Spring 应用上下文。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/spring-web.png" alt="avatar"></p><h1 id="Spring-Bean-作用域"><a href="#Spring-Bean-作用域" class="headerlink" title="Spring Bean 作用域"></a>Spring Bean 作用域</h1><p>Spring 3 中为 Bean 定义了 5 中作用域,分别为 <code>singleton(单例)</code>、<code>prototype(原型)</code>、<code>request</code>、<code>session</code> 和 <code>global session</code>,5 种作用域说明如下:</p><h3 id="singleton-单例模式-多线程下不安全"><a href="#singleton-单例模式-多线程下不安全" class="headerlink" title="singleton :单例模式(多线程下不安全)"></a>singleton :单例模式(多线程下不安全)</h3><p>1.singleton:单例模式,Spring IoC 容器中只会存在一个共享的 Bean 实例,无论有多少个Bean 引用它,始终指向同一对象。该模式在多线程下是不安全的。Singleton 作用域是Spring 中的缺省作用域,也可以显示的将 Bean 定义为 singleton 模式,配置为:<br><code>&lt;bean id=&quot;userDao&quot; class=&quot;com.ioc.UserDaoImpl&quot; scope=&quot;singleton&quot;/&gt;</code></p><h3 id="prototype-原型模式每次使用时创建"><a href="#prototype-原型模式每次使用时创建" class="headerlink" title="prototype: 原型模式每次使用时创建"></a>prototype: 原型模式每次使用时创建</h3><p>2.prototype:原型模式,每次通过 Spring 容器获取 prototype 定义的 bean 时,容器都将创建一个新的 Bean 实例,每个 Bean 实例都有自己的属性和状态,而 singleton 全局只有一个对象。根据经验,对有状态的 bean 使用 prototype 作用域,而对无状态的 bean 使用 singleton作用域。</p><h3 id="Request-一次-request-一个实例"><a href="#Request-一次-request-一个实例" class="headerlink" title="Request :一次 request 一个实例"></a>Request :一次 request 一个实例</h3><p>3.request:在一次 Http 请求中,容器会返回该 Bean 的同一实例。而对不同的 Http 请求则会产生新的 Bean,而且该 bean 仅在当前 Http Request 内有效,当前 Http 请求结束,该 bean实例也将会被销毁。<br><code>&lt;bean id=&quot;loginAction&quot; class=&quot;com.cnblogs.Login&quot; scope=&quot;request&quot;/&gt;</code></p><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>4.session:在一次 Http Session 中,容器会返回该 Bean 的同一实例。而对不同的 Session 请求则会创建新的实例,该 bean 实例仅在当前 Session 内有效。同 Http 请求相同,每一次session 请求创建新的实例,而不同的实例之间不共享属性,且实例仅在自己的 session 请求内有效,请求结束,则实例将被销毁。<br><code>&lt;bean id=&quot;userPreference&quot; class=&quot;com.ioc.UserPreference&quot; scope=&quot;session&quot;/&gt;</code></p><h3 id="global-Session"><a href="#global-Session" class="headerlink" title="global Session"></a>global Session</h3><p>5.global Session:在一个全局的 Http Session 中,容器会返回该 Bean 的同一个实例,仅在使用 portlet context 时有效。</p><h1 id="Spring-Bean-生命周期"><a href="#Spring-Bean-生命周期" class="headerlink" title="Spring Bean 生命周期"></a>Spring Bean 生命周期</h1><h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><p>1.实例化一个 Bean,也就是我们常说的 new。</p><h3 id="IOC-依赖注入"><a href="#IOC-依赖注入" class="headerlink" title="IOC 依赖注入"></a>IOC 依赖注入</h3><p>2.按照 Spring 上下文对实例化的 Bean 进行配置,也就是 IOC 注入。</p><h3 id="setBeanName-实现"><a href="#setBeanName-实现" class="headerlink" title="setBeanName 实现"></a>setBeanName 实现</h3><p>3.如果这个 Bean 已经实现了 BeanNameAware 接口,会调用它实现的 setBeanName(String)方法,此处传递的就是 Spring 配置文件中 Bean 的 id 值</p><h3 id="BeanFactoryAware-实现"><a href="#BeanFactoryAware-实现" class="headerlink" title="BeanFactoryAware 实现"></a>BeanFactoryAware 实现</h3><p>4.如果这个 Bean 已经实现了 BeanFactoryAware 接口,会调用它实现的 setBeanFactory,setBeanFactory(BeanFactory)传递的是 Spring 工厂自身(可以用这个方式来获取其它 Bean,只需在 Spring 配置文件中配置一个普通的 Bean 就可以)。</p><h3 id="ApplicationContextAware-实现"><a href="#ApplicationContextAware-实现" class="headerlink" title="ApplicationContextAware 实现"></a>ApplicationContextAware 实现</h3><p>5.如果这个 Bean 已经实现了 ApplicationContextAware 接口,会调用setApplicationContext(ApplicationContext)方法,传入 Spring 上下文(同样这个方式也可以实现步骤 4 的内容,但比 4 更好,因为 ApplicationContext 是 BeanFactory 的子接口,有更多的实现方法)</p><h3 id="postProcessBeforeInitialization-接口实现-初始化预处理"><a href="#postProcessBeforeInitialization-接口实现-初始化预处理" class="headerlink" title="postProcessBeforeInitialization 接口实现 - 初始化预处理"></a>postProcessBeforeInitialization 接口实现 - 初始化预处理</h3><p>6.如果这个 Bean 关联了 BeanPostProcessor 接口,将会调用postProcessBeforeInitialization(Object obj, String s)方法,BeanPostProcessor 经常被用作是 Bean 内容的更改,并且由于这个是在 Bean 初始化结束时调用那个的方法,也可以被应用于内存或缓存技术。</p><h3 id="init-method"><a href="#init-method" class="headerlink" title="init-method"></a>init-method</h3><p>7.如果 Bean 在 Spring 配置文件中配置了 init-method 属性会自动调用其配置的初始化方法。</p><h3 id="postProcessAfterInitialization"><a href="#postProcessAfterInitialization" class="headerlink" title="postProcessAfterInitialization"></a>postProcessAfterInitialization</h3><p>8.如果这个 Bean 关联了 BeanPostProcessor 接口,将会调用postProcessAfterInitialization(Object obj, String s)方法。<br>注:以上工作完成以后就可以应用这个 Bean 了,那这个 Bean 是一个 Singleton 的,所以一般情况下我们调用同一个 id 的 Bean 会是在内容地址相同的实例,当然在 Spring 配置文件中也可以配置非 Singleton。</p><h3 id="Destroy-过期自动清理阶段"><a href="#Destroy-过期自动清理阶段" class="headerlink" title="Destroy 过期自动清理阶段"></a>Destroy 过期自动清理阶段</h3><p>9.当 Bean 不再需要时,会经过清理阶段,如果 Bean 实现了 DisposableBean 这个接口,会调用那个其实现的 destroy()方法;</p><h3 id="destroy-method-自配置清理"><a href="#destroy-method-自配置清理" class="headerlink" title="destroy-method 自配置清理"></a>destroy-method 自配置清理</h3><ol start="10"><li>最后,如果这个 Bean 的 Spring 配置中配置了 destroy-method 属性,会自动调用其配置的销毁方法。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/spring-live.png" alt="avatar"></p><ol start="11"><li>bean 标签有两个重要的属性(init-method 和 destroy-method)。用它们你可以自己定制初始化和注销方法。它们也有相应的注解(@PostConstruct 和@PreDestroy)。</li></ol><p><code>&lt;bean id=&quot;&quot; class=&quot;&quot; init-method=&quot;初始化方法&quot; destroy-method=&quot;销毁方法&quot;&gt;</code></p><h1 id="Spring-依赖注入四种方式"><a href="#Spring-依赖注入四种方式" class="headerlink" title="Spring 依赖注入四种方式"></a>Spring 依赖注入四种方式</h1><h2 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">/*带参数,方便利用构造器进行注入*/<br>public CatDaoImpl(String message)&#123;<br>    this. message = message;<br>&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;CatDaoImpl&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.CatDaoImpl&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot; message &quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="setter-方法注入"><a href="#setter-方法注入" class="headerlink" title="setter 方法注入"></a>setter 方法注入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Id</span> </span>&#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> id;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>       <span class="hljs-keyword">this</span>.id = id; <br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.id &quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="静态工厂注入"><a href="#静态工厂注入" class="headerlink" title="静态工厂注入"></a>静态工厂注入</h2><blockquote><p>静态工厂顾名思义,就是通过调用静态工厂的方法来获取自己需要的对象,为了让 spring 管理所有对象,我们不能直接通过”工程类.静态方法()”来获取对象,而是依然通过 spring 注入的形式获取:</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DaoFactory</span> </span>&#123; <span class="hljs-comment">//静态工厂</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FactoryDao <span class="hljs-title">getStaticFactoryDaoImpl</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StaticFacotryDaoImpl();<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringAction</span> </span>&#123;<br><span class="hljs-keyword">private</span> FactoryDao staticFactoryDao; <span class="hljs-comment">//注入对象</span><br><span class="hljs-comment">//注入对象的 set 方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStaticFactoryDao</span><span class="hljs-params">(FactoryDao staticFactoryDao)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.staticFactoryDao = staticFactoryDao;<br>&#125;<br>&#125;<br><span class="hljs-comment">//factory-method=&quot;getStaticFactoryDaoImpl&quot;指定调用哪个工厂方法</span><br>````<br>```xml<br>&lt;bean name=<span class="hljs-string">&quot;springAction&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot; SpringAction&quot;</span> &gt;<br>&lt;!--使用静态工厂的方法注入对象,对应下面的配置文件--&gt;<br>&lt;property name=&quot;staticFactoryDao&quot; ref=&quot;staticFactoryDao&quot;&gt;&lt;/property&gt;<br>&lt;/bean&gt;<br>&lt;!--此处获取对象的方式是从工厂类中获取静态方法--&gt;<br>&lt;bean name=<span class="hljs-string">&quot;staticFactoryDao&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;DaoFactory&quot;</span><br>factory-method=&quot;getStaticFactoryDaoImpl&quot;&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure><h2 id="实例工厂"><a href="#实例工厂" class="headerlink" title="实例工厂"></a>实例工厂</h2><blockquote><p>实例工厂的意思是获取对象实例的方法不是静态的,所以你需要首先 new 工厂类,再调用普通的实例方法:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DaoFactory</span> </span>&#123; <span class="hljs-comment">//实例工厂</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FactoryDao <span class="hljs-title">getFactoryDaoImpl</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FactoryDaoImpl();&#125;<br>    &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringAction</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> FactoryDao factoryDao;<br>    <span class="hljs-comment">//注入对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFactoryDao</span><span class="hljs-params">(FactoryDao factoryDao)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.factoryDao = factoryDao;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;springAction&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;SpringAction&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--使用实例工厂的方法注入对象,对应下面的配置文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;factoryDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;factoryDao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!--此处获取对象的方式是从工厂类中获取实例方法--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;daoFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.DaoFactory&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;factoryDao&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;daoFactory&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getFactoryDaoImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="5-种不同方式的自动装配"><a href="#5-种不同方式的自动装配" class="headerlink" title="5 种不同方式的自动装配"></a>5 种不同方式的自动装配</h1><p>Spring 装配包括手动装配和自动装配,手动装配是有基于 xml 装配、构造方法、setter 方法等</p><p>自动装配有五种自动装配的方式,可以用来指导 Spring 容器用自动装配方式来进行依赖注入。</p><ol><li>no:默认的方式是不进行自动装配,通过显式设置 ref 属性来进行装配。</li><li>byName:通过参数名 自动装配,Spring 容器在配置文件中发现 bean 的 autowire 属性被设置成 byname,之后容器试图匹配、装配和该 bean 的属性具有相同名字的 bean。</li><li>byType:通过参数类型自动装配,Spring 容器在配置文件中发现 bean 的 autowire 属性被设置成 byType,之后容器试图匹配、装配和该 bean 的属性具有相同类型的 bean。如果有多个 bean 符合条件,则抛出错误。</li><li>constructor:这个方式类似于 byType, 但是要提供给构造器参数,如果没有确定的带参数的构造器参数类型,将会抛出异常。</li><li>autodetect:首先尝试使用 constructor 来自动装配,如果无法工作,则使用 byType 方式。</li></ol><h1 id="Spring-APO-原理"><a href="#Spring-APO-原理" class="headerlink" title="Spring APO 原理"></a>Spring APO 原理</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>“ 横切”的技术,剖解开封装的对象内部,并将那些影响了多个类的公共行为封装到一个可重用模块,并将其命名为”Aspect”,即切面。所谓”切面”,简单说就是那些与业务无关,却为业务模块所共<br>同调用的逻辑或责任封装起来,便于减少系统的重复代码,降低模块之间的耦合度,并有利于未来的可操作性和可维护性。使用”横切”技术,AOP 把软件系统分为两个部分:核心关注点和横切关注点。业务处理的主要流<br>程是核心关注点,与之关系不大的部分是横切关注点。横切关注点的一个特点是,他们经常发生在核心关注点的多处,而各处基本相似,比如权限认证、日志、事物。AOP 的作用在于分离系统中的各种关注点,将核心关注点和横切关注点分离开来。</p><h2 id="AOP-主要应用场景有"><a href="#AOP-主要应用场景有" class="headerlink" title="AOP 主要应用场景有:"></a>AOP 主要应用场景有:</h2><ol><li>Authentication 权限</li><li>Caching 缓存</li><li>Context passing 内容传递</li><li>Error handling 错误处理</li><li>Lazy loading 懒加载</li><li>Debugging 调试</li><li>logging, tracing, profiling and monitoring 记录跟踪 优化 校准</li><li>Performance optimization 性能优化</li><li>Persistence 持久化</li><li>Resource pooling 资源池</li><li>Synchronization 同步</li><li>Transactions 事务</li></ol><h2 id="AOP-核心概念"><a href="#AOP-核心概念" class="headerlink" title="AOP 核心概念"></a>AOP 核心概念</h2><p>1、切面(aspect):类是对物体特征的抽象,切面就是对横切关注点的抽象<br>2、横切关注点:对哪些方法进行拦截,拦截后怎么处理,这些关注点称之为横切关注点。<br>3、连接点(joinpoint):被拦截到的点,因为 Spring 只支持方法类型的连接点,所以在 Spring中连接点指的就是被拦截到的方法,实际上连接点还可以是字段或者构造器。<br>4、切入点(pointcut):对连接点进行拦截的定义<br>5、通知(advice):所谓通知指的就是指拦截到连接点之后要执行的代码,通知分为前置、后置、异常、最终、环绕通知五类。<br>6、目标对象:代理的目标对象<br>7、织入(weave):将切面应用到目标对象并导致代理对象创建的过程<br>8、引入(introduction):在不修改代码的前提下,引入可以在运行期为类动态地添加一些方法或字段。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/spring-aop.png" alt="avatar"></p><h3 id="AOP-两种代理方式"><a href="#AOP-两种代理方式" class="headerlink" title="AOP 两种代理方式"></a>AOP 两种代理方式</h3><p>Spring 提 供 了 两 种 方 式 来 生 成 代 理 对 象 : JDKProxy 和 Cglib , 具体使用哪种方式生成由AopProxyFactory 根据 AdvisedSupport 对象的配置来决定。默认的策略是如果目标类是接口,则使用 JDK 动态代理技术,否则使用 Cglib 来生成代理。</p><ul><li><p>JDK 动态接口代理</p><blockquote><p>1.JDK 动态代理主要涉及到 java.lang.reflect 包中的两个类:Proxy 和 InvocationHandler。<br>InvocationHandler 是一个接口,通过实现该接口定义横切逻辑,并通过反射机制调用目标类<br>的代码,动态将横切逻辑和业务逻辑编制在一起。Proxy 利用 InvocationHandler 动态创建<br>一个符合某一接口的实例,生成目标类的代理对象。</p></blockquote></li><li><p>CGLib 动态代理</p><blockquote><p>2.:CGLib 全称为 Code Generation Library,是一个强大的高性能,高质量的代码生成类库,<br>可以在运行期扩展 Java 类与实现 Java 接口,CGLib 封装了 asm,可以再运行期动态生成新<br>的 class。和 JDK 动态代理相比较:JDK 创建代理有一个限制,就是只能为接口创建代理实例,<br>而对于没有通过接口定义业务方法的类,则可以通过 CGLib 创建动态代理。</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransactionDemo</span> </span>&#123;<br><span class="hljs-meta">@Pointcut(value=&quot;execution(* com.yangxin.core.service.*.*.*(..))&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">point</span><span class="hljs-params">()</span></span>&#123;<br>&#125;<br><span class="hljs-meta">@Before(value=&quot;point()&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;<br>System.out.println(<span class="hljs-string">&quot;transaction begin&quot;</span>);<br>&#125;<br><span class="hljs-meta">@AfterReturning(value = &quot;point()&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span></span>&#123;<br>System.out.println(<span class="hljs-string">&quot;transaction commit&quot;</span>);<br>&#125;<br><span class="hljs-meta">@Around(&quot;point()&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">around</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;transaction begin&quot;</span>);<br>joinPoint.proceed();<br>System.out.println(<span class="hljs-string">&quot;transaction commit&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/spring-proxy.png" alt="avatar"></p><h1 id="Spring-MVC-原理"><a href="#Spring-MVC-原理" class="headerlink" title="Spring MVC 原理"></a>Spring MVC 原理</h1><blockquote><p>Spring 的模型-视图-控制器(MVC)框架是围绕一个 DispatcherServlet 来设计的,这个 Servlet会把请求分发给各个处理器,并支持可配置的处理器映射、视图渲染、本地化、时区与主题渲染等,甚至还能支持文件上传。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/spring-mvc.png" alt="avatar"></p><h3 id="Http-请求到-DispatcherServlet"><a href="#Http-请求到-DispatcherServlet" class="headerlink" title="Http 请求到 DispatcherServlet"></a>Http 请求到 DispatcherServlet</h3><p>(1) 客户端请求提交到 DispatcherServlet。</p><h3 id="HandlerMapping-寻找处理器"><a href="#HandlerMapping-寻找处理器" class="headerlink" title="HandlerMapping 寻找处理器"></a>HandlerMapping 寻找处理器</h3><p>(2) 由 DispatcherServlet 控制器查询一个或多个 HandlerMapping,找到处理请求的Controller。</p><h3 id="调用处理器-Controller"><a href="#调用处理器-Controller" class="headerlink" title="调用处理器 Controller"></a>调用处理器 Controller</h3><p>(3) DispatcherServlet 将请求提交到 Controller。<br>Controller 调用业务逻辑处理后,返回 ModelAndView<br>(4)(5)调用业务处理和返回结果:Controller 调用业务逻辑处理后,返回 ModelAndView。</p><h3 id="DispatcherServlet-查询-ModelAndView"><a href="#DispatcherServlet-查询-ModelAndView" class="headerlink" title="DispatcherServlet 查询 ModelAndView"></a>DispatcherServlet 查询 ModelAndView</h3><p>(6)(7)处理视图映射并返回模型: DispatcherServlet 查询一个或多个 ViewResoler 视图解析器,找到 ModelAndView 指定的视图。</p><h3 id="ModelAndView-反馈浏览器-HTTP"><a href="#ModelAndView-反馈浏览器-HTTP" class="headerlink" title="ModelAndView 反馈浏览器 HTTP"></a>ModelAndView 反馈浏览器 HTTP</h3><p>(8) Http 响应:视图负责将结果显示到客户端。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/spring-mvc-anno.png" alt="avatar"></p><h1 id="Spring-Boot-原理"><a href="#Spring-Boot-原理" class="headerlink" title="Spring Boot 原理"></a>Spring Boot 原理</h1><p>Spring Boot 是由 Pivotal 团队提供的全新框架,其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置,从而使开发人员不再需要定义样板化的配置。通过这种方式,Spring Boot 致力于在蓬勃发展的快速应用开发领域(rapid applicationdevelopment)成为领导者。其特点如下:</p><ol><li>创建独立的 Spring 应用程序</li><li>嵌入的 Tomcat,无需部署 WAR 文件</li><li>简化 Maven 配置</li><li>自动配置 Spring</li><li>提供生产就绪型功能,如指标,健康检查和外部配置</li><li>绝对没有代码生成和对 XML 没有要求配置 [1]</li></ol><h1 id="JPA-原理"><a href="#JPA-原理" class="headerlink" title="JPA 原理"></a>JPA 原理</h1><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是计算机应用中不可或缺的组件模型,它保证了用户操作的原子性 ( Atomicity )、一致性( Consistency )、隔离性 ( Isolation ) 和持久性 ( Durabilily )。</p><h3 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h3><p>紧密依赖于底层资源管理器(例如数据库连接 ),事务处理局限在当前事务资源内。此种事务处理方式不存在对应用服务器的依赖,因而部署灵活却无法支持多数据源的分布式事务。在数据库连接中使用本地事务示例如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transferAccount</span><span class="hljs-params">()</span> </span>&#123;<br>Connection conn = <span class="hljs-keyword">null</span>;<br>Statement stmt = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span>&#123;<br>conn = getDataSource().getConnection();<br><span class="hljs-comment">// 将自动提交设置为 false,若设置为 true 则数据库将会把每一次数据更新认定为一个事务并自动提交</span><br>conn.setAutoCommit(<span class="hljs-keyword">false</span>);<br>stmt = conn.createStatement();<br><span class="hljs-comment">// 将 A 账户中的金额减少 500</span><br>stmt.execute(<span class="hljs-string">&quot;update t_account set amount = amount - 500 where account_id = &#x27;A&#x27;&quot;</span>);<br><span class="hljs-comment">// 将 B 账户中的金额增加 500</span><br>stmt.execute(<span class="hljs-string">&quot;update t_account set amount = amount + 500 where account_id = &#x27;B&#x27;&quot;</span>);<br><span class="hljs-comment">// 提交事务</span><br>conn.commit();<br><span class="hljs-comment">// 事务提交:转账的两步操作同时成功</span><br>&#125; <span class="hljs-keyword">catch</span>(SQLException sqle)&#123;<br><span class="hljs-comment">// 发生异常,回滚在本事务中的操做</span><br>conn.rollback();<br><span class="hljs-comment">// 事务回滚:转账的两步操作完全撤销</span><br>stmt.close();<br>conn.close();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><blockquote><p>Java 事务编程接口(JTA:Java Transaction API)和 Java 事务服务 (JTS;Java Transaction<br>Service) 为 J2EE 平台提供了分布式事务服务。分布式事务(Distributed Transaction)包括事务<br>管 理 器 ( Transaction Manager ) 和 一 个 或 多 个 支 持 XA 协 议 的 资 源 管 理 器 ( Resource<br>Manager )。我们可以将资源管理器看做任意类型的持久化数据存储;事务管理器承担着所有事务<br>参与单元的协调与控制。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transferAccount</span><span class="hljs-params">()</span> </span>&#123;<br>UserTransaction userTx = <span class="hljs-keyword">null</span>;<br>Connection connA = <span class="hljs-keyword">null</span>; Statement stmtA = <span class="hljs-keyword">null</span>;<br>Connection connB = <span class="hljs-keyword">null</span>; Statement stmtB = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// 获得 Transaction 管理对象</span><br>userTx = (UserTransaction)getContext().lookup(<span class="hljs-string">&quot;java:comp/UserTransaction&quot;</span>);<br>connA = getDataSourceA().getConnection();<span class="hljs-comment">// 从数据库 A 中取得数据库连接</span><br>connB = getDataSourceB().getConnection();<span class="hljs-comment">// 从数据库 B 中取得数据库连接</span><br>userTx.begin(); <span class="hljs-comment">// 启动事务</span><br>stmtA = connA.createStatement();<span class="hljs-comment">// 将 A 账户中的金额减少 500</span><br>stmtA.execute(<span class="hljs-string">&quot;update t_account set amount = amount - 500 where account_id = &#x27;A&#x27;&quot;</span>);<br><span class="hljs-comment">// 将 B 账户中的金额增加 500</span><br>stmtB = connB.createStatement();<br>stmtB.execute(<span class="hljs-string">&quot;update t_account set amount = amount + 500 where account_id = &#x27;B&#x27;&quot;</span>);<br>userTx.commit();<span class="hljs-comment">// 提交事务</span><br><span class="hljs-comment">// 事务提交:转账的两步操作同时成功(数据库 A 和数据库 B 中的数据被同时更新)</span><br>&#125; <span class="hljs-keyword">catch</span>(SQLException sqle)&#123;<br><span class="hljs-comment">// 发生异常,回滚在本事务中的操纵</span><br>userTx.rollback();<span class="hljs-comment">// 事务回滚:数据库 A 和数据库 B 中的数据更新被同时撤销</span><br>&#125; <span class="hljs-keyword">catch</span>(Exception ne)&#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><blockquote><p>两阶段提交主要保证了分布式事务的原子性:即所有结点要么全做要么全不做,所谓的两个阶段是指:第一阶段:准备阶段;第二阶段:提交阶段。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/spring-mvc-jps.png" alt="avatar"></p><p>1 准备阶段<br>事务协调者(事务管理器)给每个参与者(资源管理器)发送 Prepare 消息,每个参与者要么直接返回<br>失败(如权限验证失败),要么在本地执行事务,写本地的 redo 和 undo 日志,但不提交,到达一<br>种“万事俱备,只欠东风”的状态。<br>2 提交阶段:<br>如果协调者收到了参与者的失败消息或者超时,直接给每个参与者发送回滚(Rollback)消息;否则,<br>发送提交(Commit)消息;参与者根据协调者的指令执行提交或者回滚操作,释放所有事务处理过<br>程中使用的锁资源。(注意:必须在最后阶段释放锁资源)将提交分成两阶段进行的目的很明确,就是尽可能晚地提交事务,让事务在提交前尽可能地完成所有能完成的工作。</p><h1 id="Mybatis-缓存"><a href="#Mybatis-缓存" class="headerlink" title="Mybatis 缓存"></a>Mybatis 缓存</h1><blockquote><p>Mybatis 中有一级缓存和二级缓存,默认情况下一级缓存是开启的,而且是不能关闭的。一级缓存<br>是指 SqlSession 级别的缓存,当在同一个 SqlSession 中进行相同的 SQL 语句查询时,第二次以<br>后的查询不会从数据库查询,而是直接从缓存中获取,一级缓存最多缓存 1024 条 SQL。</p></blockquote><blockquote><p>二级缓存<br>是指可以跨 SqlSession 的缓存。是 mapper 级别的缓存,对于 mapper 级别的缓存不同的<br>sqlsession 是可以共享的。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/spring-mvc-cache.png" alt="avatar"></p><p>Mybatis 的一级缓存原理( sqlsession 级别 )<br>第一次发出一个查询 sql,sql 查询结果写入 sqlsession 的一级缓存中,缓存使用的数据结构是一个 map。</p><blockquote><p>key:MapperID+offset+limit+Sql+所有的入参<br>value:用户信息</p></blockquote><p>同一个 sqlsession 再次发出相同的 sql,就从缓存中取出数据。如果两次中间出现 commit 操作(修改、添加、删除),本 sqlsession 中的一级缓存区域全部清空,下次再去缓存中查询不到所以要从数据库查询,从数据库查询到再写入缓存。</p><p>二级缓存原理( mapper 基本 )</p><p>二级缓存的范围是 mapper 级别(mapper 同一个命名空间),mapper 以命名空间为单位创建缓存数据结构,结构是 map。mybatis 的二级缓存是通过 CacheExecutor 实现的。CacheExecutor</p><p>其实是 Executor 的代理对象。所有的查询操作,在 CacheExecutor 中都会先匹配缓存中是否存<br>在,不存在则查询数据库。<br>key:MapperID+offset+limit+Sql+所有的入参<br>具体使用需要配置:</p><ol><li>Mybatis 全局配置中启用二级缓存配置</li><li>在对应的 Mapper.xml 中配置 cache 节点</li><li>在对应的 select 查询节点中添加 useCache=true</li></ol><h1 id="Tomcat-架构"><a href="#Tomcat-架构" class="headerlink" title="Tomcat 架构"></a>Tomcat 架构</h1><p><a href="https://www.cnblogs.com/alimayun/p/10604532.html">参考资料</a></p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络安全入门学习资料</title>
    <link href="/2020/07/23/note/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/"/>
    <url>/2020/07/23/note/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><ul><li>《黑客初级入门》</li><li>《白帽子讲web安全》</li><li>《从零开始学习黑客技术入门教程(基础)》</li><li>《白帽子讲web安全》</li><li>《web前端黑客技术揭秘》</li><li>《黑客攻防宝典：web实战篇》</li><li>《暗战亮剑:黑客渗透于防御全程实录》</li><li>《backtrack从入门到精通》</li><li>《黑客攻防技术与案例剖析》</li><li>《黑客攻防技术与案例剖析》</li><li>《黑客大曝光第6版》</li><li>《黑客攻防技术宝典-WEB实战篇》</li><li>《黑客攻防技术宝典系统实战篇》</li><li>《黑客WEB脚本攻击与防御技术核心剖析》</li><li>《黑客渗透笔记完整版》</li><li>《Q版缓冲区溢出教程》</li><li>《php漏洞挖掘书籍》</li><li>《Shellcoder编程揭秘》</li><li>《黑客防线2009缓冲区溢出攻击与防范专辑》</li><li>《黑客大曝光：无线网络安全（原书第2版）》</li><li>《LINUX黑客大曝光（第2版）》</li><li>《0day安全软件漏洞分析技术（第一版和第二版）</li><li>《Binary+Hacks+黑客秘笈100选》</li><li>《Windows黑客技术揭秘与攻防1C语言篇》</li><li>《黑武器-linux_BT4无线黑客》</li><li>《黑客入侵网页攻防修炼》</li><li>《backtrack4:assuring security by penetration testing》</li><li>《Web应用安全威胁于防治（基于owasp top 与esapi）</li><li>《backtrack4:利用渗透测试保证系统安全》</li><li>《无线网络黑客攻防》</li><li>《Metasploit渗透测试指南》</li><li>《网络安全进阶笔记》</li><li>《Linux网络安全技术与实现(第2版)》</li><li>《网络安全 王淑江、 等 机械工业出版社 (2007-09出版)》</li><li>《Web系统安全和渗透性测试基础》</li><li>《渗透测试实践指南:必知必会的工具与方法》</li><li>《大中型网络入侵要案直击与防御》</li><li>《Web安全测试》</li><li>《Python灰帽子:黑客与逆向工程师的Python编程之道》</li><li>《SQL Injection Attacks and Defense（SQL注入攻击和防御）》</li><li>《SQL Injection Attacks and Possible Remedies（SQL注入攻击和可能的补救措施）》</li><li>《SQL: PL-SQL, Transact-SQL, SQL Injection, Database Console Commands, Xleratordb, Foreign Key, Navicat, Cursor,…》</li><li>《CEH Certified Ethical Hacker Study Guide [With CDROM]（国家认证的道德黑客学习指南(光盘)》</li><li>《The Shellcoder’s Handbook: Discovering and Exploiting Security Holes(这个Shellcoder手册:发现和利用安全漏洞）》《Sockets, Shellcode, Porting and Coding: Reverse Engineering Exploits and Tool Coding for Security Professionals…（套接字,Shellcode,移植和编码:逆向工程利用和工具编码为安全专家……)》《Metasploit Toolkit for Penetration Testing, Exploit Development, and Vulnerability Research（Metasploit工具包对渗透测试,利用开发和脆弱性研究)》《Buffer Overflow Attacks: Detect, Exploit, Prevent（缓冲区溢出攻击:检测,利用,防止）》</li></ul>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s 入门实践</title>
    <link href="/2020/07/07/k8s/k8s-%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/"/>
    <url>/2020/07/07/k8s/k8s-%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><ul><li>至少2台 2核4G 的服务器 Cent OS 7.6 / 7.7 / 7.8</li></ul><h3 id="服务器信息-CentOS-Linux-release-7-8-2003-Core"><a href="#服务器信息-CentOS-Linux-release-7-8-2003-Core" class="headerlink" title="服务器信息 CentOS Linux release 7.8.2003 (Core)"></a>服务器信息 CentOS Linux release 7.8.2003 (Core)</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Architecture</span>:          x<span class="hljs-number">86</span>_<span class="hljs-number">64</span><br><span class="hljs-attribute">CPU</span> op-mode(s):        <span class="hljs-number">32</span>-bit, <span class="hljs-number">64</span>-bit<br><span class="hljs-attribute">Byte</span> Order:            Little Endian<br><span class="hljs-attribute">CPU</span>(s):                <span class="hljs-number">4</span><br><span class="hljs-attribute">On</span>-line CPU(s) list:   <span class="hljs-number">0</span>-<span class="hljs-number">3</span><br><span class="hljs-attribute">Thread</span>(s) per core:    <span class="hljs-number">2</span><br><span class="hljs-attribute">Core</span>(s) per socket:    <span class="hljs-number">2</span><br><span class="hljs-attribute">Socket</span>(s):             <span class="hljs-number">1</span><br><span class="hljs-attribute">NUMA</span> node(s):          <span class="hljs-number">1</span><br><span class="hljs-attribute">Vendor</span> ID:             GenuineIntel<br><span class="hljs-attribute">CPU</span> family:            <span class="hljs-number">6</span><br><span class="hljs-attribute">Model</span>:                 <span class="hljs-number">85</span><br><span class="hljs-attribute">Model</span> name:            Intel(R) Xeon(R) Gold <span class="hljs-number">6266</span>C CPU @ <span class="hljs-number">3</span>.<span class="hljs-number">00</span>GHz<br><span class="hljs-attribute">Stepping</span>:              <span class="hljs-number">7</span><br><span class="hljs-attribute">CPU</span> MHz:               <span class="hljs-number">3000</span>.<span class="hljs-number">000</span><br><span class="hljs-attribute">BogoMIPS</span>:              <span class="hljs-number">6000</span>.<span class="hljs-number">00</span><br><span class="hljs-attribute">Hypervisor</span> vendor:     KVM<br><span class="hljs-attribute">Virtualization</span> type:   full<br><span class="hljs-attribute">L1d</span> cache:             <span class="hljs-number">32</span>K<br><span class="hljs-attribute">L1i</span> cache:             <span class="hljs-number">32</span>K<br><span class="hljs-attribute">L2</span> cache:              <span class="hljs-number">1024</span>K<br><span class="hljs-attribute">L3</span> cache:              <span class="hljs-number">30976</span>K<br><span class="hljs-attribute">NUMA</span> node<span class="hljs-number">0</span> CPU(s):     <span class="hljs-number">0</span>-<span class="hljs-number">3</span><br><span class="hljs-attribute">Flags</span>:                 fpu vme de pse tsc msr pae mce cx<span class="hljs-number">8</span> apic sep mtrr pge mca cmov pat pse<span class="hljs-number">36</span> clflush mmx fxsr sse sse<span class="hljs-number">2</span> ss ht syscall nx pdpe<span class="hljs-number">1</span>gb rdtscp lm constant_tsc rep_good nopl xtopology nonstop_tsc eagerfpu pni pclmulqdq ssse<span class="hljs-number">3</span> fma cx<span class="hljs-number">16</span> pcid sse<span class="hljs-number">4</span>_<span class="hljs-number">1</span> sse<span class="hljs-number">4</span>_<span class="hljs-number">2</span> x<span class="hljs-number">2</span>apic movbe popcnt tsc_deadline_timer aes xsave avx f<span class="hljs-number">16</span>c rdrand hypervisor lahf_lm abm <span class="hljs-number">3</span>dnowprefetch invpcid_single ssbd ibrs ibpb stibp ibrs_enhanced fsgsbase tsc_adjust bmi<span class="hljs-number">1</span> hle avx<span class="hljs-number">2</span> smep bmi<span class="hljs-number">2</span> erms invpcid rtm mpx avx<span class="hljs-number">512</span>f avx<span class="hljs-number">512</span>dq rdseed adx smap clflushopt clwb avx<span class="hljs-number">512</span>cd avx<span class="hljs-number">512</span>bw avx<span class="hljs-number">512</span>vl xsaveopt xsavec xgetbv<span class="hljs-number">1</span> arat avx<span class="hljs-number">512</span>_vnni md_clear spec_ctrl intel_stibp flush_l<span class="hljs-number">1</span>d arch_capabilities<br><br></code></pre></td></tr></table></figure><p>K8s</p><ul><li>kubelet</li></ul><p>Docker 镜像</p><ul><li>etcd</li><li>kube-proxy</li><li>kube-apiserver</li><li>kube-controller-manager</li><li>kube-scheduler</li></ul><h1 id="安装Kubernates"><a href="#安装Kubernates" class="headerlink" title="安装Kubernates"></a>安装Kubernates</h1><ul><li><p>修改 hostname,不能使用localhost</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">如果您需要修改 <span class="hljs-string">hostname</span>，可执行如下指令：<br><span class="hljs-comment"># 修改 hostname</span><br><span class="hljs-string">hostnamectl</span> <span class="hljs-built_in">set-hostname</span> <span class="hljs-string">your-new-host-name</span><br><span class="hljs-string"></span><span class="hljs-comment"># 查看修改结果</span><br><span class="hljs-string">hostnamectl</span> <span class="hljs-string">status</span><br><span class="hljs-string"></span><span class="hljs-comment"># 设置 hostname 解析</span><br><span class="hljs-string">echo</span> <span class="hljs-string">&quot;127.0.0.1   $(hostname)&quot;</span> &gt;&gt; /<span class="hljs-string">etc</span>/<span class="hljs-string">hosts</span><br></code></pre></td></tr></table></figure></li><li><p>检查网络</p></li></ul><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs pf">[root@server-<span class="hljs-number">781</span>e6bf7-bce3-<span class="hljs-number">4</span>d09-adc8-<span class="hljs-number">2</span>a169fdb8719 ~]<span class="hljs-comment"># ip route show</span><br><span class="hljs-keyword">default</span> via <span class="hljs-number">192.168</span>.<span class="hljs-number">0.1</span> dev eth0 <span class="hljs-keyword">proto</span> dhcp metric <span class="hljs-number">100</span> <br><span class="hljs-number">169.254</span>.<span class="hljs-number">169.254</span> via <span class="hljs-number">192.168</span>.<span class="hljs-number">0.254</span> dev eth0 <span class="hljs-keyword">proto</span> dhcp metric <span class="hljs-number">100</span> <br><span class="hljs-number">172.17</span>.<span class="hljs-number">0.0</span>/<span class="hljs-number">16</span> dev docker0 <span class="hljs-keyword">proto</span> kernel scope link src <span class="hljs-number">172.17</span>.<span class="hljs-number">0.1</span> <br><span class="hljs-number">172.18</span>.<span class="hljs-number">0.0</span>/<span class="hljs-number">16</span> dev br-<span class="hljs-number">66</span>ad3449f59f <span class="hljs-keyword">proto</span> kernel scope link src <span class="hljs-number">172.18</span>.<span class="hljs-number">0.1</span> <br><span class="hljs-number">172.19</span>.<span class="hljs-number">0.0</span>/<span class="hljs-number">16</span> dev br-<span class="hljs-number">3</span>d8dbba954bf <span class="hljs-keyword">proto</span> kernel scope link src <span class="hljs-number">172.19</span>.<span class="hljs-number">0.1</span> <br><span class="hljs-number">192.168</span>.<span class="hljs-number">0.0</span>/<span class="hljs-number">24</span> dev eth0 <span class="hljs-keyword">proto</span> kernel scope link src <span class="hljs-number">192.168</span>.<span class="hljs-number">0.39</span> metric <span class="hljs-number">100</span> <br>[root@server-<span class="hljs-number">781</span>e6bf7-bce3-<span class="hljs-number">4</span>d09-adc8-<span class="hljs-number">2</span>a169fdb8719 ~]<span class="hljs-comment"># ip address</span><br><span class="hljs-number">1</span>: lo: <span class="hljs-variable">&lt;LOOPBACK,UP,LOWER_UP&gt;</span> mtu <span class="hljs-number">65536</span> qdisc noqueue <span class="hljs-keyword">state</span> UNKNOWN <span class="hljs-keyword">group</span> <span class="hljs-keyword">default</span> qlen <span class="hljs-number">1000</span><br>    link/loopback <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> brd <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><br>    <span class="hljs-keyword">inet</span> <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>/<span class="hljs-number">8</span> scope host lo<br>       valid_lft forever preferred_lft forever<br>    <span class="hljs-keyword">inet6</span> ::<span class="hljs-number">1</span>/<span class="hljs-number">128</span> scope host <br>       valid_lft forever preferred_lft forever<br><span class="hljs-number">2</span>: eth0: <span class="hljs-variable">&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</span> mtu <span class="hljs-number">1500</span> qdisc mq <span class="hljs-keyword">state</span> UP <span class="hljs-keyword">group</span> <span class="hljs-keyword">default</span> qlen <span class="hljs-number">1000</span><br>    link/ether fa:<span class="hljs-number">16</span>:<span class="hljs-number">3</span>e:c1:b5:a5 brd ff:ff:ff:ff:ff:ff<br>    <span class="hljs-keyword">inet</span> <span class="hljs-number">192.168</span>.<span class="hljs-number">0.39</span>/<span class="hljs-number">24</span> brd <span class="hljs-number">192.168</span>.<span class="hljs-number">0.255</span> scope <span class="hljs-keyword">global</span> noprefixroute dynamic eth0<br>       valid_lft <span class="hljs-number">53761</span>sec preferred_lft <span class="hljs-number">53761</span>sec<br>    <span class="hljs-keyword">inet6</span> fe80::f816:<span class="hljs-number">3</span>eff:fec1:b5a5/<span class="hljs-number">64</span> scope link <br>       valid_lft forever preferred_lft forever<br><span class="hljs-number">3</span>: docker0: <span class="hljs-variable">&lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt;</span> mtu <span class="hljs-number">1500</span> qdisc noqueue <span class="hljs-keyword">state</span> DOWN <span class="hljs-keyword">group</span> <span class="hljs-keyword">default</span> <br>    link/ether <span class="hljs-number">02</span>:<span class="hljs-number">42</span>:<span class="hljs-number">54</span>:bb:c6:<span class="hljs-number">75</span> brd ff:ff:ff:ff:ff:ff<br>    <span class="hljs-keyword">inet</span> <span class="hljs-number">172.17</span>.<span class="hljs-number">0.1</span>/<span class="hljs-number">16</span> scope <span class="hljs-keyword">global</span> docker0<br>       valid_lft forever preferred_lft forever<br>    <span class="hljs-keyword">inet6</span> fe80::<span class="hljs-number">42</span>:<span class="hljs-number">54</span>ff:febb:c675/<span class="hljs-number">64</span> scope link <br>       valid_lft forever preferred_lft forever<br><span class="hljs-number">4</span>: br-<span class="hljs-number">66</span>ad3449f59f: <span class="hljs-variable">&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</span> mtu <span class="hljs-number">1500</span> qdisc noqueue <span class="hljs-keyword">state</span> UP <span class="hljs-keyword">group</span> <span class="hljs-keyword">default</span> <br>    link/ether <span class="hljs-number">02</span>:<span class="hljs-number">42</span>:ee:d9:c2:<span class="hljs-number">68</span> brd ff:ff:ff:ff:ff:ff<br>    <span class="hljs-keyword">inet</span> <span class="hljs-number">172.18</span>.<span class="hljs-number">0.1</span>/<span class="hljs-number">16</span> brd <span class="hljs-number">172.18</span>.<span class="hljs-number">255.255</span> scope <span class="hljs-keyword">global</span> br-<span class="hljs-number">66</span>ad3449f59f<br>       valid_lft forever preferred_lft forever<br>    <span class="hljs-keyword">inet6</span> fe80::<span class="hljs-number">42</span>:eeff:fed9:c268/<span class="hljs-number">64</span> scope link <br>       valid_lft forever preferred_lft forever<br><span class="hljs-number">5</span>: br-<span class="hljs-number">3</span>d8dbba954bf: <span class="hljs-variable">&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</span> mtu <span class="hljs-number">1500</span> qdisc noqueue <span class="hljs-keyword">state</span> UP <span class="hljs-keyword">group</span> <span class="hljs-keyword">default</span> <br>    link/ether <span class="hljs-number">02</span>:<span class="hljs-number">42</span>:<span class="hljs-number">6</span>c:a5:<span class="hljs-number">67</span>:cc brd ff:ff:ff:ff:ff:ff<br>    <span class="hljs-keyword">inet</span> <span class="hljs-number">172.19</span>.<span class="hljs-number">0.1</span>/<span class="hljs-number">16</span> brd <span class="hljs-number">172.19</span>.<span class="hljs-number">255.255</span> scope <span class="hljs-keyword">global</span> br-<span class="hljs-number">3</span>d8dbba954bf<br>       valid_lft forever preferred_lft forever<br>    <span class="hljs-keyword">inet6</span> fe80::<span class="hljs-number">42</span>:<span class="hljs-number">6</span>cff:fea5:<span class="hljs-number">67</span>cc/<span class="hljs-number">64</span> scope link <br>       valid_lft forever preferred_lft forever<br><span class="hljs-number">9</span>: veth7dba01e@if8: <span class="hljs-variable">&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</span> mtu <span class="hljs-number">1500</span> qdisc noqueue master br-<span class="hljs-number">66</span>ad3449f59f <span class="hljs-keyword">state</span> UP <span class="hljs-keyword">group</span> <span class="hljs-keyword">default</span> <br>    link/ether aa:<span class="hljs-number">7</span>c:a6:ae:<span class="hljs-number">85</span>:<span class="hljs-number">2</span>c brd ff:ff:ff:ff:ff:ff link-netnsid <span class="hljs-number">0</span><br>    <span class="hljs-keyword">inet6</span> fe80::a87c:a6ff:feae:<span class="hljs-number">852</span>c/<span class="hljs-number">64</span> scope link <br>       valid_lft forever preferred_lft forever<br><span class="hljs-number">15</span>: veth9f52d5f@if14: <span class="hljs-variable">&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</span> mtu <span class="hljs-number">1500</span> qdisc noqueue master br-<span class="hljs-number">3</span>d8dbba954bf <span class="hljs-keyword">state</span> UP <span class="hljs-keyword">group</span> <span class="hljs-keyword">default</span> <br>    link/ether e2:bd:<span class="hljs-number">35</span>:<span class="hljs-number">53</span>:c6:<span class="hljs-number">0</span>c brd ff:ff:ff:ff:ff:ff link-netnsid <span class="hljs-number">1</span><br>    <span class="hljs-keyword">inet6</span> fe80::e0bd:<span class="hljs-number">35</span>ff:fe53:c60c/<span class="hljs-number">64</span> scope link <br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure><ul><li><p>安装 Docker</p></li><li><p>安装 nfs-utils</p></li><li><p>安装 kubectl / kubeadm / kubelet</p></li></ul><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 在 master 节点和 worker 节点都要执行</span><br><span class="hljs-meta"># 最后一个参数 1.18.6 用于指定 kubenetes 版本，支持所有 1.18.x 版本的安装</span><br><span class="hljs-meta"># 腾讯云 docker hub 镜像</span><br><span class="hljs-meta"># export REGISTRY_MIRROR=&quot;https://mirror.ccs.tencentyun.com&quot;</span><br><span class="hljs-meta"># DaoCloud 镜像</span><br><span class="hljs-meta"># export REGISTRY_MIRROR=&quot;http://f1361db2.m.daocloud.io&quot;</span><br><span class="hljs-meta"># 华为云镜像</span><br><span class="hljs-meta"># export REGISTRY_MIRROR=&quot;https://05f073ad3c0010ea0f4bc00b7105ec20.mirror.swr.myhuaweicloud.com&quot;</span><br><span class="hljs-meta"># 阿里云 docker hub 镜像</span><br>export REGISTRY_MIRROR=https:<span class="hljs-comment">//registry.cn-hangzhou.aliyuncs.com</span><br>curl -sSL https:<span class="hljs-comment">//kuboard.cn/install-script/v1.18.x/install_kubelet.sh | sh -s 1.18.6</span><br></code></pre></td></tr></table></figure><details><summary>脚本内容</summary><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#!/bin/bash</span><br><br><span class="hljs-comment"># 在 master 节点和 worker 节点都要执行</span><br><br><span class="hljs-comment"># 安装 docker</span><br><span class="hljs-comment"># 参考文档如下</span><br><span class="hljs-comment"># https://docs.docker.com/install/linux/docker-ce/centos/ </span><br><span class="hljs-comment"># https://docs.docker.com/install/linux/linux-postinstall/</span><br><br><span class="hljs-comment"># 卸载旧版本</span><br>yum remove -y docker \<br>docker-client \<br>docker-client-latest \<br>docker-ce-cli \<br>docker-common \<br>docker-latest \<br>docker-latest-logrotate \<br>docker-logrotate \<br>docker-selinux \<br>docker-engine-selinux \<br>docker-engine<br><br><span class="hljs-comment"># 设置 yum repository</span><br>yum install -y yum-utils \<br>device-mapper-persistent-data \<br>lvm2<br>yum-config-manager --add-repo http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/docker-ce/</span>linux<span class="hljs-regexp">/centos/</span>docker-ce.repo<br><br><span class="hljs-comment"># 安装并启动 docker</span><br>yum install -y docker-ce-<span class="hljs-number">19.03</span>.<span class="hljs-number">8</span> docker-ce-cli-<span class="hljs-number">19.03</span>.<span class="hljs-number">8</span> containerd.io<br>systemctl enable docker<br>systemctl start docker<br><br><span class="hljs-comment"># 安装 nfs-utils</span><br><span class="hljs-comment"># 必须先安装 nfs-utils 才能挂载 nfs 网络存储</span><br>yum install -y nfs-utils<br>yum install -y wget<br><br><span class="hljs-comment"># 关闭 防火墙</span><br>systemctl stop firewalld<br>systemctl disable firewalld<br><br><span class="hljs-comment"># 关闭 SeLinux</span><br>setenforce <span class="hljs-number">0</span><br>sed -i <span class="hljs-string">&quot;s/SELINUX=enforcing/SELINUX=disabled/g&quot;</span> <span class="hljs-regexp">/etc/</span>selinux/config<br><br><span class="hljs-comment"># 关闭 swap</span><br>swapoff -a<br>yes | cp <span class="hljs-regexp">/etc/</span>fstab <span class="hljs-regexp">/etc/</span>fstab_bak<br>cat <span class="hljs-regexp">/etc/</span>fstab_bak |grep -v swap &gt; <span class="hljs-regexp">/etc/</span>fstab<br><br><span class="hljs-comment"># 修改 /etc/sysctl.conf</span><br><span class="hljs-comment"># 如果有配置，则修改</span><br>sed -i <span class="hljs-string">&quot;s#^net.ipv4.ip_forward.*#net.ipv4.ip_forward=1#g&quot;</span>  <span class="hljs-regexp">/etc/</span>sysctl.conf<br>sed -i <span class="hljs-string">&quot;s#^net.bridge.bridge-nf-call-ip6tables.*#net.bridge.bridge-nf-call-ip6tables=1#g&quot;</span>  <span class="hljs-regexp">/etc/</span>sysctl.conf<br>sed -i <span class="hljs-string">&quot;s#^net.bridge.bridge-nf-call-iptables.*#net.bridge.bridge-nf-call-iptables=1#g&quot;</span>  <span class="hljs-regexp">/etc/</span>sysctl.conf<br>sed -i <span class="hljs-string">&quot;s#^net.ipv6.conf.all.disable_ipv6.*#net.ipv6.conf.all.disable_ipv6=1#g&quot;</span>  <span class="hljs-regexp">/etc/</span>sysctl.conf<br>sed -i <span class="hljs-string">&quot;s#^net.ipv6.conf.default.disable_ipv6.*#net.ipv6.conf.default.disable_ipv6=1#g&quot;</span>  <span class="hljs-regexp">/etc/</span>sysctl.conf<br>sed -i <span class="hljs-string">&quot;s#^net.ipv6.conf.lo.disable_ipv6.*#net.ipv6.conf.lo.disable_ipv6=1#g&quot;</span>  <span class="hljs-regexp">/etc/</span>sysctl.conf<br>sed -i <span class="hljs-string">&quot;s#^net.ipv6.conf.all.forwarding.*#net.ipv6.conf.all.forwarding=1#g&quot;</span>  <span class="hljs-regexp">/etc/</span>sysctl.conf<br><span class="hljs-comment"># 可能没有，追加</span><br>echo <span class="hljs-string">&quot;net.ipv4.ip_forward = 1&quot;</span> &gt;&gt; <span class="hljs-regexp">/etc/</span>sysctl.conf<br>echo <span class="hljs-string">&quot;net.bridge.bridge-nf-call-ip6tables = 1&quot;</span> &gt;&gt; <span class="hljs-regexp">/etc/</span>sysctl.conf<br>echo <span class="hljs-string">&quot;net.bridge.bridge-nf-call-iptables = 1&quot;</span> &gt;&gt; <span class="hljs-regexp">/etc/</span>sysctl.conf<br>echo <span class="hljs-string">&quot;net.ipv6.conf.all.disable_ipv6 = 1&quot;</span> &gt;&gt; <span class="hljs-regexp">/etc/</span>sysctl.conf<br>echo <span class="hljs-string">&quot;net.ipv6.conf.default.disable_ipv6 = 1&quot;</span> &gt;&gt; <span class="hljs-regexp">/etc/</span>sysctl.conf<br>echo <span class="hljs-string">&quot;net.ipv6.conf.lo.disable_ipv6 = 1&quot;</span> &gt;&gt; <span class="hljs-regexp">/etc/</span>sysctl.conf<br>echo <span class="hljs-string">&quot;net.ipv6.conf.all.forwarding = 1&quot;</span>  &gt;&gt; <span class="hljs-regexp">/etc/</span>sysctl.conf<br><span class="hljs-comment"># 执行命令以应用</span><br>sysctl -p<br><br><span class="hljs-comment"># 配置K8S的yum源</span><br>cat &lt;&lt;EOF &gt; <span class="hljs-regexp">/etc/yum</span>.repos.d/kubernetes.repo<br>[kubernetes]<br>name=Kubernetes<br>baseurl=http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/kubernetes/yum</span><span class="hljs-regexp">/repos/</span>kubernetes-el7-x86_64<br>enabled=<span class="hljs-number">1</span><br>gpgcheck=<span class="hljs-number">0</span><br>repo_gpgcheck=<span class="hljs-number">0</span><br>gpgkey=http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/kubernetes/yum</span><span class="hljs-regexp">/doc/yum</span>-key.gpg<br>       http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/kubernetes/yum</span><span class="hljs-regexp">/doc/</span>rpm-package-key.gpg<br>EOF<br><br><span class="hljs-comment"># 卸载旧版本</span><br>yum remove -y kubelet kubeadm kubectl<br><br><span class="hljs-comment"># 安装kubelet、kubeadm、kubectl</span><br><span class="hljs-comment"># 将 $&#123;1&#125; 替换为 kubernetes 版本号，例如 1.17.2</span><br>yum install -y kubelet-<span class="hljs-variable">$&#123;1&#125;</span> kubeadm-<span class="hljs-variable">$&#123;1&#125;</span> kubectl-<span class="hljs-variable">$&#123;1&#125;</span><br><br><span class="hljs-comment"># 修改docker Cgroup Driver为systemd</span><br><span class="hljs-comment"># # 将/usr/lib/systemd/system/docker.service文件中的这一行 ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</span><br><span class="hljs-comment"># # 修改为 ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --exec-opt native.cgroupdriver=systemd</span><br><span class="hljs-comment"># 如果不修改，在添加 worker 节点时可能会碰到如下错误</span><br><span class="hljs-comment"># [WARNING IsDockerSystemdCheck]: detected &quot;cgroupfs&quot; as the Docker cgroup driver. The recommended driver is &quot;systemd&quot;. </span><br><span class="hljs-comment"># Please follow the guide at https://kubernetes.io/docs/setup/cri/</span><br>sed -i <span class="hljs-string">&quot;s#^ExecStart=/usr/bin/dockerd.*#ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --exec-opt native.cgroupdriver=systemd#g&quot;</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/systemd/</span>system/docker.service<br><br><span class="hljs-comment"># 设置 docker 镜像，提高 docker 镜像下载速度和稳定性</span><br><span class="hljs-comment"># 如果您访问 https://hub.docker.io 速度非常稳定，亦可以跳过这个步骤</span><br>curl -sSL https:<span class="hljs-regexp">//</span>kuboard.cn<span class="hljs-regexp">/install-script/</span>set_mirror.sh | sh -s <span class="hljs-variable">$&#123;REGISTRY_MIRROR&#125;</span><br><br><span class="hljs-comment"># 重启 docker，并启动 kubelet</span><br>systemctl daemon-reload<br>systemctl restart docker<br>systemctl enable kubelet &amp;&amp; systemctl start kubelet<br><br>docker version<br></code></pre></td></tr></table></figure></details><br><ul><li>初始化 master 节点</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 只在 master 节点执行</span><br><span class="hljs-comment"># 替换 x.x.x.x 为 master 节点实际 IP（请使用内网 IP）</span><br><span class="hljs-comment"># export 命令只在当前 shell 会话中有效，开启新的 shell 窗口后，如果要继续安装过程，请重新执行此处的 export 命令</span><br><span class="hljs-attribute">export</span> MASTER_IP=x.x.x.x<br><span class="hljs-comment"># 替换 apiserver.demo 为 您想要的 dnsName</span><br><span class="hljs-attribute">export</span> APISERVER_NAME=apiserver.demo<br><span class="hljs-comment"># Kubernetes 容器组所在的网段，该网段安装完成后，由 kubernetes 创建，事先并不存在于您的物理网络中</span><br><span class="hljs-attribute">export</span> POD_SUBNET=<span class="hljs-number">10.100.0.1</span>/<span class="hljs-number">16</span><br><span class="hljs-attribute">echo</span> <span class="hljs-string">&quot;$&#123;MASTER_IP&#125;    $&#123;APISERVER_NAME&#125;&quot;</span> &gt;&gt; /etc/hosts<br><span class="hljs-attribute">curl</span> -sSL https://kuboard.cn/install-script/v<span class="hljs-number">1</span>.<span class="hljs-number">18</span>.x/init_master.sh | sh -s <span class="hljs-number">1</span>.<span class="hljs-number">18</span>.<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><details>    <summary>脚本代码</summary><pre><code><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#!/bin/bash</span><br><br><span class="hljs-comment"># 只在 master 节点执行</span><br><br><span class="hljs-comment"># 脚本出错时终止执行</span><br>set -e<br><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$&#123;#POD_SUBNET&#125;</span> -eq <span class="hljs-number">0</span> ] || [ <span class="hljs-variable">$&#123;#APISERVER_NAME&#125;</span> -eq <span class="hljs-number">0</span> ]; then<br>  echo -e <span class="hljs-string">&quot;\033[31;1m请确保您已经设置了环境变量 POD_SUBNET 和 APISERVER_NAME \033[0m&quot;</span><br>  echo 当前POD_SUBNET=<span class="hljs-variable">$POD_SUBNET</span><br>  echo 当前APISERVER_NAME=<span class="hljs-variable">$APISERVER_NAME</span><br>  <span class="hljs-keyword">exit</span> <span class="hljs-number">1</span><br>fi<br><br><br><span class="hljs-comment"># 查看完整配置选项 https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2</span><br>rm -f ./kubeadm-config.yaml<br>cat &lt;&lt;EOF &gt; ./kubeadm-config.yaml<br>apiVersion: kubeadm.k8s.io/v1beta2<br>kind: ClusterConfiguration<br>kubernetesVersion: v<span class="hljs-variable">$&#123;1&#125;</span><br>imageRepository: registry.aliyuncs.com/k8sxio<br>controlPlaneEndpoint: <span class="hljs-string">&quot;$&#123;APISERVER_NAME&#125;:6443&quot;</span><br>networking:<br>  serviceSubnet: <span class="hljs-string">&quot;10.96.0.0/16&quot;</span><br>  podSubnet: <span class="hljs-string">&quot;$&#123;POD_SUBNET&#125;&quot;</span><br>  dnsDomain: <span class="hljs-string">&quot;cluster.local&quot;</span><br>EOF<br><br><span class="hljs-comment"># kubeadm init</span><br><span class="hljs-comment"># 根据您服务器网速的情况，您需要等候 3 - 10 分钟</span><br>kubeadm init --config=kubeadm-config.yaml --upload-certs<br><br><span class="hljs-comment"># 配置 kubectl</span><br>rm -rf <span class="hljs-regexp">/root/</span>.kube/<br>mkdir <span class="hljs-regexp">/root/</span>.kube/<br>cp -i <span class="hljs-regexp">/etc/</span>kubernetes<span class="hljs-regexp">/admin.conf /</span>root<span class="hljs-regexp">/.kube/</span>config<br><br><span class="hljs-comment"># 安装 calico 网络插件</span><br><span class="hljs-comment"># 参考文档 https://docs.projectcalico.org/v3.13/getting-started/kubernetes/self-managed-onprem/onpremises</span><br>echo <span class="hljs-string">&quot;安装calico-3.13.1&quot;</span><br>rm -f calico-<span class="hljs-number">3.13</span>.<span class="hljs-number">1</span>.yaml<br>wget https:<span class="hljs-regexp">//</span>kuboard.cn<span class="hljs-regexp">/install-script/</span>calico/calico-<span class="hljs-number">3.13</span>.<span class="hljs-number">1</span>.yaml<br>kubectl apply -f calico-<span class="hljs-number">3.13</span>.<span class="hljs-number">1</span>.yaml<br><br></code></pre></td></tr></table></figure></code></pre></details><br><ul><li>检查 master 初始化结果</li></ul><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 只在 master 节点执行</span><br><span class="hljs-meta"># 执行如下命令，等待 3-10 分钟，直到所有的容器组处于 Running 状态</span><br>watch kubectl <span class="hljs-keyword">get</span> pod -n kube-system -o wide<br><span class="hljs-meta"># 查看 master 节点初始化结果</span><br>kubectl <span class="hljs-keyword">get</span> nodes -o wide<br></code></pre></td></tr></table></figure><p>成功</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Every</span> <span class="hljs-number">2</span>.<span class="hljs-number">0</span>s: kubectl get pod -n kube-system -o wide                                                                                                                                                                                               Tue Jul <span class="hljs-number">28</span> <span class="hljs-number">17</span>:<span class="hljs-number">31</span>:<span class="hljs-number">56</span> <span class="hljs-number">2020</span><br><br><span class="hljs-attribute">NAME</span>                                       READY   STATUS     RESTARTS   AGE    IP             NODE     NOMINATED NODE   READINESS GATES<br><span class="hljs-attribute">calico</span>-kube-controllers-<span class="hljs-number">5</span>b<span class="hljs-number">8</span>b<span class="hljs-number">769</span>fcd-dw<span class="hljs-number">2</span>fq   <span class="hljs-number">0</span>/<span class="hljs-number">1</span>     Pending    <span class="hljs-number">0</span>          <span class="hljs-number">99</span>s    &lt;none&gt;         &lt;none&gt;   &lt;none&gt;           &lt;none&gt;<br><span class="hljs-attribute">calico</span>-node-gcw<span class="hljs-number">6</span>r                          <span class="hljs-number">0</span>/<span class="hljs-number">1</span>     Init:<span class="hljs-number">0</span>/<span class="hljs-number">3</span>   <span class="hljs-number">0</span>          <span class="hljs-number">99</span>s    <span class="hljs-number">192.168.0.39</span>   mikey    &lt;none&gt;           &lt;none&gt;<br><span class="hljs-attribute">coredns</span>-<span class="hljs-number">66</span>db<span class="hljs-number">54</span>ff<span class="hljs-number">7</span>f-<span class="hljs-number">2</span>f<span class="hljs-number">9</span>qn                   <span class="hljs-number">0</span>/<span class="hljs-number">1</span>     Pending    <span class="hljs-number">0</span>          <span class="hljs-number">99</span>s    &lt;none&gt;         &lt;none&gt;   &lt;none&gt;           &lt;none&gt;<br><span class="hljs-attribute">coredns</span>-<span class="hljs-number">66</span>db<span class="hljs-number">54</span>ff<span class="hljs-number">7</span>f-csm<span class="hljs-number">5</span>w                   <span class="hljs-number">0</span>/<span class="hljs-number">1</span>     Pending    <span class="hljs-number">0</span>          <span class="hljs-number">99</span>s    &lt;none&gt;         &lt;none&gt;   &lt;none&gt;           &lt;none&gt;<br><span class="hljs-attribute">etcd</span>-mikey                                 <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running    <span class="hljs-number">0</span>          <span class="hljs-number">108</span>s   <span class="hljs-number">192.168.0.39</span>   mikey    &lt;none&gt;           &lt;none&gt;<br><span class="hljs-attribute">kube</span>-apiserver-mikey                       <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running    <span class="hljs-number">0</span>          <span class="hljs-number">108</span>s   <span class="hljs-number">192.168.0.39</span>   mikey    &lt;none&gt;           &lt;none&gt;<br><span class="hljs-attribute">kube</span>-controller-manager-mikey              <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running    <span class="hljs-number">0</span>          <span class="hljs-number">108</span>s   <span class="hljs-number">192.168.0.39</span>   mikey    &lt;none&gt;           &lt;none&gt;<br><span class="hljs-attribute">kube</span>-proxy-xhmgq                           <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running    <span class="hljs-number">0</span>          <span class="hljs-number">99</span>s    <span class="hljs-number">192.168.0.39</span>   mikey    &lt;none&gt;           &lt;none&gt;<br><span class="hljs-attribute">kube</span>-scheduler-mikey                       <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running    <span class="hljs-number">0</span>          <span class="hljs-number">108</span>s   <span class="hljs-number">192.168.0.39</span>   mikey    &lt;none&gt;           &lt;none&gt;<br><br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[root@<span class="hljs-keyword">server</span><span class="hljs-number">-781e6</span>bf7-bce3<span class="hljs-number">-4</span>d09-adc8<span class="hljs-number">-2</span>a169fdb8719 ~]# kubectl <span class="hljs-keyword">get</span> nodes -o wide<br><span class="hljs-type">NAME</span>    STATUS     ROLES    AGE     <span class="hljs-keyword">VERSION</span>   <span class="hljs-type">INTERNAL</span>-IP    <span class="hljs-keyword">EXTERNAL</span>-IP   OS-IMAGE                KERNEL-<span class="hljs-keyword">VERSION</span>                CONTAINER-RUNTIME<br>mikey   NotReady   master   <span class="hljs-number">2</span>m18s   v1<span class="hljs-number">.18</span><span class="hljs-number">.6</span>   <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.39</span>   &lt;<span class="hljs-keyword">none</span>&gt;        CentOS Linux <span class="hljs-number">7</span> (Core)   <span class="hljs-number">3.10</span><span class="hljs-number">.0</span><span class="hljs-number">-1062.12</span><span class="hljs-number">.1</span>.el7.x86_64   docker://<span class="hljs-number">19.3</span><span class="hljs-number">.8</span><br><br></code></pre></td></tr></table></figure><ul><li>初始化 worker节点<blockquote><p>获得 join命令参数在 master 节点上执行</p></blockquote></li></ul><p><code>kubeadm token create --print-join-command</code></p><p>可获取kubeadm join 命令及参数，如下所示</p><p>kubeadm token create 命令的输出</p><blockquote><p>kubeadm join apiserver.demo:6443 –token mpfjma.4vjjg8flqihor4vt     –discovery-token-ca-cert-hash sha256:6f7a8e40a810323672de5eee6f4d19aa2dbdb38411845a1bf5dd63485c43d303</p></blockquote><p><code>该 token 的有效时间为 2 个小时，2小时内，您可以使用此 token 初始化任意数量的 worker 节点</code></p><ul><li>初始化worker</li></ul><p>针对所有的 worker 节点执行</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 只在 worker 节点执行</span><br><span class="hljs-comment"># 替换 x.x.x.x 为 master 节点的内网 IP</span><br><span class="hljs-attribute">export</span> MASTER_IP=x.x.x.x<br><span class="hljs-comment"># 替换 apiserver.demo 为初始化 master 节点时所使用的 APISERVER_NAME</span><br><span class="hljs-attribute">export</span> APISERVER_NAME=apiserver.demo<br><span class="hljs-attribute">echo</span> <span class="hljs-string">&quot;$&#123;MASTER_IP&#125;    $&#123;APISERVER_NAME&#125;&quot;</span> &gt;&gt; /etc/hosts<br><span class="hljs-comment"># 替换为 master 节点上 kubeadm token create 命令的输出</span><br><span class="hljs-attribute">kubeadm</span> join apiserver.demo:<span class="hljs-number">6443</span> --token mpfjma.<span class="hljs-number">4</span>vjjg<span class="hljs-number">8</span>flqihor<span class="hljs-number">4</span>vt     --discovery-token-ca-cert-hash sha<span class="hljs-number">256</span>:<span class="hljs-number">031</span>a<span class="hljs-number">838</span>dcdb<span class="hljs-number">8</span>a<span class="hljs-number">66</span>e<span class="hljs-number">0</span>a<span class="hljs-number">5</span>ddb<span class="hljs-number">826</span>a<span class="hljs-number">2</span>ada<span class="hljs-number">6065</span>d<span class="hljs-number">3</span>f<span class="hljs-number">68</span>d<span class="hljs-number">5</span>ddfa<span class="hljs-number">97226270</span>a<span class="hljs-number">0</span>e<span class="hljs-number">56861160</span><br></code></pre></td></tr></table></figure><p>出现问题<code>kubeadm reset</code>进行重置</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://kuboard.cn/install/install-k8s.html#%E6%96%87%E6%A1%A3%E7%89%B9%E7%82%B9">单节点安装</a></p><p><a href="https://kuboard.cn/learning/k8s-bg/what-is-k8s.html#%E5%9B%9E%E9%A1%BE">Kubernates 教学</a></p>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernates</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 基础</title>
    <link href="/2020/07/07/java/Java-%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/07/07/java/Java-%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="JAVA-异常分类及处理"><a href="#JAVA-异常分类及处理" class="headerlink" title="JAVA 异常分类及处理"></a>JAVA 异常分类及处理</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>如果某个方法不能按照正常的途径完成任务,就可以通过另一种路径退出方法。在这种情况下<br> 会抛出一个封装了错误信息的对象。此时,这个方法会立刻退出同时不返回任何值。另外,调用<br> 这个方法的其他代码也无法继续执行,异常处理机制会将代码执行交给异常处理器。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/exception.png" alt="avatar"></p><h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><blockquote><p>Throwable 是 Java 语言中所有错误或异常的超类。下一层分为 Error 和 Exception</p></blockquote><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><blockquote><p>Error 类是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误,除了告知用户,剩下的就是尽力使程序安全的终止。</p></blockquote><h3 id="Exception-RuntimeException、CheckedException"><a href="#Exception-RuntimeException、CheckedException" class="headerlink" title="Exception(RuntimeException、CheckedException)"></a>Exception(RuntimeException、CheckedException)</h3><blockquote><p>Exception 又 有 两 个 分 支 , 一 个 是 运 行 时 异 常 RuntimeException , 一 个 是CheckedException。</p></blockquote><h3 id="RuntimeException"><a href="#RuntimeException" class="headerlink" title="RuntimeException"></a>RuntimeException</h3><blockquote><p>如 : <code>NullPointerException</code> 、 <code>ClassCastException</code> ; 一 个 是 检 查 异 常<br>CheckedException,如 I/O 错误导致的 <code>IOException</code>、<code>SQLException</code>。 RuntimeException 是<br>那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。 如果出现 RuntimeException,那么一定是程序员的错误.</p></blockquote><h3 id="检查异常-CheckedException"><a href="#检查异常-CheckedException" class="headerlink" title="检查异常 CheckedException:"></a>检查异常 CheckedException:</h3><blockquote><p>一般是外部错误,这种异常都发生在编译阶段,Java 编译器会强<br>制程序去捕获此类异常,即会出现要求你把这段可能出现异常的程序进行 try catch,该类异常一<br>般包括几个方面:</p></blockquote><ol><li>试图在文件尾部读取数据</li><li>试图打开一个错误格式的 URL</li><li>试图根据给定的字符串查找 class 对象,而这个字符串表示的类并不存在</li></ol><h3 id="异常的处理方式"><a href="#异常的处理方式" class="headerlink" title="异常的处理方式"></a>异常的处理方式</h3><p>遇到问题不进行具体处理,而是继续抛给调用者 (throw,throws)  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String s = <span class="hljs-string">&quot;abc&quot;</span>;<br>        <span class="hljs-keyword">if</span>(s.equals(<span class="hljs-string">&quot;abc&quot;</span>)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NumberFormatException();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(s);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>    <span class="hljs-keyword">return</span> a/b;<br>&#125;<br></code></pre></td></tr></table></figure><p>try catch 捕获异常针对性处理方式<br>Throw 和 throws 的区别:<br>位置不同:</p><blockquote><p>throws 用在函数上,后面跟的是异常类,可以跟多个;而 throw 用在函数内,后面跟的是异常对象。</p></blockquote><p>功能不同:  </p><blockquote><p>throws 用来声明异常,让调用者只知道该功能可能出现的问题,可以给出预先的处理方式;throw 抛出具体的问题对象,执行到 throw,功能就已经结束了,跳转到调用者,并将具体的问题对象抛给调用者。也就是说 throw 语句独立存在时,下面不要定义其他语句,因为执行不到。</p></blockquote><blockquote><p>throws 表示出现异常的一种可能性,并不一定会发生这些异常;throw 则是抛出了异常,<br> 执行 throw 则一定抛出了某种异常对象。</p></blockquote><blockquote><p>两者都是消极处理异常的方式,只是抛出或者可能抛出异常,但是不会由函数去处理异<br> 常,真正的处理异常由函数的上层调用处理。</p></blockquote><h1 id="JAVA-反射"><a href="#JAVA-反射" class="headerlink" title="JAVA 反射"></a>JAVA 反射</h1><h2 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h2><blockquote><p>动态语言,是指程序在运行时可以改变其结构:新的函数可以引进,已有的函数可以被删除等结<br> 构上的变化。比如常见的 JavaScript 就是动态语言,除此之外 Ruby,Python 等也属于动态语言,<br> 而 C、C++则不属于动态语言。从反射角度说 JAVA 属于半动态语言。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/reflex.png" alt="avatar"></p><h2 id="反射机制概念-运行状态中知道类所有的属性和方法"><a href="#反射机制概念-运行状态中知道类所有的属性和方法" class="headerlink" title="反射机制概念 (运行状态中知道类所有的属性和方法)"></a>反射机制概念 (运行状态中知道类所有的属性和方法)</h2><blockquote><p>在 Java 中的反射机制是指在运行状态中,对于任意一个类都能够知道这个类所有的属性和方法;<br>并且对于任意一个对象,都能够调用它的任意一个方法;这种动态获取信息以及动态调用对象方<br>法的功能成为 Java 语言的反射机制。</p></blockquote><h3 id="反射的应用场合"><a href="#反射的应用场合" class="headerlink" title="反射的应用场合"></a>反射的应用场合</h3><p>编译时类型和运行时类型  </p><p>在 Java 程序中许多对象在运行是都会出现两种类型:编译时类型和运行时类型。 编译时的类型由<br>声明对象时实用的类型来决定,运行时的类型由实际赋值给对象的类型决定 。如:<br><code>Person p=new Student();</code><br>其中编译时类型为 Person,运行时类型为 Student。</p><p>的编译时类型无法获取具体方法  </p><blockquote><p>程序在运行时还可能接收到外部传入的对象,该对象的编译时类型为 Object,但是程序有需要调用<br> 该对象的运行时类型的方法。为了解决这些问题,程序需要在运行时发现对象和类的真实信息。<br> 然而,如果编译时根本无法预知该对象和类属于哪些类,程序只能依靠运行时信息来发现该对象<br> 和类的真实信息,此时就必须使用到反射了。</p></blockquote><p>Java 反射 API<br>反射 API 用来生成 JVM 中的类、接口或则对象的信息。  </p><blockquote><ol><li>Class 类:反射的核心类,可以获取类的属性,方法等信息。</li><li>Field 类:Java.lang.reflec 包中的类,表示类的成员变量,可以用来获取和设置类之中的属性值。</li><li>Method 类: Java.lang.reflec 包中的类,表示类的方法,它可以用来获取类中的方法信息或者执行方法。</li><li>Constructor 类: Java.lang.reflec 包中的类,表示类的构造方法。</li></ol></blockquote><h4 id="反射使用步骤-获取-Class-对象、调用对象方法"><a href="#反射使用步骤-获取-Class-对象、调用对象方法" class="headerlink" title="反射使用步骤(获取 Class 对象、调用对象方法)"></a>反射使用步骤(获取 Class 对象、调用对象方法)</h4><blockquote><ol><li>反射使用步骤(获取 Class 对象、调用对象方法)获取想要操作的类的 Class 对象,他是反射的核心,通过 Class 对象我们可以任意调用类的方法</li><li>调用 Class 类中的方法,既就是反射的使用阶段</li><li>使用反射 API 来操作这些信息</li></ol></blockquote><p>获取 Class 对象的 3 种方法<br>调用某个对象的 getClass()方法  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Person p=<span class="hljs-keyword">new</span> Person();<br>Class clazz=p.getClass();<br></code></pre></td></tr></table></figure><p>调用某个类的 class 属性来获取该类对应的 Class 对象  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class clazz=Person.class;<br></code></pre></td></tr></table></figure><p>使用 Class 类中的 forName()静态方法(最安全/性能最好)  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class clazz=Class.forName(<span class="hljs-string">&quot;类的全路径&quot;</span>); (最常用)<br></code></pre></td></tr></table></figure><p>当我们获得了想要操作的类的 Class 对象后,可以通过 Class 类中的方法获取并查看该类中的方法和属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取 Person 类的 Class 对象</span><br>Class clazz=Class.forName(<span class="hljs-string">&quot;reflection.Person&quot;</span>);<br><span class="hljs-comment">//获取 Person 类的所有方法信息</span><br>Method[] method=clazz.getDeclaredMethods();<br><span class="hljs-keyword">for</span>(Method m:method)&#123;<br>    System.out.println(m.toString());<br>&#125;<br><span class="hljs-comment">//获取 Person 类的所有成员属性信息</span><br>Field[] field=clazz.getDeclaredFields();<br><span class="hljs-keyword">for</span>(Field f:field)&#123;<br>    System.out.println(f.toString());<br>&#125;<br><span class="hljs-comment">//获取 Person 类的所有构造方法信息</span><br>Constructor[] constructor=clazz.getDeclaredConstructors();<br><span class="hljs-keyword">for</span>(Constructor c:constructor)&#123;<br>    System.out.println(c.toString());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="创建对象的两种方法"><a href="#创建对象的两种方法" class="headerlink" title="创建对象的两种方法"></a>创建对象的两种方法</h4><p>Class 对象的 newInstance()  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例,但是这种方法要求<br>该 Class 对象对应的类有默认的空构造器。<br></code></pre></td></tr></table></figure><p>调用 Constructor 对象的 newInstance()  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">先使用 Class 对象获取指定的 Constructor 对象,再调用 Constructor 对象的 newInstance()<br>方法来创建 Class 对象对应类的实例,通过这种方法可以选定构造方法创建实例。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取 Person 类的 Class 对象</span><br>Class clazz=Class.forName(<span class="hljs-string">&quot;reflection.Person&quot;</span>);<br><span class="hljs-comment">//使用.newInstane 方法创建对象</span><br>Person p=(Person) clazz.newInstance();<br><span class="hljs-comment">//获取构造方法并创建对象</span><br>Constructor c=clazz.getDeclaredConstructor(String.class,String.class,<span class="hljs-keyword">int</span>.class);<br><span class="hljs-comment">//创建对象并设置属性</span><br>Person p1=(Person) c.newInstance(<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-string">&quot;男&quot;</span>,<span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure><h1 id="JAVA-注解"><a href="#JAVA-注解" class="headerlink" title="JAVA 注解"></a>JAVA 注解</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><blockquote><p>A nnotation(注解)是 Java 提供的一种对元程序中元素关联信息和元数据(metadata)的途径<br> 和方法。Annatation(注解)是一个接口,程序可以通过反射来获取指定程序中元素的 Annotation<br> 对象,然后通过该 Annotation 对象来获取注解中的元数据信息。</p></blockquote><h2 id="四种标准元注解"><a href="#四种标准元注解" class="headerlink" title="四种标准元注解"></a>四种标准元注解</h2><blockquote><p>元注解的作用是负责注解其他注解。 Java5.0 定义了 4 个标准的 meta-annotation 类型,它们被<br> 用来提供对其它 annotation 类型作说明。</p></blockquote><p>@Target 修饰的对象范围  </p><blockquote><p>@Target 说明了 Annotation 所修饰的对象范围: Annotation 可被用于 packages、types(类、<br> 接口、枚举、Annotation 类型)、类型成员(方法、构造方法、成员变量、枚举值)、方法参数<br> 和本地变量(如循环变量、catch 参数)。在 Annotation 类型的声明中使用了 target 可更加明晰<br> 其修饰的目标</p></blockquote><p>@Retention 定义 被保留的时间长短  </p><blockquote><p>Retention 定义了该 Annotation 被保留的时间长短:表示需要在什么级别保存注解信息,用于描<br> 述注解的生命周期(即:被描述的注解在什么范围内有效),取值(RetentionPoicy)由:</p></blockquote><ul><li>SOURCE:在源文件中有效(即源文件保留)</li><li>CLASS:在 class 文件中有效(即 class 保留)</li><li>RUNTIME:在运行时有效(即运行时保留)</li></ul><p>@Documented 描述-javadoc  </p><blockquote><p>@ Documented 用于描述其它类型的 annotation 应该被作为被标注的程序成员的公共 API,因此可以被例如 javadoc 此类的工具文档化。</p></blockquote><p>@Inherited 阐述了某个被标注的类型是被继承的  </p><blockquote><p>@Inherited 元注解是一个标记注解,@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的 annotation 类型被用于一个 class,则这个 annotation 将被用于该class 的子类。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/annotation.png" alt="avatar"></p><p>注解处理器  </p><blockquote><p>如果没有用来读取注解的方法和工作,那么注解也就不会比注释更有用处了。使用注解的过程中,很重要的一部分就是创建于使用注解处理器。Java SE5 扩展了反射机制的 API,以帮助程序员快速的构造自定义注解处理器。下面实现一个注解处理器。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java">/<span class="hljs-number">1</span>:*** 定义注解*/<br><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> FruitProvider &#123;<br>    <span class="hljs-comment">/**供应商编号*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> -1</span>;<br>    <span class="hljs-comment">/*** 供应商名称*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>    <span class="hljs-comment">/** * 供应商地址*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br><span class="hljs-comment">//2:注解使用</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> </span>&#123;<br>    <span class="hljs-meta">@FruitProvider(id = 1, name = &quot;陕西红富士集团&quot;, address = &quot;陕西省西安市延安路&quot;)</span><br>    <span class="hljs-keyword">private</span> String appleProvider;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAppleProvider</span><span class="hljs-params">(String appleProvider)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.appleProvider = appleProvider;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAppleProvider</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> appleProvider;<br>    &#125;<br>&#125;<br>/<span class="hljs-number">3</span>:*********** 注解处理器 ***************/<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FruitInfoUtil</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getFruitInfo</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>&#123;<br>        String strFruitProvicer = <span class="hljs-string">&quot;供应商信息:&quot;</span>;<br>        Field[] fields = clazz.getDeclaredFields();<span class="hljs-comment">//通过反射获取处理注解</span><br>        <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>            <span class="hljs-keyword">if</span> (field.isAnnotationPresent(FruitProvider.class)) &#123;<br>                FruitProvider fruitProvider = (FruitProvider) field.getAnnotation(FruitProvider.class);<br><span class="hljs-comment">//注解信息的处理地方</span><br>                strFruitProvicer = <span class="hljs-string">&quot; 供应商编号:&quot;</span> + fruitProvider.id() + <span class="hljs-string">&quot; 供应商名称:&quot;</span><br>                        + fruitProvider.name() + <span class="hljs-string">&quot; 供应商地址:&quot;</span>+ fruitProvider.address();<br>                System.out.println(strFruitProvicer);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FruitRun</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        FruitInfoUtil.getFruitInfo(Apple.class);<br><span class="hljs-comment">/***********输出结果***************/</span><br><span class="hljs-comment">// 供应商编号:1 供应商名称:陕西红富士集团 供应商地址:陕西省西安市延</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="JAVA-内部类"><a href="#JAVA-内部类" class="headerlink" title="JAVA 内部类"></a>JAVA 内部类</h1><blockquote><p>Java 类中不仅可以定义变量和方法,还可以定义类,这样定义在类内部的类就被称为内部类。根据定义的方式不同,内部类分为静态内部类,成员内部类,局部内部类,匿名内部类四种。</p></blockquote><p>静态内部类  </p><blockquote><p>定义在类内部的静态类,就是静态内部类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Out</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(a);<br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>静态内部类可以访问外部类所有的静态变量和方法,即使是 private 的也一样。</li><li>静态内部类和一般类一致,可以定义静态变量、方法,构造方法等。</li><li>其它类使用静态内部类需要使用“外部类.静态内部类”方式,如下所示:Out.Inner inner = new Out.Inner();inner.print();</li><li>Java 集合类 HashMap 内部就有一个静态内部类 Entry。Entry 是 HashMap 存放元素的抽象,HashMap 内部维护 Entry 数组用了存放元素,但是 Entry 对使用者是透明的。像这种和外部类关系密切的,且不依赖外部类实例的,都可以使用静态内部类。</li></ol><p>成员内部类  </p><blockquote><p>定义在类内部的非静态类,就是成员内部类。成员内部类不能定义静态方法和变量(final 修饰的除外)。这是因为成员内部类是非静态的,类初始化的时候先初始化静态成员,如果允许成员内部类定义静态变量,那么成员内部类的静态变量初始化顺序是有歧义的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Out</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b;<br>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>      System.out.println(a);<br>      System.out.println(b);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>局部内部类(定义在方法中的类)  </p><blockquote><p>定义在方法中的类,就是局部类。如果一个类只在某个方法中使用,则可以考虑使用局部类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Out</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> d = <span class="hljs-number">1</span>;<br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>&#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(c);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>匿名内部类(要继承一个父类或者实现一个接口、直接使用 new 来生成一个对象的引用) </p><blockquote><p>匿名内部类我们必须要继承一个父类或者实现一个接口,当然也仅能只继承一个父类或者实现一<br> 个接口。同时它也是没有 class 关键字,这是因为匿名内部类是直接使用 new 来生成一个对象的引<br> 用。</p></blockquote> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bird</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Bird bird)</span></span>&#123;<br>        System.out.println(bird.getName() + <span class="hljs-string">&quot;能够飞 &quot;</span> + bird.fly() + <span class="hljs-string">&quot;米&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Test test = <span class="hljs-keyword">new</span> Test();<br>        test.test(<span class="hljs-keyword">new</span> Bird() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">10000</span>;<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;大雁&quot;</span>;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="JAVA-泛型"><a href="#JAVA-泛型" class="headerlink" title="JAVA 泛型"></a>JAVA 泛型</h1><blockquote><p>泛型提供了编译时类型安全检测机制,该机制允许程序员在编译时检测到非法的类型。泛型的本<br> 质是参数化类型,也就是说所操作的数据类型被指定为一个参数。比如我们要写一个排序方法,<br> 能够对整型数组、字符串数组甚至其他任何类型的数组进行排序,我们就可以使用 Java 泛型。</p></blockquote><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法()"></a>泛型方法(<E>)</h2><blockquote><p>你可以写一个泛型方法,该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数<br> 类型,编译器适当地处理每一个方法调用。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 泛型方法 printArray</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt; E &gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">( E[] inputArray )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> ( E element : inputArray )&#123;<br>        System.out.printf( <span class="hljs-string">&quot;%s &quot;</span>, element );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><? extends T>表示该通配符所代表的类型是 T 类型的子类。</li><li><? super T>表示该通配符所代表的类型是 T 类型的父类。</li></ol><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类<T></h2><blockquote><p>泛型类的声明和非泛型类的声明类似,除了在类名后面添加了类型参数声明部分。和泛型方法一<br> 样,泛型类的类型参数声明部分也包含一个或多个类型参数,参数间用逗号隔开。一个泛型参数,<br> 也被称为一个类型变量,是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数,<br> 这些类被称为参数化的类或参数化的类型。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Box</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T t;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T t)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.t = t;<br>        &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符?"></a>类型通配符?</h2><blockquote><p>类型通配符一般是使用 ? 代替具体的类型参数。例如<br> List&lt;?&gt; 在 逻 辑 上 是<br> List<String>,List<Integer> 等所有 List&lt;具体类型实参&gt;的父类。</p></blockquote><p>类型擦除  </p><blockquote><p>Java 中的泛型基本上都是在编译器这个层次来实现的。在生成的 Java 字节代码中是不包含泛<br> 型中的类型信息的。使用泛型的时候加上的类型参数,会被编译器在编译的时候去掉。这个<br> 过程就称为类型擦除。如在代码中定义的 List<Object>和 List<String>等类型,在编译之后<br> 都会变成 List。JVM 看到的只是 List,而由泛型附加的类型信息对 JVM 来说是不可见的。<br> 类型擦除的基本过程也比较简单,首先是找到用来替换类型参数的具体类。这个具体类一般<br> 是 Object。如果指定了类型参数的上界的话,则使用这个上界。把代码中的类型参数都替换<br> 成具体的类。</p></blockquote><h1 id="JAVA-序列化-创建可复用的-Java-对象"><a href="#JAVA-序列化-创建可复用的-Java-对象" class="headerlink" title="JAVA 序列化 ( 创建可复用的 Java 对象 )"></a>JAVA 序列化 ( 创建可复用的 Java 对象 )</h1><p>保存(持久化)对象及其状态到内存或者磁盘 </p><blockquote><p>Java 平台允许我们在内存中创建可复用的 Java 对象,但一般情况下,只有当 JVM 处于运行时,<br> 这些对象才可能存在,即,这些对象的生命周期不会比 JVM 的生命周期更长。但在现实应用中,<br> 就可能要求在 JVM 停止运行之后能够保存(持久化)指定的对象,并在将来重新读取被保存的对象。<br> Java 对象序列化就能够帮助我们实现该功能。</p></blockquote><p>序列化对象以字节数组保持-静态成员不保存  </p><blockquote><p>使用 Java 对象序列化,在保存对象时,会把其状态保存为一组字节,在未来,再将这些字节组装<br> 成对象。必须注意地是,对象序列化保存的是对象的”状态”,即它的成员变量。由此可知,对<br> 象序列化不会关注类中的静态变量。</p></blockquote><p>序列化用户远程对象传输  </p><blockquote><p>除了在持久化对象时会用到对象序列化之外,当使用 RMI(远程方法调用),或在网络中传递对象时,<br> 都会用到对象序列化。Java 序列化 API 为处理对象序列化提供了一个标准机制,该 API 简单易用。</p></blockquote><p>Serializable 实现序列化  </p><blockquote><p>在 Java 中,只要一个类实现了 java.io.Serializable 接口,那么它就可以被序列化。</p></blockquote><p>ObjectOutputStream 和 ObjectInputStream 对对象进行序列化及反序列化  </p><blockquote><p>通过 ObjectOutputStream 和 ObjectInputStream 对对象进行序列化及反序列化。</p></blockquote><p>writeObject 和 readObject 自定义序列化策略  </p><blockquote><p>在类中增加 writeObject 和 readObject 方法可以实现自定义序列化策略。</p></blockquote><p>序列化 ID  </p><blockquote><p>虚拟机是否允许反序列化,不仅取决于类路径和功能代码是否一致,一个非常重要的一点是两个<br> 类的序列化 ID 是否一致(就是 private static final long serialVersionUID)</p></blockquote><h3 id="序列化并不保存静态变量"><a href="#序列化并不保存静态变量" class="headerlink" title="序列化并不保存静态变量"></a>序列化并不保存静态变量</h3><p>序列化子父类说明  </p><blockquote></blockquote><p>Transient 关键字阻止该变量被序列化到文件中  </p><blockquote><p>1.在变量声明前加上 Transient 关键字,可以阻止该变量被序列化到文件中,在被反序列<br> 化后,transient 变量的值被设为初始值,如 int 型的是 0,对象型的是 null。</p></blockquote><blockquote><p>2.服务器端给客户端发送序列化对象数据,对象中有一些数据是敏感的,比如密码字符串<br> 等,希望对该密码字段在序列化时,进行加密,而客户端如果拥有解密的密钥,只有在<br> 客户端进行反序列化时,才可以对密码进行读取,这样可以一定程度保证序列化对象的<br> 数据安全。</p></blockquote><h1 id="JAVA-复制"><a href="#JAVA-复制" class="headerlink" title="JAVA 复制"></a>JAVA 复制</h1><blockquote><p>将一个对象的引用复制给另外一个对象,一共有三种方式。第一种方式是直接赋值,第二种方式<br> 是浅拷贝,第三种是深拷贝。所以大家知道了哈,这三种概念实际上都是为了拷贝对象。</p></blockquote><p>直接赋值复制  </p><blockquote><p>直接赋值。在 Java 中,A a1 = a2,我们需要理解的是这实际上复制的是引用,也就是<br> 说 a1 和 a2 指向的是同一个对象。因此,当 a1 变化的时候,a2 里面的成员变量也会跟<br> 着变化。</p></blockquote><p>浅复制(复制引用但不复制引用的对象)  </p><blockquote><p>创建一个新对象,然后将当前对象的非静态字段复制到该新对象,如果字段是值类型的,<br> 那么对该字段执行复制;如果该字段是引用类型的话,则复制引用但不复制引用的对象。<br> 因此,原始对象及其副本引用同一个对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Resume</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (Resume)<span class="hljs-keyword">super</span>.clone();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>深复制(复制对象和其应用对象)  </p><blockquote><p>深拷贝不仅复制对象本身，而且复制对象包含的引用指向的所有对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br>    String name;<br>    <span class="hljs-keyword">int</span> age;<br>    Professor p;<br>    Student(String name, <span class="hljs-keyword">int</span> age, Professor p) &#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>        <span class="hljs-keyword">this</span>.p = p;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;<br>        Student o = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            o = (Student) <span class="hljs-keyword">super</span>.clone();<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            System.out.println(e.toString());<br>        &#125;<br>        o.p = (Professor) p.clone();<br>        <span class="hljs-keyword">return</span> o;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>序列化(深 clone 一中实现) </p><blockquote><p>在 Java 语言里深复制一个对象,常常可以先使对象实现 Serializable 接口,然后把对象(实际上只是对象的一个拷贝)写到一个流里,再从流里读出来,便可以重建对象。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu开发环境配置</title>
    <link href="/2020/06/25/linux/Ubuntu%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/06/25/linux/Ubuntu%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h1><p><a href="https://ubuntu.com/download/desktop">镜像下载地址</a></p><blockquote><p>下载后制作成启动盘就可以安装系统了</p></blockquote><h1 id="挂载磁盘"><a href="#挂载磁盘" class="headerlink" title="挂载磁盘"></a>挂载磁盘</h1><blockquote></blockquote><h1 id="常用软件安装"><a href="#常用软件安装" class="headerlink" title="常用软件安装"></a>常用软件安装</h1><h3 id="JetBrains-系列"><a href="#JetBrains-系列" class="headerlink" title="JetBrains 系列"></a>JetBrains 系列</h3><ul><li><a href="">Android Studio</a></li><li><a href="">CLion</a></li><li><a href="">DataGrip</a></li><li><a href="">Intelli IDEA</a></li><li><a href="">GoLand</a></li><li><a href="">Pycharm</a></li><li><a href="">WebStorm</a></li></ul><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><ul><li><a href="">Chrome</a></li><li><a href="">Chromium</a></li><li><a href="">Firefox</a></li></ul><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><ul><li><a href="">Redis Desktop Manager</a></li><li><a href="">Sublime Text</a></li><li><a href="https://sunlogin.oray.com/">Sunlogin Client</a></li><li><a href="">Teamview</a></li><li><a href="">Xmind ZEN</a></li><li><a href="https://www.wps.cn/product/wpslinux">WPS</a></li><li><a href="https://github.com/nashaofu/dingtalk">DingTalk</a></li><li><a href="">Git</a></li><li><a href="">Typora</a></li><li><a href="">Sublime Text</a></li><li><a href="">Htop</a></li><li><a href="">Wireshark</a></li><li></li></ul><h3 id="其他软件"><a href="#其他软件" class="headerlink" title="其他软件"></a>其他软件</h3><ul><li><a href="">多端鼠标共享-synergy</a></li><li><a href="https://github.com/kinget007/electron-ssr">Electron-ssr</a></li><li><a href="">FileZilla</a></li><li><a href="https://github.com/getlantern/lantern">Lantern</a></li><li><a href="">Remmina</a></li><li><a href="">VirtualBox</a></li><li><a href="">网易云音乐</a></li><li><a href="">Sougou输入法</a></li><li><a href="">SimpleScreenRecorder</a></li><li><a href="">Tweaks</a></li><li><a href="">WPS</a></li></ul><h3 id="社交软件"><a href="#社交软件" class="headerlink" title="社交软件"></a>社交软件</h3><ul><li><a href="https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu">QQ</a></li><li><a href="https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu">WeChat</a></li><li><a href="https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu">TIM</a>  </li></ul><p>解决非中文系统中文乱码问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jshelllanguage">在&#x2F;opt&#x2F;deepinwine&#x2F;tools&#x2F;run.sh 和 run_v2.sh 中将 WINE_CMD 那一行修改为 WINE_CMD&#x3D;&quot;LC_ALL&#x3D;zh_CN.UTF-8 deepin-wine&quot;<br></code></pre></td></tr></table></figure><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><ul><li>JDK</li><li>Golang</li><li>Docker</li><li>Nodejs</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库篇-MySQL底层实现机制</title>
    <link href="/2020/06/08/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87-MySQL%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/06/08/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87-MySQL%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>数据库中最常见的慢查询优化方式是什么？</li><li>为什么加索引能优化查询？</li><li>你知道哪些数据结构可以提高查询速度？</li><li>那这些数据结构既然都能优化查询速度，MySQL为什么选择B+TREE</li><li></li></ul><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>数据库存储引擎是数据库底层软件组织,数据库管理系统(DBMS)使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能,使用不同的存储引擎,还可以 获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。存储引擎主要有: 1. MyIsam , 2. InnoDB, 3. Memory, 4. Archive, 5. Federated 。</p><h2 id="InnoDB-B-树"><a href="#InnoDB-B-树" class="headerlink" title="InnoDB( B+树 )"></a>InnoDB( B+树 )</h2><p>InnoDB 底层存储结构为 B+树, B 树的每个节点对应 innodb 的一个 page,page 大小是固定的,一般设为 16k。其中非叶子节点只有键值,叶子节点包含完成数据。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/innodb.png" alt="avatar"></p><p>适用场景:<br>1)经常更新的表,适合处理多重并发的更新请求。<br>2)支持事务。<br>3)可以从灾难中恢复(通过 bin-log 日志等)。<br>4)外键约束。只有他支持外键。<br>5)支持自动增加列属性 auto_increment。</p><h2 id="TokuDB-Fractal-Tree-节点带数据"><a href="#TokuDB-Fractal-Tree-节点带数据" class="headerlink" title="TokuDB( Fractal Tree-节点带数据 )"></a>TokuDB( Fractal Tree-节点带数据 )</h2><p>TokuDB 底层存储结构为 <code>Fractal Tree</code>,<code>Fractal Tree</code> 的结构与 B+树有些类似, 在 Fractal Tree中,每一个 child 指针除了需要指向一个 child 节点外,还会带有一个 Message Buffer ,这个Message Buffer 是一个 FIFO 的队列,用来缓存更新操作。</p><p>例如,一次插入操作只需要落在某节点的 Message Buffer 就可以马上返回了,并不需要搜索到叶子节点。这些缓存的更新会在查询时或后台异步合并应用到对应的节点中。TokuDB 在线添加索引,不影响读写操作, 非常快的写入性能, Fractal-tree 在事务实现上有优势。 他主要适用于访问频率不高的数据或历史数据归档。</p><h2 id="MyIASM"><a href="#MyIASM" class="headerlink" title="MyIASM"></a>MyIASM</h2><p>MyIASM 是 MySQL 默认的引擎,但是它没有提供对数据库事务的支持,也不支持行级锁和外键,因此当 INSERT(插入)或 UPDATE(更新)数据时即写操作需要锁定整个表,效率便会低一些。<br>ISAM 执行读取操作的速度很快,而且不占用大量的内存和存储资源。在设计之初就预想数据组织成有固定长度的记录,按顺序存储的。—ISAM 是一种静态索引结构。缺点是它不 支持事务处理。</p><h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>Memory(也叫 HEAP)堆内存:使用存在内存中的内容来创建表。每个 MEMORY 表只实际对应一个磁盘文件。MEMORY 类型的表访问非常得快,因为它的数据是放在内存中的,并且默认使用HASH 索引。但是一旦服务关闭,表中的数据就会丢失掉。 Memory 同时支持散列索引和 B 树索引,B 树索引可以使用部分查询和通配查询,也可以使用&lt;,&gt;和&gt;=等操作符方便数据挖掘,散列索引相等的比较快但是对于范围的比较慢很多。</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><blockquote><p>索引(Index)是帮助 MySQL 高效获取数据的数据结构。常见的查询算法,<code>顺序查找</code>,<code>二分查找</code>,<code>二叉排序树查找</code>,<code>哈希散列法</code>,<code>分块查找</code>,<code>平衡多路搜索树 B 树(B-tree)</code></p></blockquote><h2 id="常见索引原则有"><a href="#常见索引原则有" class="headerlink" title="常见索引原则有"></a>常见索引原则有</h2><ol><li>选择唯一性索引</li><li>唯一性索引的值是唯一的,可以更快速的通过该索引来确定某条记录。</li><li>为经常需要排序、分组和联合操作的字段建立索引:<br>3 .为常作为查询条件的字段建立索引。<br>4 .限制索引的数目:<br>越多的索引,会使更新表变得很浪费时间。<br>尽量使用数据量少的索引</li><li>如果索引的值很长,那么查询的速度会受到影响。<br>尽量使用前缀来索引</li><li>如果索引字段的值很长,最好使用值的前缀来索引。<br>7 .删除不再使用或者很少使用的索引<br>8 . 最左前缀匹配原则,非常重要的原则。<br>10 . 尽量选择区分度高的列作为索引<br>区分度的公式是表示字段不重复的比例<br>11 . 索引列不能参与计算,保持列“干净”:带函数的查询不参与索引。<br>12 . 尽量的扩展索引,不要新建索引。</li></ol><h2 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h2><p>范式是具有最小冗余的表结构。范式具体如下:</p><p>第一范式(1st NF -列都是不可再分)<br>第一范式的目标是确保每列的原子性:如果每列都是不可再分的最小数据单元(也称为最小的原子单元),则满足第一范式(1NF)</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/1st-nf.png" alt="avatar"></p><p>首先满足第一范式,并且表中非主键列不存在对主键的部分依赖。 第二范式要求每个表只描述一件事情。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/2st-nf.png" alt="avatar"></p><p>第三范式(3rd NF- 不存在对非主键列的传递依赖)<br>第三范式定义是,满足第二范式,并且表中的列不存在对非主键列的传递依赖。除了主键订单编号外,顾客姓名依赖于非主键顾客编号。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/3st-nf.png" alt="avatar"></p><h2 id="数据库是事务"><a href="#数据库是事务" class="headerlink" title="数据库是事务"></a>数据库是事务</h2><blockquote><p>事务(TRANSACTION)是作为单个逻辑工作单元执行的一系列操作,这些操作作为一个整体一起向系统提交,要么都执行、要么都不执行 。事务是一个不可分割的工作逻辑单元事务必须具备以下四个属性,简称 ACID 属性:</p></blockquote><h3 id="原子性-Atomicity"><a href="#原子性-Atomicity" class="headerlink" title="原子性( Atomicity )"></a>原子性( Atomicity )</h3><p>1.事务是一个完整的操作。事务的各步操作是不可分的(原子的);要么都执行,要么都不执行。</p><h3 id="一致性-Consistency"><a href="#一致性-Consistency" class="headerlink" title="一致性( Consistency )"></a>一致性( Consistency )</h3><p>2.当事务完成时,数据必须处于一致状态</p><p>隔离性( Isolation )</p><p>3.对数据进行修改的所有并发事务是彼此隔离的,这表明事务必须是独立的,它不应以任何方式依赖于或影响其他事务。</p><p>永久性( Durability )</p><p>4.事务完成后,它对数据库的修改被永久保持,事务日志能够保持事务的永久性。</p><h1 id="存储过程-特定功能的-SQL-语句集"><a href="#存储过程-特定功能的-SQL-语句集" class="headerlink" title="存储过程(特定功能的 SQL 语句集)"></a>存储过程(特定功能的 SQL 语句集)</h1><blockquote><p>一组为了完成特定功能的 SQL 语句集,存储在数据库中,经过第一次编译后再次调用不需要再次编译,用户通过指定存储过程的名字并给出参数(如果该存储过程带有参数)来执行它。存储过程是数据库中的一个重要对象。</p></blockquote><p>存储过程优化思路:</p><ol><li>尽量利用一些 sql 语句来替代一些小循环,例如聚合函数,求平均函数等。</li><li>中间结果存放于临时表,加索引。</li><li>少使用游标。sql 是个集合语言,对于集合运算具有较高性能。而 cursors 是过程运算。比如对一个 100 万行的数据进行查询。游标需要读表 100 万次,而不使用游标则只需要少量几次读取。</li><li>事务越短越好。sqlserver 支持并发操作。如果事务过多过长,或者隔离级别过高,都会造成并发操作的阻塞,死锁。导致查询极慢,cpu 占用率极地。</li><li>使用 try-catch 处理错误异常。</li><li>查找语句尽量不要放在循环内。</li></ol><h1 id="触发器-一段能自动执行的程序"><a href="#触发器-一段能自动执行的程序" class="headerlink" title="触发器(一段能自动执行的程序)"></a>触发器(一段能自动执行的程序)</h1><blockquote><p>触发器是一段能自动执行的程序,是一种特殊的存储过程,触发器和普通的存储过程的区别是:<br>触发器是当对某一个表进行操作时触发。诸如:update、insert、delete 这些操作的时候,系统<br>会自动调用执行该表上对应的触发器。SQL Server 2005 中触发器可以分为两类:DML 触发器和<br>DDL 触发器,其中 DDL 触发器它们会影响多种数据定义语言语句而激发,这些语句有 create、alter、drop 语句。</p></blockquote><h1 id="数据库并发策略"><a href="#数据库并发策略" class="headerlink" title="数据库并发策略"></a>数据库并发策略</h1><p>并发控制一般采用三种方法,分别是乐观锁和悲观锁以及时间戳。</p><h1 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><p>乐观锁认为一个用户读数据的时候,别人不会去写自己所读的数据;悲观锁就刚好相反,觉得自己读数据库的时候,别人可能刚好在写自己刚读的数据,其实就是持一种比较保守的态度;时间戳就是不加锁,通过时间戳来控制并发出现的问题。</p><h1 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h1><p>悲观锁就是在读取数据的时候,为了不让别人修改自己读取的数据,就会先对自己读取的数据加锁,只有自己把数据读完了,才允许别人修改那部分数据,或者反过来说,就是自己修改某条数据的时候,不允许别人读取该数据,只有等自己的整个事务提交了,才释放自己加上的锁,才允许其他用户访问那部分数据。</p><h1 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h1><p>时间戳就是在数据库表中单独加一列时间戳,比如“TimeStamp”,每次读出来的时候,把该字段也读出来,当写回去的时候,把该字段加 1,提交之前 ,跟数据库的该字段比较一次,如果比数据库的值大的话,就允许保存,否则不允许保存,这种处理方法虽然不使用数据库系统提供的锁机制,但是这种方法可以大大提高数据库处理的并发量,以上悲观锁所说的加“锁”,其实分为几种锁,分别是:排它锁(写锁)和共享锁(读锁)。</p><h1 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h1><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>行级锁是一种排他锁,防止其他事务修改此行;在使用以下语句时,Oracle 会自动应用行级锁:</p><ol><li>INSERT、UPDATE、DELETE、SELECT … FOR UPDATE [OF columns] [WAIT n | NOWAIT];</li><li>SELECT … FOR UPDATE 语句允许用户一次锁定多条记录进行更新</li><li>使用 COMMIT 或 ROLLBACK 语句释放锁。</li></ol><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><blockquote><p>表示对当前操作的整张表加锁,它实现简单,资源消耗较少,被大部分 MySQL 引擎支持。最常使用的 MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁(共享锁)与表独占写锁(排他锁)。</p></blockquote><h2 id="页级锁"><a href="#页级锁" class="headerlink" title="页级锁"></a>页级锁</h2><blockquote><p>页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快,但冲突多,行级冲突少,但速度慢。所以取了折衷的页级,一次锁定相邻的一组记录。BDB 支持页级锁</p></blockquote><p>1.基于 Redis 分布式锁</p><ol><li><p>获取锁的时候,使用 setnx(SETNX key val:当且仅当 key 不存在时,set 一个 key为 val 的字符串,返回 1;若 key 存在,则什么都不做,返回 0)加锁,锁的 value值为一个随机生成的 UUID,在释放锁的时候进行判断。并使用 expire 命令为锁添加一个超时时间,超过该时间则自动释放锁。</p></li><li><p>获取锁的时候调用 setnx,如果返回 0,则该锁正在被别人使用,返回 1 则成功获取锁。 还设置一个获取的超时时间,若超过这个时间则放弃获取锁。</p></li><li><p>释放锁的时候,通过 UUID 判断是不是该锁,若是该锁,则执行 delete 进行锁释放。</p></li></ol><h2 id="分区分表"><a href="#分区分表" class="headerlink" title="分区分表"></a>分区分表</h2><p>分库分表有垂直切分和水平切分两种。</p><h3 id="垂直切分-按照功能模块"><a href="#垂直切分-按照功能模块" class="headerlink" title="垂直切分 ( 按照功能模块 )"></a>垂直切分 ( 按照功能模块 )</h3><p>将表按照功能模块、关系密切程度划分出来,部署到不同的库上。例如,我们会建立定义数据库 workDB、商品数据库 payDB、用户数据库 userDB、日志数据库 logDB 等,分别用于存储项目数据定义表、商品定义表、用户数据表、日志数据表等。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/vertical-partitioning.png" alt="avatar"></p><h3 id="水平切分-按照规则划分存储"><a href="#水平切分-按照规则划分存储" class="headerlink" title="水平切分 ( 按照规则划分存储 )"></a>水平切分 ( 按照规则划分存储 )</h3><p>当一个表中的数据量过大时,我们可以把该表的数据按照某种规则,例如 userID 散列,进行划分,然后存储到多个结构相同的表,和不同的库上。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/horizontal-partitioning.png" alt="avatar"></p><h3 id="两阶段提交协议"><a href="#两阶段提交协议" class="headerlink" title="两阶段提交协议"></a>两阶段提交协议</h3><p>分布式事务是指会涉及到操作多个数据库的事务,在分布式系统中,各个节点之间在物理上相互独立,通过网络进行沟通和协调。</p><p>XA 就是 X/Open DTP 定义的交易中间件与数据库之间的接口规范(即接口函数),交易中间件<br>用它来通知数据库事务的开始、结束以及提交、回滚等。 XA 接口函数由数据库厂商提供。<br>二阶段提交(Two-phaseCommit)是指,在计算机网络以及数据库领域内,为了使基于分布式系统<br>架构下的所有节点在进行事务提交时保持一致性而设计的一种算法(Algorithm)。通常,二阶段提<br>交也被称为是一种协议(Protocol))。在分布式系统中,每个节点虽然可以知晓自己的操作时成功<br>或者失败,却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时,为了保持事<br>务的 ACID 特性,需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并<br>最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。因此,<br>二阶段提交的算法思路可以概括为:参与者将操作成败通知协调者,再由协调者根据所有参与者<br>的反馈情报决定各参与者是否要提交操作还是中止操作。</p><ul><li><p>准备阶段</p><blockquote><p>事务协调者(事务管理器)给每个参与者(资源管理器)发送 Prepare 消息,每个参与者要么直接返回<br>失败(如权限验证失败),要么在本地执行事务,写本地的 redo 和 undo 日志,但不提交,到达一<br>种“万事俱备,只欠东风”的状态。</p></blockquote></li><li><p>提交阶段</p><blockquote><p>如果协调者收到了参与者的失败消息或者超时,直接给每个参与者发送回滚(Rollback)消息;否则,<br>发送提交(Commit)消息;参与者根据协调者的指令执行提交或者回滚操作,释放所有事务处理过<br>程中使用的锁资源。(注意:必须在最后阶段释放锁资源)</p></blockquote></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>同步阻塞问题<br>1、 执行过程中,所有参与节点都是事务阻塞型的。</p><p>单点故障<br>2、 由于协调者的重要性,一旦协调者发生故障。参与者会一直阻塞下去。</p><p>数据不一致(脑裂问题)<br>3、 在二阶段提交的阶段二中,当协调者向参与者发送 commit 请求之后,发生了局部网络异常或者在发送 commit 请求过程中协调者发生了故障,导致只有一部分参与者接受到了commit 请求。于是整个分布式系统便出现了数据部一致性的现象(脑裂现象)。</p><p>二阶段无法解决的问题(数据状态不确定)<br>4、 协调者再发出 commit 消息之后宕机,而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者,这条事务的状态也是不确定的,没人知道事务是否被已经提交。</p><p>三阶段提交协议</p><p>三 阶 段 提 交 ( Three-phase commit ) , 也 叫 三 阶 段 提 交 协 议 ( Three-phase commit protocol),是二阶段提交(2PC)的改进版本。</p><p>与两阶段提交不同的是,三阶段提交有两个改动点。</p><p>1、引入超时机制。同时在协调者和参与者中都引入超时机制。<br>2、在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。也就是说,除了引入超时机制之外,3PC 把 2PC 的准备阶段再次一分为二,这样三阶段提交就有 CanCommit、PreCommit、DoCommit 三个阶段。</p><h2 id="CanCommit-阶段"><a href="#CanCommit-阶段" class="headerlink" title="CanCommit 阶段"></a>CanCommit 阶段</h2><p>协调者向参与者发送 commit 请求,参与者如果可以提交就返回 Yes 响应,否则返回 No 响应。</p><h2 id="PreCommit-阶段"><a href="#PreCommit-阶段" class="headerlink" title="PreCommit 阶段"></a>PreCommit 阶段</h2><p>协调者根据参与者的反应情况来决定是否可以继续进行,有以下两种可能。假如协调者从所有的参与者获得的反馈都是 Yes 响应,那么就会执行事务的预执行假如有任何一个参与者向协调者发送了 No 响应,或者等待超时之后,协调者都没有接到参与者的响应,那么就执行事务的中断。</p><h2 id="doCommit-阶段"><a href="#doCommit-阶段" class="headerlink" title="doCommit 阶段"></a>doCommit 阶段</h2><p>该阶段进行真正的事务提交,主要包含 1.协调这发送提交请求 2.参与者提交事务 3.参与者响应反馈( 事务提交完之后,向协调者发送 Ack 响应。)4.协调者确定完成事务。</p><h2 id="柔性事务"><a href="#柔性事务" class="headerlink" title="柔性事务"></a>柔性事务</h2><blockquote><p>在电商领域等互联网场景下,传统的事务在数据库性能和处理能力上都暴露出了瓶颈。在分布式领域基于 CAP 理论以及 BASE 理论,有人就提出了 柔性事务 的概念。CAP(一致性、可用性、分区容忍性)理论大家都理解很多次了,这里不再叙述。说一下 BASE 理论,它是在 CAP 理论的基础之上的延伸。包括 基本可用(Basically Available)、柔性状态(Soft State)、最终一致性(Eventual Consistency)。</p></blockquote><p>通常所说的柔性事务分为:两阶段型、补偿型、异步确保型、最大努力通知型几种。</p><p>两阶段型<br>1、 就是分布式事务两阶段提交,对应技术上的 XA、JTA/JTS。这是分布式环境下事务处理的</p><p>典型模式。<br>补偿型<br>2、 TCC 型事务(Try/Confirm/Cancel)可以归为补偿型。</p><p>WS-BusinessActivity 提供了一种基于补偿的 long-running 的事务处理模型。服务器 A 发起事务,服务器 B 参与事务,服务器 A 的事务如果执行顺利,那么事务 A 就先行提交,如果事务 B 也执行顺利,则事务 B 也提交,整个事务就算完成。但是如果事务 B 执行失败,事务 B 本身回滚,这时事务 A 已经被提交,所以需要执行一个补偿操作,将已经提交的事务 A 执行的操作作反操作,恢复到未执行前事务 A 的状态。这样的 SAGA 事务模型,是牺牲了一定的隔离性和一致性的,但是提高了 long-running 事务的可用性。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/soft-transcation.png" alt="avatar"></p><p>异步确保型<br>3、 通过将一系列同步的事务操作变为基于消息执行的异步操作, 避免了分布式事务中的同步阻塞操作的影响。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/async-sure.png" alt="avatar"></p><p>最大努力通知型(多次尝试)<br>4、 这是分布式事务中要求最低的一种, 也可以通过消息中间件实现, 与前面异步确保型操作不同的一点是, 在消息由 MQ Server 投递到消费者之后, 允许在达到最大重试次数之后正常结束事务。</p><h1 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h1><p>CAP 原则又称 CAP 定理,指的是在一个分布式系统中, Consistency(一致性)、 Availability(可用性)、Partition tolerance(分区容错性),三者不可得兼。</p><h2 id="一致性-C"><a href="#一致性-C" class="headerlink" title="一致性(C):"></a>一致性(C):</h2><p>1.在分布式系统中的所有数据备份,在同一时刻是否同样的值。(等同于所有节点访问同一份最新的数据副本)</p><h2 id="可用性-A"><a href="#可用性-A" class="headerlink" title="可用性(A):"></a>可用性(A):</h2><p>2.在集群中一部分节点故障后,集群整体是否还能响应客户端的读写请求。(对数据更新具备高可用性)</p><h2 id="分区容忍性-P"><a href="#分区容忍性-P" class="headerlink" title="分区容忍性(P) :"></a>分区容忍性(P) :</h2><p>3.以实际效果而言,分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性,就意味着发生了分区的情况,必须就当前操作在 C 和 A 之间做出选择。</p><h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><ul><li><p><a href="https://www.bilibili.com/video/BV1Ez411B7X2/">视频</a></p></li><li><p><a href="https://my.oschina.net/u/585635/blog/4547089">Mysql Explain 详解</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA 多线程并发</title>
    <link href="/2020/05/30/java/JAVA-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/"/>
    <url>/2020/05/30/java/JAVA-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Java-并发知识库"><a href="#Java-并发知识库" class="headerlink" title="Java 并发知识库"></a>Java 并发知识库</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/thread.png" alt="avatar"></p><h1 id="Java线程实现-创建方式"><a href="#Java线程实现-创建方式" class="headerlink" title="Java线程实现/创建方式"></a>Java线程实现/创建方式</h1><h2 id="继承Thread"><a href="#继承Thread" class="headerlink" title="继承Thread"></a>继承Thread</h2><blockquote><p>Thread类本质上是实现了<code>Runnable</code>接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过<code>Thread</code>类的<code>start</code>实例方法。start方法是一个native方法，它将启动一个新的线程，并执行run()方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MyThread.run()&quot;</span>);<br>    &#125;<br>&#125;<br><br>MyThread myThread = <span class="hljs-keyword">new</span> MyThread();<br><br>myThread.start();<br></code></pre></td></tr></table></figure><h2 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h2><blockquote><p>实现Runnable接口</p></blockquote><p>如果自己的类已经extends另一个类，就无法直接extends Thread此时，可以实现一个Runnable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OtherClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span> <span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MyThread.run()&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//启动 MyThread,需要首先实例化一个 Thread,并传入自己的 MyThread 实例:</span><br><br>MyThread myThread = <span class="hljs-keyword">new</span> MyThread();<br>Thread thread = <span class="hljs-keyword">new</span> Thread(myThread);<br>thread.start();<br><br><span class="hljs-comment">//事实上,当传入一个 Runnable target 参数给 Thread 后,Thread 的 run()方法就会调用</span><br>target.run()<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span>) &#123;<br>        target.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="执行器方式"><a href="#执行器方式" class="headerlink" title="执行器方式"></a>执行器方式</h2><blockquote><p>有返回值的任务必须实现 Callable 接口,类似的,无返回值的任务必须 Runnable 接口。执行Callable 任务后,可以获取一个 Future 的对象,在该对象上调用 get 就可以获取到 Callable 任务返回的 Object 了,再结合线程池接口 ExecutorService 就可以实现传说中有返回结果的多线程了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建一个线程池</span><br>ExecutorService pool = Executors.newFixedThreadPool(taskSize);<br><span class="hljs-comment">// 创建多个有返回值的任务</span><br>List&lt;Future&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Future&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; taskSize; i++) &#123;<br>Callable c = <span class="hljs-keyword">new</span> MyCallable(i + <span class="hljs-string">&quot; &quot;</span>);<br><span class="hljs-comment">// 执行任务并获取 Future 对象</span><br>Future f = pool.submit(c);<br>list.add(f);<br>&#125;<br><span class="hljs-comment">// 关闭线程池</span><br>pool.shutdown();<br><span class="hljs-comment">// 获取所有并发任务的运行结果</span><br><span class="hljs-keyword">for</span> (Future f : list) &#123;<br><span class="hljs-comment">// 从 Future 对象上获取任务的返回值,并输出到控制台</span><br>System.out.println(<span class="hljs-string">&quot;res:&quot;</span> + f.get().toString());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程池方式"><a href="#线程池方式" class="headerlink" title="线程池方式"></a>线程池方式</h2><blockquote><p>线程和数据库连接这些资源都是非常宝贵的资源。那么每次需要的时候创建,不需要的时候销毁,是非常浪费资源的。那么我们就可以使用缓存的策略,也就是使用线程池。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建线程池</span><br>ExecutorService threadPool = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>    threadPool.execute(<span class="hljs-keyword">new</span> Runnable() &#123; <span class="hljs-comment">// 提交多个线程任务,并执行</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; is running ..&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>       &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4种线程池"><a href="#4种线程池" class="headerlink" title="4种线程池"></a>4种线程池</h3><blockquote><p>Java 里面线程池的顶级接口是 Executor,但是严格意义上讲 Executor 并不是一个线程池,而只是一个执行线程的工具。真正的线程池接口是 ExecutorService。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/threadpool.png" alt="avatar"></p><ul><li>NewCachedThreadPool<blockquote><p>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用他们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能<br><code>调用 execute 将重用以前构造 的线程(如果线程可用)。如果现有线程没有可用的,则创建一个新线程并添加到池中。终止并 从缓存中移除那些已有 60 秒钟未被使用的线程。</code>因此,长时间保持空闲的线程池不会使用任何资源。</p></blockquote></li></ul><ul><li>newFixedThreadPool</li></ul><blockquote><p>创建一个可重用固定线程数的线程池,以共享的无界队列方式来运行这些线程。在任意点,在大<br> 多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务,<br> 则在有可用线程之前,附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何<br> 线程终止,那么一个新线程将代替它执行后续的任务(如果需要)。在某个线程被显式地关闭之<br> 前,池中的线程将一直存在。</p></blockquote><ul><li>newScheduledThreadPool</li></ul><blockquote><p>创建一个线程池,它可安排在给定延迟后运行命令或者定期地执行。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPool</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        ScheduledExecutorService scheduledThreadPool= Executors.newScheduledThreadPool(<span class="hljs-number">3</span>);<br>        scheduledThreadPool.schedule(<span class="hljs-keyword">new</span> Runnable()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;延迟三秒&quot;</span>);<br>            &#125;<br>        &#125;, <span class="hljs-number">3</span>, TimeUnit.SECONDS);<br>        scheduledThreadPool.scheduleAtFixedRate(<span class="hljs-keyword">new</span> Runnable()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;延迟 1 秒后每三秒执行一次&quot;</span>);<br>            &#125;<br>        &#125;,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,TimeUnit.SECONDS);<br><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>newSingleThreadExecutor</li></ul><blockquote><p>Executors.newSingleThreadExecutor()返回一个线程池(这个线程池只有一个线程),这个线程池可以在线程死后(或发生异常时)重新启动一个线程来替代原来的线程继续执行下去!</p></blockquote><h1 id="线程生命周期-状态"><a href="#线程生命周期-状态" class="headerlink" title="线程生命周期(状态)"></a>线程生命周期(状态)</h1><blockquote><p>当线程被创建并启动以后,它既不是一启动就进入了执行状态,也不是一直处于执行状态。在线程的生命周期中,它要经过新建(New)、就绪(Runnable)、运行(Running)、阻塞(Blocked)和死亡(Dead)5 种状态。尤其是当线程启动以后,它不可能一直”霸占”着 CPU 独自运行,所以 CPU 需要在多条线程之间切换,于是线程状态也会多次在运行、阻塞之间切换</p></blockquote><ul><li><p>新建状态(NEW)<br>当程序使用 new 关键字创建了一个线程之后,该线程就处于新建状态,此时仅由 JVM 为其分配<br>内存,并初始化其成员变量的值</p></li><li><p>就绪状态(RUNNABLE):<br>当线程对象调用了 start()方法之后,该线程处于就绪状态。Java 虚拟机会为其创建方法调用栈和<br>程序计数器,等待调度运行。</p></li><li><p>运行状态(RUNNING):<br>如果处于就绪状态的线程获得了 CPU,开始执行 run()方法的线程执行体,则该线程处于运行状<br>态。</p></li><li><p>阻塞状态(BLOCKED):<br>阻塞状态是指线程因为某种原因放弃了 cpu 使用权,也即让出了 cpu timeslice,暂时停止运行。<br>直到线程进入可运行(runnable)状态,才有机会再次获得 cpu timeslice 转到运行(running)状<br>态。阻塞的情况分三种:</p><ul><li>等待阻塞( o.wait-&gt; 等待对列):<br>   运行(running)的线程执行 o.wait()方法,JVM 会把该线程放入等待队列(waitting queue)中。</li><li>同步阻塞 (lock-&gt; 锁池 )<br>   运行(running)的线程在获取对象的同步锁时,若该同步锁被别的线程占用,则 JVM 会把该线</li><li>程放入锁池(lock pool)中。</li></ul><p>其他阻塞 (sleep/join)</p><pre><code> - 运行(running)的线程执行 Thread.sleep(long ms)或 t.join()方法,或者发出了 I/O 请求时,JVM 会把该线程置为阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O处理完毕时,线程重新转入可运行(runnable)状态。</code></pre></li><li><p>线程死亡(DEAD)<br>线程会以下面三种方式结束,结束后就是死亡状态。</p><p><em>正常结束</em>  </p><blockquote><p>1.run()或 call()方法执行完成,线程正常结束。</p></blockquote><p><em>异常结束</em></p><blockquote><p>2.线程抛出一个未捕获的 Exception 或 Error。</p></blockquote><p><em>调用 stop</em></p><blockquote><p>3.直接调用该线程的 stop()方法来结束该线程—该方法通常容易导致死锁,不推荐使用。</p></blockquote></li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/QQ%E5%9B%BE%E7%89%8720200610172044.png" alt="avatar"></p><h2 id="终止线程-4-种方式"><a href="#终止线程-4-种方式" class="headerlink" title="终止线程 4 种方式"></a>终止线程 4 种方式</h2><ul><li><p>正常运行结束</p><blockquote><p>程序运行结束,线程自动结束。</p></blockquote></li><li><p>使用退出标志退出线程</p><blockquote><p>一般 run()方法执行完,线程就会正常结束,然而,常常有些线程是伺服线程。它们需要长时间的运行,只有在外部某些条件满足的情况下,才能关闭这些线程。使用一个变量来控制循环,例如:最直接的方法就是设一个 boolean 类型的标志,并通过设置这个标志为 true 或 false 来控制 while<br>循环是否退出,代码示例:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafe</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> exit = <span class="hljs-keyword">false</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (!exit)&#123;<br>            <span class="hljs-comment">//do something</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>定义了一个退出标志 exit,当 exit 为 true 时,while 循环退出,exit 的默认值为 false.在定义 exit<br>时,使用了一个 Java 关键字 volatile,这个关键字的目的是使 exit 同步,也就是说在同一时刻只<br>能由一个线程来修改 exit 的值。</p><ul><li>Interrupt 方法结束线程<blockquote><p>使用 interrupt()方法来中断线程有两种情况:</p></blockquote></li></ul><p> 1.线程处于阻塞状态:如使用了 sleep,同步锁的 wait,socket 中的 receiver,accept 等方法时,<br> 会使线程处于阻塞状态。当调用线程的 interrupt()方法时,会抛出 InterruptException 异常。<br> 阻塞中的那个方法抛出这个异常,通过代码捕获该异常,然后 break 跳出循环状态,从而让<br> 我们有机会结束这个线程的执行。通常很多人认为只要调用 interrupt 方法线程就会结束,实<br> 际上是错的, 一定要先捕获 InterruptedException 异常之后通过 break 来跳出循环,才能正<br> 常结束 run 方法。</p><p> 2.线程未处于阻塞状态:使用 isInterrupted()判断线程的中断标志来退出循环。当使用<br> interrupt()方法时,中断标志就会置 true,和使用自定义的标志来控制循环是一样的道理。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafe</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (!isInterrupted())&#123; <span class="hljs-comment">//非阻塞过程中通过判断中断标志来退出</span><br>            <span class="hljs-keyword">try</span>&#123;<br>                Thread.sleep(<span class="hljs-number">5</span>*<span class="hljs-number">1000</span>);<span class="hljs-comment">//阻塞过程捕获中断异常来退出</span><br>            &#125;<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>                e.printStackTrace();<br>                <span class="hljs-keyword">break</span>;<span class="hljs-comment">//捕获到异常之后,执行 break 跳出循环</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>stop 方法终止线程(线程不安全)</p><blockquote><p>程序中可以直接使用 thread.stop()来强行终止线程,但是 stop 方法是很危险的,就象突然关<br>闭计算机电源,而不是按正常程序关机一样,可能会产生不可预料的结果,不安全主要是:<br>thread.stop()调用之后,创建子线程的线程就会抛出 ThreadDeatherror 的错误,并且会释放子<br>线程所持有的所有锁。一般任何进行加锁的代码块,都是为了保护数据的一致性,如果在<code>调用 thread.stop()后导致了该线程所持有的所有锁的突然释放(不可控制)</code>,那么被保护数据就有可能呈<br>现不一致性,其他线程在使用这些被破坏的数据时,有可能导致一些很奇怪的应用程序错误。因<br>此,并不推荐使用 stop 方法来终止线程。</p></blockquote></li></ul><h2 id="sleep-与-wait-区别"><a href="#sleep-与-wait-区别" class="headerlink" title="sleep 与 wait 区别"></a>sleep 与 wait 区别</h2><p> 1.对于 sleep()方法,我们首先要知道该方法是属于 Thread 类中的。而 wait()方法,则是属于Object 类中的。<br> 2.sleep()方法导致了程序暂停执行指定的时间,让出 cpu 该其他线程,但是他的监控状态依然保持者,当指定的时间到了又会自动恢复运行状态。<br> 3. 在调用 sleep()方法的过程中,线程不会释放对象锁。<br> 4. 而当调用 wait()方法的时候,线程会放弃对象锁,进入等待此对象的等待锁定池,只有针对此对象调用 notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。  </p><h2 id="start-与-run-区别"><a href="#start-与-run-区别" class="headerlink" title="start 与 run 区别"></a>start 与 run 区别</h2><p> 1.start()方法来启动线程,真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕,可以直接继续执行下面的代码。<br> 2.通过调用 Thread 类的 start()方法来启动一个线程, 这时此线程是处于就绪状态, 并没有运行。<br> 3.方法 run()称为线程体,它包含了要执行的这个线程的内容,线程就进入了运行状态,开始运行 run 函数当中的代码。 Run 方法运行结束, 此线程终止。然后 CPU 再调度其它线程。</p><h2 id="JAVA-后台线程"><a href="#JAVA-后台线程" class="headerlink" title="JAVA 后台线程"></a>JAVA 后台线程</h2><p>1.定义:守护线程–也称“服务线程”,他是后台线程,它有一个特性,即为用户线程 提供 公共服务,在没有用户线程可服务时会自动离开。  </p><p>2.优先级:守护线程的优先级比较低,用于为系统中的其它对象和线程提供服务。  </p><p>3.设置:通过 setDaemon(true)来设置线程为“守护线程”;将一个用户线程设置为守护线程的方式是在 线程对象创建 之前 用线程对象的 setDaemon 方法。  </p><p>4.在 Daemon 线程中产生的新线程也是 Daemon 的。</p><p>5.线程则是 JVM 级别的,以 Tomcat 为例,如果你在 Web 应用中启动一个线程,这个线程的生命周期并不会和 Web 应用程序保持同步。也就是说,即使你停止了 Web 应用,这个线程依旧是活跃的。  </p><p>6.example: 垃圾回收线程就是一个经典的守护线程,当我们的程序中不再有任何运行的 Thread,程序就不会再产生垃圾,垃圾回收器也就无事可做,所以当垃圾回收线程是 JVM 上仅剩的线程时,垃圾回收线程会自动离开。它始终在低级别的状态中运行,用于实时监控和管理系统中的可回收资源。</p><p>7.生命周期:守护进程(Daemon)是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端,但是依赖于系统,与系统“同生共死”。当 JVM 中所有的线程都是守护线程的时候,JVM 就可以退出了;如果还有一个或以上的非守护线程则 JVM 不会退出。  </p><h1 id="JAVA-锁"><a href="#JAVA-锁" class="headerlink" title="JAVA 锁"></a>JAVA 锁</h1><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><blockquote><p>乐观锁是一种乐观思想,即认为读多写少,遇到并发写的可能性低,每次去拿数据的时候都认为别人不会修改,所以不会上锁,但是在更新的时候会判断一下在此期间别人有没有去更新这个数据,<br>采取在写时先读出当前版本号,然后加锁操作(比较跟上一次的版本号,如果一样则更新),如果失败则要重复读-比较-写的操作。java 中的乐观锁基本都是通过 CAS 操作实现的,CAS 是一种更新的原子操作,<br>比较当前值跟传入值是否一样,一样则更新,否则失败。</p></blockquote><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><blockquote><p>悲观锁是就是悲观思想,即认为写多,遇到并发写的可能性高,每次去拿数据的时候都认为别人<br> 会修改,所以每次在读写数据的时候都会上锁,这样别人想读写这个数据就会 block 直到拿到锁。<br> java 中的悲观锁就是 Synchronized,AQS 框架下的锁则是先尝试 cas 乐观锁去获取锁,获取不到,<br> 才会转换为悲观锁,如 RetreenLock。</p></blockquote><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><blockquote><p>自旋锁原理非常简单,如果持有锁的线程能在很短时间内释放锁资源,那么那些等待竞争锁<br> 的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态,它们只需要等一等(自旋),<br> 等持有锁的线程释放锁后即可立即获取锁,这样就避免用户线程和内核的切换的消耗。<br> 线程自旋是需要消耗 cup 的,说白了就是让 cup 在做无用功,如果一直获取不到锁,那线程<br> 也不能一直占用 cup 自旋做无用功,所以需要设定一个自旋等待的最大时间。<br> 如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁,就会导致其它争用锁<br> 的线程在最大等待时间内还是获取不到锁,这时争用线程会停止自旋进入阻塞状态。</p></blockquote><p> 自旋锁的优缺点</p><blockquote><p>自旋锁尽可能的减少线程的阻塞,这对于锁的竞争不激烈,且占用锁时间非常短的代码块来<br> 说性能能大幅度的提升,因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗,这些操作会<br> 导致线程发生两次上下文切换!<br> 但是如果锁的竞争激烈,或者持有锁的线程需要长时间占用锁执行同步块,这时候就不适合<br> 使用自旋锁了,因为自旋锁在获取锁前一直都是占用 cpu 做无用功,占着 XX 不 XX,同时有大量<br> 线程在竞争一个锁,会导致获取锁的时间很长,线程自旋的消耗大于线程阻塞挂起操作的消耗,<br> 其它需要 cup 的线程又不能获取到 cpu,造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁;</p></blockquote><p> 自旋锁时间阈值 ( 1.6 引入了适应性自旋锁)</p><blockquote><p>自旋锁的目的是为了占着 CPU 的资源不释放,等到获取到锁立即进行处理。但是如何去选择<br> 自旋的执行时间呢?如果自旋执行时间太长,会有大量的线程处于自旋状态占用 CPU 资源,进而<br> 会影响整体系统的性能。因此自旋的周期选的额外重要!JVM 对于自旋周期的选择,jdk1.5 这个限度是一定的写死的,在 1.6 引入了适应性自旋锁,适应<br> 性自旋锁意味着自旋的时间不在是固定的了,而是由前一次在同一个锁上的自旋时间以及锁的拥<br> 有者的状态来决定,基本认为一个线程上下文切换的时间是最佳的一个时间,同时 JVM 还针对当<br> 前 CPU 的负荷情况做了较多的优化,如果平均负载小于 CPUs 则一直自旋,如果有超过(CPUs/2)<br> 个线程正在自旋,则后来线程直接阻塞,如果正在自旋的线程发现 Owner 发生了变化则延迟自旋<br> 时间(自旋计数)或进入阻塞,如果 CPU 处于节电模式则停止自旋,自旋时间的最坏情况是 CPU<br> 的存储延迟(CPU A 存储了一个数据,到 CPU B 得知这个数据直接的时间差),自旋时会适当放<br> 弃线程优先级之间的差异。<br> 自旋锁的开启<br> JDK1.6 中-XX:+UseSpinning 开启;<br> <code>-XX:PreBlockSpin=10</code> 为自旋次数;<br> JDK1.7 后,去掉此参数,由 jvm 控制;</p></blockquote><h3 id="Synchronized-同步锁"><a href="#Synchronized-同步锁" class="headerlink" title="Synchronized 同步锁"></a>Synchronized 同步锁</h3><p>synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁,同时属于可重入锁。</p><p><strong>Synchronized 作用范围</strong><br>1.作用于方法时,锁住的是对象的实例(this);<br>2.当作用于静态方法时,锁住的是 Class 实例,又因为 Class 的相关数据存储在永久带 PermGen(jdk1.8 则是 metaspace),永久带是全局共享的,因此静态方法锁相当于类的一个全局锁,会锁所有调用该方法的线程;<br>3.synchronized 作用于一个对象实例时,锁住的是所有以该对象为锁的代码块。它有多个队列,当多个线程一起访问某个对象监视器的时候,对象监视器会将这些线程存储在不同的容器中。</p><p><strong>Synchronized 核心组件</strong></p><ol><li>Wait Set:哪些调用 wait 方法被阻塞的线程被放置在这里;</li><li>Contention List:竞争队列,所有请求锁的线程首先被放在这个竞争队列中;</li><li>Entry List:Contention List 中那些有资格成为候选资源的线程被移动到 Entry List 中;</li><li>OnDeck:任意时刻,最多只有一个线程正在竞争锁资源,该线程被成为 OnDeck;</li><li>Owner:当前已经获取到所资源的线程被称为 Owner;</li><li>!Owner:当前释放锁的线程。</li></ol><p><strong>Synchronized 实现</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/synchronized.png" alt="avatar"></p><blockquote><p>1.JVM 每次从队列的尾部取出一个数据用于锁竞争候选者(OnDeck),但是并发情况下,<br>ContentionList 会被大量的并发线程进行 CAS 访问,为了降低对尾部元素的竞争,JVM 会将<br>一部分线程移动到 EntryList 中作为候选竞争线程。</p></blockquote><blockquote><p>2.Owner 线程会在 unlock 时,将 ContentionList 中的部分线程迁移到 EntryList 中,并指定<br>EntryList 中的某个线程为 OnDeck 线程(一般是最先进去的那个线程)。</p></blockquote><blockquote><p>3.Owner 线程并不直接把锁传递给 OnDeck 线程,而是把锁竞争的权利交给 OnDeck,<br>OnDeck 需要重新竞争锁。这样虽然牺牲了一些公平性,但是能极大的提升系统的吞吐量,在<br>JVM 中,也把这种选择行为称之为“竞争切换”。</p></blockquote><blockquote><p>4.OnDeck 线程获取到锁资源后会变为 Owner 线程,而没有得到锁资源的仍然停留在 EntryList<br>中。如果 Owner 线程被 wait 方法阻塞,则转移到 WaitSet 队列中,直到某个时刻通过 notify<br>或者 notifyAll 唤醒,会重新进去 EntryList 中。</p></blockquote><blockquote><p>5.处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态,该阻塞是由操作系统<br>来完成的(Linux 内核下采用 pthread_mutex_lock 内核函数实现的)。</p></blockquote><blockquote><p>6.Synchronized 是非公平锁。 Synchronized 在线程进入 ContentionList 时,等待的线程会先<br>尝试自旋获取锁,如果获取不到就进入 ContentionList,这明显对于已经进入队列的线程是<br>不公平的,还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁<br>资源。<a href="https://blog.csdn.net/zqz_zqz/article/details/70233767">参考</a></p></blockquote><blockquote><p>7.每个对象都有个 monitor 对象,加锁就是在竞争 monitor 对象,代码块加锁是在前后分别加<br>上 monitorenter 和 monitorexit 指令来实现的,方法加锁是通过一个标记位来判断的</p></blockquote><blockquote><p>8.synchronized 是一个重量级操作,需要调用操作系统相关接口,性能是低效的,有可能给线程加锁消耗的时间比有用操作消耗的时间更多。</p></blockquote><blockquote><p>9.Java1.6,synchronized 进行了很多的优化,有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等,效率有了本质上的提高。在之后推出的 Java1.7 与 1.8 中,均对该关键字的实现机理做<br>了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位,不需要经过操作系统加锁。</p></blockquote><blockquote><p>10.锁可以从偏向锁升级到轻量级锁,再升级到重量级锁。这种升级过程叫做锁膨胀;</p></blockquote><blockquote><p>11.JDK 1.6 中默认是开启偏向锁和轻量级锁,可以通过<code>-XX:-UseBiasedLocking</code> 来禁用偏向锁。</p></blockquote><h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><blockquote><p>ReentantLock 继承接口 Lock 并实现了接口中定义的方法,他是一种可重入锁,除了能完成 synchronized 所能完成的所有工作外,还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。</p></blockquote><h3 id="Lock-接口的主要方法"><a href="#Lock-接口的主要方法" class="headerlink" title="Lock 接口的主要方法"></a>Lock 接口的主要方法</h3> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs text">void lock(): 执行此方法时, 如果锁处于空闲状态, 当前线程将获取到锁. 相反, 如果锁已经被其他线程持有, 将禁用当前线程, 直到当前线程获取到锁.<br>boolean tryLock():如果锁可用, 则获取锁, 并立即返回 true, 否则返回 false. 该方法和lock()的区别在于, tryLock()只是&quot;试图&quot;获取锁, 如果锁不可用, 不会导致当前线程被禁用,当前线程仍然继续往下执行代码. 而 lock()方法则是一定要获取到锁, 如果锁不可用, 就一直等待, 在未获得锁之前,当前线程并不继续向下执行.<br>void unlock():执行此方法时, 当前线程将释放持有的锁. 锁只能由持有者释放, 如果线程并不持有锁, 却执行该方法, 可能导致异常的发生.<br>Condition newCondition():条件对象,获取等待通知组件。该组件和当前的锁绑定,当前线程只有获取了锁,才能调用该组件的 await()方法,而调用后,当前线程将缩放锁。<br>getHoldCount() :查询当前线程保持此锁的次数,也就是执行此线程执行 lock 方法的次数。<br>getQueueLength():返回正等待获取此锁的线程估计数,比如启动 10 个线程,1 个线程获得锁,此时返回的是 9<br>getWaitQueueLength:(Condition condition)返回等待与此锁相关的给定条件的线程估计数。比如 10 个线程,用同一个 condition 对象,并且此时这 10 个线程都执行了condition 对象的 await 方法,那么此时执行此方法返回 10<br>hasWaiters(Condition condition) : 查 询 是 否 有 线 程 等 待 与 此 锁 有 关 的 给 定 条 件(condition),对于指定 contidion 对象,有多少线程执行了 condition.await 方法<br>hasQueuedThread(Thread thread):查询给定线程是否等待获取此锁<br>hasQueuedThreads():是否有线程等待此锁<br>isFair():该锁是否公平锁<br>isHeldByCurrentThread(): 当前线程是否保持锁锁定,线程的执行 lock 方法的前后分别是 false 和 true<br>isLock():此锁是否有任意线程占用<br>lockInterruptibly():如果当前线程未被中断,获取锁<br>tryLock():尝试获得锁,仅在调用时锁未被线程占用,获得锁<br>tryLock(long timeout TimeUnit unit):如果锁在给定等待时间内没有被另一个线程保持,则获取该锁。<br></code></pre></td></tr></table></figure><h1 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h1><p>JVM 按随机、就近原则分配锁的机制则称为不公平锁,ReentrantLock 在构造函数中提供了是否公平锁的初始化方式,默认为非公平锁。非公平锁实际执行的效率要远远超出公平锁,除非程序有特殊需要,否则最常用非公平锁的分配机制。</p><h1 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h1><p>公平锁指的是锁的分配机制是公平的,通常先对锁提出获取请求的线程会先被分配到锁,ReentrantLock 在构造函数中提供了是否公平锁的初始化方式来定义公平锁。</p><h1 id="ReentrantLock-与-synchronized"><a href="#ReentrantLock-与-synchronized" class="headerlink" title="ReentrantLock 与 synchronized"></a>ReentrantLock 与 synchronized</h1><p>1.ReentrantLock 通过方法 lock()与 unlock()来进行加锁与解锁操作,与 synchronized 会被 JVM 自动解锁机制不同,ReentrantLock 加锁后需要手动进行解锁。为了避免程序出现异常而无法正常解锁的情况,使用 ReentrantLock 必须在 finally 控制块中进行解锁操作。<br>2.ReentrantLock 相比 synchronized 的优势是可中断、公平锁、多个锁。这种情况下需要使用 ReentrantLock。</p><p>ReentrantLock 实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyService</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-comment">//Lock lock=new ReentrantLock(true);//公平锁</span><br>    <span class="hljs-comment">//Lock lock=new ReentrantLock(false);//非公平锁</span><br>    <span class="hljs-keyword">private</span> Condition condition = lock.newCondition();<span class="hljs-comment">//创建 Condition</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            lock.lock();<span class="hljs-comment">//lock 加锁</span><br>            <span class="hljs-comment">//1:wait 方法等待:</span><br>            <span class="hljs-comment">//System.out.println(&quot;开始 wait&quot;);</span><br>            condition.await();<br>            <span class="hljs-comment">//通过创建 Condition 对象来使线程 wait,必须先执行 lock.lock 方法获得锁</span><br>            <span class="hljs-comment">//:2:signal 方法唤醒</span><br>            condition.signal();<span class="hljs-comment">//condition 对象的 signal 方法可以唤醒 wait 线程</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                System.out.println(<span class="hljs-string">&quot;ThreadName=&quot;</span> + Thread.currentThread().getName() + (<span class="hljs-string">&quot; &quot;</span> + (i + <span class="hljs-number">1</span>)));<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Condition-类和-Object-类锁方法区别区别"><a href="#Condition-类和-Object-类锁方法区别区别" class="headerlink" title="Condition 类和 Object 类锁方法区别区别"></a>Condition 类和 Object 类锁方法区别区别</h2><ol><li>Condition 类的 awiat 方法和 Object 类的 wait 方法等效</li><li>Condition 类的 signal 方法和 Object 类的 notify 方法等效</li><li>Condition 类的 signalAll 方法和 Object 类的 notifyAll 方法等效</li><li>ReentrantLock 类可以唤醒指定条件的线程,而 object 的唤醒是随机的</li></ol><h2 id="tryLock-和-lock-和-lockInterruptibly-的区别"><a href="#tryLock-和-lock-和-lockInterruptibly-的区别" class="headerlink" title="tryLock 和 lock 和 lockInterruptibly 的区别"></a>tryLock 和 lock 和 lockInterruptibly 的区别</h2><p>1.tryLock 能获得锁就返回 true,不能就立即返回 false,tryLock(long timeout,TimeUnitunit),可以增加时间限制,如果超过该时间段还没获得锁,返回 false<br>2. lock 能获得锁就返回 true,不能的话一直等待获得锁<br>3. lock 和 lockInterruptibly,如果两个线程分别执行这两个方法,但此时中断这两个线程,lock 不会抛出异常,而 lockInterruptibly 会抛出异常。</p><h1 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore 信号量"></a>Semaphore 信号量</h1><p>Semaphore 是一种基于计数的信号量。它可以设定一个阈值,基于此,多个线程竞争获取许可信号,做完自己的申请后归还,超过阈值后,线程申请许可信号将会被阻塞。Semaphore 可以用来构建一些对象池,资源池之类的,比如数据库连接池实现互斥锁(计数器为 1 )<br>我们也可以创建计数为 1 的 Semaphore,将其作为一种类似互斥锁的机制,这也叫二元信号量,表示两种互斥状态。<br>代码实现<br>它的用法如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个计数阈值为 5 的信号量对象</span><br><span class="hljs-comment">// 只能 5 个线程同时访问</span><br>Semaphore semp = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 申请许可</span><br>    semp.acquire();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 业务逻辑</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 释放许可</span><br>            semp.release();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Semaphore-与-ReentrantLock"><a href="#Semaphore-与-ReentrantLock" class="headerlink" title="Semaphore 与 ReentrantLock"></a>Semaphore 与 ReentrantLock</h2><p>Semaphore 基本能完成 ReentrantLock 的所有工作,使用方法也与之类似,通过 acquire()与<br>release()方法来获得和释放临界资源。经实测,Semaphone.acquire()方法默认为可响应中断锁,<br>与 ReentrantLock.lockInterruptibly()作用效果一致,也就是说在等待临界资源的过程中可以被<br>Thread.interrupt()方法中断。</p><p>此外,Semaphore 也实现了<code>可轮询的锁请求与定时锁的功能</code>,除了方法名 tryAcquire 与 tryLock<br>不同,其使用方法与 ReentrantLock 几乎一致。Semaphore 也提供了公平与非公平锁的机制,也<br>可在构造函数中进行设定。<br>Semaphore 的锁释放操作也由手动进行,因此与 ReentrantLock 一样,为避免线程因抛出异常而<br>无法正常释放锁的情况发生,释放锁的操作也必须在 finally 代码块中完成。</p><h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><p>首 先 说 明 , 此 处 AtomicInteger , 一 个 提 供 原 子 操 作 的 Integer 的 类 , 常 见 的 还 有<br><code>AtomicBoolean</code>、<code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicReference</code> 等,他们的实现原理相同,<br>区别在与运算对象类型的不同。令人兴奋地,还可以通过 AtomicReference<V>将一个对象的所<br>有操作转化成原子操作。</p><p>我们知道,在多线程程序中,诸如++i 或 i++等运算不具有原子性,是不安全的线程操作之一。<br>通常我们会使用 synchronized 将该操作变成一个原子操作,但 JVM 为此类操作特意提供了一些<br>同步类,使得使用更方便,且使程序运行效率变得更高。通过相关资料显示,通常 AtomicInteger<br>的性能是 ReentantLock 的好几倍。</p><h3 id="可重入锁-递归锁"><a href="#可重入锁-递归锁" class="headerlink" title="可重入锁(递归锁)"></a>可重入锁(递归锁)</h3><p>本文里面讲的是广义上的可重入锁,而不是单指 JAVA 下的 <code>ReentrantLock</code>。可重入锁,也叫<br>做递归锁,指的是同一线程 外层函数获得锁之后 ,内层递归函数仍然有获取该锁的代码,但不受<br>影响。在 JAVA 环境下 <code>ReentrantLock</code> 和 <code>synchronized</code> 都是 可重入锁。</p><h2 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h2><p>公平锁( Fair )<br>加锁前检查是否有排队等待的线程,优先排队等待的线程,先来先得<br>非公平锁( Nonfair )<br>加锁时不考虑排队等待问题,直接尝试获取锁,获取不到自动到队尾等待</p><ol><li>非公平锁性能比公平锁高 5~10 倍,因为公平锁需要在多核的情况下维护一个队列</li><li>Java 中的 synchronized 是非公平锁,ReentrantLock 默认的 lock()方法采用的是非公平锁。</li></ol><h3 id="ReadWriteLock-读写锁"><a href="#ReadWriteLock-读写锁" class="headerlink" title="ReadWriteLock 读写锁"></a>ReadWriteLock 读写锁</h3><p>为了提高性能,Java 提供了读写锁,在读的地方使用读锁,在写的地方使用写锁,灵活控制,如<br>果没有写锁的情况下,读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写<br>锁,多个读锁不互斥,读锁与写锁互斥,这是由 jvm 自己控制的,你只要上好相应的锁即可。<br>读锁<br>如果你的代码只读数据,可以很多人同时读,但不能同时写,那就上读锁<br>写锁<br>如果你的代码修改数据,只能有一个人在写,且不能同时读取,那就上写锁。总之,读的时候上<br>读锁,写的时候上写锁!<br>Java 中 读 写 锁 有 个 接 口 java.util.concurrent.locks.ReadWriteLock , 也 有 具 体 的 实 现</p><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><h2 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h2><p>java 并发包提供的加锁模式分为独占锁和共享锁。<br>独占锁</p><blockquote><p>独占锁模式下,每次只能有一个线程能持有锁,ReentrantLock 就是以独占方式实现的互斥锁。<br>独占锁是一种悲观保守的加锁策略,它避免了读/读冲突,如果某个只读线程获取锁,则其他读线<br>程都只能等待,这种情况下就限制了不必要的并发性,因为读操作并不会影响数据的一致性。</p></blockquote><p>共享锁</p><blockquote><p>共享锁则允许多个线程同时获取锁,并发访问 共享资源,如:ReadWriteLock。共享锁则是一种<br>乐观锁,它放宽了加锁策略,允许多个执行读操作的线程同时访问共享资源。</p></blockquote><p>1.AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE,他们分别标识 AQS 队列中等待线程的锁获取模式。<br>2.java 的并发包中提供了 ReadWriteLock,读-写锁。它允许一个资源可以被多个读操作访问,或者被一个 写操作访问,但两者不能同时进行。</p><h3 id="重量级锁-Mutex-Lock"><a href="#重量级锁-Mutex-Lock" class="headerlink" title="重量级锁( Mutex Lock )"></a>重量级锁( Mutex Lock )</h3><p>Synchronized 是通过对象内部的一个叫做监视器锁(monitor)来实现的。但是监视器锁本质又是依赖于底层的操作系统的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态,这个成本非常高,状态之间的转换需要相对比较长的时间,这就是为什么<br>Synchronized 效率低的原因。因此,这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为“重量级锁”。JDK 中对 Synchronized 做的种种优化,其核心都是为了减少这种重量级锁的使用。<br>JDK1.6 以后,为了减少获得锁和释放锁所带来的性能消耗,提高性能,引入了“轻量级锁”和“偏向锁”。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>锁的状态总共有四种:无锁状态、偏向锁、轻量级锁和重量级锁。</p><p><strong>锁升级</strong><br>随着锁的竞争,锁可以从偏向锁升级到轻量级锁,再升级的重量级锁(但是锁的升级是单向的,<br>也就是说只能从低到高升级,不会出现锁的降级)。</p><p>  “轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是,首先需要强调一点的是,<br>轻量级锁并不是用来代替重量级锁的,它的本意是在没有多线程竞争的前提下,减少传统的重量<br>级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前,先明白一点,轻量级锁所适应的场<br>景是线程交替执行同步块的情况,如果存在同一时间访问同一锁的情况,就会导致轻量级锁膨胀<br>为重量级锁。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><blockquote><p>Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争,而且总是由同一线<br>程多次获得。偏向锁的目的是在某个线程获得锁之后,消除这个线程锁重入(CAS)的开销,看起<br>来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级<br>锁执行路径,因为轻量级锁的获取及释放依赖多次 CAS 原子指令,而偏向锁只需要在置换<br>ThreadID 的时候依赖一次 CAS 原子指令(由于一旦出现多线程竞争的情况就必须撤销偏向锁,所<br>以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗)。上面说过,轻<br>量级锁是为了在线程交替执行同步块时提高性能,而偏向锁则是在只有一个线程执行同步块时进<br>一步提高性能。</p></blockquote><h3 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h3><blockquote><p>分段锁也并非一种实际的锁,而是一种思想 ConcurrentHashMap 是学习分段锁的最好实践</p></blockquote><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><ul><li><p>减少锁持有时间  </p><blockquote><p>只用在有线程安全要求的程序上加锁</p></blockquote></li><li><p>减小锁粒度</p><blockquote><p>将大对象(这个对象可能会被很多线程访问),拆成小对象,大大增加并行度,降低锁竞争。<br>降低了锁的竞争,偏向锁,轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是<br>ConcurrentHashMap。</p></blockquote></li><li><p>锁分离</p><blockquote><p>最常见的锁分离就是读写锁 ReadWriteLock,根据功能进行分离成读锁和写锁,这样读读不互<br>斥,读写互斥,写写互斥,即保证了线程安全,又提高了性能,具体也请查看[高并发 Java 五]<br>JDK 并发包 1。读写分离思想可以延伸,只要操作互不影响,锁就可以分离。比如<br>LinkedBlockingQueue 从头部取出,从尾部放数据</p></blockquote></li><li><p>锁粗化</p><blockquote><p>通常情况下,为了保证多线程间的有效并发,会要求每个线程持有锁的时间尽量短,即在使用完<br>公共资源后,应该立即释放锁。但是,凡事都有一个度,如果对同一个锁不停的进行请求、同步<br>和释放,其本身也会消耗系统宝贵的资源,反而不利于性能的优化 。<br>锁消除<br>锁消除是在编译器级别的事情。在即时编译器时,如果发现不可能被共享的对象,则可以消除这<br>些对象的锁操作,多数是因为程序员编码不规范引起。<br><a href="https://www.jianshu.com/p/39628e1180a9">参考</a></p></blockquote></li></ul><p>4.1.10.</p><ul><li>线程基本方法<br>线程相关的基本方法有 <code>wait,notify,notifyAll,sleep,join,yield</code> 等。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/threadmethods.png" alt="avatar"></p><h2 id="线程等待-wait"><a href="#线程等待-wait" class="headerlink" title="线程等待(wait)"></a>线程等待(wait)</h2><blockquote><p>调用该方法的线程进入 WAITING 状态,只有等待另外线程的通知或被中断才会返回,需要注意的<br>是调用 wait()方法后,会释放对象的锁。因此,wait 方法一般用在同步方法或同步代码块中。<br>4.1.10.2.</p></blockquote><h2 id="线程睡眠-sleep"><a href="#线程睡眠-sleep" class="headerlink" title="线程睡眠(sleep)"></a>线程睡眠(sleep)</h2><p>sleep 导致当前线程休眠,与 wait 方法不同的是 sleep 不会释放当前占有的锁,sleep(long)会导致线程进入 <code>TIMED-WATING</code> 状态,而 wait()方法会导致当前线程进入 <code>WATING</code> 状态</p><h2 id="线程让步-yield"><a href="#线程让步-yield" class="headerlink" title="线程让步(yield)"></a>线程让步(yield)</h2><p>yield 会使当前线程让出 CPU 执行时间片,与其他线程一起重新竞争 CPU 时间片。一般情况下,优先级高的线程有更大的可能性成功竞争得到 CPU 时间片,但这又不是绝对的,有的操作系统对线程优先级并不敏感。</p><h2 id="线程中断-interrupt"><a href="#线程中断-interrupt" class="headerlink" title="线程中断(interrupt)"></a>线程中断(interrupt)</h2><p>中断一个线程,其本意是给这个线程一个通知信号,会影响这个线程内部的一个中断标识位。这个线程本身并不会因此而改变状态(如阻塞,终止等)。</p><p>1.调用 interrupt()方法并不会中断一个正在运行的线程。也就是说处于 Running 状态的线程并不会因为被中断而被终止,仅仅改变了内部维护的中断标识位而已。</p><p>2.若调用 sleep()而使线程处于 TIMED-WATING 状态,这时调用 interrupt()方法,会抛出InterruptedException,从而使线程提前结束 TIMED-WATING 状态。</p><p>3.许多声明抛出 InterruptedException 的方法(如 Thread.sleep(long mills 方法)),抛出异常前,都会清除中断标识位,所以抛出异常后,调用 isInterrupted()方法将会返回 false。</p><p>4.中断状态是线程固有的一个标识位,可以通过此标识位安全的终止线程。比如,你想终止一个线程 thread 的时候,可以调用 thread.interrupt()方法,在线程的 run 方法内部可以根据 thread.isInterrupted()的值来优雅的终止线程。</p><h3 id="Join-等待其他线程终止"><a href="#Join-等待其他线程终止" class="headerlink" title="Join 等待其他线程终止"></a>Join 等待其他线程终止</h3><pre><code>join() 方法,等待其他线程终止,在当前线程中调用一个线程的 join() 方法,则当前线程转为阻塞状态,回到另一个线程结束,当前线程再由阻塞状态变为就绪状态,等待 cpu 的宠幸。</code></pre><h5 id="为什么要用-join-方法"><a href="#为什么要用-join-方法" class="headerlink" title="为什么要用 join()方法?"></a>为什么要用 join()方法?</h5><pre><code>很多情况下,主线程生成并启动了子线程,需要用到子线程返回的结果,也就是需要主线程需要在子线程结束后再结束,这时候就要用到 join() 方法。</code></pre><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">System.out.println(Thread.currentThread().getName() + &quot;线程运行开始!&quot;);<br>Thread6 thread1 = new Thread6();<br>thread1.setName(&quot;线程 B&quot;);<br>thread1.join();<br>System.out.println(&quot;这时 thread1 执行完毕之后才能执行主线程&quot;);<br></code></pre></td></tr></table></figure><h3 id="线程唤醒-notify"><a href="#线程唤醒-notify" class="headerlink" title="线程唤醒(notify)"></a>线程唤醒(notify)</h3><p>Object 类中的 notify() 方法,唤醒在此对象监视器上等待的单个线程,如果所有线程都在此对象上等待,则会选择唤醒其中一个线程,选择是任意的,并在对实现做出决定时发生,线程通过调<br>用其中一个 wait() 方法,在对象的监视器上等待,直到当前的线程放弃此对象上的锁定,才能继续执行被唤醒的线程,被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。类似的方法还有 notifyAll() ,唤醒再次监视器上等待的所有线程。</p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法:"></a>其他方法:</h4><ol><li><code>sleep()</code>:强迫一个线程睡眠N毫秒。</li><li><code>isAlive()</code>: 判断一个线程是否存活。</li><li><code>join()</code>: 等待线程终止。</li><li><code>activeCount()</code>: 程序中活跃的线程数。</li><li><code>enumerate()</code>: 枚举程序中的线程。</li><li><code>currentThread()</code>: 得到当前线程。</li><li><code>isDaemon()</code>: 一个线程是否为守护线程。</li><li><code>setDaemon()</code>: 设置一个线程为守护线程。(用户线程和守护线程的区别在于,是否等待主线程依赖于主线程结束而结束)</li><li><code>setName()</code>: 为线程设置一个名称。</li><li><code>wait()</code>: 强迫一个线程等待。</li><li><code>notify()</code>: 通知一个线程继续运行。</li><li><code>setPriority()</code>: 设置一个线程的优先级。</li><li><code>getPriority()</code>::获得一个线程的优先级。</li></ol><h2 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h2><blockquote><p>巧妙地利用了时间片轮转的方式, CPU 给每个任务都服务一定的时间,然后把当前任务的状态保存下来,在加载下一任务的状态后,继续服务下一任务,任务的状态保存及再加载, 这段过程就叫做上下文切换。时间片轮转的方式使多个任务在同一颗 CPU 上执行变成了可能。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/threadcontentchange.png" alt="avatar"></p><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>(有时候也称做任务)是指一个程序运行的实例。在 Linux 系统中,线程就是能并行运行并且与他们的父进程(创建他们的进程)共享同一地址空间(一段内存区域)和其他资源的轻量级的进程。</p><h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><p>是指某一时间点 CPU 寄存器和程序计数器的内容。</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>是 CPU 内部的数量较少但是速度很快的内存(与之对应的是 CPU 外部相对较慢的 RAM 主内存)。寄存器通过对常用值(通常是运算的中间值)的快速访问来提高计算机程序运行的速度。</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>是一个专用的寄存器,用于表明指令序列中 CPU 正在执行的位置,存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置,具体依赖于特定的系统。</p><h3 id="PCB-“切换桢”"><a href="#PCB-“切换桢”" class="headerlink" title="PCB-“切换桢”"></a>PCB-“切换桢”</h3><p>上下文切换可以认为是内核(操作系统的核心)在 CPU 上对于进程(包括线程)进行切换,上下文切换过程中的信息是保存在进程控制块(PCB, process control block)中的。PCB 还经常被称作“切换桢”(switchframe)。信息会一直保存到 CPU 的内存中,直到他们被再次使用。</p><p>###上下文切换的活动:</p><ol><li>挂起一个进程,将这个进程在 CPU 中的状态(上下文)存储于内存中的某处。</li><li>在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复。</li><li>跳转到程序计数器所指向的位置(即跳转到进程被中断时的代码行),以恢复该进程在程序中。</li></ol><h3 id="引起线程上下文切换的原因"><a href="#引起线程上下文切换的原因" class="headerlink" title="引起线程上下文切换的原因"></a>引起线程上下文切换的原因</h3><ol><li>当前执行任务的时间片用完之后,系统 CPU 正常调度下一个任务;</li><li>当前执行任务碰到 IO 阻塞,调度器将此任务挂起,继续下一任务;</li><li>多个任务抢占锁资源,当前任务没有抢到锁资源,被调度器挂起,继续下一任务;</li><li>用户代码挂起当前任务,让出 CPU 时间;</li><li>硬件中断;</li></ol><h2 id="同步锁与死锁"><a href="#同步锁与死锁" class="headerlink" title="同步锁与死锁"></a>同步锁与死锁</h2><p>同步锁<br>当多个线程同时访问同一个数据时,很容易出现问题。为了避免这种情况出现,我们要保证线程同步互斥,就是指并发执行的多个线程,在同一时间内只允许一个线程访问共享数据。 Java 中可以使用 synchronized 关键字来取得一个对象的同步锁。</p><p>死锁<br>何为死锁,就是多个线程同时被阻塞,它们中的一个或者全部都在等待某个资源被释放。</p><p>线程池原理<br>线程池做的工作主要是控制运行的线程的数量,处理过程中将任务放入队列,然后在线程创建后启动这些任务,如果线程数量超过了最大数量超出数量的线程排队等候,等其它线程执行完毕,再从队列中取出任务来执行。他的主要特点为:线程复用;控制最大并发数;管理线程。</p><h3 id="线程复用"><a href="#线程复用" class="headerlink" title="线程复用"></a>线程复用</h3><p>每一个 Thread 的类都有一个 start 方法。 当调用 start 启动线程时 Java 虚拟机会调用该类的 run方法。 那么该类的 run() 方法中就是调用了 Runnable 对象的 run() 方法。 我们可以继承重写<br>Thread 类,在其 start 方法中添加不断循环调用传递过来的 Runnable 对象。 这就是线程池的实现原理。循环方法中不断获取 Runnable 是用 Queue 实现的,在获取下一个 Runnable 之前可以是阻塞的。</p><h3 id="线程池的组成"><a href="#线程池的组成" class="headerlink" title="线程池的组成"></a>线程池的组成</h3><p>一般的线程池主要分为以下 4 个组成部分:</p><ol><li>线程池管理器:用于创建并管理线程池</li><li>工作线程:线程池中的线程</li><li>任务接口:每个任务必须实现的接口,用于工作线程调度其运行</li><li>任务队列:用于存放待处理的任务,提供一种缓冲机制<br>Java 中 的 线 程 池 是 通 过 Executor 框 架 实 现 的 , 该 框 架 中 用 到 了 Executor , Executors ,ExecutorService,ThreadPoolExecutor ,Callable 和 Future、FutureTask 这几个类。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/threadpoolcon.png" alt="avatar"><br>ThreadPoolExecutor 的构造方法如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,<span class="hljs-keyword">int</span> maximumPoolSize, <span class="hljs-keyword">long</span> keepAliveTime,TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,Executors.defaultThreadFactory(), defaultHandler);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>corePoolSize:指定了线程池中的线程数量。</li><li>maximumPoolSize:指定了线程池中的最大线程数量。</li><li>keepAliveTime:当前线程池数量超过 corePoolSize 时,多余的空闲线程的存活时间,即多次时间内会被销毁。</li><li>unit:keepAliveTime 的单位。</li><li>workQueue:任务队列,被提交但尚未被执行的任务。</li><li>threadFactory:线程工厂,用于创建线程,一般用默认的即可。</li><li>handler:拒绝策略,当任务太多来不及处理,如何拒绝任务。</li></ol><h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><p>线程池中的线程已经用完了,无法继续为新任务服务,同时,等待队列也已经排满了,再也<br>塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。<br>JDK 内置的拒绝策略如下:</p><ol><li>AbortPolicy : 直接抛出异常,阻止系统正常运行。</li><li>CallerRunsPolicy : 只要线程池未关闭,该策略直接在调用者线程中,运行当前被丢弃的任务。显然这样做不会真的丢弃任务,但是,任务提交线程的性能极有可能会急剧下降。</li><li>DiscardOldestPolicy : 丢弃最老的一个请求,也就是即将被执行的一个任务,并尝试再次提交当前任务。</li><li>DiscardPolicy : 该策略默默地丢弃无法处理的任务,不予任何处理。如果允许任务丢失,这是最好的一种方案。以上内置拒绝策略均实现了 RejectedExecutionHandler 接口,若以上策略仍无法满足实际需要,完全可以自己扩展 RejectedExecutionHandler 接口。</li></ol><h3 id="Java-线程池工作过程"><a href="#Java-线程池工作过程" class="headerlink" title="Java 线程池工作过程"></a>Java 线程池工作过程</h3><p>1.线程池刚创建时,里面没有一个线程。任务队列是作为参数传进来的。不过,就算队列里面有任务,线程池也不会马上执行它们。<br>2.当调用 execute() 方法添加一个任务时,线程池会做如下判断:</p><blockquote><p>a) 如果正在运行的线程数量小于 corePoolSize,那么马上创建线程运行这个任务;</p></blockquote><blockquote><p>b) 如果正在运行的线程数量大于或等于 corePoolSize,那么将这个任务放入队列;</p></blockquote><blockquote><p>c) 如果这时候队列满了,而且正在运行的线程数量小于 maximumPoolSize,那么还是要创建非核心线程立刻运行这个任务;</p></blockquote><blockquote><p>d)如果队列满了,而且正在运行的线程数量大于或等于 maximumPoolSize,那么线程池会抛出异常 RejectExecutionException。<br>3. 当一个线程完成任务时,它会从队列中取下一个任务来执行。<br>4. 当一个线程无事可做,超过一定的时间(keepAliveTime)时,线程池会判断,如果当前运行的线程数大于 corePoolSize,那么这个线程就被停掉。所以线程池的所有任务完成后,它最终会收缩到 corePoolSize 的大小。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/threadwork.png" alt="avatar"></p><h3 id="JAVA-阻塞队列原理"><a href="#JAVA-阻塞队列原理" class="headerlink" title="JAVA 阻塞队列原理"></a>JAVA 阻塞队列原理</h3><blockquote><p>阻塞队列,关键字是阻塞,先理解阻塞的含义,在阻塞队列中,线程阻塞有这样的两种情况:</p></blockquote><p>1.当队列中没有数据的情况下,消费者端的所有线程都会被自动阻塞(挂起),直到有数据放入队列。<br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/thread-1.png" alt="avatar"></p><p>2.当队列中填满数据的情况下,生产者端的所有线程都会被自动阻塞(挂起),直到队列中有空的位置,线程被自动唤醒。<br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/thread-2.png" alt="avatar"></p><h3 id="阻塞队列的主要方法"><a href="#阻塞队列的主要方法" class="headerlink" title="阻塞队列的主要方法"></a>阻塞队列的主要方法</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/blockqueue.png" alt="avatar"></p><ul><li>抛出异常:抛出一个异常;  </li><li>特殊值:返回一个特殊值(null 或 false,视情况而定)</li><li>则塞:在成功操作之前,一直阻塞线程</li><li>超时:放弃前只在最大的时间内阻塞</li></ul><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作:"></a>插入操作:</h3><p>1:public abstract boolean add(E paramE):将指定元素插入此队列中(如果立即可行且不会违反容量限制),成功时返回 true,如果当前没有可用的空间,则抛出 IllegalStateException。如果该元素是 NULL,则会抛出 NullPointerException 异常。</p><p>2:public abstract boolean offer(E paramE):将指定元素插入此队列中(如果立即可行且不会违反容量限制),成功时返回 true,如果当前没有可用的空间,则返回 false。</p><p>3:public abstract void put(E paramE) throws InterruptedException: 将指定元素插入此队列中,将等待可用的空间(如果有必要)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(E paramE)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    checkNotNull(paramE);<br>    ReentrantLock localReentrantLock = <span class="hljs-keyword">this</span>.lock;<br>    localReentrantLock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.count == <span class="hljs-keyword">this</span>.items.length)<br>            <span class="hljs-keyword">this</span>.notFull.await();<span class="hljs-comment">//如果队列满了,则线程阻塞等待</span><br>            enqueue(paramE);<br>            localReentrantLock.unlock();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            localReentrantLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4:offer(E o, long timeout, TimeUnit unit):可以设定等待的时间,如果在指定的时间内,还不能往队列中加入 BlockingQueue,则返回失败。</p><h3 id="获取数据操作"><a href="#获取数据操作" class="headerlink" title="获取数据操作:"></a>获取数据操作:</h3><p>1:poll(time):取走 BlockingQueue 里排在首位的对象,若不能立即取出,则可以等 time 参数规定的时间,取不到时返回 null;</p><p>2:poll(long timeout, TimeUnit unit):从 BlockingQueue 取出一个队首的对象,如果在指定时间内,队列一旦有数据可取,则立即返回队列中的数据。否则直到时间超时还没有数据可取,返回失败。</p><p>3:take():取走 BlockingQueue 里排在首位的对象,若 BlockingQueue 为空,阻断进入等待状态直到 BlockingQueue 有新的数据被加入。</p><p>4.drainTo():一次性从 BlockingQueue 获取所有可用的数据对象(还可以指定获取数据的个数),通过该方法,可以提升获取数据效率;不需要多次分批加锁或释放锁。</p><h3 id="Java中的阻塞队列"><a href="#Java中的阻塞队列" class="headerlink" title="Java中的阻塞队列"></a>Java中的阻塞队列</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/blocking_queue.png" alt="avatar"></p><ul><li>ArrayBlockingQueue: 由数组结构组成的有界阻塞队列.(公平、非公平)<blockquote><p>用数组实现的有界阻塞队列。此队列按照先进先出(FIFO)的原则对元素进行排序。默认情况下<br>不保证访问者公平的访问队列,所谓公平访问队列是指阻塞的所有生产者线程或消费者线程,当<br>队列可用时,可以按照阻塞的先后顺序访问队列,即先阻塞的生产者线程,可以先往队列里插入<br>元素,先阻塞的消费者线程,可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐<br>量。我们可以使用以下代码创建一个公平的阻塞队列:<code>ArrayBlockingQueue fairQueue = new ArrayBlockingQueue(1000,true);</code></p></blockquote></li></ul><ul><li>LinkedBlockingQueue: 由链表结构组成的有界阻塞队列.(两个独立锁提高并发)<blockquote><p>基于链表的阻塞队列,同 ArrayListBlockingQueue 类似,此队列按照先进先出(FIFO)的原则对<br>元素进行排序。而 LinkedBlockingQueue 之所以能够高效的处理并发数据,还因为其对于生产者<br>端和消费者端分别采用了独立的锁来控制数据同步,这也意味着在高并发的情况下生产者和消费<br>者可以并行地操作队列中的数据,以此来提高整个队列的并发性能。<br>LinkedBlockingQueue 会默认一个类似无限大小的容量(Integer.MAX_VALUE)。</p></blockquote></li></ul><ul><li>PriorityBlockingQueue: 支持优先级排序的无界阻塞队列.(compareTo 排序实现优先)<blockquote><p>是 一 个 支持 优 先级 的 无界 队 列 。默 认 情况 下 元素 采 取 自然 顺 序升 序 排列 。 可 以自 定 义实 现<br>compareTo()方法来指定元素进行排序规则,或者初始化 PriorityBlockingQueue 时,指定构造<br>参数 Comparator 来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</p></blockquote></li></ul><ul><li>DelayQueue: 使用优先级队列实现的无界阻塞队列.(缓存失效、定时任务 )<blockquote><p>是一个支持延时获取元素的无界阻塞队列。队列使用 PriorityQueue 来实现。队列中的元素必须实<br>现 Delayed 接口,在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才<br>能从队列中提取元素。我们可以将 DelayQueue 运用在以下应用场景:</p></blockquote></li></ul><blockquote><p>1.缓存系统的设计:可以用 DelayQueue 保存缓存元素的有效期,使用一个线程循环查询 DelayQueue,一旦能从 DelayQueue 中获取元素时,表示缓存有效期到了。<br>2.定时任务调度 : 使用 DelayQueue 保存当天将会执行的任务和执行时间,一旦从DelayQueue 中获取到任务就开始执行,从比如 TimerQueue 就是使用 DelayQueue 实现的。</p></blockquote><ul><li>SynchronousQueue: 不存储元素的阻塞队列.(不存储数据、可用于传递数据)<blockquote><p>是一个不存储元素的阻塞队列。每一个 put 操作必须等待一个 take 操作,否则不能继续添加元素。<br>SynchronousQueue 可以看成是一个传球手,负责把生产者线程处理的数据直接传递给消费者线<br>程。队列本身并不存储任何元素,非常适合于传递性场景,比如在一个线程中使用的数据,传递给<br>另 外 一 个 线 程 使 用 , SynchronousQueue 的 吞 吐 量 高 于 LinkedBlockingQueue 和<br>ArrayBlockingQueue。</p></blockquote></li></ul><ul><li><p>LinkedTransferQueue: 由链表结构组成的无界阻塞队列.</p><blockquote><p>是 一 个 由 链 表 结 构 组 成 的 无 界 阻 塞 TransferQueue 队 列 。 相 对 于 其 他 阻 塞 队 列 ,<br>LinkedTransferQueue 多了 tryTransfer 和 transfer 方法。</p></blockquote><blockquote><p>1.transfer 方法:如果当前有消费者正在等待接收元素(消费者使用 take()方法或带时间限制的<br>poll()方法时),transfer 方法可以把生产者传入的元素立刻 transfer(传输)给消费者。如<br>果没有消费者在等待接收元素,transfer 方法会将元素存放在队列的 tail 节点,并等到该元素<br>被消费者消费了才返回。</p></blockquote><blockquote><p>2.tryTransfer 方法。则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费<br>者等待接收元素,则返回 false。和 transfer 方法的区别是 tryTransfer 方法无论消费者是否<br>接收,方法立即返回。而 transfer 方法是必须等到消费者消费了才返回。<br>对于带有时间限制的 tryTransfer(E e, long timeout, TimeUnit unit)方法,则是试图把生产者传<br>入的元素直接传给消费者,但是如果没有消费者消费该元素则等待指定的时间再返回,如果超时<br>还没消费元素,则返回 false,如果在超时时间内消费了元素,则返回 true。</p></blockquote></li></ul><ul><li>LinkedBlockingDeque: 由链表结构组成的双向阻塞队列.<blockquote><p>是一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两端插入和移出元素。<br>双端队列因为多了一个操作队列的入口,在多线程同时入队时,也就减少了一半的竞争。相比其<br>他 的 阻 塞 队 列 , LinkedBlockingDeque 多 了 addFirst , addLast , offerFirst , offerLast ,<br>peekFirst,peekLast 等方法,以 First 单词结尾的方法,表示插入,获取(peek)或移除双端队<br>列的第一个元素。以 Last 单词结尾的方法,表示插入,获取或移除双端队列的最后一个元素。另<br>外插入方法 add 等同于 addLast,移除方法 remove 等效于 removeFirst。但是 take 方法却等同<br>于 takeFirst,不知道是不是 Jdk 的 bug,使用时还是用带有 First 和 Last 后缀的方法更清楚。<br>在初始化 LinkedBlockingDeque 时可以设置容量防止其过渡膨胀。另外双向阻塞队列可以运用在<br>“工作窃取”模式中。</p></blockquote></li></ul><h3 id="CyclicBarrier、CountDownLatch、Semaphore-的用法"><a href="#CyclicBarrier、CountDownLatch、Semaphore-的用法" class="headerlink" title="CyclicBarrier、CountDownLatch、Semaphore 的用法"></a>CyclicBarrier、CountDownLatch、Semaphore 的用法</h3><h4 id="CountDownLatch-线程计数器"><a href="#CountDownLatch-线程计数器" class="headerlink" title="CountDownLatch(线程计数器 )"></a>CountDownLatch(线程计数器 )</h4><blockquote><p>CountDownLatch 类位于 java.util.concurrent 包下,利用它可以实现类似计数器的功能。比如有<br>一个任务 A,它要等待其他 4 个任务执行完毕之后才能执行,此时就可以利用 CountDownLatch<br>来实现这种功能了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">new</span> Thread() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;正在执行&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">3000</span>);<br>        System.out.println(<span class="hljs-string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;执行完毕&quot;</span>);<br>        latch.countDown();<br>    &#125;<br><br>    ;<br>&#125;.start();<br><span class="hljs-keyword">new</span> Thread() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;正在执行&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">3000</span>);<br>        System.out.println(<span class="hljs-string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;执行完毕&quot;</span>);<br>        latch.countDown();<br>    &#125;<br><br>    ;<br>&#125;.start();<br>System.out.println(<span class="hljs-string">&quot;等待 2 个子线程执行完毕...&quot;</span>);<br>latch.await();<br>System.out.println(<span class="hljs-string">&quot;2 个子线程已经执行完毕&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;继续执行主线程&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="CyclicBarrier-回环栅栏-等待至-barrier-状态再全部同时执行"><a href="#CyclicBarrier-回环栅栏-等待至-barrier-状态再全部同时执行" class="headerlink" title="CyclicBarrier(回环栅栏-等待至 barrier 状态再全部同时执行)"></a>CyclicBarrier(回环栅栏-等待至 barrier 状态再全部同时执行)</h4><blockquote><p>字面意思回环栅栏,通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环<br> 是因为当所有等待线程都被释放以后,CyclicBarrier 可以被重用。我们暂且把这个状态就叫做<br> barrier,当调用 await()方法之后,线程就处于 barrier 了。<br> CyclicBarrier 中最重要的方法就是 await 方法,它有 2 个重载版本:</p></blockquote><p> 1.public int await():用来挂起当前线程,直至所有线程都到达 barrier 状态再同时执行后续任务;<br> 2.public int await(long timeout, TimeUnit unit):让这些线程等待至一定的时间,如果还有线程没有到达 barrier 状态就直接让到达 barrier 的线程执行后续任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> N = <span class="hljs-number">4</span>;<br>    CyclicBarrier barrier = <span class="hljs-keyword">new</span> CyclicBarrier(N);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)<br>        <span class="hljs-keyword">new</span> Writer(barrier).start();<br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Writer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-keyword">private</span> CyclicBarrier cyclicBarrier;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Writer</span><span class="hljs-params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.cyclicBarrier = cyclicBarrier;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">5000</span>);<br>            <span class="hljs-comment">//以睡眠来模拟线程需要预定写入数据操作</span><br>            System.out.println(<span class="hljs-string">&quot; 线 程 &quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot; 写 入 数 据 完 毕,等待其他线程写入完毕&quot;</span>);<br>            cyclicBarrier.await();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">catch</span>( BrokenBarrierException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;所有线程写入完毕,继续处理其他任务,比如数据操作&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Semaphore-信号量-控制同时访问的线程个数"><a href="#Semaphore-信号量-控制同时访问的线程个数" class="headerlink" title="Semaphore(信号量-控制同时访问的线程个数)"></a>Semaphore(信号量-控制同时访问的线程个数)</h4><p>Semaphore 翻译成字面意思为 信号量,Semaphore 可以控制同时访问的线程个数,通过<br>acquire() 获取一个许可,如果没有就等待,而 release() 释放一个许可。<br>Semaphore 类中比较重要的几个方法:</p><p>1.public void acquire(): 用来获取一个许可,若无许可能够获得,则会一直等待,直到获得许可。<br>2. public void acquire(int permits):获取 permits 个许可<br>3. public void release() { } :释放许可。注意,在释放许可之前,必须先获获得许可。<br>4. public void release(int permits) { }:释放 permits 个许可 </p><blockquote><p>上面 4 个方法都会被阻塞,如果想立即得到执行结果,可以使用下面几个方法</p></blockquote><p>1.public boolean tryAcquire():尝试获取一个许可,若获取成功,则立即返回 true,若获取失败,则立即返回 false<br>2.public boolean tryAcquire(long timeout, TimeUnit unit):尝试获取一个许可,若在指定的时间内获取成功,则立即返回 true,否则则立即返回 false<br>3.public boolean tryAcquire(int permits):尝试获取 permits 个许可,若获取成功,则立即返回 true,若获取失败,则立即返回 false<br>4.public boolean tryAcquire(int permits, long timeout, TimeUnit unit): 尝试获取 permits个许可,若在指定的时间内获取成功,则立即返回 true,否则则立即返回 false<br>5.还可以通过 availablePermits()方法得到可用的许可数目。例子:若一个工厂有 5 台机器,但是有 8 个工人,一台机器同时只能被一个工人使用,只有使用完了,其他工人才能继续使用。那么我们就可以通过 Semaphore 来实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SemaphoreDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> N = <span class="hljs-number">8</span>;<br>        <span class="hljs-comment">//工人数</span><br>        Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">5</span>); <span class="hljs-comment">//机器数目</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) <span class="hljs-keyword">new</span> Worker(i, semaphore).start();<br><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num;<br>        <span class="hljs-keyword">private</span> Semaphore semaphore;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Worker</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, Semaphore semaphore)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.num = num;<br>            <span class="hljs-keyword">this</span>.semaphore = semaphore;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                semaphore.acquire();<br>                System.out.println(<span class="hljs-string">&quot;工人&quot;</span> + <span class="hljs-keyword">this</span>.num + <span class="hljs-string">&quot;占用一个机器在生产...&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>                System.out.println(<span class="hljs-string">&quot;工人&quot;</span> + <span class="hljs-keyword">this</span>.num + <span class="hljs-string">&quot;释放出机器&quot;</span>);<br>                semaphore.release();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>CountDownLatch 和 CyclicBarrier 都能够实现线程之间的等待,只不过它们侧重点不同;CountDownLatch 一般用于某个线程 A 等待若干个其他线程执行完任务之后,它才执行;而 CyclicBarrier 一般用于一组线程互相等待至某个状态,然后这一组线程再同时执行;另外,CountDownLatch 是不能够重用的,而 CyclicBarrier 是可以重用的。</li><li>Semaphore 其实和锁有点类似,它一般用于控制对某组资源的访问权限。</li></ul><h4 id="volatile-关键字的作用-变量可见性、禁止重排序"><a href="#volatile-关键字的作用-变量可见性、禁止重排序" class="headerlink" title="volatile 关键字的作用(变量可见性、禁止重排序)"></a>volatile 关键字的作用(变量可见性、禁止重排序)</h4><blockquote><p>Java 语言提供了一种稍弱的同步机制,即 volatile 变量,用来确保将变量的更新操作通知到其他线程。volatile 变量具备两种特性,volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方,因此在读取 volatile 类型的变量时总会返回最新写入的值。</p></blockquote><p><strong>变量可见性</strong><br>其一是保证该变量对所有线程可见,这里的可见性指的是当一个线程修改了变量的值,那么新的<br>值对于其他线程是可以立即获取的。<br><strong>禁止重排序</strong><br>volatile 禁止了指令重排。<br><code>比 sychronized 更轻量级的同步锁</code><br>在访问 volatile 变量时不会执行加锁操作,因此也就不会使执行线程阻塞,因此 volatile 变量是一<br>种比 sychronized 关键字更轻量级的同步机制。volatile 适合这种场景:一个变量被多个线程共<br>享,线程直接给这个变量赋值。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/volatile.png" alt="avatar"></p><blockquote><p>当对非 volatile 变量进行读写的时候,每个线程先从内存拷贝变量到 CPU 缓存中。如果计算机有<br> 多个 CPU,每个线程可能在不同的 CPU 上被处理,这意味着每个线程可以拷贝到不同的 CPU<br> cache 中。而声明变量是 volatile 的,JVM 保证了每次读变量都从内存中读,跳过 CPU cache<br> 这一步。</p></blockquote><p><strong>适用场景</strong><br>值得说明的是对 volatile 变量的单次读/写操作可以保证原子性的,如 long 和 double 类型变量,<br>但是并不能保证 i++这种操作的原子性,因为本质上 i++是读、写两次操作。在某些场景下可以<br>代替 Synchronized。但是,volatile 的不能完全取代 Synchronized 的位置,只有在一些特殊的场景下,<br>才能适用 volatile。总的来说,必须同时满足下面两个条件才能保证在并发环境的线程安全:</p><p>(1)对变量的写操作不依赖于当前值(比如 i++),或者说是单纯的变量赋值(boolean flag = true)。</p><p>(2)该变量没有包含在具有其他变量的不变式中,也就是说,不同的 volatile 变量之间,不能互相依赖。只有在状态真正独立于程序内其他内容时才能使用 volatile。</p><h2 id="如何在两个线程之间共享数据"><a href="#如何在两个线程之间共享数据" class="headerlink" title="如何在两个线程之间共享数据"></a>如何在两个线程之间共享数据</h2><p>Java 里面进行多线程通信的主要方式就是共享内存的方式,共享内存主要的关注点有两个:可见<br>性和有序性原子性。Java 内存模型(JMM)解决了可见性和有序性的问题,而锁解决了原子性的<br>问题,理想情况下我们希望做到“同步”和“互斥”。有以下常规实现方法:</p><p><code>将数据抽象成一个类,并将数据的操作作为这个类的方法</code></p><p>1.将数据抽象成一个类,并将对这个数据的操作作为这个类的方法,这么设计可以和容易做到同步,只要在方法上加”synchronized“</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyData</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;<br>            j++;<br>            System.out.println(<span class="hljs-string">&quot;线程&quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot;j 为:&quot;</span>+j);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dec</span><span class="hljs-params">()</span></span>&#123;<br>            j--;<br>            System.out.println(<span class="hljs-string">&quot;线程&quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot;j 为:&quot;</span>+j);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> j;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>        MyData data;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AddRunnable</span><span class="hljs-params">(MyData data)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.data= data;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            data.add();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>        MyData data;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DecRunnable</span><span class="hljs-params">(MyData data)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.data = data;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            data.dec();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MyData data = <span class="hljs-keyword">new</span> MyData();<br>        Runnable add = <span class="hljs-keyword">new</span> AddRunnable(data);<br>        Runnable dec = <span class="hljs-keyword">new</span> DecRunnable(data);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(add).start();<br>            <span class="hljs-keyword">new</span> Thread(dec).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Runnable 对象作为一个类的内部类<br>2.将 Runnable 对象作为一个类的内部类,共享数据作为这个类的成员变量,每个线程对共享数<br>据的操作方法也封装在外部类,以便实现对数据的各个操作的同步和互斥,作为内部类的各<br>个 Runnable 对象调用外部类的这些方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyData</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;<br>        j++;<br>        System.out.println(<span class="hljs-string">&quot;线程&quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot;j 为:&quot;</span>+j);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dec</span><span class="hljs-params">()</span></span>&#123;<br>        j--;<br>        System.out.println(<span class="hljs-string">&quot;线程&quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot;j 为:&quot;</span>+j);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> j;&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> MyData data = <span class="hljs-keyword">new</span> MyData();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;i++)&#123;<br>            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable()&#123;<br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    data.add();<br>                &#125;<br>            &#125;).start();<br>            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable()&#123;<br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    data.dec();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ThreadLocal-作用-线程本地存储"><a href="#ThreadLocal-作用-线程本地存储" class="headerlink" title="ThreadLocal 作用( 线程本地存储 )"></a>ThreadLocal 作用( 线程本地存储 )</h3><p>ThreadLocal,很多地方叫做线程本地变量,也有些地方叫做线程本地存储,ThreadLocal 的作用<br>是提供线程内的局部变量,这种变量在线程的生命周期内起作用,减少同一个线程内多个函数或<br>者组件之间一些公共变量的传递的复杂度。<br>ThreadLocalMap (线程的一个属性)<br>1.每个线程中都有一个自己的 ThreadLocalMap 类对象,可以将线程自己的对象保持到其中,各管各的,线程可以正确的访问到自己的对象。<br>2.将 一 个共 用的 ThreadLocal 静 态实 例作 为 key, 将 不同 对象 的引 用保存 到 不同 线程 的ThreadLocalMap 中,然后在线程执行的各处通过这个静态 ThreadLocal 实例的 get()方法取得自己线程保存的那个对象,避免了将这个对象作为参数传递的麻烦。<br>3.ThreadLocalMap 其实就是线程里面的一个属性,它在 Thread 类中定义<code>ThreadLocal.ThreadLocalMap threadLocals = null;</code></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/ThreadLocal.png" alt="avatar"></p><p><strong>使用场景</strong><br>最常见的 ThreadLocal 使用场景为 用来解决 数据库连接、Session 管理等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal threadSession = <span class="hljs-keyword">new</span> ThreadLocal();<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Session <span class="hljs-title">getSession</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InfrastructureException </span>&#123;<br>       Session s = (Session) threadSession.get();<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span>) &#123;<br>               s = getSessionFactory().openSession();<br>               threadSession.set(s);<br>           &#125;<br>       &#125; <span class="hljs-keyword">catch</span> (HibernateException ex) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InfrastructureException(ex);<br>       &#125;<br>       <span class="hljs-keyword">return</span> s;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="synchronized-和-ReentrantLock-的区别"><a href="#synchronized-和-ReentrantLock-的区别" class="headerlink" title="synchronized 和 ReentrantLock 的区别"></a>synchronized 和 ReentrantLock 的区别</h3><p><strong>两者的共同点:</strong></p><ol><li>都是用来协调多线程对共享对象、变量的访问</li><li>都是可重入锁,同一线程可以多次获得同一个锁</li><li>都保证了可见性和互斥性</li></ol><p><strong>两者的不同点:</strong></p><ol><li>ReentrantLock 显示的获得、释放锁,synchronized 隐式获得释放锁</li><li>ReentrantLock 可响应中断、可轮回,synchronized 是不可以响应中断的,为处理锁的不可用性提供了更高的灵活性</li><li>ReentrantLock 是 API 级别的,synchronized 是 JVM 级别的</li><li>ReentrantLock 可以实现公平锁</li><li>ReentrantLock 通过 Condition 可以绑定多个条件</li><li>底层实现不一样, synchronized 是同步阻塞,使用的是悲观并发策略,lock 是同步非阻塞,采用的是乐观并发策略</li><li>Lock 是一个接口,而 synchronized 是 Java 中的关键字,synchronized 是内置的语言实现。</li><li>synchronized 在发生异常时,会自动释放线程占有的锁,因此不会导致死锁现象发生;而 Lock 在发生异常时,如果没有主动通过 unLock()去释放锁,则很可能造成死锁现象,因此使用 Lock 时需要在 finally 块中释放锁。</li><li>Lock 可以让等待锁的线程响应中断,而 synchronized 却不行,使用 synchronized 时,等待的线程会一直等待下去,不能够响应中断。</li><li>通过 Lock 可以知道有没有成功获取锁,而 synchronized 却无法办到。</li><li>Lock 可以提高多个线程进行读操作的效率,既就是实现读写锁等。</li></ol><h3 id="ConcurrentHashMap-并发"><a href="#ConcurrentHashMap-并发" class="headerlink" title="ConcurrentHashMap 并发"></a>ConcurrentHashMap 并发</h3><p>减小锁粒度</p><blockquote><p>减小锁粒度是指缩小锁定对象的范围,从而减小锁冲突的可能性,从而提高系统的并发能力。减<br>小锁粒度是一种削弱多线程锁竞争的有效手段,这种技术典型的应用是 ConcurrentHashMap(高<br>性能的 HashMap)类的实现。对于 HashMap 而言,最重要的两个方法是 get 与 set 方法,如果我<br>们对整个 HashMap 加锁,可以得到线程安全的对象,但是加锁粒度太大。Segment 的大小也被<br>称为 ConcurrentHashMap 的并发度。</p></blockquote><p>ConcurrentHashMap 分段锁</p><blockquote><p>ConcurrentHashMap,它内部细分了若干个小的 HashMap,称之为段(Segment)。默认情况下<br>一个 ConcurrentHashMap 被进一步细分为 16 个段,既就是锁的并发度。<br>如果需要在 ConcurrentHashMap 中添加一个新的表项,并不是将整个 HashMap 加锁,而是首<br>先根据 hashcode 得到该表项应该存放在哪个段中,然后对该段加锁,并完成 put 操作。在多线程<br>环境中,如果多个线程同时进行 put 操作,只要被加入的表项不存放在同一个段中,则线程间可以<br>做到真正的并行。</p></blockquote><p>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成</p><blockquote><p>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。Segment 是一种可<br>重入锁 ReentrantLock,在 ConcurrentHashMap 里扮演锁的角色,HashEntry 则用于存储键值<br>对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组,Segment 的结构和 HashMap<br>类似,是一种数组和链表结构, 一个 Segment 里包含一个 HashEntry 数组,每个 HashEntry 是<br>一个链表结构的元素, 每个 Segment 守护一个 HashEntry 数组里的元素,当对 HashEntry 数组的<br>数据进行修改时,必须首先获得它对应的 Segment 锁。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/ConcurrentHashMap.png" alt="avatar"></p><h2 id="Java-中用到的线程调度"><a href="#Java-中用到的线程调度" class="headerlink" title="Java 中用到的线程调度"></a>Java 中用到的线程调度</h2><p>抢占式调度:  </p><blockquote><p>抢占式调度指的是每条线程执行的时间、线程的切换都由系统控制,系统控制指的是在系统某种<br>运行机制下,可能每条线程都分同样的执行时间片,也可能是某些线程执行的时间片较长,甚至<br>某些线程得不到执行的时间片。在这种机制下,一个线程的堵塞不会导致整个进程堵塞。</p></blockquote><p>协同式调度:  </p><blockquote><p>协同式调度指某一线程执行完后主动通知系统切换到另一线程上执行,这种模式就像接力赛一样,<br>一个人跑完自己的路程就把接力棒交接给下一个人,下个人继续往下跑。线程的执行时间由线程<br>本身控制,线程切换可以预知,不存在多线程同步问题,但它有一个致命弱点:如果一个线程编<br>写有问题,运行到一半就一直堵塞,那么可能导致整个系统崩溃。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/threadway.png" alt="avatar"></p><p>JVM 的线程调度实现(抢占式调度)</p><blockquote><p>java 使用的线程调使用抢占式调度,Java 中线程会按优先级分配 CPU 时间片运行,且优先级越高<br>越优先执行,但优先级高并不代表能独自占用执行时间片,可能是优先级高得到越多的执行时间<br>片,反之,优先级低的分到的执行时间少但不会分配不到执行时间。</p></blockquote><p>线程让出 cpu 的情况:</p><p>1.当前运行线程主动放弃 CPU,JVM 暂时放弃 CPU 操作(基于时间片轮转调度的 JVM 操作系统不会让线程永久放弃 CPU,或者说放弃本次时间片的执行权),例如调用 yield()方法。<br>2. 当前运行线程因为某些原因进入阻塞状态,例如阻塞在 I/O 上。<br>3. 当前运行线程结束,即运行完 run()方法里面的任务。</p><h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><p>优先调度算法</p><p>1.先来先服务调度算法(FCFS)<br>当在作业调度中采用该算法时,每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业,将它们调入内存,为它们分配资源、创建进程,然后放入就绪队列。在进程调度中采用 FCFS 算法时,则每次调度是从就绪队列中选择一个最先进入该队列的进程,为之分配处理机,使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机,特点是:算法比较简单,可以实现基本上的公平。</p><p>2.短作业(进程)优先调度算法<br>短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业,将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程,将处理机分配给它,使它立即执行并一直执行到完成,或发生某事件而被阻塞放弃处理机时再重新调度。该算法未照顾紧迫型作业。</p><h3 id="高优先权优先调度算法"><a href="#高优先权优先调度算法" class="headerlink" title="高优先权优先调度算法"></a>高优先权优先调度算法</h3><p>为了照顾紧迫型作业,使之在进入系统后便获得优先处理,引入了最高优先权优先(FPF)调度<br>算法。当把该算法用于作业调度时,系统将从后备队列中选择若干个优先权最高的作业装入内存。<br>当用于进程调度时,该算法是把处理机分配给就绪队列中优先权最高的进程。</p><p>1.非抢占式优先权算法<br>在这种方式下,系统一旦把处理机分配给就绪队列中优先权最高的进程后,该进程便一直执行下<br>去,直至完成;或因发生某事件使该进程放弃处理机时。这种调度算法主要用于批处理系统中;<br>也可用于某些对实时性要求不严的实时系统中。</p><p>2.抢占式优先权调度算法<br>在这种方式下,系统同样是把处理机分配给优先权最高的进程,使之执行。但在其执行期间,只<br>要又出现了另一个其优先权更高的进程,进程调度程序就立即停止当前进程(原优先权最高的进程)<br>的执行,重新将处理机分配给新到的优先权最高的进程。显然,这种抢占式的优先权调度算法能<br>更好地满足紧迫作业的要求,故而常用于要求比较严格的实时系统中,以及对性能要求较高的批<br>处理和分时系统中。</p><h3 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h3><p>在批处理系统中,短作业优先算法是一种比较好的算法,其主要的不足之处是长作业的运行<br>得不到保证。如果我们能为每个作业引入前面所述的动态优先权,并使作业的优先级随着等待时<br>间的增加而以速率 a 提高,则长作业在等待一定的时间后,必然有机会分配到处理机。该优先权的<br>变化规律可描述为:</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/hightresponse.png" alt="avatar"></p><p>(1) 如果作业的等待时间相同,则要求服务的时间愈短,其优先权愈高,因而该算法有利于短作业。<br>(2) 当要求服务的时间相同时,作业的优先权决定于其等待时间,等待时间愈长,其优先权愈高,因而它实现的是先来先服务。<br>(3) 对于长作业,作业的优先级可以随等待时间的增加而提高,当其等待时间足够长时,其优先级便可升到很高,从而也可获得处理机。简言之,该算法既照顾了短作业,又考虑了作业到达的先后次序,不会使长作业长期得不到服务。因此,该算法实现了一种较好的折衷。当然,在利用该算法时,每要进行调度之前,都须先做响应比的计算,这会增加系统开销。</p><h3 id="基于时间片的轮转调度算法"><a href="#基于时间片的轮转调度算法" class="headerlink" title="基于时间片的轮转调度算法"></a>基于时间片的轮转调度算法</h3><p>1.时间片轮转法<br>在早期的时间片轮转法中,系统将所有的就绪进程按先来先服务的原则排成一个队列,每次调度<br>时,把 CPU 分配给队首进程,并令其执行一个时间片。时间片的大小从几 ms 到几百 ms。当执行<br>的时间片用完时,由一个计时器发出时钟中断请求,调度程序便据此信号来停止该进程的执行,<br>并将它送往就绪队列的末尾;然后,再把处理机分配给就绪队列中新的队首进程,同时也让它执<br>行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处<br>理机执行时间。</p><p>2.多级反馈队列调度算法</p><p>(1) 应设置多个就绪队列,并为各个队列赋予不同的优先级。第一个队列的优先级最高,第二<br>个队列次之,其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各<br>不相同,在优先权愈高的队列中,为每个进程所规定的执行时间片就愈小。例如,第二个队列的<br>时间片要比第一个队列的时间片长一倍,……,第 i+1 个队列的时间片要比第 i 个队列的时间片长<br>一倍。</p><p>(2) 当一个新进程进入内存后,首先将它放入第一队列的末尾,按 FCFS 原则排队等待调度。当<br>轮到该进程执行时,如它能在该时间片内完成,便可准备撤离系统;如果它在一个时间片结束时<br>尚未完成,调度程序便将该进程转入第二队列的末尾,再同样地按 FCFS 原则等待调度执行;如果<br>它在第二队列中运行一个时间片后仍未完成,再依次将它放入第三队列,……,如此下去,当一个<br>长作业(进程)从第一队列依次降到第 n 队列后,在第 n 队列便采取按时间片轮转的方式运行。</p><p>(3) 仅当第一队列空闲时,调度程序才调度第二队列中的进程运行;仅当第 1<del>(i-1)队列均空时,<br>才会调度第 i 队列中的进程运行。如果处理机正在第 i 队列中为某进程服务时,又有新进程进入优<br>先权较高的队列(第 1</del>(i-1)中的任何一个队列),则此时新进程将抢占正在运行进程的处理机,即<br>由调度程序把正在运行的进程放回到第 i 队列的末尾,把处理机分配给新到的高优先权进程。<br>在多级反馈队列调度算法中,如果规定第一个队列的时间片略大于多数人机交互所需之处理时间<br>时,便能够较好的满足各种类型用户的需要。</p><h1 id="什么是-CAS-比较并交换-乐观锁机制-锁自旋"><a href="#什么是-CAS-比较并交换-乐观锁机制-锁自旋" class="headerlink" title="什么是 CAS( 比较并交换-乐观锁机制-锁自旋 )"></a>什么是 CAS( 比较并交换-乐观锁机制-锁自旋 )</h1><h3 id="概念及特性"><a href="#概念及特性" class="headerlink" title="概念及特性"></a>概念及特性</h3><blockquote><p>CAS(Compare And Swap/Set)比较并交换,CAS 算法的过程是这样:它包含 3 个参数<br>CAS(V,E,N)。V 表示要更新的变量(内存值),E 表示预期值(旧的),N 表示新值。当且仅当 V 值等<br>于 E 值时,才会将 V 的值设为 N,如果 V 值和 E 值不同,则说明已经有其他线程做了更新,则当<br>前线程什么都不做。最后,CAS 返回当前 V 的真实值。<br>CAS 操作是抱着乐观的态度进行的(乐观锁),它总是认为自己可以成功完成操作。当多个线程同时<br>使用 CAS 操作一个变量时,只有一个会胜出,并成功更新,其余均会失败。失败的线程不会被挂<br>起,仅是被告知失败,并且允许再次尝试,当然也允许失败的线程放弃操作。基于这样的原理,<br>CAS 操作即使没有锁,也可以发现其他线程对当前线程的干扰,并进行恰当的处理。</p></blockquote><h3 id="原子包-java-util-concurrent-atomic-锁自旋"><a href="#原子包-java-util-concurrent-atomic-锁自旋" class="headerlink" title="原子包 java.util.concurrent.atomic(锁自旋)"></a>原子包 java.util.concurrent.atomic(锁自旋)</h3><blockquote><p>JDK1.5 的原子包:java.util.concurrent.atomic 这个包里面提供了一组原子类。其基本的特性就<br>是在多线程环境下,当有多个线程同时执行这些类的实例包含的方法时,具有排他性,即当某个<br>线程进入方法,执行其中的指令时,不会被其他线程打断,而别的线程就像自旋锁一样,一直等<br>到该方法执行完成,才由 JVM 从等待队列中选择一个另一个线程进入,这只是一种逻辑上的理解。<br>相对于对于 synchronized 这种阻塞算法,CAS 是非阻塞算法的一种常见实现。由于一般 CPU 切<br>换时间比 CPU 指令集操作更加长, 所以 J.U.C 在性能上有了很大的提升。如下代码:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicInteger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> value;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndIncrement</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123; <span class="hljs-comment">//CAS 自旋,一直尝试,直达成功</span><br>            <span class="hljs-keyword">int</span> current = get();<br>            <span class="hljs-keyword">int</span> next = current + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (compareAndSet(current, next))<br>                <span class="hljs-keyword">return</span> current;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expect, <span class="hljs-keyword">int</span> update)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-keyword">this</span>, valueOffset, expect, update);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>getAndIncrement 采用了 CAS 操作,每次从内存中读取数据然后将此数据和+1 后的结果进行<br>CAS 操作,如果成功就返回结果,否则重试直到成功为止。而 compareAndSet 利用 JNI 来完成<br>CPU 指令的操作。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/CAS.png" alt="avatar"></p><h3 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h3><p>CAS 会导致“ABA 问题”。CAS 算法实现一个重要前提需要取出内存中某时刻的数据,而在下时<br>刻比较并替换,那么在这个时间差类会导致数据的变化。<br>比如说一个线程 one 从内存位置 V 中取出 A,这时候另一个线程 two 也从内存中取出 A,并且<br>two 进行了一些操作变成了 B,然后 two 又将 V 位置的数据变成 A,这时候线程 one 进行 CAS 操<br>作发现内存中仍然是 A,然后 one 操作成功。尽管线程 one 的 CAS 操作成功,但是不代表这个过<br>程就是没有问题的。<br>部分乐观锁的实现是通过版本号(version)的方式来解决 ABA 问题,乐观锁每次在执行数据的修<br>改操作时,都会带上一个版本号,一旦版本号和数据的版本号一致就可以执行修改操作并对版本<br>号执行+1 操作,否则就执行失败。因为每次操作的版本号都会随之增加,所以不会出现 ABA 问<br>题,因为版本号只会增加不会减少。</p><h3 id="什么是-AQS-抽象的队列同步器"><a href="#什么是-AQS-抽象的队列同步器" class="headerlink" title="什么是 AQS( 抽象的队列同步器 )"></a>什么是 AQS( 抽象的队列同步器 )</h3><p>AbstractQueuedSynchronizer 类如其名,抽象的队列式的同步器,AQS 定义了一套多线程访问<br>共享资源的同步器框架,许多同步类实现都依赖于它,如常用的<br><code>ReentrantLock/Semaphore/CountDownLatch</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/ABA.png" alt="avatar"></p><p>它维护了一个 volatile int state(代表共享资源)和一个 FIFO 线程等待队列(多线程争用资源被<br>阻塞时会进入此队列)。这里 volatile 是核心关键词,具体 volatile 的语义,在此不述。state 的<br>访问方式有三种:</p><ul><li>getState()</li><li>setState()</li><li>compareAndSetState()</li></ul><h3 id="AQS-定义两种资源共享方式"><a href="#AQS-定义两种资源共享方式" class="headerlink" title="AQS 定义两种资源共享方式"></a>AQS 定义两种资源共享方式</h3><ul><li>Exclusive 独占资源 -ReentrantLock</li><li>Exclusive(独占,只有一个线程能执行,如 ReentrantLock)</li><li>Share 共享资源 -Semaphore/CountDownLatch</li><li>Share(共享,多个线程可同时执行,如 Semaphore/CountDownLatch)。</li></ul><p>AQS 只是一个框架,具体资源的获取/释放方式交由自定义同步器去实现,AQS 这里只定义了一个接口,具体资源的获取交由自定义同步器去实现了(通过 state 的 get/set/CAS)之所以没有定义成<br>abstract , 是 因 为 独 占 模 式 下 只 用 实 现 tryAcquire-tryRelease , 而 共 享 模 式 下 只 用 实 现tryAcquireShared-tryReleaseShared。如果都定义成 abstract,那么每个模式也要去实现另一模式下的接口。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可,至于具体线程等待队列的维护(如获取资源失败入队/唤醒出队等),AQS 已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法:</p><ol><li>isHeldExclusively():该线程是否正在独占资源。只有用到 condition 才需要去实现它。</li><li>tryAcquire(int):独占方式。尝试获取资源,成功则返回 true,失败则返回 false。</li><li>tryRelease(int):独占方式。尝试释放资源,成功则返回 true,失败则返回 false。</li><li>tryAcquireShared(int):共享方式。尝试获取资源。负数表示失败;0 表示成功,但没有剩余可用资源;正数表示成功,且有剩余资源。</li><li>tryReleaseShared(int):共享方式。尝试释放资源,如果释放后允许唤醒后续等待结点返回true,否则返回 false。</li></ol><h3 id="同步器的实现是-ABS-核心-state-资源状态计数"><a href="#同步器的实现是-ABS-核心-state-资源状态计数" class="headerlink" title="同步器的实现是 ABS 核心( state 资源状态计数)"></a>同步器的实现是 ABS 核心( state 资源状态计数)</h3><p>同步器的实现是 ABS 核心,以 ReentrantLock 为例,state 初始化为 0,表示未锁定状态。A 线程<br>lock()时,会调用 tryAcquire()独占该锁并将 state+1。此后,其他线程再 tryAcquire()时就会失<br>败,直到 A 线程 unlock()到 state=0(即释放锁)为止,其它线程才有机会获取该锁。当然,释放<br>锁之前,A 线程自己是可以重复获取此锁的(state 会累加),这就是可重入的概念。但要注意,<br>获取多少次就要释放多么次,这样才能保证 state 是能回到零态的。<br>以 CountDownLatch 以例,任务分为 N 个子线程去执行,state 也初始化为 N(注意 N 要与<br>线程个数一致)。这 N 个子线程是并行执行的,每个子线程执行完后 countDown()一次,state<br>会 CAS 减 1。等到所有子线程都执行完后(即 state=0),会 unpark()主调用线程,然后主调用线程<br>就会从 await()函数返回,继续后余动作。</p><h3 id="ReentrantReadWriteLock-实现独占和共享两种方式"><a href="#ReentrantReadWriteLock-实现独占和共享两种方式" class="headerlink" title="ReentrantReadWriteLock 实现独占和共享两种方式"></a>ReentrantReadWriteLock 实现独占和共享两种方式</h3><p>一般来说,自定义同步器要么是独占方法,要么是共享方式,他们也只需实现 tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared 中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式,如 ReentrantReadWriteLock。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 集合</title>
    <link href="/2020/05/29/java/Java-%E9%9B%86%E5%90%88/"/>
    <url>/2020/05/29/java/Java-%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="接口继承关系和实现"><a href="#接口继承关系和实现" class="headerlink" title="接口继承关系和实现"></a>接口继承关系和实现</h1><blockquote><p>集合类存放于Java.util包中，主要有三种：<code>set(集)</code>，<code>list(列表包含Queue)</code>，<code>map(映射)</code></p></blockquote><ul><li>Collection:Collection是集合List、Set、Queue的最基本的接口。</li><li>Iterator:迭代器，可以通过迭代器遍历集合中的数据。</li><li>Map:是映射表的基础接口</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/TIM%E5%9B%BE%E7%89%8720200529102225.png" alt="avatar"></p><p>集合框架</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/TIM%E5%9B%BE%E7%89%8720200529102233.png" alt="avatar"></p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><blockquote><p>Java的List是非常常用的的数据类型。List是有序的Collection。Java List一共三个实现：<code>ArrayList</code>，<code>Vector</code>，<code>LinkedList</code></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/List.png" alt="avatar"></p><ul><li><p>ArrayList(数组)</p><blockquote><p>ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</p></blockquote></li><li><p>Vector(数组实现、线程同步)</p><blockquote><p>Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程同步，即某一刻只有一个线程能够写Vector，避免多线程同时而引起的不一致性，但实现同步需要很高的花费，因此访问它比访问ArrayList慢。</p></blockquote></li><li><p>LinkList(链表)</p><blockquote><p>LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当做堆栈、队列和双向队列使用</p></blockquote></li></ul><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><blockquote><p>Set注重独一无二的性质，该体系结合用于存储无序(存入存出的顺序不一定相同)元素，值元素不能重复。对象的相等本质是对象的hashCode值(java是依据对象的内存地址计算出的此序号)判断的，如果想让两个不同的对象视为相等的，就必须覆盖Object的hashCode方法和equals方法</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/TIM%E5%9B%BE%E7%89%8720200529175509.png" alt="avatar"></p><h2 id="HashSet-Hash表"><a href="#HashSet-Hash表" class="headerlink" title="HashSet(Hash表)"></a>HashSet(Hash表)</h2><blockquote><p>哈希表存放的是哈希值。HashSet存储元素的顺序并不是按照存入时的顺序<code>(和List显然不同)</code>而是按照哈希值来存的所以取数据也是按照哈希值取的。元素的哈希值是通过元素的<code>hashcode</code>方法获取的，HashSet首先判断两个元素的哈希值，如果哈希值用于，接着会比较<code>equals</code>方法如果equals结果为true，HashSet就视为同一个元素。如果equals为false就不是同一个元素。</p></blockquote><blockquote><p>哈希值相同equals为false的元素是怎么存储呢？就是在同样的哈希值下顺延<code>(可以认为哈希值相同的元素放在一个哈希桶中)</code>也就是哈希一样的存一列。如图1所示表示hashCode值不相同的情况;图2表示hashCode值相同，但是equals不相同情况。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/TIM%E5%9B%BE%E7%89%8720200529102233.png" alt="avatar"></p><blockquote><p>HashSet通过hashCode值来确定元素在内存中的位置。一个hashCode位置上可以存放多个元素。</p></blockquote><h2 id="TreeSet-二叉树"><a href="#TreeSet-二叉树" class="headerlink" title="TreeSet(二叉树)"></a>TreeSet(二叉树)</h2><ul><li><p>TreeSet()是使用二叉树的原理对新add()的对象按照指定的顺序排序(升序、降序)，每增加一个对象都会进行进行排序，将对象插入的二叉树指定的位置。</p></li><li><p>Integer和String对象都可以进行默认的TreeSet排序，而自定义类的对象是不可以的，<code>自己定义的类必须实现Comparable接口，并且复写相应的compareTo()函数</code>，才可以正常使用。</p></li><li><p>在覆写compare()函数时，要返回相应的值才能使TreeSet按照一定的规则来排序</p></li><li><p>在比较此对象与指定对象的顺序。如果该对象大小，等于或大于指定对象，则分别防护负整数、零或正整数。</p></li></ul><h2 id="LinkHashSet-HashSet-LinkedHashMap"><a href="#LinkHashSet-HashSet-LinkedHashMap" class="headerlink" title="LinkHashSet(HashSet+LinkedHashMap)"></a>LinkHashSet(HashSet+LinkedHashMap)</h2><blockquote><p>对于LinkedHashSet而言，它继承与HashSet、又基于LinkedHashMap来实现的。LinkedHashSet底层使用LinkedHashMap来保存所有元素，它继承于HashSet，其所有的方法操作上又与HashSet相同，因此LinkedHashSet的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个LinkedHashMap来实现，在相关操作上与父类HashSet的操作相同，直接调用父类HashSet的方法即可。</p></blockquote><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/TIM%E5%9B%BE%E7%89%8720200530115930.png" alt="avatar"></p><h2 id="HashMap-数组-链表-红黑树"><a href="#HashMap-数组-链表-红黑树" class="headerlink" title="HashMap(数组+链表+红黑树)"></a>HashMap(数组+链表+红黑树)</h2><blockquote><p>HashMap 根据键的 hashCode 值存储数据,大多数情况下可以直接定位到它的值,因而具有很快<br> 的访问速度,但遍历顺序却是不确定的。 HashMap 最多只允许一条记录的键为 null,允许多条记<br> 录的值为 null。HashMap 非线程安全,即任一时刻可以有多个线程同时写 HashMap,可能会导<br> 致数据的不一致。如果需要满足线程安全,可以用 Collections 的 synchronizedMap 方法使<br> HashMap 具有线程安全的能力,或者使用 ConcurrentHashMap。我们用下面这张图来介绍<br> HashMap 的结构。</p></blockquote><h2 id="Java7实现"><a href="#Java7实现" class="headerlink" title="Java7实现"></a>Java7实现</h2><blockquote><p>Java7HashMap结构</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/TIM%E5%9B%BE%E7%89%8720200530121604.png" alt="avatar"></p><blockquote><p>大方向上,HashMap 里面是一个数组,然后数组中每个元素是一个单向链表。上图中,每个绿色<br>的实体是嵌套类 Entry 的实例,Entry 包含四个属性:key, value, hash 值和用于单向链表的 next。</p></blockquote><ol><li>capacity:当前数组容量,始终保持 2^n,可以扩容,扩容后数组大小为当前的 2 倍。</li><li>loadFactor:负载因子,默认为 0.75。</li><li>threshold:扩容的阈值,等于 capacity * loadFactor</li></ol><h2 id="Java8实现"><a href="#Java8实现" class="headerlink" title="Java8实现"></a>Java8实现</h2><blockquote><p>Java8 对 HashMap 进行了一些修改,最大的不同就是利用了红黑树,所以其由 数组+链表+红黑<br> 树 组成。<br> 根据 Java7 HashMap 的介绍,我们知道,查找的时候,根据 hash 值我们能够快速定位到数组的<br> 具体下标,但是之后的话,需要顺着链表一个个比较下去才能找到我们需要的,时间复杂度取决<br> 于链表的长度,为 O(n)。为了降低这部分的开销,在 Java8 中,当链表中的元素超过了 8 个以后,<br> 会将链表转换为红黑树,在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</p></blockquote><blockquote><p>Java8 HashMap结构</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/TIM%E5%9B%BE%E7%89%8720200530121933.png" alt="avatar"></p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="Segment-段"><a href="#Segment-段" class="headerlink" title="Segment 段"></a>Segment 段</h3><blockquote><p>ConcurrentHashMap 和 HashMap 思路是差不多的,但是因为它支持并发操作,所以要复杂一<br>些。整个 ConcurrentHashMap 由一个个 Segment 组成,Segment 代表”部分“或”一段“的<br>意思,所以很多地方都会将其描述为分段锁。注意,行文中,我很多地方用了“槽”来代表一个segment。</p></blockquote><h3 id="线程安全-Segment-继承-ReentrantLock-加锁"><a href="#线程安全-Segment-继承-ReentrantLock-加锁" class="headerlink" title="线程安全(Segment 继承 ReentrantLock 加锁)"></a>线程安全(Segment 继承 ReentrantLock 加锁)</h3><blockquote><p>简单理解就是,ConcurrentHashMap 是一个 Segment 数组,Segment 通过继承<br>ReentrantLock 来进行加锁,所以每次需要加锁的操作锁住的是一个 segment,这样只要保证每<br>个 Segment 是线程安全的,也就实现了全局的线程安全。</p></blockquote><h4 id="Java7-ConcurrentHashMap结构"><a href="#Java7-ConcurrentHashMap结构" class="headerlink" title="Java7 ConcurrentHashMap结构"></a>Java7 ConcurrentHashMap结构</h4><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/TIM%E5%9B%BE%E7%89%8720200530122248.png" alt="avatar"></p><h4 id="并行度-默认-16"><a href="#并行度-默认-16" class="headerlink" title="并行度(默认 16)"></a>并行度(默认 16)</h4><blockquote><p>concurrencyLevel:并行级别、并发数、Segment 数,怎么翻译不重要,理解它。默认是 16,<br>也就是说 ConcurrentHashMap 有 16 个 Segments,所以理论上,这个时候,最多可以同时支<br>持 16 个线程并发写,只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时<br>候设置为其他值,但是一旦初始化以后,它是不可以扩容的。再具体到每个 Segment 内部,其实<br>每个 Segment 很像之前介绍的 HashMap,不过它要保证线程安全,所以处理起来要麻烦些。</p></blockquote><h4 id="Java8-ConcurrentHashMap结构"><a href="#Java8-ConcurrentHashMap结构" class="headerlink" title="Java8 ConcurrentHashMap结构"></a>Java8 ConcurrentHashMap结构</h4><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/TIM%E5%9B%BE%E7%89%8720200530122718.png" alt="avatar"></p><h2 id="HashTable-线程安全"><a href="#HashTable-线程安全" class="headerlink" title="HashTable(线程安全)"></a>HashTable(线程安全)</h2><p>Hashtable 是遗留类,很多映射的常用功能与 HashMap 类似,不同的是它承自 Dictionary 类,<br>并且是线程安全的,任一时间只有一个线程能写 Hashtable,并发性不如 ConcurrentHashMap,<br>因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用,不需要线程安全<br>的场合可以用 HashMap 替换,需要线程安全的场合可以用 ConcurrentHashMap 替换。</p><h2 id="TreeMap-可排序"><a href="#TreeMap-可排序" class="headerlink" title="TreeMap(可排序)"></a>TreeMap(可排序)</h2><p>TreeMap 实现 SortedMap 接口,能够把它保存的记录根据键排序,默认是按键值的升序排序,<br>也可以指定排序的比较器,当用 Iterator 遍历 TreeMap 时,得到的记录是排过序的。<br>如果使用排序的映射,建议使用 TreeMap。<br>在使用 TreeMap 时,key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的<br>Comparator,否则会在运行时抛出 java.lang.ClassCastException 类型的异常。</p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-tree/index.html">参考</a></p><h2 id="LinkHashMap-记录插入顺序"><a href="#LinkHashMap-记录插入顺序" class="headerlink" title="LinkHashMap(记录插入顺序)"></a>LinkHashMap(记录插入顺序)</h2><p>LinkedHashMap 是 HashMap 的 一 个 子 类 , 保 存 了 记 录 的 插 入 顺 序 , 在 用 Iterator 遍 历<br>LinkedHashMap 时,先得到的记录肯定是先插入的,也可以在构造时带参数,按照访问次序排序。</p><p><a href="http://www.importnew.com/28263.html">参考 1</a><br><a href="http://www.importnew.com/20386.html#comment-648123">参考 2</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Collection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阅读书单</title>
    <link href="/2020/05/27/another/%E5%85%B6%E4%BB%96%E7%AF%87-%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95/"/>
    <url>/2020/05/27/another/%E5%85%B6%E4%BB%96%E7%AF%87-%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="电子书网站"><a href="#电子书网站" class="headerlink" title="电子书网站"></a>电子书网站</h1><p><a href="cn.epubee.com/books">cn.epubee.com</a></p><p><a href="www.jiumodiary.com">www.jiumodiary.com</a></p><p><a href="www.owllook.net">www.owllook.net</a></p><p><a href="mebook.cc">mebook.cc</a></p><p><a href="www.xilinjie.com">www.xilinjie.com</a></p><p><a href="bookfere.com">bookfere.com</a></p><p><a href="www.pansoso.com">www.pansoso.com</a></p><p><a href="dianzishu.renrensousuo.com">dianzishu.renrensousuo.com</a></p><p><a href="www.pdfzj.cn">www.pdfzj.cn</a></p><p><a href="www.book118.com">www.book118.com</a></p><p><a href="sobooks.cc">sobooks.cc</a></p><p><a href="kgbook.com">kgbook.com</a></p><p><a href="www.en8848.com.cn/Soft/">www.en8848.com.cn</a></p><p><a href="cn.epubee.com/books/">cn.epubee.com</a></p><p><a href="bestcbooks.com">bestcbooks.com</a></p><h1 id="智商"><a href="#智商" class="headerlink" title="智商"></a>智商</h1><ul><li><a href="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/pdf/%E8%89%BE%E5%BE%B7%E5%8B%92%EF%BC%8C%E8%8C%83%E5%A4%9A%E4%BC%A6%E3%80%8A%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E3%80%8B%EF%BC%88%E7%BE%8E%EF%BC%89.pdf">如何阅读一本书</a></li><li>精进</li><li>学习之道</li><li>刻意练习</li><li>学会提问</li><li>撤掉思维里面的墙</li><li>故事思维</li><li>创新：皮克斯的启示</li><li>高效的秘密</li><li>沃顿商学院最欢迎的谈判课</li><li>羊皮卷</li></ul><h1 id="情商"><a href="#情商" class="headerlink" title="情商"></a>情商</h1><ul><li>蔡永康的说话之道</li><li>人性的优点</li><li>人性的弱点</li><li>和任何人都聊得来</li><li>沟通的艺术</li><li>高难度谈话</li><li>情商</li><li>心动开关</li><li>像TED一样演讲</li><li>乔布斯的魔力演讲</li></ul><h1 id="健康"><a href="#健康" class="headerlink" title="健康"></a>健康</h1><p>怎样吃东西才更健康<br>今天的东西为啥不好吃<br>第三个餐盘<br>营养补充剂真的有那么神奇<br>战胜饥饿<br>轻断食<br>食疗圣经<br>大脑塑造者<br>肠子的小心思  </p><h1 id="逆境"><a href="#逆境" class="headerlink" title="逆境"></a>逆境</h1><p>反脆弱<br>怦然心动的人生整理魔法<br>自控力<br>世界如此险恶你要内心强大<br>冲破黑暗<br>告别玻璃心的13件事<br>习惯的力量<br>用毅力走向成功<br>另一种选择<br>不在乎的人生魔法  </p><h1 id="德体"><a href="#德体" class="headerlink" title="德体"></a>德体</h1><p>追风筝的人<br>战争与松脂<br>第23条军规<br>在暗室中<br>双生梦魇<br>百年孤独<br>罪与罚<br>狼图腾<br>平凡的世界<br>奇迹  </p><h1 id="财富"><a href="#财富" class="headerlink" title="财富"></a>财富</h1><p>魔鬼经济学1<br>魔鬼经济学2<br>贫穷的本质<br>负利率时代<br>与巴菲特共进午餐<br>投资中最简单的事<br>滚雪球<br>从零开始稳稳赚<br>百万富翁的思维密码<br>数字黄金  </p><h1 id="视野"><a href="#视野" class="headerlink" title="视野"></a>视野</h1><p>大国游戏  </p><h1 id="豆瓣TOP"><a href="#豆瓣TOP" class="headerlink" title="豆瓣TOP"></a>豆瓣TOP</h1><p>1.《百年孤独》 （豆瓣评分：9.2)<br>2.《如何阅读一本书》 （豆瓣评分：8.5)<br>3.《少有人走的路》 （豆瓣评分：8.4)<br>4.《乌合之众》 （豆瓣评分：8.4)<br>5.《追风筝的人》 （豆瓣评分：8.8)<br>6.《万历十五年》 （豆瓣评分：8.9)<br>7.《红楼梦》 （豆瓣评分：9.5)<br>8.《三体》 （豆瓣评分：8.8)<br>9.《失控》 （豆瓣评分：8.8)<br>10.《白夜行》 （豆瓣评分：9.1)<br>11.《不能承受的生命之轻》 （豆瓣评分：8.4)<br>12.《社会心理学》 （豆瓣评分：9)<br>13.《心理学与生活》 （豆瓣评分：8.7)<br>14.《小王子》 （豆瓣评分：9)<br>15.《影响力》 （豆瓣评分：8.6)<br>16.《哥德尔、艾舍尔、巴赫》 （豆瓣评分：9.4)<br>17.《通往奴役之路》 （豆瓣评分：8.9)<br>18.《历史深处的忧虑》 （豆瓣评分：9)<br>19.《霍乱时期的爱情》 （豆瓣评分：9)<br>20.《枪炮、病菌与钢铁》 （豆瓣评分：8.8)<br>21.《月亮和六便士》 （豆瓣评分：9)<br>22.《论美国的民主》 （豆瓣评分：9.2)<br>23.《送你一颗子弹》 （豆瓣评分：8.6)<br>24.《中国历代政治得失》 （豆瓣评分：9.1)<br>25.《文学回忆录（全2册)   》 （豆瓣评分：9.2)<br>26.《围城》 （豆瓣评分：8.9)<br>27.《民主的细节》 （豆瓣评分：8.6)<br>28.《寻路中国》 （豆瓣评分：9)<br>29.《人类简史》 （豆瓣评分：9.3)<br>30.《艺术的故事》 （豆瓣评分：9.6)<br>31.《解忧杂货店》 （豆瓣评分：8.6)<br>32.《看不见的城市》 （豆瓣评分：8.8)<br>33.《天才在左 疯子在右》 （豆瓣评分：8.3)<br>34.《高效能人士的七个习惯（精华版)   》 （豆瓣评分：8.2)<br>35.《设计中的设计》 （豆瓣评分：8.6)<br>36.《目送》 （豆瓣评分：8.7)<br>37.《看见》 （豆瓣评分：8.8)<br>38.《江城》 （豆瓣评分：9)<br>39.《娱乐至死》 （豆瓣评分：8.6)<br>40.《情人》 （豆瓣评分：8.1)<br>41.《把时间当作朋友》 （豆瓣评分：8.6)<br>42.《社会契约论》 （豆瓣评分：8.8)<br>43.《我们仨》 （豆瓣评分：8.6)<br>44.《社会性动物》 （豆瓣评分：9.1)<br>45.《理想国》 （豆瓣评分：8.7)<br>46.《自控力》 （豆瓣评分：8.3)<br>47.《思考，快与慢》 （豆瓣评分：8.3)<br>48.《国史大纲（上下)   》 （豆瓣评分：9.3)<br>49.《写给大家看的设计书（第3版)   》 （豆瓣评分：8.6)<br>50.《狂热分子》 （豆瓣评分：9.1)<br>51.《遇见未知的自己》 （豆瓣评分：8.1)<br>52.《苏菲的世界》 （豆瓣评分：8.5)<br>53.《天朝的崩溃》 （豆瓣评分：9)<br>54.《这些人，那些事》 （豆瓣评分：8.8)<br>55.《嫌疑人X的献身》 （豆瓣评分：8.9)<br>56.《牧羊少年奇幻之旅》 （豆瓣评分：8.7)<br>57.《浪潮之巅》 （豆瓣评分：9.1)<br>58.《挪威的森林》 （豆瓣评分：8)<br>59.《菊与刀》 （豆瓣评分：8.2)<br>60.《一九八四》 （豆瓣评分：9.3)<br>61.《史记（全十册)   》 （豆瓣评分：9.5)<br>62.《查令十字街84号》 （豆瓣评分：8.4)<br>63.《从一到无穷大》 （豆瓣评分：9.1)<br>64.《爱的艺术》 （豆瓣评分：8.8)<br>65.《决策与判断》 （豆瓣评分：8.5)<br>66.《黑客与画家》 （豆瓣评分：8.8)<br>67.《学会提问》 （豆瓣评分：8.6)<br>68.《心是孤独的猎手》 （豆瓣评分：8.5)<br>69.《点石成金》 （豆瓣评分：8.5)<br>70.《自私的基因》 （豆瓣评分：8.7)<br>71.《孤独六讲》 （豆瓣评分：8.1)<br>72.《最好的告别》 （豆瓣评分：9)<br>73.《卡拉马佐夫兄弟》 （豆瓣评分：9.3)<br>74.《窗边的小豆豆》 （豆瓣评分：8.7)<br>75.《刀锋》 （豆瓣评分：9)<br>76.《三体Ⅱ》 （豆瓣评分：9.2)<br>77.《故事》 （豆瓣评分：9.2)<br>78.《亲爱的安德烈》 （豆瓣评分：8.7)<br>79.《三体Ⅲ》 （豆瓣评分：9.2)<br>80.《卓有成效的管理者》 （豆瓣评分：8.8)<br>81.《沟通的艺术（插图修订第14版)   》 （豆瓣评分：8.7)<br>82.《《华尔街日报》是如何讲故事的》 （豆瓣评分：8.4)<br>83.《当我谈跑步时我谈些什么》 （豆瓣评分：8.1)<br>84.《活着》 （豆瓣评分：9.1)<br>85.《中国大历史》 （豆瓣评分：8.3)<br>86.《西方哲学史（上卷)   》 （豆瓣评分：8.9)<br>87.《夹边沟记事》 （豆瓣评分：9.1)<br>88.《无声告白》 （豆瓣评分：8.2)<br>89.《定位》 （豆瓣评分：8.3)<br>90.《何以笙箫默》 （豆瓣评分：8)<br>91.《总统是靠不住的》 （豆瓣评分：8.8)<br>92.《设计心理学》 （豆瓣评分：8.2)<br>93.《万物静默如谜》 （豆瓣评分：8.5)<br>94.《平凡的世界（全三部)   》 （豆瓣评分：9)<br>95.《我也有一个梦想》 （豆瓣评分：9)<br>96.《最初的爱情 最后的仪式》 （豆瓣评分：8)<br>97.《规训与惩罚》 （豆瓣评分：9.1)<br>98.《认识电影》 （豆瓣评分：8.9)<br>99.《沉默的大多数》 （豆瓣评分：9.1)<br>100.《带一本书去巴黎》 （豆瓣评分：8.5)<br>101.《学习之道（第2版)   》 （豆瓣评分：8.3)<br>102.《君主论》 （豆瓣评分：8.7)<br>103.《耶路撒冷三千年》 （豆瓣评分：8)<br>104.《玫瑰的名字》 （豆瓣评分：8.5)<br>105.《万物：创世》 （豆瓣评分：8.9)<br>106.《拖延心理学》 （豆瓣评分：8.2)<br>107.《进化心理学》 （豆瓣评分：8.9)<br>108.《史蒂夫·乔布斯传》 （豆瓣评分：8.7)<br>109.《悉达多》 （豆瓣评分：9)<br>110.《叫魂》 （豆瓣评分：8.9)<br>111.《非暴力沟通》 （豆瓣评分：8.5)<br>112.《金字塔原理》 （豆瓣评分：8.1)<br>113.《时间简史》 （豆瓣评分：8.8)<br>114.《唯有孤独恒常如新》 （豆瓣评分：8.2)<br>115.《光荣与梦想》 （豆瓣评分：8.9)<br>116.《乡关何处》 （豆瓣评分：8.6)<br>117.《巨流河》 （豆瓣评分：8.7)<br>118.《旧制度与大革命》 （豆瓣评分：8.9)<br>119.《斯通纳》 （豆瓣评分：8.8)<br>120.《恶意》 （豆瓣评分：8.4)<br>121.《灿烂千阳》 （豆瓣评分：8.8)<br>122.《常识》 （豆瓣评分：8.1)<br>123.《发现之旅》 （豆瓣评分：9)<br>124.《悲伤与理智》 （豆瓣评分：8.7)<br>125.《穷查理宝典》 （豆瓣评分：9)<br>126.《永恒的终结》 （豆瓣评分：9)<br>127.《局外人》 （豆瓣评分：9)<br>128.《聪明的投资者》 （豆瓣评分：9)<br>129.《激荡三十年（上)   》 （豆瓣评分：8.8)<br>130.《极权主义的起源》 （豆瓣评分：8.7)<br>131.《计算机程序的构造和解释》 （豆瓣评分：9.5)<br>132.《上帝掷股子吗》 （豆瓣评分：9.2)<br>133.《伟大的博弈》 （豆瓣评分：8.3)<br>134.《三生三世 十里桃花》 （豆瓣评分：8.3)<br>135.《暗时间》 （豆瓣评分：8.5)<br>136.《人生的枷锁》 （豆瓣评分：9)<br>137.《创业维艰》 （豆瓣评分：8.5)<br>138.《开放社会及其敌人（全二卷)   》 （豆瓣评分：8.9)<br>139.《瓦尔登湖》 （豆瓣评分：8.5)<br>140.《动物农场》 （豆瓣评分：9.2)<br>141.《精益创业》 （豆瓣评分：8.4)<br>142.《旅行的艺术》 （豆瓣评分：8.3)<br>143.《论自由》 （豆瓣评分：8.7)<br>144.《三国演义（全二册)   》 （豆瓣评分：9.2)<br>145.《万物有灵且美》 （豆瓣评分：8.8)<br>146.《正义论》 （豆瓣评分：8.8)<br>147.《繁花》 （豆瓣评分：8.7)<br>148.《巴菲特致股东的信》 （豆瓣评分：8.3)<br>149.《别做正常的傻瓜》 （豆瓣评分：8.2)<br>150.《路西法效应》 （豆瓣评分：8.6)<br>151.《经济学原理》 （豆瓣评分：9.4)<br>152.《什么是数学》 （豆瓣评分：9.1)<br>153.《退步集》 （豆瓣评分：8.1)<br>154.《如何阅读一本小说》 （豆瓣评分：8.1)<br>155.《潜规则》 （豆瓣评分：8.3)<br>156.《批评官员的尺度》 （豆瓣评分：8.9)<br>157.《美国大城市的死与生（纪念版)   》 （豆瓣评分：8.7)<br>158.《源泉》 （豆瓣评分：9.1)<br>159.《新教伦理与资本主义精神》 （豆瓣评分：8.8)<br>160.《存在与时间》 （豆瓣评分：8.7)<br>161.《美丽新世界》 （豆瓣评分：8.5)<br>162.《正见》 （豆瓣评分：8.8)<br>163.《万物简史》 （豆瓣评分：8.8)<br>164.《美国宪政历程》 （豆瓣评分：9.1)<br>165.《忧郁的热带》 （豆瓣评分：9.1)<br>166.《香水》 （豆瓣评分：8.5)<br>167.《异乡人》 （豆瓣评分：8.9)<br>168.《华婿引（全二册)   》 （豆瓣评分：8.6)<br>169.《数学之美》 （豆瓣评分：8.7)<br>170.《焚舟纪》 （豆瓣评分：8.5)<br>171.《树上的男爵》 （豆瓣评分：9)<br>172.《上学记》 （豆瓣评分：8.8)<br>173.《国富论》 （豆瓣评分：9)<br>174.《人间词话》 （豆瓣评分：9)<br>175.《24个比利》 （豆瓣评分：8.3)<br>176.《1Q84 BOOK 1》 （豆瓣评分：8.3)<br>177.《与“众”不同的心理学》 （豆瓣评分：8.8)<br>178.《维特根斯坦传》 （豆瓣评分：9.1)<br>179.《微微一笑很倾城》 （豆瓣评分：8.2)<br>180.《午夜之子》 （豆瓣评分：8.4)<br>181.《平如美棠》 （豆瓣评分：9)<br>182.《天真的人类学家》 （豆瓣评分：8.8)<br>183.《人类的群星闪耀时》 （豆瓣评分：8.7)<br>184.《杀死一只知更鸟》 （豆瓣评分：9.2)<br>185.《算法导论（原书第2版)   》 （豆瓣评分：9.4)<br>186.《重来》 （豆瓣评分：8.3)<br>187.《乡土中国》 （豆瓣评分：9.2)<br>188.《疯癫与文明》 （豆瓣评分：8.7)<br>189.《伊斯坦布尔》 （豆瓣评分：8.4)<br>190.《圣经》 （豆瓣评分：9)<br>191.《利维坦》 （豆瓣评分：8.6)<br>192.《昨日的世界》 （豆瓣评分：9.2)<br>193.《肖申克的救赎》 （豆瓣评分：9.1)<br>194.《1984》 （豆瓣评分：9.3)<br>195.《小于一》 （豆瓣评分：8.6)<br>196.《经济学原理（上下)   》 （豆瓣评分：9)<br>197.《代码大全（第2版)   》 （豆瓣评分：9.3)<br>198.《精神分析引论》 （豆瓣评分：8.6)<br>199.《启示录》 （豆瓣评分：8.5)<br>200.《飘（上下)   》 （豆瓣评分：9.3)<br>201.《联邦党人文集》 （豆瓣评分：9)<br>202.《用户体验的要素》 （豆瓣评分：8.2)<br>203.《众病之王》 （豆瓣评分：9.1)<br>204.《一九八四·动物农场》 （豆瓣评分：9.2)<br>205.《情感化设计》 （豆瓣评分：8)<br>206.《哈利·波特与魔法石》 （豆瓣评分：9)<br>207.《追寻记忆的痕迹》 （豆瓣评分：8.9)<br>208.《拆掉思维里的墙》 （豆瓣评分：8)<br>209.《邓小平时代》 （豆瓣评分：8.8)<br>210.《作为意志和表象的世界》 （豆瓣评分：8.9)<br>211.《怪诞行为学》 （豆瓣评分：8.1)<br>212.《哈扎尔辞典（阳本)   》 （豆瓣评分：8.8)<br>213.《时间旅行者的妻子》 （豆瓣评分：8.1)<br>214.《为什么读经典》 （豆瓣评分：8.3)<br>215.《致命的自负》 （豆瓣评分：8.8)<br>216.《安吉拉·卡特的精怪故事集》 （豆瓣评分：8)<br>217.《漫长的告别》 （豆瓣评分：8.1)<br>218.《十一种孤独》 （豆瓣评分：8.1)<br>219.《彼得·林奇的成功投资》 （豆瓣评分：8.7)<br>220.《沉思录》 （豆瓣评分：8.2)<br>221.《观念的水位》 （豆瓣评分：8.3)<br>222.《没有人给他写信的上校》 （豆瓣评分：8.5)<br>223.《晚清七十年 （全五册)   》 （豆瓣评分：8.8)<br>224.《你今天真好看》 （豆瓣评分：8.8)<br>225.《姑获鸟之夏》 （豆瓣评分：8.1)<br>226.《博尔赫斯小说集》 （豆瓣评分：9.1)<br>227.《来自新世界 （上下)   》 （豆瓣评分：9)<br>228.《逃避自由》 （豆瓣评分：8.9)<br>229.《我不知道该说什么，关于死亡还是爱情》 （豆瓣评分：8.9)<br>230.《设计中的设计 | 全本》 （豆瓣评分：9.1)<br>231.《策略思维》 （豆瓣评分：8.5)<br>232.《反脆弱》 （豆瓣评分：8.3)<br>233.《狼图腾》 （豆瓣评分：8.3)<br>234.《亲密关系》 （豆瓣评分：8.7)<br>235.《全球通史(上)》 （豆瓣评分：9.2)<br>236.《创新者的窘境》 （豆瓣评分：8.5)<br>237.《大问题》 （豆瓣评分：9)<br>238.《人间失格》 （豆瓣评分：8.3)<br>239.《简约至上》 （豆瓣评分：8.4)<br>240.《雕刻时光》 （豆瓣评分：9)<br>241.《你一定爱读的极简欧洲史》 （豆瓣评分：8.3)<br>242.《一桩事先张扬的凶杀案》 （豆瓣评分：8.6)<br>243.《达·芬奇密码》 （豆瓣评分：8.2)<br>244.《游戏改变世界》 （豆瓣评分：8.2)<br>245.《福尔摩斯探案全集（上中下)   》 （豆瓣评分：9.2)<br>246.《失物之书》 （豆瓣评分：8.5)<br>247.《股票作手回忆录》 （豆瓣评分：8.7)<br>248.《生命是什么》 （豆瓣评分：8.7)<br>249.《黄金时代》 （豆瓣评分：8.8)<br>250.《那些古怪又让人忧心的问题》 （豆瓣评分：8.2)<br>251.《东方快车谋杀案》 （豆瓣评分：9)<br>252.《顾淮文集》 （豆瓣评分：9.1)<br>253.《富爸爸，穷爸爸》 （豆瓣评分：8.2)<br>254.《论中国》 （豆瓣评分：8.6)<br>255.《金色梦乡》 （豆瓣评分：9)<br>256.《九故事》 （豆瓣评分：8.5)<br>257.《怦然心动的人生整理魔法》 （豆瓣评分：8)<br>258.《爱你就像爱生命》 （豆瓣评分：8.8)<br>259.《中国近代史（上册)   》 （豆瓣评分：9.4)<br>260.《禅与摩托车维修艺术》 （豆瓣评分：8.4)<br>261.《强风吹拂》 （豆瓣评分：9.1)<br>262.《浮生六记》 （豆瓣评分：8.9)<br>263.《活了100万次的猫》 （豆瓣评分：8.9)<br>264.《金融的逻辑》 （豆瓣评分：8)<br>265.《第二性》 （豆瓣评分：8.6)<br>266.《我的孤独是一座花园》 （豆瓣评分：8.7)<br>267.《美的历程》 （豆瓣评分：8.8)<br>268.《火星救援》 （豆瓣评分：8.9)<br>269.《无人生还》 （豆瓣评分：8.9)<br>270.《我执》 （豆瓣评分：8)<br>271.《野蛮大陆》 （豆瓣评分：9)<br>272.《ZOO》 （豆瓣评分：8.6)<br>273.《尤利西斯》 （豆瓣评分：8.4)<br>274.《冬牧场》 （豆瓣评分：9)<br>275.《偷影子的人》 （豆瓣评分：8)<br>276.《激荡三十年（下)   》 （豆瓣评分：8.9)<br>277.《野火集》 （豆瓣评分：8.8)<br>278.《大教堂》 （豆瓣评分：8.5)<br>279.《猜猜我有多爱你》 （豆瓣评分：9.3)<br>280.《了不起的盖茨比》 （豆瓣评分：8.3)<br>281.《一个人的朝圣》 （豆瓣评分：8.1)<br>282.《如彗星划过夜空》 （豆瓣评分：8.9)<br>283.《人性中的善良天使》 （豆瓣评分：8.8)<br>284.《历史研究》 （豆瓣评分：9.1)<br>285.《自由》 （豆瓣评分：8.5)<br>286.《十四堂人生创意课》 （豆瓣评分：8.2)<br>287.《新世界》 （豆瓣评分：8.9)<br>288.《毛姆短篇小说精选集》 （豆瓣评分：9.1)<br>289.《失明症漫记》 （豆瓣评分：9.1)<br>290.《公正》 （豆瓣评分：9.1)<br>291.《血酬定律》 （豆瓣评分：8.2)<br>292.《城记》 （豆瓣评分：8.7)<br>293.《天国之秋》 （豆瓣评分：8.7)<br>294.《美学散步》 （豆瓣评分：8.8)<br>295.《如果在冬夜，一个旅人》 （豆瓣评分：8.7)<br>296.《金融炼金术》 （豆瓣评分：8.4)<br>297.《孙子兵法》 （豆瓣评分：9.3)<br>298.《一个陌生女人的来信》 （豆瓣评分：8.7)<br>299.《德米安》 （豆瓣评分：9)<br>300.《傲慢与偏见》 （豆瓣评分：8.8)<br>301.《边城》 （豆瓣评分：8.6)<br>302.《铁皮鼓》 （豆瓣评分：8.5)<br>303.《悟空传》 （豆瓣评分：8.4)<br>304.《寻找家园》 （豆瓣评分：9.2)<br>305.《从优秀到卓越》 （豆瓣评分：8.1)<br>306.《1453：君士坦丁堡之战》 （豆瓣评分：9)<br>307.《证券分析》 （豆瓣评分：8.8)<br>308.《水浒传（全二册)   》 （豆瓣评分：8.5)<br>309.《秘密花园》 （豆瓣评分：8.1)<br>310.《海边的卡夫卡》 （豆瓣评分：8.1)<br>311.《西藏生死书》 （豆瓣评分：8.6)<br>312.《佛祖在一号线》 （豆瓣评分：8.2)<br>313.《超越时空》 （豆瓣评分：9)<br>314.《改变心理学的40项研究》 （豆瓣评分：8.8)<br>315.《C程序设计语言》 （豆瓣评分：9.4)<br>316.《中国文化要义》 （豆瓣评分：9)<br>317.《哪来的天才？》 （豆瓣评分：8)<br>318.《相约星期二》 （豆瓣评分：8.4)<br>319.《倾城之恋》 （豆瓣评分：8.5)<br>320.《阿拉伯的劳伦斯》 （豆瓣评分：9.1)<br>321.《城门开》 （豆瓣评分：8.4)<br>322.《孩子你慢慢来》 （豆瓣评分：8.8)<br>323.《中国法律与中国社会》 （豆瓣评分：9.2)<br>324.《被淹没和被拯救的》 （豆瓣评分：9.1)<br>325.《第五项修炼》 （豆瓣评分：8.5)<br>326.《日瓦戈医生》 （豆瓣评分：8.6)<br>327.《自由秩序原理》 （豆瓣评分：9)<br>328.《写作这回事》 （豆瓣评分：8.6)<br>329.《人生的智慧》 （豆瓣评分：9.3)<br>330.《占星术杀人魔法》 （豆瓣评分：8.4)<br>331.《基业长青》 （豆瓣评分：8.2)<br>332.《我的阿勒泰》 （豆瓣评分：8.8)<br>333.《江村经济》 （豆瓣评分：8.9)<br>334.《观看之道》 （豆瓣评分：8.3)<br>335.《设计模式》 （豆瓣评分：9.1)<br>336.《经济学的思维方式（第11版)   》 （豆瓣评分：8.7)<br>337.《渴望生活》 （豆瓣评分：9.2)<br>338.《古拉格：一部历史》 （豆瓣评分：9.2)<br>339.《超越死亡》 （豆瓣评分：9)<br>340.《你的灯亮着吗?》 （豆瓣评分：8.2)<br>341.《明朝那些事儿（一)   》 （豆瓣评分：8.8)<br>342.《当世界年纪还小的时候》 （豆瓣评分：8.6)<br>343.《中国哲学简史》 （豆瓣评分：8.8)<br>344.《资治通鑑（全二十册)   》 （豆瓣评分：9.3)<br>345.《生活与命运》 （豆瓣评分：9)<br>346.《西班牙旅行笔记》 （豆瓣评分：8.6)<br>347.《中国近代史》 （豆瓣评分：8.8)<br>348.《向前一步》 （豆瓣评分：8.1)<br>349.《谈谈方法》 （豆瓣评分：8.6)<br>350.《长恨歌》 （豆瓣评分：8.3)<br>351.《奇特的一生》 （豆瓣评分：8.3)<br>352.《夏洛的网》 （豆瓣评分：8.5)<br>353.《银河系漫游指南》 （豆瓣评分：8.8)<br>354.《清明上河图密码》 （豆瓣评分：8.2)<br>355.《二十首情诗和一首绝望的歌》 （豆瓣评分：8.3)<br>356.《中国文化的深层结构》 （豆瓣评分：8.6)<br>357.《简爱》 （豆瓣评分：8.5)<br>358.《一个广告人的自白》 （豆瓣评分：8.4)<br>359.《时间的针脚》 （豆瓣评分：8.4)<br>360.《华夏意匠》 （豆瓣评分：9.2)<br>361.《没有色彩的多崎作和他的巡礼之年》 （豆瓣评分：8.3)<br>362.《野蛮生长》 （豆瓣评分：8.3)<br>363.《我不喜欢这世界，我只喜欢你》 （豆瓣评分：8.2)<br>364.《全球通史(下)》 （豆瓣评分：9.2)<br>365.《魍魉之匣（上)   》 （豆瓣评分：8.5)<br>366.《质数的孤独》 （豆瓣评分：8)<br>367.《思考的技术》 （豆瓣评分：8)<br>368.《自由在高处》 （豆瓣评分：8.1)<br>369.《习惯的力量》 （豆瓣评分：8)<br>370.《刺猬的优雅》 （豆瓣评分：8.1)<br>371.《泛若不系之舟》 （豆瓣评分：8.6)<br>372.《基地》 （豆瓣评分：9.2)<br>373.《最好的我们》 （豆瓣评分：8.9)<br>374.《独裁者手册》 （豆瓣评分：8.9)<br>375.《别闹了，费曼先生》 （豆瓣评分：8.9)<br>376.《穆斯林的葬礼》 （豆瓣评分：8.3)<br>377.《人性的弱点全集》 （豆瓣评分：8.3)<br>378.《蝇王》 （豆瓣评分：8.2)<br>379.《不去会死！》 （豆瓣评分：8.2)<br>380.《我在伊朗长大》 （豆瓣评分：9.3)<br>381.《财富之城》 （豆瓣评分：8.9)<br>382.《逃离》 （豆瓣评分：8)<br>383.《对伪心理学说不》 （豆瓣评分：9.2)<br>384.《金雀花王朝》 （豆瓣评分：8.6)<br>385.《复杂》 （豆瓣评分：8.8)<br>386.《X的悲剧》 （豆瓣评分：8.5)<br>387.《八十年代访谈录》 （豆瓣评分：8.1)<br>388.《万有引力之虹》 （豆瓣评分：8.3)<br>389.《怎样选择成长股》 （豆瓣评分：8.5)<br>390.《我们的祖先》 （豆瓣评分：9.4)<br>391.《想象的共同体》 （豆瓣评分：8.8)<br>392.《此间的少年》 （豆瓣评分：8.4)<br>393.《所罗门王的指环》 （豆瓣评分：9.2)<br>394.《美的历史》 （豆瓣评分：8.4)<br>395.《认得几个字》 （豆瓣评分：8.2)<br>396.《好妈妈胜过好老师》 （豆瓣评分：9.1)<br>397.《万火归一》 （豆瓣评分：8.7)<br>398.《万万没想到》 （豆瓣评分：8.5)<br>399.《风之影》 （豆瓣评分：8.6)<br>400.《恶童日记》 （豆瓣评分：8.6)<br>401.《步步惊心》 （豆瓣评分：8.1)<br>402.《项塔兰》 （豆瓣评分：9.1)<br>403.《惶然录》 （豆瓣评分：9)<br>404.《佳期如梦》 （豆瓣评分：8)<br>405.《大卫，不可以》 （豆瓣评分：8.8)<br>406.《共 产党宣言》 （豆瓣评分：8.6)<br>407.《逻辑哲学论》 （豆瓣评分：9.1)<br>408.《爱弥儿》 （豆瓣评分：8.7)<br>409.《传统十论》 （豆瓣评分：9.1)<br>410.《全球通史（第7版 上册)   》 （豆瓣评分：8.9)<br>411.《奥克诺斯》 （豆瓣评分：9.1)<br>412.《大萝卜和难挑的鳄梨》 （豆瓣评分：8.1)<br>413.《冰与火之歌（卷一)   》 （豆瓣评分：9.3)<br>414.《交往与空间》 （豆瓣评分：8.8)<br>415.《消费社会》 （豆瓣评分：8.4)<br>416.《纯粹理性批判》 （豆瓣评分：8.9)<br>417.《1Q84 BOOK 2》 （豆瓣评分：8.4)<br>418.《一朵桔梗花》 （豆瓣评分：8.5)<br>419.《荆棘鸟》 （豆瓣评分：8.6)<br>420.《大英博物馆世界简史（全3册)   》 （豆瓣评分：9.2)<br>421.《偷书贼》 （豆瓣评分：8)<br>422.《杂草的故事》 （豆瓣评分：8.4)<br>423.《深夜食堂 01》 （豆瓣评分：9)<br>424.《理解媒介》 （豆瓣评分：8.5)<br>425.《毛姆传》 （豆瓣评分：8.4)<br>426.《蛤蟆的油》 （豆瓣评分：8.4)<br>427.《电影艺术（插图第8版)   》 （豆瓣评分：8.9)<br>428.《道德经》 （豆瓣评分：9.4)<br>429.《过于喧嚣的孤独》 （豆瓣评分：8.8)<br>430.《圣诞忆旧集》 （豆瓣评分：8.6)<br>431.《台北人》 （豆瓣评分：8.9)<br>432.《伯罗奔尼撒战争史》 （豆瓣评分：8.9)<br>433.《洞穴奇案》 （豆瓣评分：9.1)<br>434.《万物既伟大又渺小》 （豆瓣评分：9)<br>435.《2666》 （豆瓣评分：8.6)<br>436.《神们自己》 （豆瓣评分：8.4)<br>437.《月光落在左手上》 （豆瓣评分：8.3)<br>438.《给孩子的诗》 （豆瓣评分：8.2)<br>439.《迷宫中的将军》 （豆瓣评分：8.6)<br>440.《天龙八部》 （豆瓣评分：9)<br>441.《老子注译及评介》 （豆瓣评分：9.2)<br>442.《大败局》 （豆瓣评分：8.3)<br>443.《梦中的欢快葬礼和十二个异乡故事》 （豆瓣评分：8.6)<br>444.《重新认识你自己》 （豆瓣评分：8.6)<br>445.《高难度谈话》 （豆瓣评分：8.2)<br>446.《版式设计原理》 （豆瓣评分：8.4)<br>447.《改变》 （豆瓣评分：8.5)<br>448.《追忆似水年华》 （豆瓣评分：9.1)<br>449.《街道的美学》 （豆瓣评分：8.6)<br>450.《社会学的想像力》 （豆瓣评分：8.6)<br>451.《文明的冲突与世界秩序的重建》 （豆瓣评分：8.4)<br>452.《金阁寺》 （豆瓣评分：8.6)<br>453.《未央歌》 （豆瓣评分：8.4)<br>454.《无缘社会》 （豆瓣评分：8.4)<br>455.《没有个性的人》 （豆瓣评分：9)<br>456.《一个村庄里的中国》 （豆瓣评分：8)<br>457.《深入理解计算机系统》 （豆瓣评分：9.5)<br>458.《生活在别处》 （豆瓣评分：8.3)<br>459.《忧伤的时候，到厨房去》 （豆瓣评分：8.2)<br>460.《我的精神家园》 （豆瓣评分：9)<br>461.《纳尔齐斯与歌尔德蒙》 （豆瓣评分：9.2)<br>462.《许三观卖血记》 （豆瓣评分：8.7)<br>463.《文明之光（第一册)   》 （豆瓣评分：9)<br>464.《单向度的人》 （豆瓣评分：8.4)<br>465.《莲花》 （豆瓣评分：8)<br>466.《所有我们看不见的光》 （豆瓣评分：9)<br>467.《门萨的娼妓》 （豆瓣评分：8)<br>468.《脑髓地狱》 （豆瓣评分：8)<br>469.《我爱问连岳》 （豆瓣评分：8.1)<br>470.《信息简史》 （豆瓣评分：8.8)<br>471.《那些回不去的年少时光》 （豆瓣评分：8.5)<br>472.《政府论（下篇)   》 （豆瓣评分：8.9)<br>473.《袁氏当国》 （豆瓣评分：8.5)<br>474.《集体行动的逻辑》 （豆瓣评分：8.5)<br>475.《商业模式新生代》 （豆瓣评分：8.4)<br>476.《童年的消逝》 （豆瓣评分：8.4)<br>477.《寂静的春天》 （豆瓣评分：8.3)<br>478.《呼啸山庄》 （豆瓣评分：8.4)<br>479.《罗伯特议事规则》 （豆瓣评分：8.7)<br>480.《深入理解计算机系统（原书第2版)   》 （豆瓣评分：9.7)<br>481.《纯真博物馆》 （豆瓣评分：8.1)<br>482.《编程珠玑》 （豆瓣评分：9.2)<br>483.《金枝（上下册)   》 （豆瓣评分：8.8)<br>484.《重新发现社会》 （豆瓣评分：8.4)<br>485.《看海的人》 （豆瓣评分：8.4)<br>486.《最好的时光》 （豆瓣评分：8.4)<br>487.《云中歌1》 （豆瓣评分：8.2)<br>488.《就业、利息和货币通论》 （豆瓣评分：8.6)<br>489.《致D》 （豆瓣评分：8.5)<br>490.《世界尽头与冷酷仙境》 （豆瓣评分：8.5)<br>491.《喜宝》 （豆瓣评分：8.1)<br>492.《巴黎评论·作家访谈Ⅰ》 （豆瓣评分：9)<br>493.《西方美学史》 （豆瓣评分：8.7)<br>494.《海子诗全集》 （豆瓣评分：9.2)<br>495.《失落的一角》 （豆瓣评分：8.8)<br>496.《博尔赫斯谈话录》 （豆瓣评分：8.8)<br>497.《自杀论》 （豆瓣评分：8.4)<br>498.《我脑袋里的怪东西》 （豆瓣评分：8.7)<br>499.《诗学》 （豆瓣评分：8.9)<br>500.《如何读，为什么读》 （豆瓣评分：8.4)   </p>]]></content>
    
    
    <categories>
      
      <category>书籍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>书籍</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java IO/NIO</title>
    <link href="/2020/05/27/java/Java-IO-NIO/"/>
    <url>/2020/05/27/java/Java-IO-NIO/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="阻塞IO模型"><a href="#阻塞IO模型" class="headerlink" title="阻塞IO模型"></a>阻塞IO模型</h1><blockquote><p>最传统的一种IO模型，即在读写数据过程中会发生阻塞现象。当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程用户线程才解除block状态。典型的阻塞IO模型的例子为：data = socket.read();如果数据没有就绪就会一种阻塞在read方法。</p></blockquote><h1 id="非阻塞IO模型"><a href="#非阻塞IO模型" class="headerlink" title="非阻塞IO模型"></a>非阻塞IO模型</h1><blockquote><p>当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error时，他就知道数据还没有准备好，于是他可以再次发送read操作。一旦内核中的数据准备好了，并且有再次接收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。所以事实上在非阻塞IO模型中，用户线程需要不断的询问内核数据是否就绪，也就是说非阻塞IO不会交出CPU而是一直占用CPU。典型的非阻塞IO模型如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <br>    data = socket.read();<br>    <br>    <span class="hljs-keyword">if</span> (data!= error)&#123;<br>        <span class="hljs-comment">//处理数据</span><br>        <span class="hljs-keyword">break</span>;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>但是对于非阻塞IO就有一个非常严重的问题，在while循环中需要不断的去询问内核数据是否就绪，这样导致CPU占用率非常高，因此一般情况下很少使用while循环这种方式来读取数据。</p><h1 id="多路复用IO模型"><a href="#多路复用IO模型" class="headerlink" title="多路复用IO模型"></a>多路复用IO模型</h1><blockquote><p>多路复用IO模型是目前使用的比较多的模型。Java NIO实际上就是多路复用IO。在对多路复用IO模型中，会有一个线程不断的去轮询多个socket的状态，只有当socket真正有读写事件时，才正真调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。在JavaNIO中，是通过<code>selector,select()</code>去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。多路复用IO模式，通过一个线程就可以管理多个socket，只有当socket真正有读写事件发生才会占用资源进行实际的读写操作。因此，多路复用IO比较时候连接数比较多的情况。</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">另外多路复用IO为何非阻塞IO模型的效率是因为在非阻塞IO中，不断的询问socket状态时通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程高得多。<br></code></pre></td></tr></table></figure><p>不过要注意的是，多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。</p><h1 id="信号驱动IO模型"><a href="#信号驱动IO模型" class="headerlink" title="信号驱动IO模型"></a>信号驱动IO模型</h1><p>在信号驱动 IO 模型中,当用户线程发起一个 IO 请求操作,会给对应的 socket 注册一个信号函<br>数,然后用户线程会继续执行,当内核数据就绪时会发送一个信号给用户线程,用户线程接收到<br>信号之后,便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作。</p><h1 id="异步-IO-模型"><a href="#异步-IO-模型" class="headerlink" title="异步 IO 模型"></a>异步 IO 模型</h1><p>异步 IO 模型才是最理想的 IO 模型,在异步 IO 模型中,当用户线程发起 read 操作之后,立刻就<br>可以开始去做其它的事。而另一方面,从内核的角度,当它受到一个 asynchronous read 之后,<br>它会立刻返回,说明 read 请求已经成功发起了,因此不会对用户线程产生任何 block。然后,内<br>核会等待数据准备完成,然后将数据拷贝到用户线程,当这一切都完成之后,内核会给用户线程<br>发送一个信号,告诉它 read 操作完成了。也就说用户线程完全不需要实际的整个 IO 操作是如何<br>进行的,只需要先发起一个请求,当接收内核返回的成功信号时表示 IO 操作已经完成,可以直接<br>去使用数据了。</p><blockquote><p>也就说在异步 IO 模型中,IO 操作的两个阶段都不会阻塞用户线程,这两个阶段都是由内核自动完<br>成,然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用 IO 函数进行具体的<br>读写。这点是和信号驱动模型有所不同的,在信号驱动模型中,当用户线程接收到信号表示数据<br>已经就绪,然后需要用户线程调用 IO 函数进行实际的读写操作;而在异步 IO 模型中,收到信号<br>表示 IO 操作已经完成,不需要再在用户线程中调用 IO 函数进行实际的读写操作。</p></blockquote><p>[注意]<code>异步 IO 是需要操作系统的底层支持,在 Java 7 中,提供了 Asynchronous IO。</code></p><p><a href="http://www.importnew.com/19816.html">参考</a></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/javaio.png" alt="avatar"></p><h1 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h1><blockquote><p>NIO主要有三大核心部分:Channel(通道)，Buffer(缓冲区)，Selector。传统IO基于字节流和字符流进行操作而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入通道中。Selector(选择区)用于监听多个通道的事件(比如：连接打开，数据到达)。因此，单线程可以监控多个数据通道。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/java_nio_network_model.png" alt="avatar"></p><p>NIO和传统IO之间第一个最大的区别是，<code>IO是面向流的，NIO是面向缓冲区的</code></p><p>NIO的缓冲区</p><blockquote><p>Java IO面向流意味着每次从流中读取一个或者多个字节，直至读取完所有字节，他们没有被缓存在任何地方。此外，他不能前后移动流中的数据，如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。NIO的缓冲导向方法不同。数据读取到一个它稍后处理的缓冲区，需要时刻在缓存区中前后移动。这就增加了处理过程中的灵活性。但是还需要检查是否该缓冲区中包含所有您需要处理的数据，而且需要确保当更多的数据读入缓冲区时，不要覆盖缓冲区里未处理的数据。</p></blockquote><p>NIO的非阻塞</p><blockquote><p>IO的各种流是阻塞的。这意味着当一个线程调用read()或write()时，该线程被阻塞，直到直到有一些数据被读取,或数据完全写入。该线程在此期间不能再干任何事情了。 NIO 的非阻塞模式,使一个线程从某通道发送请求读取数据,但是它仅能得到目前可用的数据,如果目前没有数据可用时,就什么都不会获取。而不是保持线程阻塞,所以直至数据变的可以读取之前,该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道,但不需要等待它完全写入,这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用于在其它通道上执行 IO 操作,所以一个单独的线程现在可以管理多个输入和输出通道(channel)。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/java_nio_package.png" alt="avatar"></p><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><blockquote><p>首先说一下Channel，国内大多数翻译成“通道”。Channel和IO中的Stream(流)是差不多一个等级的。只不过Stream是单向的，譬如：InputStream,OutPutStream,而Channel是双向的，既可以用来进行读操作也可以用来进行写操作。</p></blockquote><p>NIO中的Channel的主要实现有</p><ul><li>FileChannel</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><blockquote><p>分别对应IO，UDP，TCP(Server和Client)</p></blockquote><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><blockquote><p>Buffer顾名思义缓冲区实际上是一个容器，是一个连续数组。Channel提供文件，网络读取数据的渠道，但是读取或者写入的数据都必须经由Buffer</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/TIM%E5%9B%BE%E7%89%8720200528214729.png" alt="avatar"></p><blockquote><p>上图描述一个客户端向服务端发送数据，然后服务端接收数据的过程。客户端发送数据时，必须将数据存入Buffer中，然后将Buffer中的内容写入通道。服务端这边接收数据必须通过Channel将数据读入到Buffer中，然后再从Buffer中取出数据来处理。</p></blockquote><p>在NIO中Buffer是一个顶层父类，他是一个抽象类，常用的Buffer的子类有<code>ByteBuffer、IntBuffer、CharBuffer、LongBuffer、DoubleBuffer、FloatBuffer、ShortBuff</code></p><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><blockquote><p>Selector类是NIO的核心类，Selector能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理。这样一来只是用一个单线程就可管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用函数来进行读写，就大大减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，并且避免了多线程之间的上下文切换导致的开销。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO/NIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 知识汇总</title>
    <link href="/2020/05/19/java/JVM-%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    <url>/2020/05/19/java/JVM-%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="JVM-知识汇总"><a href="#JVM-知识汇总" class="headerlink" title="JVM 知识汇总"></a>JVM 知识汇总</h1><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">JVM是可运行Java代码的假想计算机，包括一套字节指令集，一组寄存器，一个栈，一个垃圾回收，堆和一个存储方法域．<br>Jvm是运行在操作系统上的他与硬件没有直接的交互．<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jvm.png" alt="avatar"></p><h1 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h1><blockquote><p>我们都知道Java源文件，通过编译器能够生产相应的.Class文件，也就是字节码文件，而字节码文件又通过Java虚拟机中的解释器，编译成特定机器上的机器码</p></blockquote><blockquote><p>Java源文件–&gt;编译器–&gt;字节码文件–&gt;JVM–&gt;机器码</p></blockquote><blockquote><p>每一种平台的解释器是不同的，但是实现的虚拟机是相同的，这也就是Java为什么能够跨平台的原因，当一个程序从开始运行，这时虚拟机就开始实例化了，多个程序启动　就会存在多个虚拟机实例．程序退出或者关闭则虚拟机实例消亡，多个虚拟机实例之间数据不能共享&lt;</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/RunTimeJvm.png" alt="avatar"> </p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><blockquote><p>这里所说的线程程序执行过程中的一个线程实体．JVM允许一个应用并发执行多个线程．<code>Hotspot JVM中的Java线程与原生操作系统线程有直接的映射关系</code>．当线程本地存储，缓冲区分配，同步对象，栈，程序计数器等准备好以后，就会创建一个操作系统图原生线程，并把他们分配到任何可以的CPU上．当原生线程初始化完毕，就会调用Java线程的run()方法．当线程结束时，会释放原生线程和Java线程的所有资源</p></blockquote><h3 id="Hotspot-JVM后台运行的系统线程主要有下面几个"><a href="#Hotspot-JVM后台运行的系统线程主要有下面几个" class="headerlink" title="Hotspot JVM后台运行的系统线程主要有下面几个"></a>Hotspot JVM后台运行的系统线程主要有下面几个</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/20200519184914.png" alt="avatar"> </p><h3 id="JVM-内存区域"><a href="#JVM-内存区域" class="headerlink" title="JVM 内存区域"></a>JVM 内存区域</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/20200519185041.png" alt="avatar"> </p><blockquote><p>jvm内存区域主要分为线程私有区域［程序计数器，虚拟机栈，本地方法区］，线程共享区域［java堆，方法区］，直接内存．</p></blockquote><p><code>线程私有数据区域生命周期与线程相同，依赖用户线程的启动/结束而创建/销毁(在Hotspot VM内)，每个线程都与操作系统的本地线程直接映射，因此这部分内存区域的存/否跟随本地线程的生/死对应</code></p><h4 id="线程共享区域随虚拟机的启动-关闭而创建-销毁"><a href="#线程共享区域随虚拟机的启动-关闭而创建-销毁" class="headerlink" title="线程共享区域随虚拟机的启动/关闭而创建/销毁"></a>线程共享区域随虚拟机的启动/关闭而创建/销毁</h4><blockquote><p>直接内存并不是JVM运行时数据区的一部分,但也会被频繁的使用:在JDK1.4引入的NIO提供了基于Channel与Buffer的IO方式．他可以使用Native函数库直接分配堆外内存，然后使用DirectByteBuffer对象作为这个内存的引用进行操作，这样避免了在Java堆和Native中来回复制数据，因此在一场场景中可以显著提高性能．</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/TIM%E5%9B%BE%E7%89%8720200519213321.png" alt="avatar"> </p><h1 id="程序计数器-线程私有"><a href="#程序计数器-线程私有" class="headerlink" title="程序计数器(线程私有)"></a>程序计数器(线程私有)</h1><blockquote><p>一块较小的内存空间，<code>是当前线程所执行的字节码的行号指示器</code>，每条线程都要有一个独立的程序计数器，这类内存也称为<code>线程私有</code>的内存．</p></blockquote><blockquote><p>正在执行Java方法的话，计数器记录的是虚拟机字节码指令的地址(当前指令的地址)．如果还是Native方法则为空．</p></blockquote><blockquote><p>这个内存区域是　唯一一个在虚拟机中没有规定任何OutOfMemoryError情况的区域</p></blockquote><h1 id="虚拟机栈-线程私有"><a href="#虚拟机栈-线程私有" class="headerlink" title="虚拟机栈(线程私有)"></a>虚拟机栈(线程私有)</h1><blockquote><p>是描述Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表，操作数栈，动态链接，方法出口等信息．每一个方法从调用直至执行完成的过程，就对应着一个在虚拟机栈中入栈到出栈的过程</p></blockquote><blockquote><p>栈帧( Frame)是用来存储数据和部分过程结果的数据结构,同时也被用来处理动态链接(Dynamic Linking)、 方法返回值和异常分派( Dispatch Exception)。栈帧随着方法调用而创建,随着方法结束而销毁——无论方法是正常完成还是异常完成(抛出了在方法内未被捕获的异常)都算作方法结束。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/TIM%E5%9B%BE%E7%89%8720200519213321.png" alt="avatar"> </p><h1 id="本地方法区-线程私有"><a href="#本地方法区-线程私有" class="headerlink" title="本地方法区(线程私有)"></a>本地方法区(线程私有)</h1><blockquote><p>本地方法区和 Java Stack 作用类似, 区别是虚拟机栈为执行 Java 方法服务, 而本地方法栈则为<br> Native 方法服务, 如果一个 VM 实现使用 C-linkage 模型来支持 Native 调用, 那么该栈将会是一个<br> C 栈,但 HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一。</p></blockquote><h1 id="堆-Heap-线程共享-运行时数据区"><a href="#堆-Heap-线程共享-运行时数据区" class="headerlink" title="堆(Heap-线程共享)-运行时数据区"></a>堆(Heap-线程共享)-运行时数据区</h1><blockquote><p>是被线程共享的一块内存区域，<code>创建的对象和数组都保存在Java堆内存中,也是垃圾收集器进行垃圾收集的最重要的内存区域</code>，由于现代VM采用分代收集算法，因此Java堆从GC的角度还可以细分为：新生代(Eden区，From Survivor区和To Survivor区)和老年代</p></blockquote><h1 id="方法区-永久代-线程共享"><a href="#方法区-永久代-线程共享" class="headerlink" title="方法区/永久代(线程共享)"></a>方法区/永久代(线程共享)</h1><blockquote><p>即我们常说的永久代(Permanent Generation)用于存储被jvm加载的类信息，常量，静态变量，即时编译器编译后的代码等数据．HotSpot VM把GC分代收集扩展至方法区，即使用Java堆的永久代来实现方法区，这样HotSpot的垃圾收集器就可以像管理Java堆一样内存管理这部分内存，而不必为方法区开发专门的内存管理器(永久代的内存回收的主要目标是针对常量池的回收和类型的卸载，因此收益一般很小)</p></blockquote><p>运行时常量</p><blockquote><p>运行时常量池(Runtime Constant Pool)是方法区的一部分。Class 文件中除了有类的版<br> 本、字段、方法、接口等描述等信息外,还有一项信息是常量池(Constant Pool Table),用于存放编译期生成的各种字面量和符号引用,这部分内容将在类加<br> 载后存放到方法区的运行时常量池中。 Java 虚拟机对 Class 文件的每一部分(自然也包括常量<br> 池)的格式都有严格的规定,每一个字节用于存储哪种数据都必须符合规范上的要求,这样才会<br> 被虚拟机认可、装载和执行。</p></blockquote><h1 id="JVM运行时内存"><a href="#JVM运行时内存" class="headerlink" title="JVM运行时内存"></a>JVM运行时内存</h1><blockquote><p>Java堆GC的角度还可以细分为:新生代(Eden区，From Survivor区和To Survivor区)和老年代</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/Jvm_runtime.png" alt="avatar"></p><h2 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h2><blockquote><p>是用来存放新生对象的，一般占用堆的1/3空间.由于频繁创建对象，所以新生代会频繁触发MinorGC进行垃圾回收.新生代又分为Eden区、SurvivorFrom、SurvivorTo三个区。</p></blockquote><h3 id="Eden区"><a href="#Eden区" class="headerlink" title="Eden区"></a>Eden区</h3><blockquote><p>Java新对象的出生地<code>（如果新创建的对象占用内存很大，则直接分配到老年代）</code>当Eden区内存不够的时候就会触发MinorGC，对新生代进行一次垃圾回收。</p></blockquote><h3 id="SurvivorFrom"><a href="#SurvivorFrom" class="headerlink" title="SurvivorFrom"></a>SurvivorFrom</h3><blockquote><p>上一次GC的幸存者，作为这一次GC的被扫描者</p></blockquote><h3 id="SurvivorTo"><a href="#SurvivorTo" class="headerlink" title="SurvivorTo"></a>SurvivorTo</h3><blockquote><p>保留了一次MinorGC过程中的幸存者</p></blockquote><h3 id="MinorGC的过程-复制-gt-清空-gt-互换"><a href="#MinorGC的过程-复制-gt-清空-gt-互换" class="headerlink" title="MinorGC的过程(复制-&gt;清空-&gt;互换)"></a>MinorGC的过程(复制-&gt;清空-&gt;互换)</h3><blockquote><p>MinorGC采用复制算法</p></blockquote><ul><li><p>eden、SurvivorFrom、复制到SurvivorTo年龄+1</p><blockquote><p>首先，把Eden和SurvivorFrom区域中存活的对象复制到SurvivorTo区域(如果有对象的年龄以及达到了老年的标准，则赋值到老年代)，同时把这些对象的年龄+1（如果SurvivorTo不够位置了就放到老年区）</p></blockquote></li><li><p>清空Eden、SurvivorFrom</p><blockquote><p>然后清空Eden和SurvivorFrom中的对象</p></blockquote></li><li><p>SurvivorTo 和 SurvivorFrom互换</p><blockquote><p>最后，SurvivorTo和SurvivorFrom互换，原SurvivorFrom成为下一次GC时的SurvivorFrom区</p></blockquote></li></ul><h1 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h1><p><code>主要存放应用程序中生命周期长的内存对象</code></p><blockquote><p>老年代的对象比较稳定，所以MajorGC不会频繁执行。在进行MajorGC前一般都先进行了一次MinorGC使得有新生代对象晋入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间。</p></blockquote><blockquote><p>MajorGC采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC的耗时比较长，因为要扫描再回收。MajorGC会产生内存碎片为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满足了装不下的时候，就会抛出OOM(OutOfMemory)异常。</p></blockquote><h1 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h1><blockquote><p>指的是内存的永久保存区域，主要存放Class和Meta(元数据)的信息Class在被加载的时候被放入永久区域，他和存放实例的区域不同　<code>GC不会在主程序运行期对永久区进行清理</code>.所以这也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出OOM异常。</p></blockquote><h1 id="Java8与元数据"><a href="#Java8与元数据" class="headerlink" title="Java8与元数据"></a>Java8与元数据</h1><blockquote><p>在Java8中，永久代已经被移除，被一个称为“元数据”（元空间）的区域所取代。元空间的本质和永久代类似，元空间与永久代之间的最大区别在于：元空间并不在虚拟机中，而是使用本地内存。因此默认情况下元空间的大小仅仅受本地内存限制。类的元数据放入native memory字符串池和类的静态变量放入Java堆中，这样可以加载多少类的元数据就不会由MaxPermSize控制，而是由系统实际可用空间来控制。</p></blockquote><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/jvmrubback.png" alt="avatar"></p><h2 id="如何确定垃圾"><a href="#如何确定垃圾" class="headerlink" title="如何确定垃圾"></a>如何确定垃圾</h2><ul><li><p>引用计数法</p><blockquote><p>在Java中引用和对象是有关联的。如果要操作对象则必须用引用进行。因此很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单的说，即一个对象如果没有任何与之关联的引用，即他们的引用计数都不为零，则说明对象不太可能在被利用到，那么　这个对象就是可回收对象。</p></blockquote></li><li><p>可达性分析</p><blockquote><p>为了解决引用计数法的循环引用问题，Java使用了可达性分析方法。通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。<br>要注意的是不可达对象不等价于回收对象，不可达对象变为可回收对象至少要经过两次标记过程，两次标记后仍然是可回收对象，则将面临回收。</p></blockquote></li><li><p>标记清除法(Mark-Sweep)</p><blockquote><p>最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记处所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。如图</p></blockquote></li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/mark_sweep.png" alt="avatar"></p><p>缺点：<code>内存碎片化严重，后续可能发生大对象不能找到可利用空间的问题</code></p><ul><li>复制算法(copying)<blockquote><p>为了解决Mark-Sweep算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只使用期中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉，如图：</p></blockquote></li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/copy.png" alt="avatar"></p><p>缺点：<code>内存被压缩到了原本的一半。且存活对象对象增多的话，Copying算法的效率会大大降低</code></p><ul><li>标记整理算法(Mark-Compact)<blockquote><p>结合以上两个算法，为了避免缺陷而提出。标记阶段和Mark-Sweep算法相同，标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界的对象</p></blockquote></li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/Mark-Compact.png" alt="avatar"></p><ul><li>分代收集算法<blockquote><p>分代收集法是目前大部分 JVM 所采用的方法,其核心思想是根据对象存活的不同生命周期将内存划分为不同的域,一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(YoungGeneration)。老生代的特点是每次垃圾回收时只有少量对象需要被回收,新生代的特点是每次垃圾回收时都有大量垃圾需要被回收,因此可以根据不同区域选择不同的算法。</p></blockquote></li></ul><p>新生代与复制算法</p><blockquote><p>目前大部分 JVM 的 GC 对于新生代都采取 Copying 算法,因为新生代中每次垃圾回收都要<br> 回收大部分对象,即要复制的操作比较少,但通常并不是按照 1:1 来划分新生代。一般将新生代<br> 划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space),每次使用<br> Eden 空间和其中的一块 Survivor 空间,当进行回收时,将该两块空间中还存活的对象复制到另<br> 一块 Survivor 空间中。<br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/young-mark-copy.png" alt="avatar"></p></blockquote><p>老年代与标记复制算法</p><blockquote><p>而老年代因为每次只回收少量对象,因而采用 Mark-Compact 算法。<br>1.JAVA 虚拟机提到过的处于方法区的永生代(Permanet Generation),它用来存储 class 类,常量,方法描述等。对永生代的回收主要包括废弃常量和无用的类。<br>2.对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space(Survivor 目前存放对象的那一块),少数情况会直接分配到老生代。<br>3.当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC,进行 GC 后,EdenSpace 和 From Space 区的存活对象会被挪到 To Space,然后将 Eden Space 和 FromSpace 进行清理。<br>4.如果 To Space 无法足够存储某个对象,则将这个对象存储到老生代。<br>5.在进行 GC 后,使用的便是 Eden Space 和 To Space 了,如此反复循环。<br>6.当对象在 Survivor 区躲过一次 GC 后,其年龄就会+1。默认情况下年龄到达 15 的对象会被移到老生代中。</p></blockquote><h1 id="Java-四种引用类型"><a href="#Java-四种引用类型" class="headerlink" title="Java 四种引用类型"></a>Java 四种引用类型</h1><ul><li>强引用<blockquote><p>在 Java 中最常见的就是强引用,把一个对象赋给一个引用变量,这个引用变量就是一个强引<br>用。当一个对象被强引用变量引用时,它处于可达状态,它是不可能被垃圾回收机制回收的,即<br>使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之<br>一。</p></blockquote></li><li>软引用<blockquote><p>软引用需要用 SoftReference 类来实现,对于只有软引用的对象来说,当系统内存足够时它<br>不会被回收,当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。</p></blockquote></li><li>弱引用<blockquote><p>弱引用需要用 WeakReference 类来实现,它比软引用的生存期更短,对于只有弱引用的对象<br>来说,只要垃圾回收机制一运行,不管 JVM 的内存空间是否足够,总会回收该对象占用的内存。</p></blockquote></li><li>虚引用<blockquote><p>虚引用需要 PhantomReference 类来实现,它不能单独使用,必须和引用队列联合使用。虚<br>引用的主要作用是跟踪对象被垃圾回收的状态。</p></blockquote></li></ul><h1 id="GC-分代收集算法-VS-分区收集算法"><a href="#GC-分代收集算法-VS-分区收集算法" class="headerlink" title="GC 分代收集算法 VS 分区收集算法"></a>GC 分代收集算法 VS 分区收集算法</h1><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><blockquote><p>当前主流VM垃圾收集都采用“分代收集”(Generational Collection)算法，这种算法会根据对象存活周期的不同将内存划分为几块，如JVM中的<code>新生代、老年代、永久代</code>这样就可以根据各年代分别采用最适当的GC算法</p></blockquote><h1 id="在新生代-复制算法"><a href="#在新生代-复制算法" class="headerlink" title="在新生代-复制算法"></a>在新生代-复制算法</h1><p>每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量<br>存活对象的复制成本就可以完成收集.</p><h1 id="在老年代-标记整理算法"><a href="#在老年代-标记整理算法" class="headerlink" title="在老年代-标记整理算法"></a>在老年代-标记整理算法</h1><p>因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标<br>记—整理”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存.<br>分区算法则将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收. 这样做的<br>好处是可以控制一次回收多少个小区间 , 根据目标停顿时间, 每次合理地回收若干个小区间(而不是<br>整个堆), 从而减少一次 GC 所产生的停顿。</p><h1 id="GC-垃圾收集器"><a href="#GC-垃圾收集器" class="headerlink" title="GC 垃圾收集器"></a>GC 垃圾收集器</h1><p>Java 堆内存被划分为新生代和年老代两部分,新生代主要使用复制和标记-清除垃圾回收 算法 ;<br>年老代主要使用标记-整理垃圾回收算法,因此 java 虚拟中针对新生代和年老代分别提供了多种不<br>同的垃圾收集器,JDK1.6 中 Sun HotSpot 虚拟机的垃圾收集器如下:</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/JDK16SunHotspot.png" alt="avatar"></p><ul><li><p>Serial 垃圾收集器(单线程、复制算法)</p><blockquote><p>Serial(英文连续)是最基本垃圾收集器，使用复制算法，曾经是JDK1.3.1之前新生代唯一的垃圾收集器。Serial是一个单线程的收集器，它不但只会使用一个CPU或一条线程去完成垃圾收集工作而且在进行垃圾收集同时，必须暂停所有的工作线程，但是它简单高效，对于限定单个CPU环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此Serial垃圾收集器依然是Java虚拟机在Client模式下默认的新生代垃圾收集器。</p></blockquote></li><li><p>ParNew垃圾收集器(Serial+多线程)</p><blockquote><p>ParNew垃圾收集器其实是Serial收集器的多线程版本，也是使用多线程进行垃圾收集之外，其余的行为和Serial收集器完全一致，ParNew垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。ParNew收集器默认开启和CPU数目相同的线程数，可以通过-XX:ParallelGCThreads参数来限制垃圾收集器的线程数。(Parallel:平行的)ParNew虽然是除了多线程和Serial收集器几乎完全一致，但是ParNew垃圾收集器是很多Java虚拟机运行在Server模式下新生代的默认垃圾收集器。</p></blockquote></li><li><p>Parallel Scavenge收集器(多线程复制算法、高效)</p><blockquote><p>Parallel Scavenge收集器也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃圾收集器，它重点关注的是程序达到一个可控制的吞吐量(Thoughput,CPU用于运行用户代码的时间/CPU总消耗时间，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间))，高吞吐量可以最高效率利用CPU时间尽快完成程序运算任务，主要适用在后台运算而不需要太多交互的任务。自适应调节策略也是ParallelScavenge收集器与ParNew收集器的一个重要区别。</p></blockquote></li><li><p>Serial Old收集器(单线程标记整理算法)</p><blockquote><p>Serial Old是Serial 垃圾收集器年代老版本，它同样是单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在Client默认的Java虚拟机默认的年代垃圾收集器。在这个模式下，主要有两个用途：</p></blockquote></li></ul><p>1.在JDK1.5之前版本中与新生代的Parallel　Scavenge收集器搭配使用。</p><p>2.作为年老代中使用CMS收集器的后备垃圾收集方案：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/TIM%E5%9B%BE%E7%89%8720200527092744.png" alt="avatar"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">新生代 Parallel Scavenge 收集器与 ParNew 收集器工作原理类似,都是多线程的收集器,都使<br>用的是复制算法,在垃圾收集过程中都需要暂停所有的工作线程。新生代 Parallel<br>Scavenge/ParNew 与年老代 Serial Old 搭配垃圾收集过程图:<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/TIM%E5%9B%BE%E7%89%8720200527092908.png" alt="avatar"></p><ul><li>Parallel Old收集器(多线程标记整理算法)<blockquote><p>Parallel Old收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法，在JDK1.才开始提供。<br>在JDK1.6之前，新生代使用ParallelScavenge收集器只能搭配年老代的Serial Old收集器只能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old正是为了在老代同样提供吞吐量优先的垃圾收集的搭配策略。<br>新生代Parallel Scavenge和老年代Parallel Old收集器搭配运行过程图：</p></blockquote></li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/TIM%E5%9B%BE%E7%89%8720200527095030.png" alt="avatar"></p><ul><li>CMS收集器(多线程标记清除算法)<blockquote><p>Concurrent mark sweep(CMS)收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。</p></blockquote></li></ul><p><code>CMS工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下4个阶段：</code></p><p>初始标记</p><blockquote><p>只是标记一下 GC Roots 能直接关联的对象,速度很快,仍然需要暂停所有的工作线程。</p></blockquote><p>并发标记</p><blockquote><p>进行 GC Roots 跟踪的过程,和用户线程一起工作,不需要暂停工作线程。</p></blockquote><p>重新标记</p><blockquote><p>为了修正在并发标记期间,因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录,仍然需要暂停所有的工作线程。</p></blockquote><p>并发标记</p><blockquote><p>清除 GC Roots 不可达对象,和用户线程一起工作,不需要暂停工作线程。由于耗时最长的并发标记和并发清除过程中,垃圾收集线程可以和用户现在一起并发工作,所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行。</p></blockquote><p>CMS收集器工作过程</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/TIM%E5%9B%BE%E7%89%8720200527100033.png" alt="avatar"></p><ul><li>G1收集器<blockquote><p>Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果,相比与 CMS 收集器,G1 收<br>集器两个最突出的改进是:</p></blockquote></li></ul><ol><li>基于标记-整理算法,不产生内存碎片。</li><li>可以非常精确控制停顿时间,在不牺牲吞吐量前提下,实现低停顿垃圾回收。<blockquote><p>G1 收集器避免全区域垃圾收集,它把堆内存划分为大小固定的几个独立区域,并且跟踪这些区域<br>的垃圾收集进度,同时在后台维护一个优先级列表,每次根据所允许的收集时间,优先回收垃圾<br>最多的区域。区域划分和优先级区域回收机制,确保 G1 收集器可以在有限时间获得最高的垃圾收<br>集效率。</p></blockquote></li></ol><h1 id="Jvm类加载机制"><a href="#Jvm类加载机制" class="headerlink" title="Jvm类加载机制"></a>Jvm类加载机制</h1><blockquote><p>JVM类加载机制分为:<code>加载、验证、准备、解析、初始化</code></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/TIM%E5%9B%BE%E7%89%8720200528223950.png" alt="avatar"></p><ul><li><p>加载</p><blockquote><p>加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的入口。注意这里不一定是要从一个Class文件获取，这里既可以从ZIP包中读取(比如jar包和war包中读取)，也可以在运行计算生成(动态代理)，也可以由其它文件生成(比如将jsp文件转换成对应的Class类)。</p></blockquote></li><li><p>验证</p><blockquote><p>这一阶段的主要目的是为了确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害自身的安全。</p></blockquote></li><li><p>准备</p><blockquote><p>准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间，注意这里所说的初始值概念，比如说一个类变量定义为：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> v = <span class="hljs-number">8080</span>;<br></code></pre></td></tr></table></figure><p>实际上变量V在准备阶段过后的初始值为0而不是8080，将V赋值为8080的put static指令是程序被编译后，存放于类构造器<client>方法之中<br>但是注意如果声明为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> v = <span class="hljs-number">8080</span>;<br></code></pre></td></tr></table></figure><p>在编译阶段会为V生成ConstantValue属性，在准备阶段虚拟机会根据ConstantValue属性将V赋值为8080</p></li><li><p>解析</p><blockquote><p>解析阶段是指虚拟机将常量池中的符合引用替换为直接引用的过程。符合引用就是class文件中的<code>CONSTANT_Class_info</code>，<code>CONSTANT_Field_Info</code>，<code>CONSTANT_Method_Info</code>等类型常量。</p></blockquote></li></ul><p>符合引用:</p><blockquote><p>符号引用与虚拟机实现的布局无关,引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同,但是它们能接受的符号引用必须是一致的,因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。</p></blockquote><p>直接引用:</p><blockquote><p>直接引用可以是指向目标的指针,相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用,那引用的目标必定已经在内存中存在.</p></blockquote><p>初始化:</p><blockquote><p>初始化阶段是类加载最后一个阶段,前面的类加载阶段之后,除了在加载阶段可以自定义类加载器以外,其它操作都由 JVM 主导。到了初始阶段,才开始真正执行类中定义的 Java 程序代码。</p></blockquote><p>类构造器:</p><blockquote><p>初始化阶段是执行类构造器<client>方法的过程。<client>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子<client>方法执行之前,父类的<client>方法已经执行完毕,如果一个类中没有对静态变量赋值也没有静态语句块,那么编译器可以不为这个类生成<client>()方法。</p></blockquote><p><code>[注]</code>以下几种情况不会执行类初始化：<br>1.通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。<br>2.定义对象数组，不会触发该类的初始化。<br>3.常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，也不会触发定义常量所在的类<br>4.通过类名获取Class对象不会触发类的初始化。<br>5.通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。<br>6.通过ClassLoader默认的loadClass方法也不会触发初始化动作。</p><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><blockquote><p>虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类，JVM提供了3种类加载器</p></blockquote><ul><li>启动类加载器(Bootstrap ClassLoader)<blockquote><p>负责加载<code>JAVA_HOME\lib</code>目录中的，或者通过<code>-Xbootclasspath</code>参数指定路径中的，且被虚拟机认可(按文件名识别，如rt.jar)的类。</p></blockquote></li><li>扩展类加载器(Extension ClassLoader)<blockquote><p>负责加载<code>JAVA_HOME\lib\ext</code>目录中的，或者通过<code>java.ext.dirs</code>系统变量指定路径中的类库。</p></blockquote></li><li>应用程序类加载器(Application ClassLoader)<blockquote><p>负责加载用户路径(classpath)上的类库。<br>JVM通过双亲委派模型进行类的加载，当然我们也可以通过继承<code>java.lang.ClassLoader</code>实现自定义的类加载器</p></blockquote></li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/application_classloader.png" alt="avatar"></p><h2 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h2><blockquote><p>当一个类收到类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候(在它的加载路径下没有找到所需的Class)，子类加载器才会尝试自己去加载。</p></blockquote><blockquote><p>采用双亲委派的好处是比如加载位于<code>rt.jar</code>包中的类<code>java.lang.Object</code>，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同一个Object对象。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/TIM%E5%9B%BE%E7%89%8720200529101019.png" alt="avatar"></p><h3 id="OSGI-动态模型系统"><a href="#OSGI-动态模型系统" class="headerlink" title="OSGI(动态模型系统)"></a>OSGI(动态模型系统)</h3><blockquote><p>OSGI(Open Service Gateway Initiative)，是面向Java的动态模型系统，是Java动态模块化系统的一系列规范。</p></blockquote><h1 id="动态改变构造"><a href="#动态改变构造" class="headerlink" title="动态改变构造"></a>动态改变构造</h1><p>OSGi 服务平台提供在多种网络设备上无需重启的动态改变构造的功能。为了最小化耦合度和促使<br>这些耦合度可管理,OSGi 技术提供一种面向服务的架构,它能使这些组件动态地发现对方。</p><h1 id="模块化编程与热插拔"><a href="#模块化编程与热插拔" class="headerlink" title="模块化编程与热插拔"></a>模块化编程与热插拔</h1><p>OSGi 旨在为实现 Java 程序的模块化编程提供基础条件,基于 OSGi 的程序很可能可以实现模块级的热插拔功能,当程序升级更新时,可以只停用、重新安装然后启动程序的其中一部分,这对企业级程序开发来说是非常具有诱惑力的特性。OSGi 描绘了一个很美好的模块化开发目标,而且定义了实现这个目标的所需要服务与架构,同时也有成熟的框架进行实现支持。但并非所有的应用都适合采用 OSGi 作为基础架构,它在提供强大功能同时,也引入了额外的复杂度,因为它不遵守了类加载的双亲委托模型。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lua 脚本学习</title>
    <link href="/2020/05/02/note/Lua-%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/05/02/note/Lua-%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>Lua is free software distributed in source code. It may be used for any purpose, including commercial purposes, at absolutely no cost.<br>Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p></blockquote><p>Lua 是巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个研究小组于 1993 年开发的，该小组成员有：<code>Roberto Ierusalimschy</code>、<code>Waldemar Celes</code> 和 <code>Luiz Henrique de Figueiredo</code>。</p><h2 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h2><p>其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p><h2 id="Lua-特性"><a href="#Lua-特性" class="headerlink" title="Lua 特性"></a>Lua 特性</h2><ul><li>轻量级: 它用标准C语言编写并以源代码形式开放，编译后仅仅一百余K，可以很方便的嵌入别的程序里。</li><li>可扩展: Lua提供了非常易于使用的扩展接口和机制：由宿主语言(通常是C或C++)提供这些功能，Lua可以使用它们，就像是本来就内置的功能一样。</li></ul><h2 id="其它特性"><a href="#其它特性" class="headerlink" title="其它特性:"></a>其它特性:</h2><ul><li>支持面向过程(procedure-oriented)编程和函数式编程(functional programming)；</li><li>自动内存管理；只提供了一种通用类型的表（table），用它可以实现数组，哈希表，集合，对象；</li><li>语言内置模式匹配；闭包(closure)；函数也可以看做一个值；提供多线程（协同进程，并非操作系统所支持的线程）支持；</li><li>通过闭包和table可以很方便地支持面向对象编程所需要的一些关键机制，比如数据抽象，虚函数，继承和重载等。</li></ul><h1 id="Lua-应用场景"><a href="#Lua-应用场景" class="headerlink" title="Lua 应用场景"></a>Lua 应用场景</h1><ul><li>游戏开发</li><li>独立应用脚本</li><li>Web 应用脚本</li><li>扩展和数据库插件如：MySQL Proxy 和 MySQL WorkBench</li><li>安全系统，如入侵检测系统</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -R -O http://www.lua.org/ftp/lua-5.3.5.tar.gz<br>tar zxf lua-5.3.5.tar.gz<br><span class="hljs-built_in">cd</span> lua-5.3.5<br>make linux <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>编译出错<br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/complie-error.png" alt="avatar"><br>解决方法<br><code>sudo apt-get install libreadline7 libreadline-dev</code><br>重新编译<br><code>make linux test</code><br>创建软连接<br><code>sudo ln -s /home/mikey/DATA/DevTools/lua-5.3.5/src/lua /usr/bin/lua</code><br>测试  </p><pre><code>mikey@localhost: luaLua 5.3.5  Copyright (C) 1994-2018 Lua.org, PUC-Rio&gt; print(&quot;Hello Mikey&quot;)Hello Mikey&gt; ```  # Lua 数据库访问Lua 数据库的操作库：LuaSQL。开源，支持的数据库有：ODBC, ADO, Oracle, MySQL, SQLite 和 PostgreSQL。  LuaSQL 可以使用 LuaRocks 来安装可以根据需要安装你需要的数据库驱动。  LuaRocks 安装方法：<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ wget http:<span class="hljs-regexp">//</span>luarocks.org<span class="hljs-regexp">/releases/</span>luarocks-<span class="hljs-number">2.2</span>.<span class="hljs-number">1</span>.tar.gz<br>$ tar zxpf luarocks-<span class="hljs-number">2.2</span>.<span class="hljs-number">1</span>.tar.gz<br>$ cd luarocks-<span class="hljs-number">2.2</span>.<span class="hljs-number">1</span><br>$ ./configure; sudo make bootstrap<br>$ sudo luarocks install luasocket<br>$ lua<br>Lua <span class="hljs-number">5.3</span>.<span class="hljs-number">0</span> Copyright (C) <span class="hljs-number">1994</span>-<span class="hljs-number">2015</span> Lua.org, PUC-Rio<br>&gt; require <span class="hljs-string">&quot;socket&quot;</span><br>Window 下安装 LuaRocks：`https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/keplerproject/</span>luarocks<span class="hljs-regexp">/wiki/</span>Installation-instructions-<span class="hljs-keyword">for</span>-Windows`<br></code></pre></td></tr></table></figure>安装不同数据库驱动：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">luarocks <span class="hljs-keyword">install</span> luasql-sqlite3<br>luarocks <span class="hljs-keyword">install</span> luasql-postgres<br>luarocks <span class="hljs-keyword">install</span> luasql-mysql<br>luarocks <span class="hljs-keyword">install</span> luasql-sqlite<br>luarocks <span class="hljs-keyword">install</span> luasql-odbc<br><span class="hljs-string">``</span><span class="hljs-string">``</span>  <br>你也可以使用源码安装方式，Lua Github 源码地址：<span class="hljs-string">`https://github.com/keplerproject/luasql`</span><br><br>Lua 连接MySql 数据库：<br><br></code></pre></td></tr></table></figure>实例require &quot;luasql.mysql&quot;--创建环境对象env = luasql.mysql()--连接数据库conn = env:connect(&quot;数据库名&quot;,&quot;用户名&quot;,&quot;密码&quot;,&quot;IP地址&quot;,端口)--设置数据库的编码格式conn:execute&quot;SET NAMES UTF8&quot;--执行数据库操作cur = conn:execute(&quot;select * from role&quot;)row = cur:fetch(&#123;&#125;,&quot;a&quot;)--文件对象的创建file = io.open(&quot;role.txt&quot;,&quot;w+&quot;);while row do    var = string.format(&quot;%d %s\n&quot;, row.id, row.name)    print(var)    file:write(var)    row = cur:fetch(row,&quot;a&quot;)endfile:close()  --关闭文件对象conn:close()  --关闭数据库连接env:close()   --关闭数据库环境</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.runoob.com/lua/lua-tutorial.html">菜鸟教程</a><br><a href="https://www.runoob.com/manual/lua53doc/">官方手册</a></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lua</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何让Netty服务随Tomcat启动</title>
    <link href="/2020/05/01/problem/How-to-start-netty-in-Tomcat/"/>
    <url>/2020/05/01/problem/How-to-start-netty-in-Tomcat/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="关于在Tomcat容器中启动Netty服务器的方法"><a href="#关于在Tomcat容器中启动Netty服务器的方法" class="headerlink" title="关于在Tomcat容器中启动Netty服务器的方法"></a>关于在Tomcat容器中启动Netty服务器的方法</h1><blockquote><p>最近在一个web应用上重构一个即时通信功能的,考虑到负载和性能的原因,所以决定采用Netty来作为服务器端,但是如果在主线程中启动netty就会陷入阻塞状态,导致Tomcat无法启动．</p></blockquote><h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><blockquote><p>我们知道，netty在主线程启动会陷入阻塞，那么我们就可以开启一个新线程来启动netty服务器，让主线程启动Tomcat即可</p></blockquote><h1 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h1><details>    <summary>application-netty.xml</summary><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans   </span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/beans/spring-beans-4.1.xsd  </span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/context   </span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/context/spring-context-4.1.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 扫描关于Netty Websocket的包 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.gxwzu.websocket&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 把Netty的一些类服务器注册到Spring，方便处理和扩展 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 用于处理客户端连接请求 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bossGroup&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;io.netty.channel.nio.NioEventLoopGroup&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 用于处理客户端I/O操作 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;workerGroup&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;io.netty.channel.nio.NioEventLoopGroup&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 服务器启动引导类 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;serverBootstrap&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;io.netty.bootstrap.ServerBootstrap&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 自定义的Netty Websocket服务器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;webSocketServer&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.gxwzu.websocket.WebSocketServer&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;port&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;chat.server.port&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;childChannelHandler&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;webSocketChildChannelHandler&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure></details><details>    <summary>WebSocketChildChannelHandler</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.gxwzu.websocket;<br><br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandler;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<br><span class="hljs-keyword">import</span> io.netty.handler.codec.http.HttpObjectAggregator;<br><span class="hljs-keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;<br><span class="hljs-keyword">import</span> io.netty.handler.stream.ChunkedWriteHandler;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ProjectName</span> gdm</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> 麦奇</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Email</span> biaogejiushibiao@outlook.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 4/28/20 8:19 AM</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Title</span>: WebSocketChildChannelHandler</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment"> **/</span><br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSocketChildChannelHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt; </span>&#123;<br><br>    <span class="hljs-meta">@Resource(name = &quot;webSocketServerHandler&quot;)</span><br>    <span class="hljs-keyword">private</span> ChannelHandler webSocketServerHandler;<br><br>    <span class="hljs-meta">@Resource(name = &quot;httpRequestHandler&quot;)</span><br>    <span class="hljs-keyword">private</span> ChannelHandler httpRequestHandler;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ch.pipeline().addLast(<span class="hljs-string">&quot;http-codec&quot;</span>, <span class="hljs-keyword">new</span> HttpServerCodec()); <span class="hljs-comment">// HTTP编码解码器</span><br>        ch.pipeline().addLast(<span class="hljs-string">&quot;aggregator&quot;</span>, <span class="hljs-keyword">new</span> HttpObjectAggregator(<span class="hljs-number">65536</span>)); <span class="hljs-comment">// 把HTTP头、HTTP体拼成完整的HTTP请求</span><br>        ch.pipeline().addLast(<span class="hljs-string">&quot;http-chunked&quot;</span>, <span class="hljs-keyword">new</span> ChunkedWriteHandler()); <span class="hljs-comment">// 分块，方便大文件传输，不过实质上都是短的文本数据</span><br>        ch.pipeline().addLast(<span class="hljs-string">&quot;websocket-handler&quot;</span>,webSocketServerHandler);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary>WebSocketServer</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs java">kage com.gxwzu.websocket;<br><br><span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<br><span class="hljs-keyword">import</span> io.netty.channel.*;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<br><span class="hljs-keyword">import</span> io.netty.util.concurrent.Future;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ProjectName</span> gdm</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> 麦奇</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Email</span> biaogejiushibiao@outlook.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 4/28/20 8:17 AM</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Title</span>: WebSocketServer</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment"> **/</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSocketServer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(WebSocketServer.class);<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> EventLoopGroup bossGroup;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> EventLoopGroup workerGroup;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ServerBootstrap serverBootstrap;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> port;<br><br>    <span class="hljs-keyword">private</span> ChannelHandler childChannelHandler;<br><br>    <span class="hljs-keyword">private</span> ChannelFuture serverChannelFuture;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WebSocketServer</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        build();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构建服务器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">long</span> begin = System.currentTimeMillis();<br>            serverBootstrap.group(bossGroup, workerGroup) <span class="hljs-comment">//boss辅助客户端的tcp连接请求  worker负责与客户端之前的读写操作</span><br>                    .channel(NioServerSocketChannel.class) <span class="hljs-comment">//配置客户端的channel类型</span><br>                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">1024</span>) <span class="hljs-comment">//配置TCP参数，握手字符串长度设置</span><br>                    .option(ChannelOption.TCP_NODELAY, <span class="hljs-keyword">true</span>) <span class="hljs-comment">//TCP_NODELAY算法，尽可能发送大块数据，减少充斥的小块数据</span><br>                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>)<span class="hljs-comment">//开启心跳包活机制，就是客户端、服务端建立连接处于ESTABLISHED状态，超过2小时没有交流，机制会被启动</span><br>                    .childOption(ChannelOption.RCVBUF_ALLOCATOR, <span class="hljs-keyword">new</span> FixedRecvByteBufAllocator(<span class="hljs-number">592048</span>))<span class="hljs-comment">//配置固定长度接收缓存区分配器</span><br>                    .childHandler(childChannelHandler); <span class="hljs-comment">//绑定I/O事件的处理类,WebSocketChildChannelHandler中定义</span><br>            <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br><br>            logger.info(<span class="hljs-string">&quot;Netty Websocket服务器启动完成，耗时 &quot;</span> + (end - begin) + <span class="hljs-string">&quot; ms，已绑定端口 &quot;</span> + port + <span class="hljs-string">&quot; 阻塞式等候客户端连接&quot;</span>);<br><br>            serverChannelFuture = serverBootstrap.bind(port).sync();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            logger.info(e.getMessage());<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 关闭资源</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>&#123;<br>        serverChannelFuture.channel().close();<br>        Future&lt;?&gt; bossGroupFuture = bossGroup.shutdownGracefully();<br>        Future&lt;?&gt; workerGroupFuture = workerGroup.shutdownGracefully();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            bossGroupFuture.await();<br>            workerGroupFuture.await();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignore) &#123;<br>            ignore.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ChannelHandler <span class="hljs-title">getChildChannelHandler</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> childChannelHandler;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setChildChannelHandler</span><span class="hljs-params">(ChannelHandler childChannelHandler)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.childChannelHandler = childChannelHandler;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPort</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> port;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.port = port;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary>WebSocketChildChannelHandler</summary><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">package</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.gxwzu</span><span class="hljs-selector-class">.websocket</span>;<br><br><span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">io</span><span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.channel</span><span class="hljs-selector-class">.ChannelHandler</span>;<br><span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">io</span><span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.channel</span><span class="hljs-selector-class">.ChannelInitializer</span>;<br><span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">io</span><span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.channel</span><span class="hljs-selector-class">.socket</span><span class="hljs-selector-class">.SocketChannel</span>;<br><span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">io</span><span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.handler</span><span class="hljs-selector-class">.codec</span><span class="hljs-selector-class">.http</span><span class="hljs-selector-class">.HttpObjectAggregator</span>;<br><span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">io</span><span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.handler</span><span class="hljs-selector-class">.codec</span><span class="hljs-selector-class">.http</span><span class="hljs-selector-class">.HttpServerCodec</span>;<br><span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">io</span><span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.handler</span><span class="hljs-selector-class">.stream</span><span class="hljs-selector-class">.ChunkedWriteHandler</span>;<br><span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.stereotype</span><span class="hljs-selector-class">.Component</span>;<br><br><span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">javax</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.Resource</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @ProjectName gdm</span><br><span class="hljs-comment"> * @Author 麦奇</span><br><span class="hljs-comment"> * @Email biaogejiushibiao@outlook.com</span><br><span class="hljs-comment"> * @Date 4/28/20 8:19 AM</span><br><span class="hljs-comment"> * @Version 1.0</span><br><span class="hljs-comment"> * @Title: WebSocketChildChannelHandler</span><br><span class="hljs-comment"> * @Description:</span><br><span class="hljs-comment"> **/</span><br><br><span class="hljs-keyword">@Component</span><br>public class WebSocketChildChannelHandler extends ChannelInitializer&lt;SocketChannel&gt; &#123;<br><br>    <span class="hljs-keyword">@Resource</span>(name = <span class="hljs-string">&quot;webSocketServerHandler&quot;</span>)<br>    private ChannelHandler webSocketServerHandler;<br><br>    <span class="hljs-keyword">@Resource</span>(name = <span class="hljs-string">&quot;httpRequestHandler&quot;</span>)<br>    private ChannelHandler httpRequestHandler;<br><br>    <span class="hljs-keyword">@Override</span><br>    protected void initChannel(SocketChannel ch) throws Exception &#123;<br>        <span class="hljs-selector-tag">ch</span><span class="hljs-selector-class">.pipeline</span>()<span class="hljs-selector-class">.addLast</span>(&quot;<span class="hljs-selector-tag">http-codec</span>&quot;, <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">HttpServerCodec</span>()); // <span class="hljs-selector-tag">HTTP</span>编码解码器<br>        <span class="hljs-selector-tag">ch</span><span class="hljs-selector-class">.pipeline</span>()<span class="hljs-selector-class">.addLast</span>(&quot;<span class="hljs-selector-tag">aggregator</span>&quot;, <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">HttpObjectAggregator</span>(65536)); // 把<span class="hljs-selector-tag">HTTP</span>头、<span class="hljs-selector-tag">HTTP</span>体拼成完整的<span class="hljs-selector-tag">HTTP</span>请求<br>        <span class="hljs-selector-tag">ch</span><span class="hljs-selector-class">.pipeline</span>()<span class="hljs-selector-class">.addLast</span>(&quot;<span class="hljs-selector-tag">http-chunked</span>&quot;, <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">ChunkedWriteHandler</span>()); // 分块，方便大文件传输，不过实质上都是短的文本数据<br>        <span class="hljs-selector-tag">ch</span><span class="hljs-selector-class">.pipeline</span>()<span class="hljs-selector-class">.addLast</span>(&quot;<span class="hljs-selector-tag">http-handler</span>&quot;, <span class="hljs-selector-tag">httpRequestHandler</span>);<br>        <span class="hljs-selector-tag">ch</span><span class="hljs-selector-class">.pipeline</span>()<span class="hljs-selector-class">.addLast</span>(&quot;<span class="hljs-selector-tag">websocket-handler</span>&quot;,<span class="hljs-selector-tag">webSocketServerHandler</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></details><details>    <summary>AppContext</summary><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.gxwzu.websocket;<br><br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.<span class="hljs-keyword">annotation</span>.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.Scope;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> javax.<span class="hljs-keyword">annotation</span>.PostConstruct;<br><span class="hljs-keyword">import</span> javax.<span class="hljs-keyword">annotation</span>.PreDestroy;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Scope()</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppContext</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(AppContext.<span class="hljs-keyword">class</span>);<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> WebSocketServer webSocketServer;<br><br>    <span class="hljs-keyword">private</span> Thread nettyThread;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 描述：Tomcat加载完ApplicationContext-main和netty文件后：</span><br><span class="hljs-comment">     *      1. 启动Netty WebSocket服务器；</span><br><span class="hljs-comment">     *      2. 加载用户数据；</span><br><span class="hljs-comment">     *      3. 加载用户交流群数据。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> void <span class="hljs-keyword">init</span>() &#123;<br>        nettyThread = new Thread(webSocketServer);<br>        logger.info(<span class="hljs-string">&quot;开启独立线程，启动Netty WebSocket服务器...&quot;</span>);<br>        nettyThread.start();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 描述：Tomcat服务器关闭前需要手动关闭Netty Websocket相关资源，否则会造成内存泄漏。</span><br><span class="hljs-comment">     *      1. 释放Netty Websocket相关连接；</span><br><span class="hljs-comment">     *      2. 关闭Netty Websocket服务器线程。（强行关闭，是否有必要？）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SuppressWarnings(<span class="hljs-meta-string">&quot;deprecation&quot;</span>)</span><br>    <span class="hljs-meta">@PreDestroy</span><br>    <span class="hljs-keyword">public</span> void close() &#123;<br>        logger.info(<span class="hljs-string">&quot;正在释放Netty Websocket相关连接...&quot;</span>);<br>        webSocketServer.close();<br>        logger.info(<span class="hljs-string">&quot;正在关闭Netty Websocket服务器线程...&quot;</span>);<br>        nettyThread.stop();<br>        logger.info(<span class="hljs-string">&quot;系统成功关闭！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/albertfly/article/details/51526423">Tomcat 通过listener 启动netty 服务</a></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Minikube 使用教程</title>
    <link href="/2020/04/02/k8s/Minikube-Use-Tutorials/"/>
    <url>/2020/04/02/k8s/Minikube-Use-Tutorials/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="启动-K8s-集群"><a href="#启动-K8s-集群" class="headerlink" title="启动 K8s 集群"></a>启动 K8s 集群</h2><p><code>sudo minikube start --vm-driver=none --image-repository=registry.aliyuncs.com/google_containers</code></p><h3 id="启动GUI"><a href="#启动GUI" class="headerlink" title="启动GUI"></a>启动GUI</h3><p><code>minikube dashboard</code></p><h2 id="K8s-部署应用程序"><a href="#K8s-部署应用程序" class="headerlink" title="K8s 部署应用程序"></a>K8s 部署应用程序</h2><p>Server.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><br><span class="hljs-keyword">var</span> handleRequest = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">request, response</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Received request for URL: &#x27;</span> + request.url);<br>  response.writeHead(<span class="hljs-number">200</span>);<br>  response.end(<span class="hljs-string">&#x27;Hello World!&#x27;</span>);<br>&#125;;<br><span class="hljs-keyword">var</span> www = http.createServer(handleRequest);<br>www.listen(<span class="hljs-number">8080</span>);<br></code></pre></td></tr></table></figure><p>Dockerfile</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">FROM</span> <span class="hljs-string">node:6.9.2</span><br><span class="hljs-string">EXPOSE</span> <span class="hljs-number">8080</span><br><span class="hljs-string">COPY</span> <span class="hljs-string">server.js</span> <span class="hljs-string">.</span><br><span class="hljs-string">CMD</span> <span class="hljs-string">node</span> <span class="hljs-string">Server.js</span><br></code></pre></td></tr></table></figure><p>打包镜像</p><p><code>docker build -t hello-node:v1 .</code></p><p>部署应用</p><p><code>kubectl run hello-node --image=hello-node:v1 --port=8080</code></p><p>查看Deployment：</p><p><code>kubectl get deployments</code></p><p>输出：</p><blockquote><p>NAME        DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE<br>hello-node   1         1         1            1           3m</p></blockquote><p>查看Pod：</p><p><code>kubectl get pods</code></p><p>输出：</p><blockquote><p>NAME                        READY     STATUS    RESTARTS   AGE<br>hello-node-714049816-ztzrb   1/1       Running   0          6m</p></blockquote><p>查看群集events：</p><p><code>kubectl get events</code></p><p>查看kubectl配置：</p><p><code>kubectl config view</code></p><p>创建Service</p><blockquote><p>默认情况，这Pod只能通过Kubernetes群集内部IP访问。要使hello-node容器从Kubernetes虚拟网络外部访问，须要使用Kubernetes Service暴露Pod。</p></blockquote><p>我们可以使用kubectl expose命令将Pod暴露到外部环境：</p><p><code>kubectl expose deployment hello-node --type=LoadBalancer</code></p><p>查看刚创建的Service：</p><p><code>kubectl get services</code></p><p>输出：</p><blockquote><p>NAME        CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE<br>hello-node   10.0.0.71    <pending>     8080/TCP   6m<br>kubernetes   10.0.0.1     <none>        443/TCP    14d</p></blockquote><blockquote><p>通过–type=LoadBalancer flag来在群集外暴露Service，在支持负载均衡的云提供商上，将配置外部IP地址来访问Service。在Minikube上，该LoadBalancer type使服务可以通过minikube Service 命令访问。</p></blockquote><p><code>minikube service hello-node</code></p><p>将打开浏览器，在本地IP地址为应用提供服务，显示“Hello World”的消息。</p><p>最后可以查看到一些日志</p><p><code>kubectl logs &lt;POD-NAME&gt;</code></p><h2 id="K8s-更新应用程序"><a href="#K8s-更新应用程序" class="headerlink" title="K8s 更新应用程序"></a>K8s 更新应用程序</h2><p>编辑server.js文件以返回新消息：</p><p><code>response.end(&#39;Hello World Again!&#39;);</code></p><p>build新版本镜像</p><p><code>docker build -t hello-node:v2 .</code></p><p>Deployment更新镜像：</p><p><code>kubectl set image deployment/hello-node hello-node=hello-node:v2</code></p><p>再次运行应用以查看新消息：</p><p><code>minikube service hello-node</code></p><h2 id="删除-K8s-集群"><a href="#删除-K8s-集群" class="headerlink" title="删除 K8s 集群"></a>删除 K8s 集群</h2><p>现在可以删除在群集中创建的资源：</p><p><code>kubectl delete service hello-node</code><br><code>kubectl delete deployment hello-node</code></p><p>或者停止Minikube：</p><p><code>minikube stop</code></p><h2 id="K8s-kubectl-命令表"><a href="#K8s-kubectl-命令表" class="headerlink" title="K8s kubectl 命令表"></a>K8s kubectl 命令表</h2><p><a href="http://docs.kubernetes.org.cn/683.html">kubectl命令列表</a></p>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter 快速入门</title>
    <link href="/2020/03/29/front/Flutter-Quick-Start/"/>
    <url>/2020/03/29/front/Flutter-Quick-Start/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="Flutter-简单介绍"><a href="#Flutter-简单介绍" class="headerlink" title="Flutter 简单介绍"></a>Flutter 简单介绍</h2><p>Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。</p><h2 id="Flutter-相关特性"><a href="#Flutter-相关特性" class="headerlink" title="Flutter 相关特性"></a>Flutter 相关特性</h2><ul><li><p>快速开发:Flutter的热重载可帮助您快速地进行测试、构建UI、添加功能并更快地修复错误。在iOS和Android模拟器或真机上可以在亚秒内重载，并且不会丢失状态。</p></li><li><p>富有表现力，漂亮的用户界面:使用Flutter内置美丽的Material Design和Cupertino（iOS风格）widget、丰富的motion API、平滑而自然的滑动效果和平台感知，为您的用户带来全新体验。</p></li><li><p>现代的，响应式框架:使用Flutter的现代、响应式框架，和一系列基础widget，轻松构建您的用户界面。使用功能强大且灵活的API（针对2D、动画、手势、效果等）解决艰难的UI挑战。</p></li></ul><h2 id="Flutter-安装教程"><a href="#Flutter-安装教程" class="headerlink" title="Flutter 安装教程"></a>Flutter 安装教程</h2><p>下载 Flutter SDK: </p><p><code>wget https://storage.googleapis.com/flutter_infra/releases/stable/linux/flutter_linux_v1.12.13+hotfix.8-stable.tar.xz</code></p><p>解压:</p><p> <code>cd ~/development</code><br> <code>tar xf ~/Downloads/flutter_linux_v1.12.13+hotfix.8-stable.tar.xz</code></p><p>如果不想安装固定版本的安装包，可以跳过步骤1和2。相反，从GitHub上的Flutter repo获取源代码，并根据需要更改分支或标记。例如：</p><p> <code>git clone https://github.com/flutter/flutter.git -b stable</code></p><p>添加Flutter 工具到你的path路径:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PUB_HOSTED_URL=https://pub.flutter-io.cn<br><span class="hljs-built_in">export</span> FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn<br><span class="hljs-built_in">export</span> PATH=/home/mikey/DATA/DevTools/flutter/bin:&#123;PATH&#125;:&#123;PATH&#125;:<span class="hljs-variable">$&#123;ANDROID_HOME&#125;</span>/platform-tools<br></code></pre></td></tr></table></figure><p>可选地，预下载开发二进制文件:</p><p><code>lutter precache</code></p><p>运行 flutter doctor</p><p><code>flutter doctor</code></p><p>此命令检查您的环境并向终端窗口显示报告。Dart SDK与Flutter捆绑在一起，不需要单独安装Dart。仔细检查输出是否有其他需要安装的软件或要执行的其他任务。<br>例如:</p><blockquote><p>Android toolchain - develop for Android devices<br>    • Android SDK at /Users/obiwan/Library/Android/sdk<br>    ✗ Android SDK is missing command line tools; download from <a href="https://goo.gl/XxQghQ">https://goo.gl/XxQghQ</a><br>    • Try re-installing or updating your Android SDK,<br>      visit <a href="https://flutter.dev/setup/#android-setup">https://flutter.dev/setup/#android-setup</a> for detailed instructions.  </p></blockquote><h2 id="Android-Studio-设置"><a href="#Android-Studio-设置" class="headerlink" title="Android Studio 设置"></a>Android Studio 设置</h2><p>安装插件：</p><p>1.flutter</p><p>2.dart</p><h2 id="Flutter-简单案例"><a href="#Flutter-简单案例" class="headerlink" title="Flutter 简单案例"></a>Flutter 简单案例</h2><p><a href="https://flutterchina.club/get-started/codelab/">编写您的第一个 Flutter App</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://flutter.dev/docs">官网文档</a></p><p><a href="https://flutter.dev/docs/get-started/install/linux">安装教程</a></p><p><a href="https://book.flutterchina.club/">flutter实战</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Minikube 安装教程</title>
    <link href="/2020/03/25/k8s/minikube-install-tutorials/"/>
    <url>/2020/03/25/k8s/minikube-install-tutorials/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="MINIKUBE-INSTALL-TUTORIALS"><a href="#MINIKUBE-INSTALL-TUTORIALS" class="headerlink" title="MINIKUBE INSTALL TUTORIALS"></a>MINIKUBE INSTALL TUTORIALS</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul><li>Ubuntu16</li></ul><h2 id="安装-kubectl"><a href="#安装-kubectl" class="headerlink" title="安装 kubectl"></a>安装 kubectl</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.18.0/bin/linux/amd64/kubectl<br>chmod +x ./kubectl<br>sudo mv ./kubectl /usr/local/bin/kubectl<br>kubectl version --client<br></code></pre></td></tr></table></figure><h2 id="安装-Minikube"><a href="#安装-Minikube" class="headerlink" title="安装 Minikube"></a>安装 Minikube</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube_1.8.0_amd64.deb &amp;&amp; sudo dpkg -i minikube_1.8.0_amd64.deb<br></code></pre></td></tr></table></figure><blockquote><p>国内可能无法访问,可以采用阿里源</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">curl -Lo minikube https://github.com/kubernetes/minikube/releases/download/v1.8.0/minikube-linux-amd64 &amp;&amp; chmod +x minikube &amp;&amp; sudo mv minikube /usr/local/bin/<br></code></pre></td></tr></table></figure><h2 id="配置-Hypervisor"><a href="#配置-Hypervisor" class="headerlink" title="配置 Hypervisor"></a>配置 Hypervisor</h2><p>验证您的系统是否启用了虚拟化支持：<code>egrep -q &#39;vmx|svm&#39; /proc/cpuinfo &amp;&amp; echo yes || echo no</code></p><blockquote><p>如果上述命令输出“否”：<br> 如果您在虚拟机中运行，那么您的虚拟机监控程序不允许嵌套虚拟化。你需要使用无（裸金属）驱动器<br> 如果您在物理机器上运行，请确保您的BIOS启用了硬件虚拟化</p></blockquote><h2 id="启动-Minikube"><a href="#启动-Minikube" class="headerlink" title="启动 Minikube"></a>启动 Minikube</h2><p><code>sudo minikube start --vm-driver=none --image-repository=registry.aliyuncs.com/google_containers</code></p><h2 id="所需镜像如下"><a href="#所需镜像如下" class="headerlink" title="所需镜像如下"></a>所需镜像如下</h2><blockquote><p>若无法连接谷歌可直接下载以下镜像（要对应版本）</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">docker pull registry.aliyuncs.com/google_containers/kube-proxy:v1.17.3<br>docker pull registry.aliyuncs.com/google_containers/kube-controller-manager:v1.17.3<br>docker pull registry.aliyuncs.com/google_containers/kube-apiserver:v1.17.3<br>docker pull registry.aliyuncs.com/google_containers/kube-scheduler:v1.17.3<br>docker pull registry.aliyuncs.com/google_containers/coredns:1.6.5<br>docker pull registry.aliyuncs.com/google_containers/etcd:3.4.3-0<br>docker pull registry.aliyuncs.com/google_containers/pause:3.1<br>docker pull registry.aliyuncs.com/google_containers/storage-provisioner:v1.8.1<br></code></pre></td></tr></table></figure><h2 id="Kubernetes-可视化界面"><a href="#Kubernetes-可视化界面" class="headerlink" title="Kubernetes 可视化界面"></a>Kubernetes 可视化界面</h2><p><code>minikube dashboard</code></p><p>访问控制台的连接即可</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/AliyunContainerService/minikube">Github代码库</a><br><a href="https://yq.aliyun.com/articles/221687">参考博文</a><br><a href="https://minikube.sigs.k8s.io/docs/start/">官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K8s 安装教程</title>
    <link href="/2020/03/21/k8s/k8s-install-tutorials/"/>
    <url>/2020/03/21/k8s/k8s-install-tutorials/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Kubernetes-安装-kubeadm"><a href="#Kubernetes-安装-kubeadm" class="headerlink" title="Kubernetes 安装 kubeadm"></a>Kubernetes 安装 kubeadm</h1><ul><li>1 事先准备</li><li>2 检查所需端口</li><li>2.1 Master节点</li><li>2.2 工作节点</li><li>3 Docker 安装</li><li>4 kubectl 安装</li><li>5 kubelet和kubeadm 安装</li></ul><h1 id="事先准备"><a href="#事先准备" class="headerlink" title="事先准备"></a>事先准备</h1><ul><li>多台Ubuntu 16.04+、CentOS 7或HypriotOS v1.0.1 + 系统  </li><li>每台机器最少1GB+内存  </li><li>集群中所有机器之间网络连接正常  </li><li>每个节点有唯一MAC地址和product_uuid  </li><li>打开某些端口。请参阅以下部分  </li></ul><h1 id="检查所需端口"><a href="#检查所需端口" class="headerlink" title="检查所需端口"></a>检查所需端口</h1><h2 id="Master节点"><a href="#Master节点" class="headerlink" title="Master节点"></a>Master节点</h2><table><tr><th>端口范围</th><th>用途</th></tr><tr><td>6443 *</td><td>    Kubernetes API server</td></tr><tr><td>2379-2380</td><td>    etcd server client API</td></tr><tr><td>10250</td><td>    Kubelet API</td></tr><tr><td>10251</td><td>    kube-scheduler</td></tr><tr><td>10252</td><td>    kube-controller-manager</td></tr><tr><td>10255</td><td>Read-only Kubelet API (Heapster)</td></tr></table><h2 id="工作节点"><a href="#工作节点" class="headerlink" title="工作节点"></a>工作节点</h2><table><tr><th>端口范围</th><th>用途</th></tr><tr><td>10250</td><td>Kubelet API</td></tr><tr><td>2379-2380</td><td>Read-only Kubelet API (Heapster)</td></tr><tr><td>30000-32767</td><td>NodePort Services默认端口范围。</td></tr></table><h1 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h1><p>在机器安装Docker，推荐使用1.12 版本（v1.10和v1.11也可以正常使用），1.13和17.03+版本未经过Kubernetes团队的测试和验证。有关安装说明，请参阅Docker官方文档 Docker安装。</p><h1 id="kubectl-安装"><a href="#kubectl-安装" class="headerlink" title="kubectl 安装"></a>kubectl 安装</h1><p>在所有机器上安装kubectl，可参考： kubectl安装。</p><h1 id="kubelet和kubeadm-安装"><a href="#kubelet和kubeadm-安装" class="headerlink" title="kubelet和kubeadm 安装"></a>kubelet和kubeadm 安装</h1><p>在所有机器上安装以下软件包：</p><ul><li>kubelet</li><li>kubeadm</li></ul><p>注意：如果机器上已经安装了kubeadm，则应需要apt-get update &amp;&amp; apt-get upgrade或者yum update获得最新版本的kubeadm。如果想了解不同版本的kubeadm，请参考</p><p>配置机器：</p><p>SSH登录主机。<br>如果使用的是Ubuntu或HypriotOS，请运行：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">apt-get update &amp;&amp; apt-get install -y apt-transport-https<br>curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -<br>cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.list<br>deb http://apt.kubernetes.io/ kubernetes-xenial main<br>EOF<br>apt-get update<br>apt-get install -y kubelet kubeadm<br></code></pre></td></tr></table></figure><p>如果使用的是CentOS，请运行：</p><p><code>cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</code></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">[kubernetes]<br>name=Kubernetes<br>baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64<br>enabled=1<br>gpgcheck=1<br>repo_gpgcheck=1<br>gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg<br>        https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg<br>EOF<br>setenforce 0<br>yum install -y kubelet kubeadm<br>systemctl enable kubelet &amp;&amp; systemctl start kubelet<br><br></code></pre></td></tr></table></figure><p>执行完后，kubelet会进入每隔几秒重新启动一次的循环模式，因为kubelet在等待kubeadm发出的命令。</p><p>注意：必须使用运行setenforce 0命令来禁用SELinux，因为需要允许容器访问主机文件系统，这是配置pod网络所要求的。（直到kubelet中对SELinux支持得到改进）</p><p>接下来使用kubeadm创建一个集群</p>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Knife4j 快速使用</title>
    <link href="/2020/03/21/note/Knife4j-Tutorials/"/>
    <url>/2020/03/21/note/Knife4j-Tutorials/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="knife4j简介"><a href="#knife4j简介" class="headerlink" title="knife4j简介"></a>knife4j简介</h2><p>前身:swagger-bootstrap-ui</p><h3 id="swagger简介"><a href="#swagger简介" class="headerlink" title="swagger简介"></a>swagger简介</h3><blockquote><p>Swagger是一个API接口管理工具，支持在线测试接口数据，根据配置自动生成API文档，结合spring mvc而提供界面化方法文档的一个开源框架。</p></blockquote><p>Swagger主要的项目<br>Swagger是一组开源项目，主要项目如下：</p><ul><li>Swagger-tools:提供各种与Swagger进行集成和交互的工具。例如模式检验、Swagger 1.2文档转换成Swagger 2.0文档等功能。</li><li>Swagger-core: 用于Java/Scala的的Swagger实现。与JAX-RS(Jersey、Resteasy、CXF…)、Servlets和Play框架进行集成。</li><li>Swagger-js: 用于JavaScript的Swagger实现。</li><li>Swagger-node-express: Swagger模块，用于node.js的Express web应用框架。</li><li>Swagger-ui：一个无依赖的HTML、JS和CSS集合，可以为Swagger兼容API动态生成优雅文档。</li><li>Swagger-codegen：一个模板驱动引擎，通过分析用户Swagger资源声明以各种语言生成客户端代码。</li><li>Swagger-editor：可让使用者在浏览器里以YAML格式编辑Swagger API规范并实时预览文档。可以生成有效的Swagger JSON描述，并用于所有Swagger工具（代码生成、文档等等）中。</li></ul><h3 id="Swagger-Bootstrap-UI简介"><a href="#Swagger-Bootstrap-UI简介" class="headerlink" title="Swagger-Bootstrap-UI简介"></a>Swagger-Bootstrap-UI简介</h3><blockquote><p>Swagger-Bootstrap-UI是springfox-swagger的增强UI实现，为Java开发者在使用Swagger的时候，能拥有一份简洁、强大的接口文档体验。</p></blockquote><h2 id="knife4j特点"><a href="#knife4j特点" class="headerlink" title="knife4j特点"></a>knife4j特点</h2><p>文档说明：根据Swagger的规范说明，详细列出接口文档的说明，包括接口地址、类型、请求示例、请求参数、响应示例、响应参数、响应码等信息，使用swagger-bootstrap-ui能根据该文档说明，对该接口的使用情况一目了然。</p><p>在线调试：提供在线接口联调的强大功能，自动解析当前接口参数,同时包含表单验证，调用参数可返回接口响应内容、headers、Curl请求命令实例、响应时间、响应状态码等信息，帮助开发者在线调试，而不必通过其他测试工具测试接口是否正确,简介、强大。</p><h2 id="knife4j使用"><a href="#knife4j使用" class="headerlink" title="knife4j使用"></a>knife4j使用</h2><p>1.创建springboot项目</p><p>2.添加依赖</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;dependencies&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;<br>        &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;<br>        &lt;!--在引用时请在maven中央仓库搜索最新版本号--&gt;<br>        &lt;version&gt;2.0.2&lt;/version&gt;<br>    &lt;/dependency&gt;<br>&lt;/dependencies&gt;<br></code></pre></td></tr></table></figure><p>3.配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2</span><br><span class="hljs-meta">@EnableKnife4j</span><br><span class="hljs-meta">@Import(BeanValidatorPluginsConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConfiguration</span> </span>&#123;<br> <br>    <span class="hljs-meta">@Bean(value = &quot;defaultApi2&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">defaultApi2</span><span class="hljs-params">()</span> </span>&#123;<br>        Docket docket=<span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)<br>                .apiInfo(apiInfo())<br>                <span class="hljs-comment">//分组名称</span><br>                .groupName(<span class="hljs-string">&quot;2.X版本&quot;</span>)<br>                .select()<br>                <span class="hljs-comment">//这里指定Controller扫描包路径</span><br>                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.swagger.bootstrap.ui.demo.new2&quot;</span>))<br>                .paths(PathSelectors.any())<br>                .build();<br>        <span class="hljs-keyword">return</span> docket;<br>    &#125;<br>    <br>　　<span class="hljs-function"><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title">apiInfo</span><span class="hljs-params">()</span> </span>&#123;<br>   　　 <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfoBuilder()<br>      　　  .title(<span class="hljs-string">&quot;大学生专业学科竞赛项目过程管理系统&quot;</span>)<br>        　　.description(<span class="hljs-string">&quot;大学生专业学科竞赛项目过程管理系统t文档&quot;</span>)<br>        　　.termsOfServiceUrl(<span class="hljs-string">&quot;&quot;</span>)<br>        　　.version(<span class="hljs-string">&quot;3.0.0&quot;</span>)<br>        　　.build();<br>　　&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注解说明</p><p><code>@EnableSwagger2</code></p><p>该注解是Springfox-swagger框架提供的使用Swagger注解，该注解必须加</p><p><code>@EnableKnife4j</code></p><p>该注解是knife4j提供的增强注解,Ui提供了例如动态参数、参数过滤、接口排序等增强功能,如果你想使用这些增强功能就必须加该注解，否则可以不用加</p><p>4.访问</p><p>在浏览器输入地址：<code>http://[you_host]:[you_port]/doc.html</code></p><p> <img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/knife4j-1.jpg" alt="avatar"></p><h2 id="knife4j资料"><a href="#knife4j资料" class="headerlink" title="knife4j资料"></a>knife4j资料</h2><p><a href="https://doc.xiaominfo.com/guide/useful.html">文档</a></p><p><a href="https://gitee.com/xiaoym/swagger-bootstrap-ui-demo">示例</a></p><p><a href="https://www.cnblogs.com/fby698/p/11581845.html">博文</a></p>]]></content>
    
    
    <categories>
      
      <category>开发组件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>接口文档</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hyperledger Caliper 性能测试工具配置</title>
    <link href="/2020/03/20/blockchain/Hyperledger-Caliper-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/03/20/blockchain/Hyperledger-Caliper-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Caliper性能测试工具配置"><a href="#Caliper性能测试工具配置" class="headerlink" title="Caliper性能测试工具配置"></a>Caliper性能测试工具配置</h1><p>基本上都是根据官方doc进行操作，个别部分有坑。</p><p><a href="https://hyperledger.github.io/caliper/docs/1_Getting_Started.html">官方doc</a></p><p>提前安装</p><blockquote><p>nodejs、node-gyp、docker、docker-compose</p></blockquote><h2 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h2><p><code>git clone https://github.com/hyperledger/caliper.git</code></p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>进入caliper代码根目录，执行以下命令：<br><code>npm install</code><br><code>npm run repoclean</code><br><code>npm run bootstrap</code></p><h2 id="安装caliper"><a href="#安装caliper" class="headerlink" title="安装caliper"></a>安装caliper</h2><p>根据官网步骤进行安装。</p><p><a href="https://github.com/hyperledger/caliper/blob/master/packages/caliper-tests-integration/README.md">安装步骤</a><br><code>cd ./packages/caliper-tests-integration</code></p><h4 id="开启Verdaccio"><a href="#开启Verdaccio" class="headerlink" title="开启Verdaccio"></a>开启Verdaccio</h4><p><code>npm run start_verdaccio</code></p><p>成功界面：<br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/Picture1.png" alt="avatar"></p><h4 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h4><p><code>npm run publish_packages</code></p><h4 id="安装caliper-1"><a href="#安装caliper-1" class="headerlink" title="安装caliper"></a>安装caliper</h4><p><code>npm run install_cli</code></p><p>成功界面：<br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/Picture2.png" alt="avatar"></p><h5 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h5><p>1.3.3.1.1.无权限<br>报错：gyp stack Error: EACCES: permission denied, mkdir ‘/usr/local/lib/node_modules/caliper…<br>原因：用户没有/usr/local/lib/node_modules/文件夹的写权限<br>解决方法：<br>（1）官方文档方法：修改npm的安装目录为一个本地用户有权限的目录，命令：<code>npm config set prefix ~/youdir</code>，修改后caliper会安装到此目录。<br>（2）我的方法：不想修改npm安装目录，并且我在root用户下进行的操作，怀疑安装过程中切换了用户。所以我修改了caliper安装命令，添加<code>--unsafe-perm</code>参数，避免用户切换。<br>修改文件：<code>packages/caliper-tests-integration/scripts/npm_install.js</code>第<code>65</code>行  </p><p>修改结果：  </p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/Picture3.png" alt="avatar"></p><p>修改完后重新执行 <code>npm run install_cli</code>  </p><p>1.3.3.1.2.卡在<code>node-pre-gyp</code>命令</p><p>若一直卡在如下界面，重新执行<code>npm run install_cli</code>。百度说要vpn，我没有vpn，重新执行命令一样ok。  </p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/Picture4.png" alt="avatar"></p><p>1.3.4.验证安装结果执行<code>caliper -v</code>，出现如下结果即安装成功</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/Picture5.png" alt="avatar"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>运行caliper提供的fabric1.4的sample。<br><code>cd packages/caliper-samples</code><br><code>caliper benchmark run -w ./ -c benchmark/simple/config.yaml -n network/fabric-v1.4/2org1peergoleveldb/fabric-ccp-go.yaml --caliper-core-skipendscript</code>  </p><p>成功界面：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/Picture6.png" alt="avatar"></p><p><code>caliper-core-skipendscript</code>加上此参数，caliper执行完会跳过下图配置文件fabric-ccp-go.yaml的end的命令，不关闭fabric环境，这样有助于查看日志。不想保留fabric环境可不加此参数。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/Picture7.png" alt="avatar"></p><p>Caliper运行日志记录在-w命令指定目录下的log目录中。</p><h2 id="官网的坑"><a href="#官网的坑" class="headerlink" title="官网的坑"></a>官网的坑</h2><p>1.5.1.千万不要执行<code>npm run cleanup</code></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/Picture8.png" alt="avatar"></p><p><code>npm run cleanup</code>执行过程中会删除安装的caliper，执行完此命令，在执行caliper -v会提示找不到命令。</p><p>1.5.2.不能执行One-step install</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/Picture9.png" alt="avatar"></p><p>官网One-step install如下：</p><p>One-step install也包含了npm run cleanup命令。所以安装完你依旧会看到如下界面：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/Picture10.png" alt="avatar"></p><p>还是不要偷懒使用一步安装了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/hyperledger/caliper">https://github.com/hyperledger/caliper</a><br><a href="https://hyperledger.github.io/caliper/docs/1_Getting_Started.html">https://hyperledger.github.io/caliper/docs/1_Getting_Started.html</a><br><a href="https://github.com/hyperledger/caliper/blob/master/packages/caliper-tests-integration/README.md">https://github.com/hyperledger/caliper/blob/master/packages/caliper-tests-integration/README.md</a>  </p>]]></content>
    
    
    <categories>
      
      <category>Hyperledger</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hyperledger Iroha</title>
    <link href="/2020/03/18/blockchain/Hyperledger-Iroha/"/>
    <url>/2020/03/18/blockchain/Hyperledger-Iroha/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Hyperledger-Iroha-简介"><a href="#Hyperledger-Iroha-简介" class="headerlink" title="Hyperledger Iroha 简介"></a>Hyperledger Iroha 简介</h1><h2 id="1-1。Iroha的主要特征是什么？"><a href="#1-1。Iroha的主要特征是什么？" class="headerlink" title="1.1。Iroha的主要特征是什么？"></a>1.1。Iroha的主要特征是什么？</h2><ul><li>简单的部署和维护</li><li>面向开发人员的各种库</li><li>基于角色的访问控制</li><li>化设计，由命令-查询分离原理驱动</li><li>和身份管理  </li></ul><p>在我们的质量模型中，我们专注于并不断改进：</p><ul><li>性（容错性，可恢复性）</li><li>效率（尤其是时间行为和资源利用）</li><li>性（易学性，用户错误保护，适当性可识别性）</li></ul><h2 id="在哪里可以使用Iroha？"><a href="#在哪里可以使用Iroha？" class="headerlink" title="在哪里可以使用Iroha？"></a>在哪里可以使用Iroha？</h2><p>Hyperledger Iroha是通用许可的区块链系统，可用于管理数字资产，身份和序列化数据。这对于银行间结算，中央银行数字货币，支付系统，国家ID和物流等应用可能很有用。</p><p>有关详细说明，请检查我们的用例场景部分。</p><p>1.3。它与比特币或以太坊有何不同？<br>比特币和以太坊被设计为无人允许的分类帐，任何人都可以加入并访问所有数据。它们还具有与系统交互所需的本机加密货币。</p><p>在Iroha中，没有本机加密货币。相反，为了满足企业的需求，允许进行系统交互，这意味着只有具有必需访问权限的人才能与系统交互。此外，还允许查询，以便可以控制对所有数据的访问。</p><p>与以太坊的主要区别尤其在于，Hyperledger Iroha允许用户通过使用系统中的预构建命令来执行常见功能，例如创建和传输数字资产。这就消除了编写繁琐且难以测试的智能合约的需要，从而使开发人员能够更快，风险更低地完成简单的任务。</p><p>1.4。它与其他Hyperledger框架或其他许可的区块链有何不同？<br>Iroha具有一种新颖的，具有Crash容错能力的共识算法（称为YAC [1]），该算法具有很高的性能，并允许以低延迟完成事务。</p><p>此外，与其他平台相比，Iroha的内置命令是一个主要优点，因为执行诸如创建数字资产，注册帐户以及在帐户之间转移资产之类的常见任务非常简单。此外，由于故障少，它缩小了攻击媒介，提高了系统的整体安全性。</p><p>最后，Iroha是唯一具有强大权限系统的分类帐，允许为所有命令，查询和网络加入设置权限。</p><p>[1]    另一个共识<br>1.5。如何围绕Iroha创建应用程序？<br>为了将区块链的功能带入您的应用程序，您应该首先考虑它如何与Iroha同行进行接口。一个好的开始是检查“ 概念和体系结构”部分，解释什么是事务和查询，以及应用程序的用户应该如何与之交互。</p><p>我们也有几个客户端库，这些库为开发人员提供了形成构建块的工具，例如签名，命令，向Iroha对等方发送消息并检查状态。</p><p>Hyperledger Iroha 核心概念<br>Why Iroha runs in a network? How to understand the objects inside and outside the system? How peers in the network collaborate and decide which data to put into the blockchain? We will look through the basics of Iroha in this section.</p><ul><li>2.1.1. Account</li><li>2.1.2. Asset</li><li>2.1.3. Block</li><li>2.1.4. Client</li><li>2.1.5. Command</li><li>2.1.6. Consensus</li><li>2.1.7. Domain</li><li>2.1.8. Peer</li><li>2.1.9. Permission</li><li>2.1.10. Proposal</li><li>2.1.11. Query</li><li>2.1.12. Quorum</li><li>2.1.13. Role</li><li>2.1.14. Signatory</li><li>2.1.15. Transaction</li><li>2.1.16. Batch of Transactions</li><li>2.1.17. Multisignature Transactions</li><li>2.1.18. Validation</li><li>2.1.19. Entity-relationship model</li></ul><h1 id="Hyperledger-Iroha-内部组成"><a href="#Hyperledger-Iroha-内部组成" class="headerlink" title="Hyperledger Iroha 内部组成"></a>Hyperledger Iroha 内部组成</h1><p>HL Iroha网络由几个基本组件组成，这些组件提供节点之间的通信。您可以在下面了解它们。</p><h1 id="Iroha体系结构图"><a href="#Iroha体系结构图" class="headerlink" title="Iroha体系结构图"></a>Iroha体系结构图</h1><p>2.2.1。Torii<br>客户的切入点。使用gRPC作为传输。为了与Iroha进行交互，任何人都可以使用gRPC端点（如“ 命令和查询”部分中所述）或使用客户端库。</p><p>2.2.2。MST处理器<br>多签名交易处理器</p><p>这是一项内部gRPC服务，可通过Gossip协议发送和接收来自其他对等方的消息。它的任务是发出尚未收到足够签名以达到法定人数的多重签名交易。</p><p>2.2.3。对等通信服务<br>Iroha的内部组件- 通过MstProcessor将交易从Torii 传输到Ordering Gate的中介。PCS的主要目标是隐藏与共识实现交互的复杂性。</p><p>2.2.4。订购门<br>它是内部Iroha组件（gRPC客户端），可将事务从对等通信服务中继到订购服务。Ordering Gate 从Ordering Service 接收提案（链中的潜在模块），并将其发送到Simulator进行状态验证。它还根据共识回合要求订购服务提供建议。</p><p>2.2.5。订购服务<br>内部Iroha组件（gRPC服务器），该组件从其他对等方接收消息，并将已通过无状态验证传递的多个交易合并到投标中。每个节点都有其自己的订购服务。提案创建可以由以下事件之一触发：</p><p>专用于交易收集的期限已到期。<br>订购服务已收到单个提案允许的最大交易量。<br>这两个参数（超时和建议的最大大小）都是可配置的（请检查特定于环境的参数页面）。</p><p>这两个触发器的共同先决条件是至少一项交易应到达订购服务。否则，将不会形成任何建议。</p><p>订购服务还对提案进行初步验证（例如，从提案中清除无状态拒绝的交易）。</p><p>2.2.6。经过验证的提案创建者<br>内部Iroha组件，对订购服务收到的投标中包含的交易执行状态验证。基于已通过状态验证的事务，将创建经过验证的提议并将其传递给Block Creator。所有未通过状态验证的交易都将被删除，并且不包含在已验证的投标中。</p><p>2.2.7。块造物主<br>系统组件，它通过一系列已通过无状态和有状态验证的事务构成块，以便进一步传播到共识。</p><p>区块创建者与“ 验证提议创建者”一起构成了一个名为Simulator的组件。</p><p>2.2.8。区块共识（YAC）<br>共识，作为一个组成部分</p><p>共识是区块链的核心-它在对等网络中的对等之间保持一致的状态。Iroha使用自己的共识算法，称为“另一个共识”（又名YAC）。</p><p>您可以在此处观看视频，其中对共识和YAC的原理进行了详尽的解释。</p><p>YAC算法的显着特征是它的可伸缩性，性能和崩溃容错能力。</p><p>为了确保网络的一致性，如果缺少块，将通过Synchronizer从另一个对等方下载它们。提交的块存储在Ametsuchi块存储中。</p><p>有关共识的一般定义，请检查此链接。</p><p>2.2.9。同步器<br>是共识的一部分。将缺失的块添加到对等方的链中（从其他对等方下载它们以保持一致性）。</p><p>2.2.10。Ametsuchi Blockstore<br>Iroha存储组件，用于存储块和从块生成的状态，称为World State View。有没有办法让客户端直接与Ametsuchi互动。</p><p>2.2.11。世界状态视图<br>WSV反映了系统的当前状态，可以视为快照。例如，WSV保留有关帐户当前拥有的资产数量的信息 ，但不包含任何交易流的信息历史记录。 </p><h1 id="Hyperledger-Iroha-快速入门"><a href="#Hyperledger-Iroha-快速入门" class="headerlink" title="Hyperledger Iroha 快速入门"></a>Hyperledger Iroha 快速入门</h1><p>在本指南中，我们将创建一个非常基本的Iroha网络，启动它，创建几个事务，并检查写入分类帐中的数据。为简单起见，我们将使用Docker。</p><p>注意</p><p>Ledger是区块链的代名词，Hyperledger Iroha也被称为分布式Ledger技术框架-本质上与“区块链框架”相同。您可以检查“ 核心概念”部分中使用的其余术语。</p><p>3.1。前提条件<br>对于本指南，您需要一台Docker已安装的机器。您可以阅读如何在Docker网站上安装它。</p><p>注意</p><p>当然，您可以从头开始构建Iroha，修改其代码并启动自定义节点！如果您想知道如何做–您可以查看Building Iroha部分。在本指南中，我们将使用Iroha的标准发行版作为docker映像。</p><p>3.2。启动Iroha </p><p>3.2.1。创建一个Docker网络<br>要进行操作，Iroha需要一个PostgreSQL数据库。让我们从创建Docker网络开始，以便Postgres和Iroha的容器可以在同一虚拟网络上运行并成功通信。在本指南中，我们将其称为iroha-network，但您可以使用任何名称。在您的终端中输入以下命令：</p><p>泊坞窗网络创建iroha-network<br>3.2.2。启动PostgreSQL容器<br>现在，我们需要PostgreSQL在容器中运行，将其附加到之前创建的网络，并公开用于通信的端口：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">docker--name some-postgres<span class="hljs-string">\</span> <br>-e POSTGRES_USER = postgres<span class="hljs-string">\</span> <br>-e POSTGRES_PASSWORD = mysecretpassword <span class="hljs-string">\</span> <br>-p <span class="hljs-number">5432</span>：<span class="hljs-number">5432</span> <span class="hljs-string">\</span> <br>--network =iroha-network<span class="hljs-string">\</span> <br>-d postgres：<span class="hljs-number">9.5</span> <span class="hljs-string">\</span> <br>-c <span class="hljs-string">&#x27;max_prepared_transactions = 100&#x27;</span><br></code></pre></td></tr></table></figure><p>注意</p><p>如果已经在主机系统上的默认端口（5432）上运行了Postgres，则应选择另一个将被占用的空闲端口。例如5433：-p 5433:5432</p><p>3.2.3。创建Blockstore<br>在运行Iroha容器之前，我们可能会创建一个持久卷来存储文件，并为该链存储块。通过以下命令完成：</p><p>码头工人卷创建块存储<br>3.2.4。准备配置文件<br>注意</p><p>为简单起见，在本指南中，我们将创建一个仅包含单个节点的网络。要了解如何运行多个对等节点，请遵循部署</p><p>现在，我们需要配置Iroha网络。这包括创建配置文件，为用户生成密钥对，编写对等方列表以及创建创世块。</p><p>不要害怕-我们已经为本指南准备了一个示例配置，因此您可以立即开始测试Iroha节点。为了获取这些文件，您需要 从Github 克隆Iroha存储库或手动复制它们（不过克隆速度更快）。</p><p><code>git clone -b master https://github.com/hyperledger/iroha --depth = 1</code></p><p>暗示</p><p>–depth=1选项允许我们仅下载最新的提交并节省一些时间和带宽。如果要获取完整的提交历史记录，则可以忽略此选项。</p><p>关于如何设置参数以及如何根据您的环境和负载期望对其进行调整的指南：配置。目前我们不需要这样做。</p><p>3.2.5。启动Iroha容器<br>我们几乎准备启动我们的Iroha集装箱。您只需要知道配置文件的路径（从上述步骤开始）。</p><p>让我们使用以下命令在Docker容器中启动Iroha节点：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haml">docker run --name iroha \ <br>-<span class="ruby">d \ </span><br><span class="ruby">-p <span class="hljs-number">50051</span>：<span class="hljs-number">50051</span> \ </span><br><span class="ruby">-v <span class="hljs-variable">$ </span>&#123; pwd ） / iroha / example：/ opt / iroha_data \ </span><br><span class="ruby">-v blockstore：/ tmp / block_store \ </span><br><span class="ruby">--network = iroha-network \ </span><br><span class="ruby">- e KEY = <span class="hljs-string">&#x27;node0&#x27;</span>  \</span><br><span class="ruby">hyperledger / iroha：latest</span><br></code></pre></td></tr></table></figure><p>如果成功启动节点，您将在启动容器的同一控制台中看到容器ID。</p><p>让我们详细了解一下此命令的作用：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript">docker run --name iroha <span class="hljs-string">\</span> 创建一个容器 iroha<br>-d <span class="hljs-string">\</span> 在后台运行容器<br>-p <span class="hljs-number">50051</span>:<span class="hljs-number">50051</span> <span class="hljs-string">\</span> 公开用于与客户端通信的端口（我们将在以后使用）<br>-v YOUR_PATH_TO_CONF_FILES:/opt/iroha_data <span class="hljs-string">\这就是我们如何将配置文件传递到docker容器的方法。示例目录在上面的代码块中指示。</span><br>-v blockstore:/tmp/block_store <span class="hljs-string">\</span> 将持久性块存储（Docker卷）添加到容器中，以便在我们停止容器后不会丢失块<br>--network=iroha-network <span class="hljs-string">\将我们的容器添加到先前创建的iroha-network</span> 用于与PostgreSQL服务器通信的容器<br>-e KEY=<span class="hljs-string">&#x27;node0&#x27;</span> <span class="hljs-string">\-在此请指出一个密钥名称，该名称将标识允许其确认操作的节点。密钥应与上述配置文件一起放在目录中。</span><br>hyperledger/iroha:latest是指向最新版本的图像的引用<br></code></pre></td></tr></table></figure><p>您可以通过运行查看日志。docker logs iroha</p><p>您可以尝试使用示例指南之一，以便将一些事务发送到Iroha并查询其状态。</p><h3 id="3-3。尝试其他指南"><a href="#3-3。尝试其他指南" class="headerlink" title="3.3。尝试其他指南"></a>3.3。尝试其他指南</h3><p>3.3.1。CLI指南：发送您的第一笔交易和查询<br>3.3.1.1。创建第一笔交易<br>3.3.1.2。创建第一个查询<br>3.3.1.3。成为坏蛋<br>3.3.2。使用Python库发送交易<br>3.3.2.1。先决条件<br>3.3.2.2。运行示例交易<br>3.3.2.3。定义命令<br>3.3.2.4。运行命令<br>Hyperledger 综合项目<br>Hyperledger联盟的想法之一是创建可以一起工作以提供最佳区块链体验的解决方案。在Iroha中，我们相信其他出色的Hyperledger工具和解决方案的集成是使Iroha更好地适合您的用例的一种方式。因此，我们致力于与多个项目的集成，并希望向您详细介绍Iroha可以与之合作的内容。</p><h3 id="4-1。Hyperledger-Ursa"><a href="#4-1。Hyperledger-Ursa" class="headerlink" title="4.1。Hyperledger Ursa"></a>4.1。Hyperledger Ursa</h3><p>Hyperledger Ursa是一个共享的密码库，使人们（和项目）可以避免重复其他密码工作，并希望在此过程中提高安全性。该库将是供项目（以及可能还有其他项目）放置和使用加密货币的可选存储库。Hyperledger Ursa由子项目组成，这些子项目是密码代码或密码代码接口的内聚实现。</p><p>通过在构建过程中仅添加一个标志，可以轻松地使用Ursa库构建Iroha 。它将允许您使用Ursa库中的加密算法代替标准的Iroha加密技术。随着Ursa中新图书馆的发展，将为您提供越来越多的选择！</p><h3 id="4-2。Hyperledger-Explorer"><a href="#4-2。Hyperledger-Explorer" class="headerlink" title="4.2。Hyperledger Explorer"></a>4.2。Hyperledger Explorer</h3><p>Hyperledger Explorer是一个区块链模块，是The Linux Foundation托管的Hyperledger项目之一。Hyperledger Explorer旨在创建一个用户友好的Web应用程序，可以查看，调用，部署或查询块，事务和相关数据，网络信息（名称，状态，节点列表），链代码和事务族，以及任何其他相关信息存储在分类帐中。</p><p>在这里，您可以了解如何将Explorer与Iroha结合使用。</p><h3 id="4-3。Hyperledger-Burrow"><a href="#4-3。Hyperledger-Burrow" class="headerlink" title="4.3。Hyperledger Burrow"></a>4.3。Hyperledger Burrow</h3><p>Hyperledger Burrow为模块化区块链客户端提供了一个经过许可的智能合约解释器，该解释器部分已按照以太坊虚拟机（EVM）的规范进行开发。</p><p>我们将很快准备有关如何使用Iroha中集成的Burrow的说明。</p><h1 id="绑定-Iroha"><a href="#绑定-Iroha" class="headerlink" title="绑定 Iroha"></a>绑定 Iroha</h1><p>In this guide we will learn how to install all dependencies, required to build Iroha and how to actually build it.</p><p>There will be 3 steps:</p><p>1.Installing environment prerequisites<br>2.Installing Iroha dependencies (will be performed automatically for Docker)<br>3.Building Iroha  </p><p>Note</p><p>You don’t need to build Iroha to start using it. Instead, you can download prepared Docker image from the Hub, this process explained in details in the Quick Start Guide page of this documentation.</p><p>5.1. Prerequisites<br>In order to successfully build Iroha, we need to configure the environment. There are several ways to do it and we will describe all of them.</p><p>Currently, we support Unix-like systems (we are basically targeting popular Linux distros and MacOS). If you happen to have Windows or you don’t want to spend time installing all dependencies you might want to consider using Docker environment. Also, Windows users might consider using WSL</p><p>Technically Iroha can be built under Windows natively in experimental mode. This guide covers that way too. All the stages related to native Windows build are separated from the main flow due to its significant differences.</p><p>Please choose your preferred platform below for a quick access:</p><ul><li>docker</li><li>linux</li><li>macOS</li><li>windows</li><li>Hint</li></ul><p>Having troubles? Check FAQ section or communicate to us directly, in case you were stuck on something. We don’t expect this to happen, but some issues with an environment are possible.</p><p>5.1.1. Docker<br>First of all, you need to install docker and docker-compose. You can read how to install it on the Docker’s website</p><p>Note</p><p>Please, use the latest available docker daemon and docker-compose.</p><p>Then you should clone the Iroha repository to the directory of your choice:</p><p><code>git clone -b master https://github.com/hyperledger/iroha --depth=1</code></p><p>Hint</p><p>–depth=1 option allows us to download only latest commit and save some time and bandwidth. If you want to get a full commit history, you can omit this option.</p><p>When it is done, you need to run the development environment. Run the scripts/run-iroha-dev.sh script:</p><p>bash scripts/run-iroha-dev.sh<br>Hint</p><p>Please make sure that Docker is running before executing the script. MacOS users could find a Docker icon in system tray, Linux users can use systemctl start docker</p><p>After you execute this script, the following things will happen:</p><p>The script will check whether you have containers with Iroha already running. Successful completion finishes with the new container shell.<br>The script will download hyperledger/iroha:develop-build and postgres images. hyperledger/iroha:develop-build image contains all development dependencies and is based on top of ubuntu:18.04. postgres image is required for starting and running Iroha.<br>Two containers are created and launched.<br>The user is attached to the interactive environment for development and testing with iroha folder mounted from the host machine. Iroha folder is mounted to /opt/iroha in Docker container.<br>Now your are ready to build Iroha! Please go directly to Building Iroha section.</p><p>5.1.2. Linux<br>To build Iroha, you will need the following packages:</p><p>build-essential git ca-certificates tar ninja-build curl unzip cmake</p><p>Use this code to install environment dependencies on Debian-based Linux distro.</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">apt-get update<span class="hljs-comment">; \</span><br>apt-get -y --no-<span class="hljs-keyword">install-recommends </span><span class="hljs-keyword">install </span>\<br><span class="hljs-keyword">build-essential </span>ninja-<span class="hljs-keyword">build </span>\<br>git ca-certificates tar curl unzip cmake<br></code></pre></td></tr></table></figure><p>Note</p><p>If you are willing to actively develop Iroha and to build shared libraries, please consider installing the latest release of CMake.</p><p>Now you are ready to install Iroha dependencies.</p><p>5.1.3. MacOS<br>If you want to build Iroha from scratch and actively develop it, please use the following code to install all environment dependencies with Homebrew:</p><p><code>xcode-select --install</code><br><code>brew install cmake ninja git gcc@7</code></p><p>Hint</p><p>To install the Homebrew itself please run</p><p><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/homebrew/install/master/install)&quot;</code></p><p>Now you are ready to install Iroha dependencies.</p><p>5.1.4. Windows<br>Note</p><p>All the listed commands are designed for building 64-bit version of Iroha.</p><p>5.1.4.1. Chocolatey Package Manager<br>First of all you need Chocolatey package manager installed. Please refer the guide for chocolatey installation.</p><p>5.1.4.2. Building the Toolset<br>Install CMake, Git, Microsoft compilers via chocolatey being in Administrative mode of command prompt:</p><p>choco install cmake git visualstudio2019-workload-vctools ninja<br>PostgreSQL is not a build dependency, but it is recommended to install it now for the testing later:</p><p>choco install postgresql<br>Don’t forget the password you set!<br>Now you are ready to install Iroha dependencies.</p><p>5.2. Installing dependencies with Vcpkg Dependency Manager<br>Currently we use Vcpkg as a dependency manager for all platforms - Linux, Windows and MacOS. We use a fixed version of Vcpkg to ensure the patches we need will work.</p><p>That stable version can only be found inside the Iroha repository, so we will need to clone Iroha. The whole process is pretty similar for all platforms but the exact commands are slightly different.</p><p>5.2.1. Linux and MacOS<br>Run in terminal:</p><p><code>git clone https://github.com/hyperledger/iroha.git</code><br><code>iroha/vcpkg/build_iroha_deps.sh</code><br><code>vcpkg/vcpkg integrate install</code></p><p>After the installation of vcpkg you will be provided with a CMake build parameter like -DCMAKE_TOOLCHAIN_FILE=/path/to/vcpkg/scripts/buildsystems/vcpkg.cmake. Save it somewhere for later use and move to Building Iroha section.</p><p>5.2.2. Windows<br>Execute from Power Shell:</p><p><code>git clone https://github.com/hyperledger/iroha.git</code><br><code>powershell -ExecutionPolicy ByPass -File .\iroha\.packer\win\scripts\vcpkg.ps1 .\vcpkg .\iroha\vcpkg</code></p><p>After the installation of vcpkg you will be provided with a CMake build parameter like -DCMAKE_TOOLCHAIN_FILE=C:/path/to/vcpkg/scripts/buildsystems/vcpkg.cmake. Save it somewhere for later use and move to Building Iroha section.</p><p>Note</p><p>If you plan to build 32-bit version of Iroha - you will need to install all the mentioned librares above prefixed with x86 term instead of x64.</p><p>5.3. Build Process<br>5.3.1. Cloning the Repository<br>This step is currently unnecessary since you have already cloned Iroha in the previous step. But if you want, you can clone the Iroha repository to the directory of your choice.</p><p><code>git clone -b master https://github.com/hyperledger/iroha</code><br><code>cd iroha</code></p><p>Hint</p><p>If you have installed the prerequisites with Docker, you don’t need to clone Iroha again, because when you run run-iroha-dev.sh it attaches to Iroha source code folder. Feel free to edit source code files with your host environment and build it within docker container.</p><p>5.3.2. Building Iroha<br>To build Iroha, use these commands:</p><p><code>cmake -H. -Bbuild -DCMAKE_TOOLCHAIN_FILE=/path/to/vcpkg/scripts/buildsystems/vcpkg.cmake -G &quot;Ninja&quot;</code><br><code>cmake --build build --target irohad -- -j&lt;number of threads&gt;</code></p><p>Note</p><p>On Docker the path to a toolchain file is /opt/dependencies/scripts/buildsystems/vcpkg.cmake. In other environment please use the path you have got in previous steps.</p><p>Number of threads will be defined differently depending on the platform: - On Linux: via nproc. - On MacOS: with sysctl -n hw.ncpu. - On Windows: use echo %NUMBER_OF_PROCESSORS%.</p><p>Note</p><p>When building on Windows do not execute this from the Power Shell. Better use x64 Native tools command prompt.</p><p>Now Iroha is built. Although, if you like, you can build it with additional parameters described below.</p><p>5.3.3. CMake Parameters<br>We use CMake to generate platform-dependent build files. It has numerous flags for configuring the final build. Note that besides the listed parameters cmake’s variables can be useful as well. Also as long as this page can be deprecated (or just not complete) you can browse custom flags via cmake -L, cmake-gui, or ccmake.</p><p>Hint</p><blockquote><p>You can specify parameters at the cmake configuring stage (e.g cmake -DTESTING=ON).</p></blockquote><p>5.3.3.1. Main Parameters<br>Parameter    Possible values    Default    Description<br>TESTING    ON/OFF    ON    Enables or disables build of the tests<br>BENCHMARKING    OFF    Enables or disables build of the Google Benchmarks library<br>COVERAGE    OFF    Enables or disables lcov setting for code coverage generation<br>USE_LIBURSA    OFF    Enables usage of the HL Ursa cryptography instead of the standard one<br>Note</p><blockquote><p>If you would like to use HL Ursa cryptography for your build, please install Rust in addition to other dependencies. Learn more about HL Ursa integration here.</p></blockquote><p>5.3.3.2. Packaging Specific Parameters<br>Parameter    Possible values    Default    Description<br>PACKAGE_ZIP    ON/OFF    OFF    Enables or disables zip packaging<br>PACKAGE_TGZ    OFF    Enables or disables tar.gz packaging<br>PACKAGE_RPM    OFF    Enables or disables rpm packaging<br>PACKAGE_DEB    OFF    Enables or disables deb packaging<br>5.3.4. Running Tests (optional)<br>After building Iroha, it is a good idea to run tests to check the operability of the daemon. You can run tests with this code:</p><p><code>cmake --build build --target test</code><br>Alternatively, you can run the following command in the build folder</p><p><code>cd build</code><br><code>ctest . --output-on-failure</code><br>Note</p><blockquote><p>Some of the tests will fail without PostgreSQL storage running, so if you are not using scripts/run-iroha-dev.sh script please run Docker container or create a local connection with following parameters:</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-builtin-name">run</span> --name some-postgres \<br>-e <span class="hljs-attribute">POSTGRES_USER</span>=postgres \<br>-e <span class="hljs-attribute">POSTGRES_PASSWORD</span>=mysecretpassword \<br>-p 5432:5432 \<br>-d postgres:9.5 \<br>-c <span class="hljs-string">&#x27;max_prepared_transactions=100&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="Hyperledger-Iroha-相关资料"><a href="#Hyperledger-Iroha-相关资料" class="headerlink" title="Hyperledger Iroha 相关资料"></a>Hyperledger Iroha 相关资料</h1><p><a href="https://iroha.readthedocs.io/en/latest/">官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>Hyperledger</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hyperledger Caliper 测试框架</title>
    <link href="/2020/03/16/blockchain/Hyperledger-Caliper/"/>
    <url>/2020/03/16/blockchain/Hyperledger-Caliper/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="Caliper-简介"><a href="#Caliper-简介" class="headerlink" title="Caliper 简介"></a>Caliper 简介</h2><p>Caliper是一个区块链性能基准框架，允许用户使用自定义用例测试不同的区块链解决方案，并获得一组性能测试结果。</p><blockquote><p>Caliper is a blockchain benchmark framework which allows users to measure the performance of a specific blockchain implementation with a set of predefined use cases. Caliper will produce reports containing a number of performance indicators, such as TPS (Transactions Per Second), transaction latency, resource utilisation etc. The intent is for Caliper results to be used as a reference in supporting the choice of a blockchain implementation suitable for the user-specific use-cases. Given the variety of blockchain configurations, network setup, as well as the specific use-cases in mind, it is not intended to be an authoritative performance assessment, nor to be used for simple comparative purposes (e.g. blockchain A does 5 TPS and blockchain B does 10 TPS, therefore B is better). The Caliper project references the definitions, metrics, and terminology as defined by the Performance &amp; Scalability Working Group (PSWG).</p></blockquote><h2 id="适用平台"><a href="#适用平台" class="headerlink" title="适用平台"></a>适用平台</h2><ul><li>Hyperledger Besu  </li><li>Hyperledger Burrow</li><li>Ethereum  </li><li>Hyperledger Fabric</li><li>FISCO BCOS</li><li>Hyperledger Iroha</li><li>Hyperledger Sawtooth</li><li>Transaction/read throughput</li><li>Transaction/read latency (minimum, maximum, average, percentile)</li><li>Resource consumption (CPU, Memory, Network IO, …)</li></ul><h2 id="安装Caliper"><a href="#安装Caliper" class="headerlink" title="安装Caliper"></a>安装Caliper</h2><p>Caliper is published as the <code>hyperledger/caliper-cli</code> NPM package and the <code>hyperledger/caliper</code><br> Docker image, both containing the CLI binary. Refer to the<br>Installing from NPM<br> and<br>Using the Docker image<br> sections for the available versions and their intricacies.</p><p>Installing and running Caliper usually consists of the following steps, thoroughly detailed by the remaining sections:</p><p>Acquire the Caliper CLI either from NPM or from DockerHub.<br>Execute a bind command through the CLI. This step pulls the specified version of SDK packages for the selected platform.<br>Start the benchmark through the CLI or by starting the Docker container.<br>The examples in the rest of the documentation use the<br>caliper-benchmarks<br> repository as the Caliper workspace since it contains many sample artifacts for benchmarking. Make sure you check out the appropriate tag/commit of the repository, matching the version of Caliper you use.</p><p>To clone the caliper-benchmarks repository, run:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">git clone http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/hyperledger/caliper-benchmarks.git<br><span class="hljs-keyword">cd</span> caliper-benchmarks<br>git checkout &lt;your Caliper <span class="hljs-keyword">version</span>&gt;<br></code></pre></td></tr></table></figure><p><em>Note</em>: </p><blockquote><p>If you are running your custom benchmark, then change this directory path (and other related configurations) accordingly in the examples.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Hyperledger</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>grpc 学习笔记</title>
    <link href="/2019/08/04/note/grpc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2019/08/04/note/grpc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Grpc介绍"><a href="#Grpc介绍" class="headerlink" title="Grpc介绍"></a>Grpc介绍</h1><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/grpc-1.png" alt="grpc特点"></p><p>在gRPC中，客户端应用程序可以直接在其他计算机上的服务器应用程序上调用方法，就好像它是本地对象一样，从而使您更轻松地创建分布式应用程序和服务。在许多RPC系统中，gRPC都基于定义服务的思想，即指定可以使用其参数和返回类型远程调用的方法。在服务器端，服务器实现此接口并运行gRPC服务器以处理客户端调用。在客户端，客户端具有一个存根（在某些语言中简称为客户端），提供与服务器相同的方法。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/landing-2.svg" alt="概念图"></p><p>从Google内部的服务器到您自己的台式机，gRPC客户端和服务器可以在各种环境中运行并相互通信，并且可以使用gRPC支持的任何语言编写。因此，例如，您可以使用Go，Python或Ruby的客户端轻松地用Java创建gRPC服务器。此外，最新的Google API的接口将具有gRPC版本，可让您轻松地在应用程序中内置Google功能。</p><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p>必备条件</p><ul><li><p><strong><a href="https://golang.org/">Go</a></strong>, any one of the <strong>three latest major</strong> <a href="https://golang.org/doc/devel/release.html">releases of Go</a>.</p><p>For installation instructions, see Go’s <a href="https://golang.org/doc/install">Getting Started</a> guide.</p></li><li><p><strong><a href="https://developers.google.com/protocol-buffers">Protocol buffer</a> compiler</strong>, <code>protoc</code>, <a href="https://developers.google.com/protocol-buffers/docs/proto3">version 3</a>.</p><p>For installation instructions, see <a href="https://grpc.io/docs/protoc-installation/">Protocol Buffer Compiler Installation</a>.</p></li><li><p><strong>Go plugins</strong> for the protocol compiler:</p><ol><li><p>Install the protocol compiler plugins for Go using the following commands:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">export</span> GO111MODULE=on  <span class="hljs-comment"># Enable module mode</span><br>$ go get google.golang.org/protobuf/cmd/protoc-gen-go \<br>         google.golang.org/grpc/cmd/protoc-gen-go-grpc<br></code></pre></td></tr></table></figure></li><li><p>Update your <code>PATH</code> so that the <code>protoc</code> compiler can find the plugins:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$PATH</span>:<span class="hljs-subst">$(go env GOPATH)</span>/bin&quot;</span><br></code></pre></td></tr></table></figure></li></ol></li></ul><h3 id="Get-the-example-code"><a href="#Get-the-example-code" class="headerlink" title="Get the example code"></a>Get the example code</h3><p>The example code is part of the <a href="https://github.com/grpc/grpc-go">grpc-go</a> repo.</p><ol><li><p><a href="https://github.com/grpc/grpc-go/archive/v1.34.0.zip">Download the repo as a zip file</a> and unzip it, or clone the repo:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git <span class="hljs-built_in">clone</span> -b v1.34.0 https://github.com/grpc/grpc-go<br></code></pre></td></tr></table></figure></li><li><p>Change to the quick start example directory:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">cd</span> grpc-go/examples/helloworld<br></code></pre></td></tr></table></figure></li></ol><h3 id="Run-the-example"><a href="#Run-the-example" class="headerlink" title="Run the example"></a>Run the example</h3><p>From the <code>examples/helloworld</code> directory:</p><ol><li><p>Compile and execute the server code:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ go run greeter_server/main.go<br></code></pre></td></tr></table></figure></li><li><p>From a different terminal, compile and execute the client code to see the client output:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ go run greeter_client/main.go<br>Greeting: Hello world<br></code></pre></td></tr></table></figure></li></ol><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p><a href="https://grpc.io/docs/">官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>RPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>grpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-kit 学习笔记</title>
    <link href="/2019/08/03/golang/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2019/08/03/golang/Go-kit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><blockquote><p>Go is a great general-purpose language, but microservices require a certain amount of specialized support. RPC safety, system observability, infrastructure integration, even program design — Go kit fills in the gaps left by the standard library, and makes Go a first-class language for writing microservices in any organization.</p></blockquote><h1 id="简单用例"><a href="#简单用例" class="headerlink" title="简单用例"></a>简单用例</h1><p>用户始终发现，学习Go kit的最有效方法是学习示例服务并向其学习。在这里，您可以找到一些示例，这些示例将使您适应Go kit的习惯用法，模式和最佳实践。</p><ul><li><strong><a href="https://gokit.io/examples/stringsvc.html">stringsvc</a></strong> 是一个教程，带您从基本原则开始编写服务。它可以帮助您了解Go kit设计中的决策。</li><li><strong><a href="https://github.com/go-kit/kit/blob/master/examples/addsvc">addsvc</a></strong> 是原始的示例服务。它在所有受支持的传输上公开了一组操作。它已完全记录，检测并使用分布式跟踪。它还演示了如何创建和使用客户端软件包。它演示了Go工具包的几乎所有功能。</li><li><strong><a href="https://github.com/go-kit/kit/blob/master/examples/profilesvc">profilesvc</a></strong> 演示了如何使用Go kit编写带有REST-ish API的微服务。它使用net / http和出色的Gorilla Web工具包。</li><li><strong><a href="https://github.com/go-kit/kit/blob/master/examples/shipping">运输</a></strong> 是基于域驱动设计原则的，由多个微服务组成的完整的“真实世界”应用程序。</li><li><strong><a href="https://github.com/go-kit/kit/blob/master/examples/apigateway">apigateway</a></strong> 演示了如何实现 由Consul服务发现系统支持的<a href="http://microservices.io/patterns/apigateway.html">API网关模式</a>。</li></ul><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p><a href="https://gokit.io/">官网文档</a></p><p><a href="https://learnku.com/go/t/36923">参考博文</a></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go-kit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Iris 学习笔记</title>
    <link href="/2019/05/25/golang/Iris-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2019/05/25/golang/Iris-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Iris简介"><a href="#Iris简介" class="headerlink" title="Iris简介"></a>Iris简介</h1><blockquote><p>Iris是一个高效且经过精心设计的跨平台Web框架，具有一组强大的功能。借助无限的潜力和可移植性，构建自己的高性能Web应用程序和API。</p></blockquote><h1 id="快速安装"><a href="#快速安装" class="headerlink" title="快速安装"></a>快速安装</h1><p>Iris is a cross-platform software.</p><p>The only requirement is the <a href="https://golang.org/dl/">Go Programming Language</a>, version 1.14 and above.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ mkdir myapp<br>$ go mod init myapp<br>$ go get github.com/kataras/iris/v12@masterCopy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>Import it in your code:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/kataras/iris/v12&quot;</span>Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><h3 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a><a href="https://www.iris-go.com/docs/#/?id=troubleshooting">Troubleshooting</a></h3><p>If you get a network error during installation please make sure you set a valid <a href="https://github.com/golang/go/wiki/Modules#are-there-always-on-module-repositories-and-enterprise-proxies">GOPROXY environment variable</a>.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">go env -w GOPROXY=https://goproxy.cn,https://gocenter.io,https://goproxy.io,directCopy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># assume the following codes in main.go file</span><br>$ cat main.goCopy to clipboardErrorCopied<br>package main<br><br>import <span class="hljs-string">&quot;github.com/kataras/iris/v12&quot;</span><br><br>func <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;<br>    app := iris.New()<br><br>    booksAPI := app.Party(<span class="hljs-string">&quot;/books&quot;</span>)<br>    &#123;<br>        booksAPI.Use(iris.Compression)<br><br>        // GET: http://localhost:8080/books<br>        booksAPI.Get(<span class="hljs-string">&quot;/&quot;</span>, list)<br>        // POST: http://localhost:8080/books<br>        booksAPI.Post(<span class="hljs-string">&quot;/&quot;</span>, create)<br>    &#125;<br><br>    app.Listen(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br><br>// Book example.<br><span class="hljs-built_in">type</span> Book struct &#123;<br>    Title string `json:<span class="hljs-string">&quot;title&quot;</span>`<br>&#125;<br><br>func list(ctx iris.Context) &#123;<br>    books := []Book&#123;<br>        &#123;<span class="hljs-string">&quot;Mastering Concurrency in Go&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;Go Design Patterns&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;Black Hat Go&quot;</span>&#125;,<br>    &#125;<br><br>    ctx.JSON(books)<br>    // TIP: negotiate the response between server<span class="hljs-string">&#x27;s prioritizes</span><br><span class="hljs-string">    // and client&#x27;</span>s requirements, instead of ctx.JSON:<br>    // ctx.Negotiation().JSON().MsgPack().Protobuf()<br>    // ctx.Negotiate(books)<br>&#125;<br><br>func create(ctx iris.Context) &#123;<br>    var b Book<br>    err := ctx.ReadJSON(&amp;b)<br>    // TIP: use ctx.ReadBody(&amp;b) to <span class="hljs-built_in">bind</span><br>    // any <span class="hljs-built_in">type</span> of incoming data instead.<br>    <span class="hljs-keyword">if</span> err != nil &#123;<br>        ctx.StopWithProblem(iris.StatusBadRequest, iris.NewProblem().<br>            Title(<span class="hljs-string">&quot;Book creation failure&quot;</span>).DetailErr(err))<br>        // TIP: use ctx.StopWithError(code, err) when only<br>        // plain text responses are expected on errors.<br>        <span class="hljs-built_in">return</span><br>    &#125;<br><br>    println(<span class="hljs-string">&quot;Received Book: &quot;</span> + b.Title)<br><br>    ctx.StatusCode(iris.StatusCreated)<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p><strong>MVC</strong> equivalent:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/kataras/iris/v12/mvc&quot;</span>Copy to clipboardErrorCopied<br>m := mvc.New(booksAPI)<br>m.Handle(<span class="hljs-built_in">new</span>(BookController))Copy to clipboardErrorCopied<br><span class="hljs-keyword">type</span> BookController <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">/* dependencies */</span><br>&#125;<br><br><span class="hljs-comment">// GET: http://localhost:8080/books</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *BookController)</span> <span class="hljs-title">Get</span><span class="hljs-params">()</span> []<span class="hljs-title">Book</span></span> &#123;<br>    <span class="hljs-keyword">return</span> []Book&#123;<br>        &#123;<span class="hljs-string">&quot;Mastering Concurrency in Go&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;Go Design Patterns&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;Black Hat Go&quot;</span>&#125;,<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// POST: http://localhost:8080/books</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *BookController)</span> <span class="hljs-title">Post</span><span class="hljs-params">(b Book)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Received Book: &quot;</span> + b.Title)<br><br>    <span class="hljs-keyword">return</span> iris.StatusCreated<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p><strong>Run</strong> your Iris web server:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ go run main.go<br>&gt; Now listening on: http://localhost:8080<br>&gt; Application started. Press CTRL+C to shut down.Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p><strong>List</strong> Books:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ curl --header <span class="hljs-string">&#x27;Accept-Encoding:gzip&#x27;</span> http://localhost:8080/books<br><br>[<br>  &#123;<br>    <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;Mastering Concurrency in Go&quot;</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;Go Design Patterns&quot;</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;Black Hat Go&quot;</span><br>  &#125;<br>]Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p><strong>Create</strong> a new Book:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ curl -i -X POST \<br>--header <span class="hljs-string">&#x27;Content-Encoding:gzip&#x27;</span> \<br>--header <span class="hljs-string">&#x27;Content-Type:application/json&#x27;</span> \<br>--data <span class="hljs-string">&quot;&#123;\&quot;title\&quot;:\&quot;Writing An Interpreter In Go\&quot;&#125;&quot;</span> \<br>http://localhost:8080/books<br><br>&gt; HTTP/1.1 201 CreatedCopy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>That’s how an <strong>error</strong> response looks like:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ curl -X POST --data <span class="hljs-string">&quot;&#123;\&quot;title\&quot; \&quot;not valid one\&quot;&#125;&quot;</span> \<br>http://localhost:8080/books<br><br>&gt; HTTP/1.1 400 Bad Request<br><br>&#123;<br>  <span class="hljs-string">&quot;status&quot;</span>: 400,<br>  <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;Book creation failure&quot;</span><br>  <span class="hljs-string">&quot;detail&quot;</span>: <span class="hljs-string">&quot;invalid character &#x27;\&quot;&#x27; after object key&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p><a href="https://iris-go.com/">官网</a></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go-iris</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gin 学习笔记</title>
    <link href="/2019/05/23/golang/Gin-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2019/05/23/golang/Gin-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Gin简介"><a href="#Gin简介" class="headerlink" title="Gin简介"></a>Gin简介</h1><blockquote><p>Gin是用Go（Golang）编写的HTTP Web框架。它具有类似于Martini的API，但性能比Martini快40倍。</p></blockquote><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><p class="note note-primary">    Go 1.7 or Go 1.8 will be no longer supported soon.</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>To install Gin package, you need to install Go and set your Go workspace first.</p><ol><li>Download and install it:</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ go get -u github.com/gin-gonic/gin<br></code></pre></td></tr></table></figure><ol><li>Import it in your code:</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br></code></pre></td></tr></table></figure><ol><li>(Optional) Import <code>net/http</code>. This is required for example if using constants such as <code>http.StatusOK</code>.</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;net/http&quot;</span><br></code></pre></td></tr></table></figure><ol><li>Create your project folder and <code>cd</code> inside</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ mkdir -p <span class="hljs-variable">$GOPATH</span>/src/github.com/myusername/project &amp;&amp; <span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-variable">$_</span>&quot;</span><br></code></pre></td></tr></table></figure><ol><li>Copy a starting template inside your project</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ curl https://raw.githubusercontent.com/gin-gonic/examples/master/basic/main.go &gt; main.go<br></code></pre></td></tr></table></figure><ol><li>Run your project</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ go run main.go<br></code></pre></td></tr></table></figure><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p><a href="https://github.com/gin-gonic/gin">官网文档</a><br><a href="https://geektutu.com/post/quick-go-gin.html">参考博文</a></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go-gin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Beego 学习笔记</title>
    <link href="/2019/05/21/golang/Beego-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2019/05/21/golang/Beego-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Bee-工具的使用"><a href="#Bee-工具的使用" class="headerlink" title="Bee 工具的使用"></a>Bee 工具的使用</h1><h2 id="bee-工具简介"><a href="#bee-工具简介" class="headerlink" title="bee 工具简介"></a>bee 工具简介</h2><p>bee 工具是一个为了协助快速开发 beego 项目而创建的项目，通过 bee 您可以很容易的进行 beego 项目的创建、热编译、开发、测试、和部署。</p><h2 id="bee-工具的安装"><a href="#bee-工具的安装" class="headerlink" title="bee 工具的安装"></a>bee 工具的安装</h2><p>您可以通过如下的方式安装 bee 工具：</p><pre><code>go get github.com/beego/bee</code></pre><p>安装完之后，<code>bee</code> 可执行文件默认存放在 <code>$GOPATH/bin</code> 里面，所以您需要把 <code>$GOPATH/bin</code> 添加到您的环境变量中，才可以进行下一步。</p><blockquote><blockquote><blockquote><p>如何添加环境变量，请自行搜索<br>如果你本机设置了 <code>GOBIN</code>，那么上面的命令就会安装到 <code>GOBIN</code> 下，请添加 GOBIN 到你的环境变量中</p></blockquote></blockquote></blockquote><h2 id="bee-工具命令详解"><a href="#bee-工具命令详解" class="headerlink" title="bee 工具命令详解"></a>bee 工具命令详解</h2><p>我们在命令行输入 <code>bee</code>，可以看到如下的信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs sql">Bee is a Fast and Flexible tool for managing your Beego Web Application.<br><br>Usage:<br><br>bee command [arguments]<br><br>The commands are:<br><br>    version     <span class="hljs-keyword">show</span> the bee &amp; beego <span class="hljs-keyword">version</span><br>    migrate     run <span class="hljs-keyword">database</span> migrations<br>    api         <span class="hljs-keyword">create</span> an api application base <span class="hljs-keyword">on</span> beego framework<br>    bale        packs non-<span class="hljs-keyword">Go</span> files <span class="hljs-keyword">to</span> <span class="hljs-keyword">Go</span> <span class="hljs-keyword">source</span> files    <br>    <span class="hljs-keyword">new</span>         <span class="hljs-keyword">create</span> an application base <span class="hljs-keyword">on</span> beego framework<br>    run         run the app which can hot compile<br>    pack        <span class="hljs-keyword">compress</span> an beego <span class="hljs-keyword">project</span><br>    fix         Fixes your application <span class="hljs-keyword">by</span> making it compatible <span class="hljs-keyword">with</span> newer <span class="hljs-keyword">versions</span> <span class="hljs-keyword">of</span> Beego<br>    dlv         <span class="hljs-keyword">Start</span> a debugging <span class="hljs-keyword">session</span> <span class="hljs-keyword">using</span> Delve<br>    dockerize   Generates a Dockerfile <span class="hljs-keyword">for</span> your Beego application<br>    generate    <span class="hljs-keyword">Source</span> code generator<br>    hprose      Creates an RPC application based <span class="hljs-keyword">on</span> Hprose <span class="hljs-keyword">and</span> Beego frameworks<br>    pack        Compresses a Beego application <span class="hljs-keyword">into</span> a single <span class="hljs-keyword">file</span><br>    rs          Run customized scripts<br>    run         Run the application <span class="hljs-keyword">by</span> <span class="hljs-keyword">starting</span> a <span class="hljs-keyword">local</span> development <span class="hljs-keyword">server</span><br>    <span class="hljs-keyword">server</span>      serving <span class="hljs-keyword">static</span> <span class="hljs-keyword">content</span> <span class="hljs-keyword">over</span> <span class="hljs-keyword">HTTP</span> <span class="hljs-keyword">on</span> port<br>    <br><span class="hljs-keyword">Use</span> bee <span class="hljs-keyword">help</span> [command] <span class="hljs-keyword">for</span> more information about a command.<br>    <br></code></pre></td></tr></table></figure><h3 id="new-命令"><a href="#new-命令" class="headerlink" title="new 命令"></a><code>new</code> 命令</h3><p><code>new</code> 命令是新建一个 Web 项目，我们在命令行下执行 <code>bee new &lt;项目名&gt;</code> 就可以创建一个新的项目。但是注意该命令必须在 <code>$GOPATH/src</code> 下执行。最后会在 <code>$GOPATH/src</code> 相应目录下生成如下目录结构的项目：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs gradle">bee <span class="hljs-keyword">new</span> myproject<br>[INFO] Creating application...<br><span class="hljs-regexp">/gopath/</span>src<span class="hljs-regexp">/myproject/</span><br><span class="hljs-regexp">/gopath/</span>src<span class="hljs-regexp">/myproject/</span>conf/<br><span class="hljs-regexp">/gopath/</span>src<span class="hljs-regexp">/myproject/</span>controllers/<br><span class="hljs-regexp">/gopath/</span>src<span class="hljs-regexp">/myproject/m</span>odels/<br><span class="hljs-regexp">/gopath/</span>src<span class="hljs-regexp">/myproject/</span><span class="hljs-keyword">static</span>/<br><span class="hljs-regexp">/gopath/</span>src<span class="hljs-regexp">/myproject/</span><span class="hljs-keyword">static</span><span class="hljs-regexp">/js/</span><br><span class="hljs-regexp">/gopath/</span>src<span class="hljs-regexp">/myproject/</span><span class="hljs-keyword">static</span><span class="hljs-regexp">/css/</span><br><span class="hljs-regexp">/gopath/</span>src<span class="hljs-regexp">/myproject/</span><span class="hljs-keyword">static</span><span class="hljs-regexp">/img/</span><br><span class="hljs-regexp">/gopath/</span>src<span class="hljs-regexp">/myproject/</span>views/<br><span class="hljs-regexp">/gopath/</span>src<span class="hljs-regexp">/myproject/</span>conf/app.conf<br><span class="hljs-regexp">/gopath/</span>src<span class="hljs-regexp">/myproject/</span>controllers/<span class="hljs-keyword">default</span>.go<br><span class="hljs-regexp">/gopath/</span>src<span class="hljs-regexp">/myproject/</span>views/index.tpl<br><span class="hljs-regexp">/gopath/</span>src<span class="hljs-regexp">/myproject/m</span>ain.go<br><span class="hljs-number">13</span>-<span class="hljs-number">11</span>-<span class="hljs-number">25</span> <span class="hljs-number">09</span>:<span class="hljs-number">50</span>:<span class="hljs-number">39</span> [SUCC] <span class="hljs-keyword">New</span> application successfully created!<br></code></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vim">myproject<br>├── <span class="hljs-keyword">conf</span><br>│   └── app.<span class="hljs-keyword">conf</span><br>├── controllers<br>│   └── default.<span class="hljs-keyword">go</span><br>├── main.<span class="hljs-keyword">go</span><br>├── models<br>├── routers<br>│   └── router.<span class="hljs-keyword">go</span><br>├── static<br>│   ├── css<br>│   ├── img<br>│   └── js<br>├── tests<br>│   └── default_test.<span class="hljs-keyword">go</span><br>└── views<br>    └── <span class="hljs-built_in">index</span>.tpl<br><br><span class="hljs-number">8</span> directories, <span class="hljs-number">4</span> <span class="hljs-keyword">files</span><br></code></pre></td></tr></table></figure><h3 id="api-命令"><a href="#api-命令" class="headerlink" title="api 命令"></a><code>api</code> 命令</h3><p>上面的 <code>new</code> 命令是用来新建 Web 项目，不过很多用户使用 beego 来开发 API 应用。所以这个 <code>api</code> 命令就是用来创建 API 应用的，执行命令之后如下所示：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gradle">bee api apiproject<br>create app folder: <span class="hljs-regexp">/gopath/</span>src/apiproject<br>create conf: <span class="hljs-regexp">/gopath/</span>src<span class="hljs-regexp">/apiproject/</span>conf<br>create controllers: <span class="hljs-regexp">/gopath/</span>src<span class="hljs-regexp">/apiproject/</span>controllers<br>create models: <span class="hljs-regexp">/gopath/</span>src<span class="hljs-regexp">/apiproject/m</span>odels<br>create tests: <span class="hljs-regexp">/gopath/</span>src<span class="hljs-regexp">/apiproject/</span>tests<br>create conf app.conf: <span class="hljs-regexp">/gopath/</span>src<span class="hljs-regexp">/apiproject/</span>conf/app.conf<br>create controllers <span class="hljs-keyword">default</span>.go: <span class="hljs-regexp">/gopath/</span>src<span class="hljs-regexp">/apiproject/</span>controllers/<span class="hljs-keyword">default</span>.go<br>create tests <span class="hljs-keyword">default</span>.go: <span class="hljs-regexp">/gopath/</span>src<span class="hljs-regexp">/apiproject/</span>tests/default_test.go<br>create models object.go: <span class="hljs-regexp">/gopath/</span>src<span class="hljs-regexp">/apiproject/m</span>odels/object.go<br>create main.go: <span class="hljs-regexp">/gopath/</span>src<span class="hljs-regexp">/apiproject/m</span>ain.go<br></code></pre></td></tr></table></figure><p>这个项目的目录结构如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vim">apiproject<br>├── <span class="hljs-keyword">conf</span><br>│   └── app.<span class="hljs-keyword">conf</span><br>├── controllers<br>│   └── object.<span class="hljs-keyword">go</span><br>│   └── user.<span class="hljs-keyword">go</span><br>├── docs<br>│   └── doc.<span class="hljs-keyword">go</span><br>├── main.<span class="hljs-keyword">go</span><br>├── models<br>│   └── object.<span class="hljs-keyword">go</span><br>│   └── user.<span class="hljs-keyword">go</span><br>├── routers<br>│   └── router.<span class="hljs-keyword">go</span><br>└── tests<br>    └── default_test.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p>从上面的目录我们可以看到和 Web 项目相比，少了 static 和 views 目录，多了一个 test 模块，用来做单元测试的。</p><p>同时，该命令还支持一些自定义参数自动连接数据库创建相关 model 和 controller:<br><code>bee api [appname] [-tables=&quot;&quot;] [-driver=mysql] [-conn=&quot;root:&lt;password&gt;@tcp(127.0.0.1:3306)/test&quot;]</code><br>如果 conn 参数为空则创建一个示例项目，否则将基于链接信息链接数据库创建项目。</p><h3 id="run-命令"><a href="#run-命令" class="headerlink" title="run 命令"></a><code>run</code> 命令</h3><p>我们在开发 Go 项目的时候最大的问题是经常需要自己手动去编译再运行，<code>bee run</code> 命令是监控 beego 的项目，通过 <a href="https://github.com/howeyc/fsnotify">fsnotify</a>监控文件系统。但是注意该命令必须在 <code>$GOPATH/src/appname</code> 下执行。<br>这样我们在开发过程中就可以实时的看到项目修改之后的效果：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs subunit">bee run<br>13<span class="hljs-string">-11</span><span class="hljs-string">-25</span> 09:53:04 [INFO] Uses &#x27;myproject&#x27; as &#x27;appname&#x27;<br>13<span class="hljs-string">-11</span><span class="hljs-string">-25</span> 09:53:04 [INFO] Initializing watcher...<br>13<span class="hljs-string">-11</span><span class="hljs-string">-25</span> 09:53:04 [TRAC] Directory(/gopath/src/myproject/controllers)<br>13<span class="hljs-string">-11</span><span class="hljs-string">-25</span> 09:53:04 [TRAC] Directory(/gopath/src/myproject/models)<br>13<span class="hljs-string">-11</span><span class="hljs-string">-25</span> 09:53:04 [TRAC] Directory(/gopath/src/myproject)<br>13<span class="hljs-string">-11</span><span class="hljs-string">-25</span> 09:53:04 [INFO] Start building...<br>13<span class="hljs-string">-11</span><span class="hljs-string">-25</span> 09:53:16 [SUCC] Build was successful<br>13<span class="hljs-string">-11</span><span class="hljs-string">-25</span> 09:53:16 [INFO] Restarting myproject ...<br>13<span class="hljs-string">-11</span><span class="hljs-string">-25</span> 09:53:16 [INFO] ./myproject is running...<br></code></pre></td></tr></table></figure><p>我们打开浏览器就可以看到效果 <code>http://localhost:8080/</code>:</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/beerun.png" alt="avatar"></p><p>如果我们修改了 <code>Controller</code> 下面的 <code>default.go</code> 文件，我们就可以看到命令行输出：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs subunit">13<span class="hljs-string">-11</span><span class="hljs-string">-25</span> 10:11:20 [EVEN] &quot;/gopath/src/myproject/controllers/default.go&quot;: DELETE|MODIFY<br>13<span class="hljs-string">-11</span><span class="hljs-string">-25</span> 10:11:20 [INFO] Start building...<br>13<span class="hljs-string">-11</span><span class="hljs-string">-25</span> 10:11:20 [SKIP] &quot;/gopath/src/myproject/controllers/default.go&quot;: CREATE<br>13<span class="hljs-string">-11</span><span class="hljs-string">-25</span> 10:11:23 [SKIP] &quot;/gopath/src/myproject/controllers/default.go&quot;: MODIFY<br>13<span class="hljs-string">-11</span><span class="hljs-string">-25</span> 10:11:23 [SUCC] Build was successful<br>13<span class="hljs-string">-11</span><span class="hljs-string">-25</span> 10:11:23 [INFO] Restarting myproject ...<br>13<span class="hljs-string">-11</span><span class="hljs-string">-25</span> 10:11:23 [INFO] ./myproject is running...<br></code></pre></td></tr></table></figure><p>刷新浏览器我们看到新的修改内容已经输出。</p><h3 id="pack-命令"><a href="#pack-命令" class="headerlink" title="pack 命令"></a><code>pack</code> 命令</h3><p><code>pack</code> 目录用来发布应用的时候打包，会把项目打包成 zip 包，这样我们部署的时候直接把打包之后的项目上传，解压就可以部署了：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle">bee pack<br>app path: <span class="hljs-regexp">/gopath/</span>src/apiproject<br>GOOS darwin GOARCH amd64<br>build apiproject<br>build success<br><span class="hljs-keyword">exclude</span> prefix:<br><span class="hljs-keyword">exclude</span> suffix: .go:.DS_Store:.tmp<br><span class="hljs-keyword">file</span> <span class="hljs-keyword">write</span> to `<span class="hljs-regexp">/gopath/</span>src<span class="hljs-regexp">/apiproject/</span>apiproject.tar.gz`<br></code></pre></td></tr></table></figure><p>我们可以看到目录下有如下的压缩文件：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">rwxr-xr-x <span class="hljs-number"> 1 </span>astaxie  staff <span class="hljs-number"> 8995376 </span>11<span class="hljs-number"> 25 </span>22:46 apiproject<br>-rw-r--r-- <span class="hljs-number"> 1 </span>astaxie  staff <span class="hljs-number"> 2240288 </span>11<span class="hljs-number"> 25 </span>22:58 apiproject.tar.gz<br>drwxr-xr-x <span class="hljs-number"> 3 </span>astaxie  staff     <span class="hljs-number"> 102 </span>11<span class="hljs-number"> 25 </span>22:31 conf<br>drwxr-xr-x <span class="hljs-number"> 3 </span>astaxie  staff     <span class="hljs-number"> 102 </span>11<span class="hljs-number"> 25 </span>22:31 controllers<br>-rw-r--r-- <span class="hljs-number"> 1 </span>astaxie  staff     <span class="hljs-number"> 509 </span>11<span class="hljs-number"> 25 </span>22:31 main.go<br>drwxr-xr-x <span class="hljs-number"> 3 </span>astaxie  staff     <span class="hljs-number"> 102 </span>11<span class="hljs-number"> 25 </span>22:31 models<br>drwxr-xr-x <span class="hljs-number"> 3 </span>astaxie  staff     <span class="hljs-number"> 102 </span>11<span class="hljs-number"> 25 </span>22:31 tests<br></code></pre></td></tr></table></figure><h3 id="bale-命令"><a href="#bale-命令" class="headerlink" title="bale 命令"></a><code>bale</code> 命令</h3><p>这个命令目前仅限内部使用，具体实现方案未完善，主要用来压缩所有的静态文件变成一个变量申明文件，全部编译到二进制文件里面，用户发布的时候携带静态文件，包括 js、css、img 和 views。最后在启动运行时进行非覆盖式的自解压。</p><h3 id="version-命令"><a href="#version-命令" class="headerlink" title="version 命令"></a><code>version</code> 命令</h3><p>这个命令是动态获取 bee、beego 和 Go 的版本，这样一旦用户出现错误，可以通过该命令来查看当前的版本</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ bee <span class="hljs-keyword">version</span><br>bee   :<span class="hljs-number">1.2</span>.<span class="hljs-number">2</span><br>beego :<span class="hljs-number">1.4</span>.<span class="hljs-number">2</span><br>Go    :<span class="hljs-keyword">go</span> <span class="hljs-keyword">version</span> go1.<span class="hljs-number">3.3</span> darwin/amd64<br></code></pre></td></tr></table></figure><h3 id="generate-命令"><a href="#generate-命令" class="headerlink" title="generate 命令"></a><code>generate</code> 命令</h3><p>这个命令是用来自动化的生成代码的，包含了从数据库一键生成 model，还包含了 scaffold 的，通过这个命令，让大家开发代码不再慢</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs verilog">bee <span class="hljs-keyword">generate</span> scaffold [scaffoldname] [-fields=<span class="hljs-string">&quot;&quot;</span>] [-driver=mysql] [-conn=<span class="hljs-string">&quot;root:@tcp(127.0.0.1:3306)/test&quot;</span>]<br>    The <span class="hljs-keyword">generate</span> scaffold command will <span class="hljs-keyword">do</span> a number of things <span class="hljs-keyword">for</span> you.<br>    -fields: a list of <span class="hljs-keyword">table</span> fields. Format: field:<span class="hljs-keyword">type</span>, ...<br>    -driver: [mysql | postgres | sqlite], the <span class="hljs-keyword">default</span> is mysql<br>    -conn:   the connection <span class="hljs-keyword">string</span> used by the driver, the <span class="hljs-keyword">default</span> is root:@tcp(<span class="hljs-number">127</span><span class="hljs-variable">.0</span><span class="hljs-variable">.0</span><span class="hljs-variable">.1</span>:<span class="hljs-number">3306</span>)/test<br>    example: bee <span class="hljs-keyword">generate</span> scaffold post -fields=<span class="hljs-string">&quot;title:string,body:text&quot;</span><br><br>bee <span class="hljs-keyword">generate</span> model [modelname] [-fields=<span class="hljs-string">&quot;&quot;</span>]<br>    <span class="hljs-keyword">generate</span> RESTful model based on fields<br>    -fields: a list of <span class="hljs-keyword">table</span> fields. Format: field:<span class="hljs-keyword">type</span>, ...<br><br>bee <span class="hljs-keyword">generate</span> controller [controllerfile]<br>    <span class="hljs-keyword">generate</span> RESTful controllers<br><br>bee <span class="hljs-keyword">generate</span> view [viewpath]<br>    <span class="hljs-keyword">generate</span> CRUD view in viewpath<br><br>bee <span class="hljs-keyword">generate</span> migration [migrationfile] [-fields=<span class="hljs-string">&quot;&quot;</span>]<br>    <span class="hljs-keyword">generate</span> migration file <span class="hljs-keyword">for</span> making database schema update<br>    -fields: a list of <span class="hljs-keyword">table</span> fields. Format: field:<span class="hljs-keyword">type</span>, ...<br><br>bee <span class="hljs-keyword">generate</span> docs<br>    <span class="hljs-keyword">generate</span> swagger doc file<br><br>bee <span class="hljs-keyword">generate</span> test [routerfile]<br>    <span class="hljs-keyword">generate</span> testcase<br><br>bee <span class="hljs-keyword">generate</span> appcode [-tables=<span class="hljs-string">&quot;&quot;</span>] [-driver=mysql] [-conn=<span class="hljs-string">&quot;root:@tcp(127.0.0.1:3306)/test&quot;</span>] [-level=<span class="hljs-number">3</span>]<br>    <span class="hljs-keyword">generate</span> appcode based on an existing database<br>    -tables: a list of <span class="hljs-keyword">table</span> names separated by &#x27;,&#x27;, <span class="hljs-keyword">default</span> is empty, indicating all tables<br>    -driver: [mysql | postgres | sqlite], the <span class="hljs-keyword">default</span> is mysql<br>    -conn:   the connection <span class="hljs-keyword">string</span> used by the driver.<br>             <span class="hljs-keyword">default</span> <span class="hljs-keyword">for</span> mysql:    root:@tcp(<span class="hljs-number">127</span><span class="hljs-variable">.0</span><span class="hljs-variable">.0</span><span class="hljs-variable">.1</span>:<span class="hljs-number">3306</span>)/test<br>             <span class="hljs-keyword">default</span> <span class="hljs-keyword">for</span> postgres: postgres:<span class="hljs-comment">//postgres:postgres@127.0.0.1:5432/postgres</span><br>    -level:  [<span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span>], <span class="hljs-number">1</span> = models; <span class="hljs-number">2</span> = models,controllers; <span class="hljs-number">3</span> = models,controllers,router<br></code></pre></td></tr></table></figure><h3 id="migrate-命令"><a href="#migrate-命令" class="headerlink" title="migrate 命令"></a><code>migrate</code> 命令</h3><p>这个命令是应用的数据库迁移命令，主要是用来每次应用升级，降级的SQL管理。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql">bee migrate [-driver=mysql] [-conn=&quot;root:@tcp(127.0.0.1:3306)/test&quot;]<br>    run all outstanding migrations<br>    -driver: [mysql | postgresql | sqlite], the default is mysql<br>    -conn:   the connection string used by the driver, the default is root:@tcp(127.0.0.1:3306)/test<br><br>bee migrate <span class="hljs-keyword">rollback</span> [-driver=mysql] [-<span class="hljs-keyword">conn</span>=<span class="hljs-string">&quot;root:@tcp(127.0.0.1:3306)/test&quot;</span>]<br>    <span class="hljs-keyword">rollback</span> the <span class="hljs-keyword">last</span> <span class="hljs-keyword">migration</span> operation<br>    -driver: [mysql | postgresql | sqlite], the <span class="hljs-keyword">default</span> <span class="hljs-keyword">is</span> mysql<br>    -<span class="hljs-keyword">conn</span>:   the <span class="hljs-keyword">connection</span> <span class="hljs-keyword">string</span> used <span class="hljs-keyword">by</span> the driver, the <span class="hljs-keyword">default</span> <span class="hljs-keyword">is</span> root:@tcp(<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">3306</span>)/<span class="hljs-keyword">test</span><br><br>bee migrate <span class="hljs-keyword">reset</span> [-driver=mysql] [-<span class="hljs-keyword">conn</span>=<span class="hljs-string">&quot;root:@tcp(127.0.0.1:3306)/test&quot;</span>]<br>    <span class="hljs-keyword">rollback</span> <span class="hljs-keyword">all</span> migrations<br>    -driver: [mysql | postgresql | sqlite], the <span class="hljs-keyword">default</span> <span class="hljs-keyword">is</span> mysql<br>    -<span class="hljs-keyword">conn</span>:   the <span class="hljs-keyword">connection</span> <span class="hljs-keyword">string</span> used <span class="hljs-keyword">by</span> the driver, the <span class="hljs-keyword">default</span> <span class="hljs-keyword">is</span> root:@tcp(<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">3306</span>)/<span class="hljs-keyword">test</span><br><br>bee migrate <span class="hljs-keyword">refresh</span> [-driver=mysql] [-<span class="hljs-keyword">conn</span>=<span class="hljs-string">&quot;root:@tcp(127.0.0.1:3306)/test&quot;</span>]<br>    <span class="hljs-keyword">rollback</span> <span class="hljs-keyword">all</span> migrations <span class="hljs-keyword">and</span> run them <span class="hljs-keyword">all</span> again<br>    -driver: [mysql | postgresql | sqlite], the <span class="hljs-keyword">default</span> <span class="hljs-keyword">is</span> mysql<br>    -<span class="hljs-keyword">conn</span>:   the <span class="hljs-keyword">connection</span> <span class="hljs-keyword">string</span> used <span class="hljs-keyword">by</span> the driver, the <span class="hljs-keyword">default</span> <span class="hljs-keyword">is</span> root:@tcp(<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">3306</span>)/<span class="hljs-keyword">test</span><br></code></pre></td></tr></table></figure><h3 id="dockerize-命令"><a href="#dockerize-命令" class="headerlink" title="dockerize 命令"></a><code>dockerize</code> 命令</h3><p>这个命令可以通过生成Dockerfile文件来实现docker化你的应用。</p><p>例子:<br>生成一个以1.6.4版本Go环境为基础镜像的Dockerfile,并暴露9000端口:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ bee dockerize -image=<span class="hljs-string">&quot;library/golang:1.6.4&quot;</span> -expose=<span class="hljs-number">9000</span><br>______<br>| ___ \<br>| |_<span class="hljs-regexp">/ /</span>  ___   ___<br>| ___ \ <span class="hljs-regexp">/ _ \ /</span> _ \<br>| |_<span class="hljs-regexp">/ /</span>|  __<span class="hljs-regexp">/|  __/</span><br>\____/  \___| \___| v1.<span class="hljs-number">6.2</span><br><span class="hljs-number">2016</span><span class="hljs-regexp">/12/</span><span class="hljs-number">26</span> <span class="hljs-number">22</span>:<span class="hljs-number">34</span>:<span class="hljs-number">54</span> INFO     ▶ <span class="hljs-number">0001</span> Generating Dockerfile...<br><span class="hljs-number">2016</span><span class="hljs-regexp">/12/</span><span class="hljs-number">26</span> <span class="hljs-number">22</span>:<span class="hljs-number">34</span>:<span class="hljs-number">54</span> SUCCESS  ▶ <span class="hljs-number">0002</span> Dockerfile generated.<br></code></pre></td></tr></table></figure><p>更多帮助信息可执行<code>bee help dockerize</code>.</p><h2 id="bee-工具配置文件"><a href="#bee-工具配置文件" class="headerlink" title="bee 工具配置文件"></a>bee 工具配置文件</h2><p>您可能已经注意到，在 bee 工具的源码目录下有一个 <code>bee.json</code> 文件，这个文件是针对 bee 工具的一些行为进行配置。该功能还未完全开发完成，不过其中的一些选项已经可以使用：</p><ul><li><code>&quot;version&quot;: 0</code>：配置文件版本，用于对比是否发生不兼容的配置格式版本。</li><li><code>&quot;go_install&quot;: false</code>：如果您的包均使用完整的导入路径（例如：<code>github.com/user/repo/subpkg</code>）,则可以启用该选项来进行 <code>go install</code> 操作，加快构建操作。</li><li><code>&quot;watch_ext&quot;: []</code>：用于监控其它类型的文件（默认只监控后缀为 <code>.go</code> 的文件）。</li><li><code>&quot;dir_structure&quot;:&#123;&#125;</code>：如果您的目录名与默认的 MVC 架构的不同，则可以使用该选项进行修改。</li><li><code>&quot;cmd_args&quot;: []</code>：如果您需要在每次启动时加入启动参数，则可以使用该选项。</li><li><code>&quot;envs&quot;: []</code>：如果您需要在每次启动时设置临时环境变量参数，则可以使用该选项。</li></ul><h1 id="路由设置"><a href="#路由设置" class="headerlink" title="路由设置"></a>路由设置</h1><p>什么是路由设置呢？前面介绍的 MVC 结构执行时，介绍过 beego 存在三种方式的路由:固定路由、正则路由、自动路由，接下来详细的讲解如何使用这三种路由。</p><h2 id="基础路由"><a href="#基础路由" class="headerlink" title="基础路由"></a>基础路由</h2><p>从 beego 1.2 版本开始支持了基本的 RESTful 函数式路由,应用中的大多数路由都会定义在 <code>routers/router.go</code> 文件中。最简单的 beego 路由由 URI 和闭包函数组成。</p><h3 id="基本-GET-路由"><a href="#基本-GET-路由" class="headerlink" title="基本 GET 路由"></a>基本 GET 路由</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">beego.<span class="hljs-constructor">Get(<span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-params">func</span>(<span class="hljs-params">ctx</span> <span class="hljs-operator">*</span><span class="hljs-params">context</span>.Context)</span>&#123;<br>     ctx.Output.<span class="hljs-constructor">Body([]<span class="hljs-params">byte</span>(<span class="hljs-string">&quot;hello world&quot;</span>)</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="基本-POST-路由"><a href="#基本-POST-路由" class="headerlink" title="基本 POST 路由"></a>基本 POST 路由</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">beego.<span class="hljs-constructor">Post(<span class="hljs-string">&quot;/alice&quot;</span>,<span class="hljs-params">func</span>(<span class="hljs-params">ctx</span> <span class="hljs-operator">*</span><span class="hljs-params">context</span>.Context)</span>&#123;<br>     ctx.Output.<span class="hljs-constructor">Body([]<span class="hljs-params">byte</span>(<span class="hljs-string">&quot;bob&quot;</span>)</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="注册一个可以响应任何-HTTP-的路由"><a href="#注册一个可以响应任何-HTTP-的路由" class="headerlink" title="注册一个可以响应任何 HTTP 的路由"></a>注册一个可以响应任何 HTTP 的路由</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">beego.<span class="hljs-constructor">Any(<span class="hljs-string">&quot;/foo&quot;</span>,<span class="hljs-params">func</span>(<span class="hljs-params">ctx</span> <span class="hljs-operator">*</span><span class="hljs-params">context</span>.Context)</span>&#123;<br>     ctx.Output.<span class="hljs-constructor">Body([]<span class="hljs-params">byte</span>(<span class="hljs-string">&quot;bar&quot;</span>)</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="所有的支持的基础函数如下所示"><a href="#所有的支持的基础函数如下所示" class="headerlink" title="所有的支持的基础函数如下所示"></a>所有的支持的基础函数如下所示</h3><ul><li>beego.Get(router, beego.FilterFunc)</li><li>beego.Post(router, beego.FilterFunc)</li><li>beego.Put(router, beego.FilterFunc)</li><li>beego.Patch(router, beego.FilterFunc)</li><li>beego.Head(router, beego.FilterFunc)</li><li>beego.Options(router, beego.FilterFunc)</li><li>beego.Delete(router, beego.FilterFunc)</li><li>beego.Any(router, beego.FilterFunc)</li></ul><h3 id="支持自定义的-handler-实现"><a href="#支持自定义的-handler-实现" class="headerlink" title="支持自定义的 handler 实现"></a>支持自定义的 handler 实现</h3><p>有些时候我们已经实现了一些 rpc 的应用,但是想要集成到 beego 中,或者其他的 httpserver 应用,集成到 beego 中来.现在可以很方便的集成:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">s := rpc.NewServer()<br>s.RegisterCodec(<span class="hljs-type">json</span>.NewCodec(), &quot;application/json&quot;)<br>s.RegisterService(<span class="hljs-built_in">new</span>(HelloService), &quot;&quot;)<br>beego.<span class="hljs-keyword">Handler</span>(&quot;/rpc&quot;, s)<br></code></pre></td></tr></table></figure><p><code>beego.Handler(router, http.Handler)</code> 这个函数是关键,第一个参数表示路由 URI, 第二个就是你自己实现的 <code>http.Handler</code>, 注册之后就会把所有 rpc 作为前缀的请求分发到 <code>http.Handler</code> 中进行处理.</p><p>这个函数其实还有第三个参数就是是否是前缀匹配,默认是 false, 如果设置了 true, 那么就会在路由匹配的时候前缀匹配,即 <code>/rpc/user</code> 这样的也会匹配去运行</p><h3 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h3><p>后面会讲到固定路由,正则路由,这些参数一样适用于上面的这些函数</p><h2 id="RESTful-Controller-路由"><a href="#RESTful-Controller-路由" class="headerlink" title="RESTful Controller 路由"></a>RESTful Controller 路由</h2><p>在介绍这三种 beego 的路由实现之前先介绍 RESTful，我们知道 RESTful 是一种目前 API 开发中广泛采用的形式，beego 默认就是支持这样的请求方法，也就是用户 Get 请求就执行 Get 方法，Post 请求就执行 Post 方法。因此默认的路由是这样 RESTful 的请求方式。</p><h2 id="固定路由"><a href="#固定路由" class="headerlink" title="固定路由"></a>固定路由</h2><p>固定路由也就是全匹配的路由，如下所示：</p><pre><code>beego.Router(&quot;/&quot;, &amp;controllers.MainController&#123;&#125;)beego.Router(&quot;/admin&quot;, &amp;admin.UserController&#123;&#125;)beego.Router(&quot;/admin/index&quot;, &amp;admin.ArticleController&#123;&#125;)beego.Router(&quot;/admin/addpkg&quot;, &amp;admin.AddController&#123;&#125;)</code></pre><p>如上所示的路由就是我们最常用的路由方式，一个固定的路由，一个控制器，然后根据用户请求方法不同请求控制器中对应的方法，典型的 RESTful 方式。</p><h2 id="正则路由"><a href="#正则路由" class="headerlink" title="正则路由"></a>正则路由</h2><p>为了用户更加方便的路由设置，beego 参考了 sinatra 的路由实现，支持多种方式的路由：</p><ul><li><p>beego.Router(“/api/?:id”, &amp;controllers.RController{})</p><p>  默认匹配   //例如对于URL”/api/123”可以匹配成功，此时变量”:id”值为”123”</p></li><li><p>beego.Router(“/api/:id”, &amp;controllers.RController{})</p><p>  默认匹配   //例如对于URL”/api/123”可以匹配成功，此时变量”:id”值为”123”，但URL”/api/“匹配失败</p></li><li><p>beego.Router(“/api/:id([0-9]+)”, &amp;controllers.RController{})</p><p>  自定义正则匹配 //例如对于URL”/api/123”可以匹配成功，此时变量”:id”值为”123”</p></li><li><p>beego.Router(“/user/:username([\\w]+)”, &amp;controllers.RController{})</p><p>  正则字符串匹配 //例如对于URL”/user/astaxie”可以匹配成功，此时变量”:username”值为”astaxie”</p></li><li><p>beego.Router(“/download/*.*“, &amp;controllers.RController{})</p><p>  *匹配方式 //例如对于URL”/download/file/api.xml”可以匹配成功，此时变量”:path”值为”file/api”， “:ext”值为”xml”</p></li><li><p>beego.Router(“/download/ceshi/*”, &amp;controllers.RController{})</p><p>  *全匹配方式 //例如对于URL”/download/ceshi/file/api.json”可以匹配成功，此时变量”:splat”值为”file/api.json”</p></li><li><p>beego.Router(“/:id:int”, &amp;controllers.RController{})</p><p>  int 类型设置方式，匹配 :id为int 类型，框架帮你实现了正则 ([0-9]+)</p></li><li><p>beego.Router(“/:hi:string”, &amp;controllers.RController{})</p><p>  string 类型设置方式，匹配 :hi 为 string 类型。框架帮你实现了正则 ([\w]+)</p></li><li><p>beego.Router(“/cms_:id([0-9]+).html”, &amp;controllers.CmsController{})</p><p>  带有前缀的自定义正则 //匹配 :id 为正则类型。匹配 cms_123.html 这样的 url :id = 123</p></li></ul><p>可以在 Controller 中通过如下方式获取上面的变量：</p><pre><code>this.Ctx.Input.Param(&quot;:id&quot;)this.Ctx.Input.Param(&quot;:username&quot;)this.Ctx.Input.Param(&quot;:splat&quot;)this.Ctx.Input.Param(&quot;:path&quot;)this.Ctx.Input.Param(&quot;:ext&quot;)</code></pre><h2 id="自定义方法及-RESTful-规则"><a href="#自定义方法及-RESTful-规则" class="headerlink" title="自定义方法及 RESTful 规则"></a>自定义方法及 RESTful 规则</h2><p>上面列举的是默认的请求方法名（请求的 method 和函数名一致，例如 <code>GET</code> 请求执行 <code>Get</code> 函数，<code>POST</code> 请求执行 <code>Post</code> 函数），如果用户期望自定义函数名，那么可以使用如下方式：</p><pre><code>beego.Router(&quot;/&quot;,&amp;IndexController&#123;&#125;,&quot;*:Index&quot;)</code></pre><p>使用第三个参数，第三个参数就是用来设置对应 method 到函数名，定义如下</p><ul><li><code>*</code>表示任意的 method 都执行该函数</li><li>使用 httpmethod:funcname 格式来展示</li><li>多个不同的格式使用 <code>;</code> 分割</li><li>多个 method 对应同一个 funcname，method 之间通过 <code>,</code> 来分割</li></ul><p>以下是一个 RESTful 的设计示例：</p><pre><code>beego.Router(&quot;/api/list&quot;,&amp;RestController&#123;&#125;,&quot;*:ListFood&quot;)beego.Router(&quot;/api/create&quot;,&amp;RestController&#123;&#125;,&quot;post:CreateFood&quot;)beego.Router(&quot;/api/update&quot;,&amp;RestController&#123;&#125;,&quot;put:UpdateFood&quot;)beego.Router(&quot;/api/delete&quot;,&amp;RestController&#123;&#125;,&quot;delete:DeleteFood&quot;)</code></pre><p>以下是多个 HTTP Method 指向同一个函数的示例：</p><pre><code>beego.Router(&quot;/api&quot;,&amp;RestController&#123;&#125;,&quot;get,post:ApiFunc&quot;)</code></pre><p>以下是不同的 method 对应不同的函数，通过 ; 进行分割的示例：</p><pre><code>beego.Router(&quot;/simple&quot;,&amp;SimpleController&#123;&#125;,&quot;get:GetFunc;post:PostFunc&quot;)</code></pre><p>可用的 HTTP Method：</p><ul><li>*: 包含以下所有的函数</li><li>get: GET 请求</li><li>post: POST 请求</li><li>put: PUT 请求</li><li>delete: DELETE 请求</li><li>patch: PATCH 请求</li><li>options: OPTIONS 请求</li><li>head: HEAD 请求</li></ul><p>如果同时存在 * 和对应的 HTTP Method，那么优先执行 HTTP Method 的方法，例如同时注册了如下所示的路由：</p><pre><code>beego.Router(&quot;/simple&quot;,&amp;SimpleController&#123;&#125;,&quot;*:AllFunc;post:PostFunc&quot;)</code></pre><p>那么执行 <code>POST</code> 请求的时候，执行 <code>PostFunc</code> 而不执行 <code>AllFunc</code>。</p><blockquote><blockquote><blockquote><p>自定义函数的路由默认不支持 RESTful 的方法，也就是如果你设置了 <code>beego.Router(&quot;/api&quot;,&amp;RestController&#123;&#125;,&quot;post:ApiFunc&quot;)</code> 这样的路由，如果请求的方法是 <code>POST</code>，那么不会默认去执行 <code>Post</code> 函数。</p></blockquote></blockquote></blockquote><h2 id="自动匹配"><a href="#自动匹配" class="headerlink" title="自动匹配"></a>自动匹配</h2><p>用户首先需要把需要路由的控制器注册到自动路由中：</p><pre><code>beego.AutoRouter(&amp;controllers.ObjectController&#123;&#125;)</code></pre><p>那么 beego 就会通过反射获取该结构体中所有的实现方法，你就可以通过如下的方式访问到对应的方法中：</p><pre><code>/object/login   调用 ObjectController 中的 Login 方法/object/logout  调用 ObjectController 中的 Logout 方法</code></pre><p>除了前缀两个 <code>/:controller/:method</code> 的匹配之外，剩下的 url beego 会帮你自动化解析为参数，保存在 <code>this.Ctx.Input.Params</code> 当中：</p><pre><code>/object/blog/2013/09/12  调用 ObjectController 中的 Blog 方法，参数如下：map[0:2013 1:09 2:12]</code></pre><p>方法名在内部是保存了用户设置的，例如 Login，url 匹配的时候都会转化为小写，所以，<code>/object/LOGIN</code> 这样的 <code>url</code> 也一样可以路由到用户定义的 <code>Login</code> 方法中。</p><p>现在已经可以通过自动识别出来下面类似的所有 url，都会把请求分发到 <code>controller</code> 的 <code>simple</code> 方法：</p><pre><code>/controller/simple/controller/simple.html/controller/simple.json/controller/simple.xml</code></pre><p>可以通过 <code>this.Ctx.Input.Param(&quot;:ext&quot;)</code> 获取后缀名。</p><h2 id="注解路由"><a href="#注解路由" class="headerlink" title="注解路由"></a>注解路由</h2><p>从 beego 1.3 版本开始支持了注解路由，用户无需在 router 中注册路由，只需要 Include 相应地 controller，然后在 controller 的 method 方法上面写上 router 注释（// @router）就可以了，详细的使用请看下面的例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// CMS API</span><br>type <span class="hljs-type">CMSController</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> </span>&#123;<br>beego.<span class="hljs-type">Controller</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(<span class="hljs-built_in">c</span> *CMSController)</span></span> <span class="hljs-type">URLMapping</span>() &#123;<br><span class="hljs-built_in">c</span>.<span class="hljs-type">Mapping</span>(<span class="hljs-string">&quot;StaticBlock&quot;</span>, <span class="hljs-built_in">c</span>.<span class="hljs-type">StaticBlock</span>)<br><span class="hljs-built_in">c</span>.<span class="hljs-type">Mapping</span>(<span class="hljs-string">&quot;AllBlock&quot;</span>, <span class="hljs-built_in">c</span>.<span class="hljs-type">AllBlock</span>)<br>&#125;<br><br><br><span class="hljs-comment">// @router /staticblock/:key [get]</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *CMSController)</span></span> <span class="hljs-type">StaticBlock</span>() &#123;<br><br>&#125;<br><br><span class="hljs-comment">// @router /all/:key [get]</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *CMSController)</span></span> <span class="hljs-type">AllBlock</span>() &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以在 <code>router.go</code> 中通过如下方式注册路由：</p><pre><code>beego.Include(&amp;CMSController&#123;&#125;)</code></pre><p>beego 自动会进行源码分析，注意只会在 dev 模式下进行生成，生成的路由放在 “/routers/commentsRouter.go” 文件中。</p><p>这样上面的路由就支持了如下的路由：</p><ul><li>GET /staticblock/:key</li><li>GET /all/:key</li></ul><p>其实效果和自己通过 Router 函数注册是一样的：</p><pre><code>beego.Router(&quot;/staticblock/:key&quot;, &amp;CMSController&#123;&#125;, &quot;get:StaticBlock&quot;)beego.Router(&quot;/all/:key&quot;, &amp;CMSController&#123;&#125;, &quot;get:AllBlock&quot;)</code></pre><p>同时大家注意到新版本里面增加了 URLMapping 这个函数，这是新增加的函数，用户如果没有进行注册，那么就会通过反射来执行对应的函数，如果注册了就会通过 interface 来进行执行函数，性能上面会提升很多。</p><h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//初始化 namespace</span><br>ns :=<br>beego.NewNamespace(<span class="hljs-string">&quot;/v1&quot;</span>,<br>beego.NSCond(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *context.Context)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">if</span> ctx.Input.Domain() == <span class="hljs-string">&quot;api.beego.me&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;),<br>beego.NSBefore(auth),<br>beego.NSGet(<span class="hljs-string">&quot;/notallowed&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *context.Context)</span></span> &#123;<br>ctx.Output.Body([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;notAllowed&quot;</span>))<br>&#125;),<br>beego.NSRouter(<span class="hljs-string">&quot;/version&quot;</span>, &amp;AdminController&#123;&#125;, <span class="hljs-string">&quot;get:ShowAPIVersion&quot;</span>),<br>beego.NSRouter(<span class="hljs-string">&quot;/changepassword&quot;</span>, &amp;UserController&#123;&#125;),<br>beego.NSNamespace(<span class="hljs-string">&quot;/shop&quot;</span>,<br>beego.NSBefore(sentry),<br>beego.NSGet(<span class="hljs-string">&quot;/:id&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *context.Context)</span></span> &#123;<br>ctx.Output.Body([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;notAllowed&quot;</span>))<br>&#125;),<br>),<br>beego.NSNamespace(<span class="hljs-string">&quot;/cms&quot;</span>,<br>beego.NSInclude(<br>&amp;controllers.MainController&#123;&#125;,<br>&amp;controllers.CMSController&#123;&#125;,<br>&amp;controllers.BlockController&#123;&#125;,<br>),<br>),<br>)<br><span class="hljs-comment">//注册 namespace</span><br>beego.AddNamespace(ns)<br></code></pre></td></tr></table></figure><p>上面这个代码支持了如下这样的请求 URL</p><ul><li>GET /v1/notallowed</li><li>GET /v1/version</li><li>GET /v1/changepassword</li><li>POST /v1/changepassword</li><li>GET /v1/shop/123</li><li>GET /v1/cms/ 对应 MainController、CMSController、BlockController 中得注解路由</li></ul><p>而且还支持前置过滤,条件判断,无限嵌套 namespace</p><p>namespace 的接口如下:</p><ul><li><p>NewNamespace(prefix string, funcs …interface{})</p><p>  初始化 namespace 对象,下面这些函数都是 namespace 对象的方法,但是强烈推荐使用 NS 开头的相应函数注册，因为这样更容易通过 gofmt 工具看的更清楚路由的级别关系</p></li><li><p>NSCond(cond namespaceCond)</p><p>  支持满足条件的就执行该 namespace, 不满足就不执行</p></li><li><p>NSBefore(filiterList …FilterFunc)</p></li><li><p>NSAfter(filiterList …FilterFunc)</p><p>  上面分别对应 beforeRouter 和 FinishRouter 两个过滤器，可以同时注册多个过滤器</p></li><li><p>NSInclude(cList …ControllerInterface)</p></li><li><p>NSRouter(rootpath string, c ControllerInterface, mappingMethods …string)</p></li><li><p>NSGet(rootpath string, f FilterFunc)</p></li><li><p>NSPost(rootpath string, f FilterFunc)</p></li><li><p>NSDelete(rootpath string, f FilterFunc)</p></li><li><p>NSPut(rootpath string, f FilterFunc)</p></li><li><p>NSHead(rootpath string, f FilterFunc)</p></li><li><p>NSOptions(rootpath string, f FilterFunc)</p></li><li><p>NSPatch(rootpath string, f FilterFunc)</p></li><li><p>NSAny(rootpath string, f FilterFunc)</p></li><li><p>NSHandler(rootpath string, h http.Handler)</p></li><li><p>NSAutoRouter(c ControllerInterface)</p></li><li><p>NSAutoPrefix(prefix string, c ControllerInterface)</p><p>  上面这些都是设置路由的函数,详细的使用和上面 beego 的对应函数是一样的</p></li><li><p>NSNamespace(prefix string, params …innnerNamespace)</p><p>  嵌套其他 namespace</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go">ns :=<br> beego.NewNamespace(<span class="hljs-string">&quot;/v1&quot;</span>,<br>beego.NSNamespace(<span class="hljs-string">&quot;/shop&quot;</span>,<br>beego.NSGet(<span class="hljs-string">&quot;/:id&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *context.Context)</span></span> &#123;<br>ctx.Output.Body([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;shopinfo&quot;</span>))<br>&#125;),<br>),<br>beego.NSNamespace(<span class="hljs-string">&quot;/order&quot;</span>,<br>beego.NSGet(<span class="hljs-string">&quot;/:id&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *context.Context)</span></span> &#123;<br>ctx.Output.Body([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;orderinfo&quot;</span>))<br>&#125;),<br>),<br>beego.NSNamespace(<span class="hljs-string">&quot;/crm&quot;</span>,<br>beego.NSGet(<span class="hljs-string">&quot;/:id&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *context.Context)</span></span> &#123;<br>ctx.Output.Body([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;crminfo&quot;</span>))<br>&#125;),<br>),<br>)<br></code></pre></td></tr></table></figure></li></ul><p>下面这些函数都是属于 *Namespace 对象的方法：不建议直接使用，当然效果和上面的 NS 开头的函数是一样的，只是上面的方式更优雅，写出来的代码更容易看得懂</p><ul><li><p>Cond(cond namespaceCond)</p><p>  支持满足条件的就执行该 namespace, 不满足就不执行,例如你可以根据域名来控制 namespace</p></li><li><p>Filter(action string, filter FilterFunc)</p><p>  action 表示你需要执行的位置, before 和 after 分别表示执行逻辑之前和执行逻辑之后的 filter</p></li><li><p>Router(rootpath string, c ControllerInterface, mappingMethods …string)</p></li></ul><ul><li><p>AutoRouter(c ControllerInterface)</p></li><li><p>AutoPrefix(prefix string, c ControllerInterface)</p></li><li><p>Get(rootpath string, f FilterFunc)</p></li><li><p>Post(rootpath string, f FilterFunc)</p></li><li><p>Delete(rootpath string, f FilterFunc)</p></li><li><p>Put(rootpath string, f FilterFunc)</p></li><li><p>Head(rootpath string, f FilterFunc)</p></li><li><p>Options(rootpath string, f FilterFunc)</p></li><li><p>Patch(rootpath string, f FilterFunc)</p></li><li><p>Any(rootpath string, f FilterFunc)</p></li><li><p>Handler(rootpath string, h http.Handler)</p><p>  上面这些都是设置路由的函数,详细的使用和上面 beego 的对应函数是一样的</p></li><li><p>Namespace(ns …*Namespace)</p></li></ul><p>更多的例子代码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>APIS<br>ns :=<br>beego.NewNamespace(<span class="hljs-string">&quot;/api&quot;</span>,<br><span class="hljs-regexp">//</span>此处正式版时改为验证加密请求<br>beego.NSCond(<span class="hljs-keyword">func</span>(ctx *context.Context) bool &#123;<br><span class="hljs-keyword">if</span> ua := ctx.Input.Request.UserAgent(); ua != <span class="hljs-string">&quot;&quot;</span> &#123;<br>return true<br>&#125;<br>return false<br>&#125;),<br>beego.NSNamespace(<span class="hljs-string">&quot;/ios&quot;</span>,<br><span class="hljs-regexp">//</span>CRUD Create(创建)、Read(读取)、Update(更新)和Delete(删除)<br>beego.NSNamespace(<span class="hljs-string">&quot;/create&quot;</span>,<br><span class="hljs-regexp">//</span> <span class="hljs-regexp">/api/i</span>os<span class="hljs-regexp">/create/</span>node/<br>beego.NSRouter(<span class="hljs-string">&quot;/node&quot;</span>, &amp;apis.CreateNodeHandler&#123;&#125;),<br><span class="hljs-regexp">//</span> <span class="hljs-regexp">/api/i</span>os<span class="hljs-regexp">/create/</span>topic/<br>beego.NSRouter(<span class="hljs-string">&quot;/topic&quot;</span>, &amp;apis.CreateTopicHandler&#123;&#125;),<br>),<br>beego.NSNamespace(<span class="hljs-string">&quot;/read&quot;</span>,<br>beego.NSRouter(<span class="hljs-string">&quot;/node&quot;</span>, &amp;apis.ReadNodeHandler&#123;&#125;),<br>beego.NSRouter(<span class="hljs-string">&quot;/topic&quot;</span>, &amp;apis.ReadTopicHandler&#123;&#125;),<br>),<br>beego.NSNamespace(<span class="hljs-string">&quot;/update&quot;</span>,<br>beego.NSRouter(<span class="hljs-string">&quot;/node&quot;</span>, &amp;apis.UpdateNodeHandler&#123;&#125;),<br>beego.NSRouter(<span class="hljs-string">&quot;/topic&quot;</span>, &amp;apis.UpdateTopicHandler&#123;&#125;),<br>),<br>beego.NSNamespace(<span class="hljs-string">&quot;/delete&quot;</span>,<br>beego.NSRouter(<span class="hljs-string">&quot;/node&quot;</span>, &amp;apis.DeleteNodeHandler&#123;&#125;),<br>beego.NSRouter(<span class="hljs-string">&quot;/topic&quot;</span>, &amp;apis.DeleteTopicHandler&#123;&#125;),<br>)<br>),<br>)<br><br>beego.AddNamespace(ns)<br></code></pre></td></tr></table></figure><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p><a href="https://beego.me/">Beego官网</a></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>beego</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 学习笔记一</title>
    <link href="/2019/05/18/golang/Golang-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <url>/2019/05/18/golang/Golang-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Go语言简介"><a href="#Go语言简介" class="headerlink" title="Go语言简介"></a>Go语言简介</h1><p>Go语言（或 Golang）起源于 2007 年，并在 2009 年正式对外发布。Go 是非常年轻的一门语言，它的主要目标是“兼具 Python 等动态语言的开发速度和 C/C++ 等编译型语言的性能与安全性”。</p><p>Go语言是编程语言设计的又一次尝试，是对类C语言的重大改进，它不但能让你访问底层操作系统，还提供了强大的网络编程和并发编程支持。Go语言的用途众多，可以进行网络编程、系统编程、并发编程、分布式编程。</p><p>Go语言的推出，旨在不损失应用程序性能的情况下降低代码的复杂性，具有“部署简单、并发性好、语言设计良好、执行性能好”等优势，目前国内诸多 IT 公司均已采用Go语言开发项目。</p><p>Go语言有时候被描述为“C 类似语言”，或者是“21 世纪的C语言”。Go 从C语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等很多思想，还有C语言一直所看中的编译后机器码的运行效率以及和现有操作系统的无缝适配。</p><p>因为Go语言没有类和继承的概念，所以它和 Java 或 C++ 看起来并不相同。但是它通过接口（interface）的概念来实现多态性。Go语言有一个清晰易懂的轻量级类型系统，在类型之间也没有层级之说。因此可以说Go语言是一门混合型的语言。</p><p>此外，很多重要的开源项目都是使用Go语言开发的，其中包括 Docker、Go-Ethereum、Thrraform 和 Kubernetes。</p><h3 id="Go语言创始人"><a href="#Go语言创始人" class="headerlink" title="Go语言创始人"></a>Go语言创始人</h3><p>对语言进行评估时，明白设计者的动机以及语言要解决的问题很重要。Go语言出自 Ken Thompson 和 Rob Pike、Robert Griesemer 之手，他们都是计算机科学领域的重量级人物。</p><ol><li>Ken Thompson<br>贝尔实验室 Unix 团队成员，C语言、Unix 和 Plan 9 的创始人之一，在 20 世纪 70 年代，设计并实现了最初的 UNIX 操作系统，仅从这一点说，他对计算机科学的贡献怎么强调都不过分。他还与 Rob Pike 合作设计了 UTF-8 编码方案。</li><li>Rob Pike<br>Go语言项目总负责人，贝尔实验室 Unix 团队成员，除帮助设计 UTF-8 外，还帮助开发了分布式多用户操作系统 Plan 9、Inferno 操作系统和 Limbo 编程语言，并与人合著了《The Unix Programming Environment》，对 UNIX 的设计理念做了正统的阐述。</li><li>Robert Griesemer<br>就职于 Google，参与开发 Java HotSpot 虚拟机，对语言设计有深入的认识，并负责 Chrome 浏览器和 Node.js 使用的 Google V8 JavaScript 引擎的代码生成部分。</li></ol><p>这些计算机科学领城的重量级人物设计Go语言的初衷是满足 Google 的需求。设计此语言花费了两年的时间，融入了整个团队多年的经验及对编程语言设计的深入认识。设计团队借鉴了 Pascal、Oberon 和C语言的设计智慧，同时让Go语言具备动态语言的便利性。因此，Go语言体现了经验丰富的计算机科学家的语言设计理念，是为全球最大的互联网公司之一设计的。</p><p>Go语言的所有设计者都说，设计Go语言是因为 C++ 给他们带来了挫败感。在 Google I/O 2012 的 Go 设计小组见面会上，Rob Pike 是这样说的：<br>我们做了大量的 C++ 开发，厌烦了等待编译完成，尽管这是玩笑，但在很大程度上来说也是事实。<br>Go 是编译型语言<br>Go 使用编译器来编译代码。编译器将源代码编译成二进制（或字节码）格式；在编译代码时，编译器检查错误、优化性能并输出可在不同平台上运行的二进制文件。要创建并运行 Go 程序，程序员必须执行如下步骤。<br>使用文本编辑器创建 Go 程序；<br>保存文件；<br>编译程序；<br>运行编译得到的可执行文件。</p><p>这不同于 Python、Ruby 和 JavaScript 等语言，它们不包含编译步骤。Go 自带了编译器，因此无须单独安装编译器。</p><h3 id="为什么要学习Go语言"><a href="#为什么要学习Go语言" class="headerlink" title="为什么要学习Go语言"></a>为什么要学习Go语言</h3><p>如果你要创建系统程序，或者基于网络的程序，Go语言是很不错的选择。作为一种相对较新的语言，它是由经验丰富且受人尊敬的计算机科学家设计的，旨在应对创建大型并发网络程序面临的挑战。</p><p>在Go语言出现之前，开发者们总是面临非常艰难的抉择，究竟是使用执行速度快但是编译速度并不理想的语言（如：C++），还是使用编译速度较快但执行效率不佳的语言（如：.NET、Java），或者说开发难度较低但执行速度一般的动态语言呢？显然，Go语言在这 3 个条件之间做到了最佳的平衡：快速编译，高效执行，易于开发。</p><p>Go语言支持交叉编译，比如说你可以在运行 Linux 系统的计算机上开发可以在 Windows 上运行的应用程序。这是第一门完全支持 UTF-8 的编程语言，这不仅体现在它可以处理使用 UTF-8 编码的字符串，就连它的源码文件格式都是使用的 UTF-8 编码。Go语言做到了真正的国际化！<br>Go语言吉祥物<br>Go语言有一个吉祥物，在会议、文档页面和博文中，大多会包含下图所示的 Go Gopher，这是才华横溢的插画家 Renee French 设计的，她也是 Go 设计者之一 Rob Pike 的妻子。</p><h2 id="2-Go语言的特性"><a href="#2-Go语言的特性" class="headerlink" title="2.Go语言的特性"></a>2.Go语言的特性</h2><p>Go语言也称为 Golang，是由 Google 公司开发的一种静态强类型、编译型、并发型、并具有垃圾回收功能的编程语言。</p><p>接下来从几个方面来具体介绍一下Go语言的特性。<br>语法简单<br>抛开语法样式不谈，单就类型和规则而言，Go 与 C99、C11 相似之处颇多，这也是Go语言被冠以“NextC”名号的重要原因。</p><p>Go语言的语法处于简单和复杂的两极。C语言简单到你每写下一行代码，都能在脑中想象出编译后的模样，指令如何执行，内存如何分配，等等。而 C 的复杂在于，它有太多隐晦而不着边际的规则，着实让人头疼。相比较而言，Go 从零开始，没有历史包袱，在汲取众多经验教训后，可从头规划一个规则严谨、条理简单的世界。</p><p>Go语言的语法规则严谨，没有歧义，更没什么黑魔法变异用法。任何人写出的代码都基本一致，这使得Go语言简单易学。放弃部分“灵活”和“自由”，换来更好的维护性，我觉得是值得的。</p><p>将“++”、“–”从运算符降级为语句，保留指针，但默认阻止指针运算，带来的好处是显而易见的。还有，将切片和字典作为内置类型，从运行时的层面进行优化，这也算是一种“简单”。<br>并发模型<br>时至今日，并发编程已成为程序员的基本技能，在各个技术社区都能看到诸多与之相关的讨论主题。在这种情况下Go语言却一反常态做了件极大胆的事，从根本上将一切都并发化，运行时用 Goroutine 运行所有的一切，包括 main.main 入口函数。</p><p>可以说，Goroutine 是 Go 最显著的特征。它用类协程的方式来处理并发单元，却又在运行时层面做了更深度的优化处理。这使得语法上的并发编程变得极为容易，无须处理回调，无须关注线程切换，仅一个关键字，简单而自然。</p><p>搭配 channel，实现 CSP 模型。将并发单元间的数据耦合拆解开来，各司其职，这对所有纠结于内存共享、锁粒度的开发人员都是一个可期盼的解脱。若说有所不足，那就是应该有个更大的计划，将通信从进程内拓展到进程外，实现真正意义上的分布式。<br>内存分配<br>将一切并发化固然是好，但带来的问题同样很多。如何实现高并发下的内存分配和管理就是个难题。好在 Go 选择了 tcmalloc，它本就是为并发而设计的高性能内存分配组件。</p><p>可以说，内存分配器是运行时三大组件里变化最少的部分。刨去因配合垃圾回收器而修改的内容，内存分配器完整保留了 tcmalloc 的原始架构。使用 cache 为当前执行线程提供无锁分配，多个 central 在不同线程间平衡内存单元复用。在更高层次里，heap 则管理着大块内存，用以切分成不同等级的复用内存块。快速分配和二级内存平衡机制，让内存分配器能优秀地完成高压力下的内存管理任务。</p><p>在最近几个版本中，编译器优化卓有成效。它会竭力将对象分配在栈上，以降低垃圾回收压力，减少管理消耗，提升执行性能。可以说，除偶尔因性能问题而被迫采用对象池和自主内存管理外，我们基本无须参与内存管理操作。<br>垃圾回收<br>垃圾回收一直是个难题。早年间，Java 就因垃圾回收低效被嘲笑了许久，后来 Sun 连续收纳了好多人和技术才发展到今天。可即便如此，在 Hadoop 等大内存应用场景下，垃圾回收依旧捉襟见肘、步履维艰。</p><p>相比 Java，Go 面临的困难要更多。因指针的存在，所以回收内存不能做收缩处理。幸好，指针运算被阻止，否则要做到精确回收都难。</p><p>每次升级，垃圾回收器必然是核心组件里修改最多的部分。从并发清理，到降低 STW 时间，直到 Go 的 1.5 版本实现并发标记，逐步引入三色标记和写屏障等等，都是为了能让垃圾回收在不影响用户逻辑的情况下更好地工作。尽管有了努力，当前版本的垃圾回收算法也只能说堪用，离好用尚有不少距离。<br>静态链接<br>Go 刚发布时，静态链接被当作优点宣传。只须编译后的一个可执行文件，无须附加任何东西就能部署。这似乎很不错，只是后来风气变了。连着几个版本，编译器都在完善动态库 buildmode 功能，场面一时变得有些尴尬。</p><p>暂不说未完工的 buildmode 模式，静态编译的好处显而易见。将运行时、依赖库直接打包到可执行文件内部，简化了部署和发布操作，无须事先安装运行环境和下载诸多第三方库。这种简单方式对于编写系统软件有着极大好处，因为库依赖一直都是个麻烦。<br>标准库<br>功能完善、质量可靠的标准库为编程语言提供了充足动力。在不借助第三方扩展的情况下，就可完成大部分基础功能开发，这大大降低了学习和使用成本。最关键的是，标准库有升级和修复保障，还能从运行时获得深层次优化的便利，这是第三方库所不具备的。</p><p>Go 标准库虽称不得完全覆盖，但也算极为丰富。其中值得称道的是 net/http，仅须简单几条语句就能实现一个高性能 Web Server，这从来都是宣传的亮点。更何况大批基于此的优秀第三方 Framework 更是将 Go 推到 Web/Microservice 开发标准之一的位置。</p><p>当然，优秀第三方资源也是语言生态圈的重要组成部分。近年来崛起的几门语言中，Go 算是独树一帜，大批优秀作品频繁涌现，这也给我们学习 Go 提供了很好的参照。<br>工具链<br>完整的工具链对于日常开发极为重要。Go 在此做得相当不错，无论是编译、格式化、错误检查、帮助文档，还是第三方包下载、更新都有对应的工具。其功能未必完善，但起码算得上简单易用。</p><p>内置完整测试框架，其中包括单元测试、性能测试、代码覆盖率、数据竞争，以及用来调优的 pprof，这些都是保障代码能正确而稳定运行的必备利器。</p><p>除此之外，还可通过环境变量输出运行时监控信息，尤其是垃圾回收和并发调度跟踪，可进一步帮助我们改进算法，获得更佳的运行期表现。</p><h2 id="3-Go语言为并发而生"><a href="#3-Go语言为并发而生" class="headerlink" title="3.Go语言为并发而生"></a>3.Go语言为并发而生</h2><p>在早期 CPU 都是以单核的形式顺序执行机器指令。Go语言的祖先C语言正是这种顺序编程语言的代表。顺序编程语言中的顺序是指：所有的指令都是以串行的方式执行，在相同的时刻有且仅有一个 CPU 在顺序执行程序的指令。</p><p>随着处理器技术的发展，单核时代以提升处理器频率来提高运行效率的方式遇到了瓶颈，单核 CPU 发展的停滞，给多核 CPU 的发展带来了机遇。相应地，编程语言也开始逐步向并行化的方向发展。</p><p>虽然一些编程语言的框架在不断地提高多核资源使用效率，例如 Java 的 Netty 等，但仍然需要开发人员花费大量的时间和精力搞懂这些框架的运行原理后才能熟练掌握。</p><p>作为程序员，要开发出能充分利用硬件资源的应用程序是一件很难的事情。现代计算机都拥有多个核，但是大部分编程语言都没有有效的工具让程序可以轻易利用这些资源。编程时需要写大量的线程同步代码来利用多个核，很容易导致错误。</p><p>Go语言正是在多核和网络化的时代背景下诞生的原生支持并发的编程语言。Go语言从底层原生支持并发，无须第三方库，开发人员可以很轻松地在编写程序时决定怎么使用 CPU 资源。</p><p>Go语言的并发是基于 goroutine 的，goroutine 类似于线程，但并非线程。可以将 goroutine 理解为一种虚拟线程。Go语言运行时会参与调度 goroutine，并将 goroutine 合理地分配到每个 CPU 中，最大限度地使用 CPU 性能。</p><p>多个 goroutine 中，Go语言使用通道（channel）进行通信，通道是一种内置的数据结构，可以让用户在不同的 goroutine 之间同步发送具有类型的消息。这让编程模型更倾向于在 goroutine 之间发送消息，而不是让多个 goroutine 争夺同一个数据的使用权。</p><p>程序可以将需要并发的环节设计为生产者模式和消费者的模式，将数据放入通道。通道另外一端的代码将这些数据进行并发计算并返回结果，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/golang-concurrent.jpg" alt="avatar"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math/rand&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// 数据生产者</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">producer</span><span class="hljs-params">(header <span class="hljs-keyword">string</span>, channel <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">string</span>)</span></span> &#123;<br><span class="hljs-comment">// 无限循环, 不停地生产数据</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// 将随机数和字符串格式化为字符串发送给通道</span><br>channel &lt;- fmt.Sprintf(<span class="hljs-string">&quot;%s: %v&quot;</span>, header, rand.Int31())<br><span class="hljs-comment">// 等待1秒</span><br>time.Sleep(time.Second)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 数据消费者</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">customer</span><span class="hljs-params">(channel &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)</span></span> &#123;<br><span class="hljs-comment">// 不停地获取数据</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// 从通道中取出数据, 此处会阻塞直到信道中返回数据</span><br>message := &lt;-channel<br><span class="hljs-comment">// 打印数据</span><br>fmt.Println(message)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 创建一个字符串类型的通道</span><br>channel := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)<br><span class="hljs-comment">// 创建producer()函数的并发goroutine</span><br><span class="hljs-keyword">go</span> producer(<span class="hljs-string">&quot;cat&quot;</span>, channel)<br><span class="hljs-keyword">go</span> producer(<span class="hljs-string">&quot;dog&quot;</span>, channel)<br><span class="hljs-comment">// 数据消费函数</span><br>customer(channel)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">dog: <span class="hljs-number">1298498081</span><br>cat: <span class="hljs-number">2019727887</span><br>dog: <span class="hljs-number">939984059</span><br>cat: <span class="hljs-number">1427131847</span><br>cat: <span class="hljs-number">911902081</span><br>dog: <span class="hljs-number">1474941318</span><br>cat: <span class="hljs-number">336122540</span><br>dog: <span class="hljs-number">140954425</span><br>dog: <span class="hljs-number">208240456</span><br>cat: <span class="hljs-number">646203300</span><br>dog: <span class="hljs-number">1106410694</span><br>cat: <span class="hljs-number">1747278511</span><br>dog: <span class="hljs-number">460128162</span><br>cat: <span class="hljs-number">817455089</span><br></code></pre></td></tr></table></figure><p>对代码的分析：<br>第 03 行，导入格式化（fmt）、随机数（math/rand）、时间（time）包参与编译。<br>第 10 行，生产数据的函数，传入一个标记类型的字符串及一个只能写入的通道。<br>第 13 行，for{} 构成一个无限循环。<br>第 15 行，使用 rand.Int31() 生成一个随机数，使用 fmt.Sprintf() 函数将 header 和随机数格式化为字符串。<br>第 18 行，使用 time.Sleep() 函数暂停 1 秒再执行这个函数。如果在 goroutine 中执行时，暂停不会影响其他 goroutine 的执行。<br>第 23 行，消费数据的函数，传入一个只能写入的通道。<br>第 26 行，构造一个不断消费消息的循环。<br>第 28 行，从通道中取出数据。<br>第 31 行，将取出的数据进行打印。<br>第 35 行，程序的入口函数，总是在程序开始时执行。<br>第 37 行，实例化一个字符串类型的通道。<br>第 39 行和第 40 行，并发执行一个生产者函数，两行分别创建了这个函数搭配不同参数的两个 goroutine。<br>第 42 行，执行消费者函数通过通道进行数据消费。</p><p>整段代码中，没有线程创建，没有线程池也没有加锁，仅仅通过关键字 go 实现 goroutine，和通道实现数据交换。</p><h2 id="4-哪些项目使用Go语言开发？"><a href="#4-哪些项目使用Go语言开发？" class="headerlink" title="4.哪些项目使用Go语言开发？"></a>4.哪些项目使用Go语言开发？</h2><p>列举的是原生使用Go语言进行开发的部分项目。</p><ul><li>Docker<br>Docker 是一种操作系统层面的虚拟化技术，可以在操作系统和应用程序之间进行隔离，也可以称之为容器。Docker 可以在一台物理服务器上快速运行一个或多个实例。例如，启动一个 CentOS 操作系统，并在其内部命令行执行指令后结束，整个过程就像自己在操作系统一样高效。</li></ul><p>项目链接：<a href="https://github.com/docker/docker">https://github.com/docker/docker</a></p><ul><li>Go语言<br>Go语言自己的早期源码使用C语言和汇编语言写成。从 Go 1.5 版本后，完全使用Go语言自身进行编写。Go语言的源码对了解Go语言的底层调度有极大的参考意义，建议希望对Go语言有深入了解的读者读一读。</li></ul><p>项目链接：<a href="https://github.com/golang/go">https://github.com/golang/go</a></p><ul><li>Kubernetes<br>Google 公司开发的构建于 Docker 之上的容器调度服务，用户可以通过 Kubernetes 集群进行云端容器集群管理。系统会自动选取合适的工作节点来执行具体的容器集群调度处理工作。其核心概念是 Container Pod（容器仓）。</li></ul><p>项目链接：<a href="https://github.com/kubernetes/kubernetes">https://github.com/kubernetes/kubernetes</a></p><ul><li>etcd<br>一款分布式、可靠的 KV 存储系统，可以快速进行云配置。由 CoreOS 开发并维护键值存储系统，它使用Go语言编写，并通过 Raft 一致性算法处理日志复制以保证强一致性。</li></ul><p>项目链接：<a href="https://github.com/coreos/etcd">https://github.com/coreos/etcd</a></p><ul><li>beego<br>beego 是一个类似 Python 的 Tornado 框架，采用了 RESTFul 的设计思路，使用Go语言编写的一个极轻量级、高可伸缩性和高性能的 Web 应用框架。</li></ul><p>项目链接：<a href="https://github.com/astaxie/beego">https://github.com/astaxie/beego</a></p><ul><li>martini<br>一款快速构建模块化的 Web 应用的Go语言框架。</li></ul><p>项目链接：<a href="https://github.com/go-martini/martini">https://github.com/go-martini/martini</a></p><ul><li>codis<br>国产的优秀分布式 Redis 解决方案。可以将 codis 理解成为 Web 服务领域的 Nginx，它实现了对 Redis 的反向代理和负载均衡。</li></ul><p>项目链接：<a href="https://github.com/CodisLabs/codis">https://github.com/CodisLabs/codis</a></p><ul><li>delve<br>Go语言强大的调试器，被很多集成环境和编辑器整合。</li></ul><p>项目链接：<a href="https://github.com/derekparker/delve">https://github.com/derekparker/delve</a></p><h2 id="5-哪些大公司正在使用Go语言"><a href="#5-哪些大公司正在使用Go语言" class="headerlink" title="5.哪些大公司正在使用Go语言"></a>5.哪些大公司正在使用Go语言</h2><p>Go语言是谷歌在 2009 年发布的一款编程语言，自面世以来它以高效的开发效率和完美的运行速度迅速风靡全球，被誉为“21 世纪的C语言”。</p><p>现在越来越多的公司开始使用Go语言开发自己的服务，同时也诞生了很多使用Go语言开发的服务和应用，比如 Docker、k8s 等，下面我们来看一下，有哪些大公司在使用Go语言。</p><ul><li>Google<br>作为创造了Go语言的 google 公司，当然会力挺Go语言了。Google 有很多基于 Go 开发的开源项目，比如 kubernets，docker，大家可以参考《哪些项目使用Go语言开发》一节了解更多的Go语言开源项目。</li><li>Facebook<br>Facebook 也在使用Go语言，为此他们还专门在 Github 上建立了一个开源组织 facebookgo。大家可以通过 <a href="https://github.com/facebookgo">https://github.com/facebookgo</a> 访问查看 facebook 开源的项目，其中最具代表性的就是著名平滑重启工具 grace。</li><li>腾讯<br>腾讯在 15 年就已经做了 Docker 万台规模的实践。因为腾讯主要的开发语言是 C/C++ ，所以在使用Go语言方面会方便很多，也有很多优势，不过日积月累的 C/C++ 代码很难改造，也不敢动，所以主要在新业务上尝试使用 Go。</li><li>百度<br>百度主要在运维方面使用到了Go语言，比如百度运维的一个 BFE 项目，主要负责前端流量的接入，其次就是百度消息通讯系统的服务器端也使用到了Go语言。</li><li>七牛云<br>七牛云算是国内第一家选Go语言做服务端的公司。早在 2011 年，当Go语言的语法还没完全稳定下来的情况下，七牛云就已经选择将 Go 作为存储服务端的主体语言。</li><li>京东<br>京东云消息推送系统、云存储，以及京东商城的列表页等都是使用Go语言开发的。</li><li>小米<br>小米对Go语言的支持，在于运维监控系统的开源，它的<a href="http://open-falcon.org/">官方网址</a>。此外，小米互娱、小米商城、小米视频、小米生态链等团队都在使用Go语言。</li><li>360<br>360 对Go语言的使用也不少，比如开源的日志搜索系统 Poseidon，大家可以通过 <a href="https://github.com/Qihoo360/poseidon">https://github.com/Qihoo360/poseidon</a> 查看，还有 360 的推送团队也在使用Go语言。</li></ul><p>除了上面提到的，还有很多公司开始尝试使用Go语言，比如美团、滴滴、新浪等。</p><p>Go语言的强项在于它适合用来开发网络并发方面的服务，比如消息推送、监控、容器等，所以在高并发的项目上大多数公司会优先选择 Golang 作为开发语言</p><h2 id="6-Go语言适合做什么"><a href="#6-Go语言适合做什么" class="headerlink" title="6.Go语言适合做什么"></a>6.Go语言适合做什么</h2><p>一、我们为什么选择Go语言<br>选择Go语言的原因可能会有很多，关于Go语言的特性、优势等，我们在之前的文档中也已经介绍了很多了。但是最主要的原因，应该是基于以下两方面的考虑：</p><p>1、执行性能<br>毕竟是类C的执行速度，对于一些服务来说，性能是极其重要的一环，事关系统的吞吐、访问的延迟，进而会影响用户的体验，Go语言通过协程可以方便的实现并行处理，达到处理效率的最大化 ，提升系统的吞吐能力。</p><p>2、开发效率<br>GO语言使用起来简单、代码描述效率高、编码规范统一、上手快。 通过少量的代码，即可实现框架的标准化，能快速的构建各种通用组件和公共类库，进一步提升开发效率，实现特定场景下的功能量产。</p><p>二、Go语言能做什么<br>Go 语言从发布 1.0 版本以来备受众多开发者关注并得到广泛使用，Go 语言的简单、高效、并发特性吸引了众多传统语言开发者的加入，而且人数越来越多。</p><p>鉴于Go语言的特点和设计的初衷，Go语言作为服务器编程语言，很适合处理日志、数据打包、虚拟机处理、文件系统、分布式系统、数据库代理等；网络编程方面，Go语言广泛应用于Web 应用、API应用、下载应用等；除此之外，Go语言还适用于内存数据库和云平台领域，目前国外很多云平台都是采用Go开发。</p><p>1、服务器编程，以前你如果使用C或者C++做的那些事情，用Go来做很合适，例如处理日志、数据打包、虚拟机处理、文件系统等。</p><p>2、分布式系统、数据库代理器、中间件等，例如Etcd。</p><p>3、网络编程，这一块目前应用最广，包括Web应用、API应用、下载应用，而且Go内置的net/http包基本上把我们平常用到的网络功能都实现了。</p><p>4、数据库操作</p><p>5、开发云平台，目前国外很多云平台在采用Go开发</p><p>三、国内外有哪些企业或项目使用Go语言<br>Go发布之后，很多公司特别是云计算公司开始用Go重构他们的基础架构，很多都是直接采用Go进行了开发，最近热火朝天的Docker就是采用Go开发的。</p><p>使用 Go 语言开发的开源项目非常多。早期的 Go 语言开源项目只是通过 Go 语言与传统项目进行C语言库绑定实现，例如 Qt、Sqlite 等；后期的很多项目都使用 Go 语言进行重新原生实现，这个过程相对于其他语言要简单一些，这也促成了大量使用 Go 语言原生开发项目的出现。</p><p>1、云计算基础设施领域<br>代表项目：docker、kubernetes、etcd、consul、cloudflare CDN、七牛云存储等。</p><p>2、基础软件<br>代表项目：tidb、influxdb、cockroachdb等。</p><p>3、微服务<br>代表项目：go-kit、micro、monzo bank的typhon、bilibili等。</p><p>4、互联网基础设施<br>代表项目：以太坊、hyperledger等。</p><p>采用Go的一些国外公司，如Google、Docker、Apple、Cloud Foundry、CloudFlare、Couchbase、CoreOS、Dropbox、MongoDB、AWS等公司；<br>采用Go开发的国内企业：如阿里云CDN、百度、小米、七牛、PingCAP、华为、金山软件、猎豹移动、饿了么等公司。</p><p>还有很多，比如阿里中间件、聚美优品、高升控股、探探、斗鱼直播、人人车、亚信、Udesk、方付通、招财猫、三一集团、美餐网等。一般的选择，都是选择用于自己公司合适的产品系统来做，比如消息推送的、监控的、容器的等，Golang特别适合做网络并发的服务，这是他的强项，所以也是被优先用于这些项目。Go语言作为一门大型项目开发语言，在很多大公司相继使用，甚至完全转向Go开发。</p><p>四、写在最后<br>当然，一个技术能不能发展起来，关键还要看三点。</p><p>有没有一个比较好的社区。</p><p>像 C、C++、Java、Python 和 JavaScript 的生态圈都是非常丰富和火爆的。尤其是有很多商业机构参与的社区那就更为人气爆棚了，比如 Linux 的社区。</p><p>有没有一个工业化的标准。</p><p>像 C、C++、Java 都是有标准化组织的。尤其是 Java，其在架构上还搞出了像 J2EE 这样的企业级标准。</p><p>有没有一个或多个杀手级应用。</p><p>C、C++ 和 Java 的杀手级应用不用多说了，就算是对于 PHP 这样还不能算是一个好的编程语言来说，因为是 Linux 时代的第一个杀手级解决方案 LAMP 中的关键技术，所以，也发展起来了。</p><p>上述的这三点是非常关键的，新的技术只需要占到其中一到两点就已经很不错了，何况有的技术，比如 Java，是三点全占到了，所以，Java 的发展是如此好。当然，除了上面这三点重要的，还有一些其它的影响因素，比如：</p><p>学习曲线是否低，上手是否快。</p><p>这点非常重要，C++ 在这点上越做越不好了。</p><p>有没有一个不错的提高开发效率的开发框架。</p><p>如：Java 的 Spring 框架，C++ 的 STL 等。</p><p>是否有一个或多个巨型的技术公司作为后盾。</p><p>如：Java 和 Linux 后面的 IBM、Sun……</p><p>有没有解决软件开发中的痛点。</p><p>如：Java 解决了 C 和 C++ 的内存管理问题。</p><p>用这些标尺来量一下 Go 语言，我们可以清楚地看到：</p><p>Go 语言容易上手；<br>Go 语言解决了并发编程和写底层应用开发效率的痛点；<br>Go 语言有 Google 这个世界一流的技术公司在后面；<br>Go 语言的杀手级应用是 Docker，而 Docker 的生态圈在这几年完全爆棚了。<br>所以，Go 语言的未来是不可限量的。当然，我个人觉得，Go 可能会吞食很多 C、C++、Java 的项目。不过，Go 语言所吞食主要的项目应该是中间层的项目，既不是非常底层也不会是业务层。</p><p>也就是说，Go 语言不会吞食底层到 C 和 C++ 那个级别的，也不会吞食到高层如 Java 业务层的项目。Go 语言能吞食的一定是 PaaS 上的项目，比如一些消息缓存中间件、服务发现、服务代理、控制系统、Agent、日志收集等等，没有复杂的业务场景，也到不了特别底层（如操作系统）的中间平台层的软件项目或工具。而 C 和 C++ 会被打到更底层，Java 会被打到更上层的业务层。</p><p>好了，我们再用上面的标尺来量一下 Go 语言的杀手级应用 Docker，你会发现基本是一样的。</p><p>Docker 上手很容易。<br>Docker 解决了运维中的环境问题以及服务调度的痛点。<br>Docker 的生态圈中有大公司在后面助力。比如 Google。<br>Docker 产出了工业界标准 OCI。<br>Docker 的社区和生态圈已经出现像 Java 和 Linux 那样的态势。<br>……<br>所以，虽然几年前的 Docker ，当时的坑儿还很多，但是，相对于这些大的因素来说，那些小坑儿都不是问题。只是需要一些时间，这些小坑儿在未来 5-10 年就可以完全被填平了。</p><p>同样，我们可以看到 Kubernetes 作为服务和容器调度的关键技术一定会是最后的赢家。</p><p>最后，我还要说一下，为什么要早一点地进入这些新技术，而不是等待这些技术成熟了后再进入。原因有这么几个。</p><p>技术的发展过程非常重要。因为你可以清楚地看到了这种新技术的生态圈发展过程。让我们收获最大的并不是这些技术本身，而是一个技术的变迁和行业的发展。</p><p>从中，我们看到了非常具体的各种思潮和思路，这些东西比起 技术本身来说更有价值。因为，这不但让我们重新思考已经掌握的技术以及如何更好地解决已有的问题，而且还让我看到了未来。不但有了技术优势，而且这些知识还让我们的技术生涯多了很多的可能性。</p><p>这些关键新技术，可以让你拿到技术的先机。这些对一个需要技术领导力的个人或公司来说都是非常重要的。</p><p>一个公司或是个人能够占有技术先机，就会比其它公司或个人有更大的影响力。一旦未来行业需求引爆，那么这个公司或是个人的影响力就会形成一个比较大的护城河，并可以快速地产生经济利益。</p><p>Go的应用范围一直在扩大，云计算，微服务，区块链，哪里都有用Go写的重量级项目。docker/kubernetes生态圈，几百/千万行代码，基本统治了云原生应用市场。去年大热的区块链，以太坊的geth，比特币的btcd，闪电网络的lnd，都是Go语言开发。还是那句话，多看看各种语言的生态，或许都并没有你想象的那么不堪。。。Go语言设计上确实不够“先进”，但也是另一种“务实”。其实go不管在国内还是国外已经很受待见了，国外google用的很多，uber也在用，国内有著名的今日头条，每日千亿级的访问妥妥的。多少语言终其一生都没有这么大的应用场景。</p><h2 id="7-Go语言和其它编程语言的对比"><a href="#7-Go语言和其它编程语言的对比" class="headerlink" title="7.Go语言和其它编程语言的对比"></a>7.Go语言和其它编程语言的对比</h2><h2 id="8-Go语言的性能如何？"><a href="#8-Go语言的性能如何？" class="headerlink" title="8.Go语言的性能如何？"></a>8.Go语言的性能如何？</h2><h2 id="9-Go语言标准库强大"><a href="#9-Go语言标准库强大" class="headerlink" title="9.Go语言标准库强大"></a>9.Go语言标准库强大</h2><h2 id="10-Go语言上手简单"><a href="#10-Go语言上手简单" class="headerlink" title="10.Go语言上手简单"></a>10.Go语言上手简单</h2><h2 id="11-Go语言代码风格清晰、简单"><a href="#11-Go语言代码风格清晰、简单" class="headerlink" title="11.Go语言代码风格清晰、简单"></a>11.Go语言代码风格清晰、简单</h2><h2 id="12-Go语言是怎么完成编译的"><a href="#12-Go语言是怎么完成编译的" class="headerlink" title="12.Go语言是怎么完成编译的"></a>12.Go语言是怎么完成编译的</h2><h2 id="13-在Windows上安装Go语言开发包"><a href="#13-在Windows上安装Go语言开发包" class="headerlink" title="13.在Windows上安装Go语言开发包"></a>13.在Windows上安装Go语言开发包</h2><h2 id="14-在Linux上安装Go语言开发包"><a href="#14-在Linux上安装Go语言开发包" class="headerlink" title="14.在Linux上安装Go语言开发包"></a>14.在Linux上安装Go语言开发包</h2><h2 id="15-在Mac-OS上安装Go语言开发包"><a href="#15-在Mac-OS上安装Go语言开发包" class="headerlink" title="15.在Mac OS上安装Go语言开发包"></a>15.在Mac OS上安装Go语言开发包</h2><h2 id="16-Go语言集成开发环境"><a href="#16-Go语言集成开发环境" class="headerlink" title="16.Go语言集成开发环境"></a>16.Go语言集成开发环境</h2><h2 id="17-Go语言工程结构详述"><a href="#17-Go语言工程结构详述" class="headerlink" title="17.Go语言工程结构详述"></a>17.Go语言工程结构详述</h2><h2 id="18-Go语言依赖管理"><a href="#18-Go语言依赖管理" class="headerlink" title="18.Go语言依赖管理"></a>18.Go语言依赖管理</h2><h2 id="19-第一个Go语言程序"><a href="#19-第一个Go语言程序" class="headerlink" title="19.第一个Go语言程序"></a>19.第一个Go语言程序</h2><h2 id="20-Go语言程序的编译和运行"><a href="#20-Go语言程序的编译和运行" class="headerlink" title="20.Go语言程序的编译和运行"></a>20.Go语言程序的编译和运行</h2><h2 id="21-Goland下载和安装"><a href="#21-Goland下载和安装" class="headerlink" title="21.Goland下载和安装"></a>21.Goland下载和安装</h2><h2 id="22-Goland入门指南"><a href="#22-Goland入门指南" class="headerlink" title="22.Goland入门指南"></a>22.Goland入门指南</h2><h2 id="23-Goland常用快捷键"><a href="#23-Goland常用快捷键" class="headerlink" title="23.Goland常用快捷键"></a>23.Goland常用快捷键</h2><h2 id="24-LiteIDE搭建Go语言开发环境"><a href="#24-LiteIDE搭建Go语言开发环境" class="headerlink" title="24.LiteIDE搭建Go语言开发环境"></a>24.LiteIDE搭建Go语言开发环境</h2><h1 id="Go语言基本语法"><a href="#Go语言基本语法" class="headerlink" title="Go语言基本语法"></a>Go语言基本语法</h1><p>  1.Go语言变量的声明<br>  2.Go语言变量的初始化<br>  3.Go语言多个变量同时赋值<br>  4.Go语言匿名变量<br>  5.Go语言变量的作用域<br>  6.Go语言整型（整数类型）<br>  7.Go语言浮点类型（小数类型）<br>  8.Go语言复数<br>  9.实例：输出正弦函数（Sin）图像<br>  10.Go语言bool类型（布尔类型）<br>  11.Go语言字符串<br>  12.Go语言字符类型（byte和rune）<br>  13.Go语言数据类型转换<br>  14.Go语言指针<br>  15.Go语言变量逃逸分析<br>  16.Go语言变量的生命周期<br>  17.Go语言常量<br>  18.Go语言模拟枚举<br>  19.Go语言类型别名<br>  20.Go语言注释的定义及使用<br>  21.Go语言关键字与标识符<br>  22.Go语言运算符的优先级<br>  23.Go语言字符串和数值类型的相互转换</p><h1 id="Go语言容器"><a href="#Go语言容器" class="headerlink" title="Go语言容器"></a>Go语言容器</h1><p>  1.Go语言数组<br>  2.Go语言多维数组<br>  3.Go语言切片<br>  4.使用append()为切片添加元素<br>  5.Go语言切片复制<br>  6.Go语言从切片中删除元素<br>  7.Go语言range关键字<br>  8.Go语言多维切片<br>  9.Go语言map（映射）<br>  10.Go语言遍历map<br>  11.map元素的删除和清空<br>  12.Go语言map的多键索引<br>  13.Go语言sync.Map<br>  14.Go语言list（列表）<br>  15.Go语言nil：空值/零值<br>  16.Go语言make和new关键字的区别及实现原理</p><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><p>  1.Go语言分支结构<br>  2.Go语言循环结构<br>  3.输出九九乘法表<br>  4.Go语言键值循环<br>  5.Go语言switch语句<br>  6.Go语言goto语句<br>  7.Go语言break（跳出循环）<br>  8.Go语言continue<br>  9.示例：聊天机器人<br>  10.示例：词频统计<br>  11.示例：缩进排序<br>  12.示例：二分查找算法<br>  13.示例：冒泡排序<br>  14.Go语言分布式id生成器</p><h1 id="Go语言函数"><a href="#Go语言函数" class="headerlink" title="Go语言函数"></a>Go语言函数</h1><p>  1.Go语言函数声明<br>  2.示例：将秒转换为具体的时间<br>  3.示例：函数中的参数传递效果测试<br>  4.Go语言函数变量<br>  5.Go语言字符串的链式处理<br>  6.Go语言匿名函数<br>  7.Go语言函数类型实现接口<br>  8.Go语言闭包（Closure）<br>  9.Go语言可变参数<br>  10.Go语言defer（延迟执行语句）<br>  11.Go语言递归函数<br>  12.Go语言处理运行时错误<br>  13.Go语言宕机（panic）<br>  14.Go语言宕机恢复（recover）<br>  15.Go语言计算函数执行时间<br>  16.示例：通过内存缓存来提升性能<br>  17.Go语言哈希函数<br>  18.Go语言函数的底层实现<br>  19.Go语言Test功能测试函数</p><h1 id="Go语言结构体"><a href="#Go语言结构体" class="headerlink" title="Go语言结构体"></a>Go语言结构体</h1><p>  1.Go语言结构体定义<br>  2.Go语言实例化结构体<br>  3.初始化结构体的成员变量<br>  4.Go语言构造函数<br>  5.Go语言方法和接收器<br>  6.为任意类型添加方法<br>  7.示例：使用事件系统实现事件的响应和处理<br>  8.类型内嵌和结构体内嵌<br>  9.结构体内嵌模拟类的继承<br>  10.初始化内嵌结构体<br>  11.内嵌结构体成员名字冲突<br>  12.示例：使用匿名结构体解析JSON数据<br>  13.Go语言垃圾回收和SetFinalizer<br>  14.示例：将结构体数据保存为JSON格式数据<br>  15.Go语言链表操作<br>  16.Go语言数据I/O对象及操作</p><h1 id="Go语言接口"><a href="#Go语言接口" class="headerlink" title="Go语言接口"></a>Go语言接口</h1><p>  1.Go语言接口声明（定义）<br>  2.Go语言实现接口的条件<br>  3.Go语言类型与接口的关系<br>  4.接口的nil判断<br>  5.Go语言类型断言<br>  6.示例：Go语言实现日志系统<br>  7.Go语言排序<br>  8.Go语言接口的嵌套组合<br>  9.Go语言接口和类型之间的转换<br>  10.Go语言空接口类型<br>  11.示例：使用空接口实现可以保存任意值的字典<br>  12.Go语言类型分支<br>  13.Go语言error接口<br>  14.Go语言接口内部实现<br>  15.示例：表达式求值器<br>  16.示例：简单的Web服务器<br>  17.部署Go语言程序到Linux服务器<br>  18.示例：音乐播放器<br>  19.示例：实现有限状态机（FSM）<br>  20.示例：二叉树数据结构的应用</p><h1 id="Go语言接口-1"><a href="#Go语言接口-1" class="headerlink" title="Go语言接口"></a>Go语言接口</h1><p>  1.Go语言接口声明（定义）<br>  2.Go语言实现接口的条件<br>  3.Go语言类型与接口的关系<br>  4.接口的nil判断<br>  5.Go语言类型断言<br>  6.示例：Go语言实现日志系统<br>  7.Go语言排序<br>  8.Go语言接口的嵌套组合<br>  9.Go语言接口和类型之间的转换<br>  10.Go语言空接口类型<br>  11.示例：使用空接口实现可以保存任意值的字典<br>  12.Go语言类型分支<br>  13.Go语言error接口<br>  14.Go语言接口内部实现<br>  15.示例：表达式求值器<br>  16.示例：简单的Web服务器<br>  17.部署Go语言程序到Linux服务器<br>  18.示例：音乐播放器<br>  19.示例：实现有限状态机（FSM）<br>  20.示例：二叉树数据结构的应用</p><h1 id="Go语言并发"><a href="#Go语言并发" class="headerlink" title="Go语言并发"></a>Go语言并发</h1><p>  1.Go语言并发简述<br>  2.Go语言轻量级线程<br>  3.Go语言并发通信<br>  4.Go语言竞争状态<br>  5.Go语言调整并发的运行性能<br>  6.并发和并行的区别<br>  7.goroutine和coroutine的区别<br>  8.Go语言通道（chan）<br>  9.示例：并发打印<br>  10.Go语言单向通道<br>  11.Go语言无缓冲的通道<br>  12.Go语言带缓冲的通道<br>  13.Go语言channel超时机制<br>  14.Go语言通道的多路复用<br>  15.Go语言模拟远程过程调用<br>  16.示例：使用通道响应计时器的事件<br>  17.Go语言关闭通道后继续使用通道<br>  18.Go语言多核并行化<br>  19.Go语言Telnet回音服务器<br>  20.检测代码在并发环境下可能出现的问题<br>  21.互斥锁和读写互斥锁<br>  22.Go语言等待组<br>  23.死锁、活锁和饥饿概述<br>  24.示例：封装qsort快速排序函数<br>  25.Go语言CSP：通信顺序进程简述<br>  26.示例：聊天服务器<br>  27.高效地使用Go语言并发特性<br>  28.使用select切换协程<br>  29.Go语言加密通信</p><h1 id="Go语言反射"><a href="#Go语言反射" class="headerlink" title="Go语言反射"></a>Go语言反射</h1><p>  1.Go语言反射（reflection）<br>  2.Go语言反射规则浅析<br>  3.反射——性能和灵活性的双刃剑<br>  4.通过反射获取类型信息<br>  5.通过反射获取指针指向的元素类型<br>  6.通过反射获取结构体的成员类型<br>  7.Go语言结构体标签<br>  8.通过反射获取值信息<br>  9.通过反射访问结构体成员的值<br>  10.判断反射值的空和有效性<br>  11.通过反射修改变量的值<br>  12.通过类型信息创建实例<br>  13.通过反射调用函数<br>  14.Go语言inject库：依赖注入</p><h1 id="Go语言文件处理"><a href="#Go语言文件处理" class="headerlink" title="Go语言文件处理"></a>Go语言文件处理</h1><p>  1.Go语言自定义数据文件<br>  2.Go语言JSON文件的读写操作<br>  3.Go语言XML文件的读写操作<br>  4.Go语言使用Gob传输数据<br>  5.Go语言纯文本文件的读写操作<br>  6.Go语言二进制文件的读写操作<br>  7.Go语言自定义二进制文件的读写操作<br>  8.Go语言zip归档文件的读写操作<br>  9.Go语言tar归档文件的读写操作<br>  10.Go语言使用buffer读取文件<br>  11.示例：并发目录遍历<br>  12.示例：从INI配置文件中读取需要的值<br>  13.Go语言文件的写入、追加、读取、复制操作<br>  14.Go语言文件锁操作</p><h1 id="Go语言编译与工具"><a href="#Go语言编译与工具" class="headerlink" title="Go语言编译与工具"></a>Go语言编译与工具</h1><p>  1.go build命令<br>  2.go clean命令<br>  3.go run命令<br>  4.go fmt命令<br>  5.go install命令<br>  6.go get命令<br>  7.go generate命令<br>  8.go test命令<br>  9.go pprof命令<br>  10.与C/C++进行交互<br>  11.Go语言内存管理<br>  12.Go语言垃圾回收<br>  13.Go语言实现RSA和AES加解密</p><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p><a href="https://github.com/mikeygithub/go-study.git">相关资料</a></p><p><a href="http://c.biancheng.net/golang/">学习网站</a></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>核心编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Centos安装图形化界面</title>
    <link href="/2018/07/05/linux/Centos%E5%AE%89%E8%A3%85%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/"/>
    <url>/2018/07/05/linux/Centos%E5%AE%89%E8%A3%85%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>最近有重新来捣鼓捣鼓Linux了，这次撸的版本是centos7.4的，虽然说是不要桌面，但是感觉初学者还是安装一下比较好balalalala。。。。。。。。。废话不说的直接进入正题：</p></blockquote><h1 id="安装X"><a href="#安装X" class="headerlink" title="安装X"></a>安装X</h1><blockquote><p>首先安装X(X Window System),如果不是root用户请先切换到root用户才能操作，命令为：</p></blockquote><p><code>su root</code> </p><p>命令为</p><p><code>yum groupinstall &quot;X Window System&quot;</code></p><p>回车，安装时间可能会比较长，安装完出现complete！提示，如果出现要确认其他信息则一路输入输入 “y”回车</p><p>查看已装软件及可装软件：</p><p><code>yum grouplist</code></p><p>由于本屌已经安装好了所以就在已经安装的分组的啦</p><h1 id="安装图形界面软件GNOME-GNOME-Desktop"><a href="#安装图形界面软件GNOME-GNOME-Desktop" class="headerlink" title="安装图形界面软件GNOME(GNOME Desktop)"></a>安装图形界面软件GNOME(GNOME Desktop)</h1><blockquote><p>这里需要特别注意！！！！一定要注意 名称必须对应 不同版本的centOS的软件名可能不同 其他Linux系统类似否则会出现No packages in any requested group available to install or update 的错误。</p></blockquote><p><code>yum groupinstall &quot;GNOME Desktop&quot;</code></p><p> 回车，出现提示一路输入”y”确认</p><p>这次的安装会更慢，内心等待，安装完会出现complete！提示。</p><h1 id="进入图形化界面"><a href="#进入图形化界面" class="headerlink" title="进入图形化界面"></a>进入图形化界面</h1><p>输入</p><p><code>startX</code></p><p>速度可能比较慢，可尝试重启</p><p><code>reboot</code></p><p>完成.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>centos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 命令汇总</title>
    <link href="/2018/07/03/linux/Linux-%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/"/>
    <url>/2018/07/03/linux/Linux-%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><table><tbody><tr><td style="text-align: center;" colspan="29" height="48"><span style="font-family: 楷体; font-size: 18pt;"><strong>Linux 命令汇总</strong></span></td></tr><tr><td colspan="4" height="19">NO</td><td colspan="4" height="19">分类</td><td colspan="4" height="19">命令名</td><td colspan="8" height="19">用法及参数</td><td colspan="8" height="19">功能注解</td></tr><tr><td colspan="4" height="19">1</td><td colspan="4" height="19">文件管理</td> <td colspan="4"  height="19">ls</td><td colspan="8"  height="19">ls-a</td><td colspan="8"  height="19">列出当前目录下的所有文件，包括以.头的隐含文件</td></tr><tr><td colspan="4" height="19"></td><td colspan="4" height="19">文件管理</td> <td colspan="4" height="19">ls</td><td colspan="8" height="19">ls-l或ll</td><td colspan="8" height="19">列出当前目录下文件的详细信息</td></tr><tr><td colspan="4" height="19"></td><td colspan="4" height="19">文件管理</td> <td colspan="4" height="19">pwd</td><td colspan="8" height="19">pwd</td><td colspan="8" height="19">查看当前所在目录的绝对路经</td></tr><tr><td colspan="4" height="19"></td><td colspan="4" height="19">文件管理</td> <td colspan="4" height="19">cd</td><td colspan="8" height="19">cd..</td><td colspan="8" height="19">回当前目录的上一级目录</td></tr><tr><td colspan="4" height="19"></td><td colspan="4" height="19">文件管理</td> <td colspan="4" height="19">cd</td><td colspan="8" height="19">cd-</td><td colspan="8" height="19">回上一次所在的目录</td></tr><tr><td colspan="4" height="19"></td><td colspan="4" height="19">文件管理</td> <td colspan="4" height="19">cd</td><td colspan="8" height="19">cd~或cd</td><td colspan="8" height="19">回当前用户的宿主目录</td></tr><tr><td colspan="4" height="19"></td><td colspan="4" height="19">文件管理</td> <td colspan="4" height="19">cd</td><td colspan="8" height="19">cd~用户名</td><td colspan="8" height="19">回指定用户的宿主目录</td></tr><tr><td colspan="4" height="19">2</td><td colspan="4" height="19">文件管理</td> <td colspan="4" height="19">mkdir</td><td colspan="8" height="19">mkdir目录名</td><td colspan="8" height="19">创建一个目录</td></tr><tr><td colspan="4" height="19"></td><td colspan="4" height="19">文件管理</td> <td colspan="4" height="19">mkdir</td><td colspan="8" height="19">mkdir–p</td><td colspan="8" height="19">递归式去创建一些嵌套目录</td></tr><tr><td colspan="4" height="19"></td><td colspan="4" height="19">文件管理</td> <td colspan="4" height="19">rmdir</td><td colspan="8" height="19">Rmdir空目录名</td><td colspan="8" height="19">删除一个空目录</td></tr><tr><td colspan="4" height="19">3</td><td colspan="4" height="19">文件管理</td> <td colspan="4" height="19">rm</td><td colspan="8" height="19">rm文件名文件名</td><td colspan="8" height="19">删除一个文件或多个文件</td></tr><tr><td colspan="4" height="19"></td><td colspan="4" height="19">文件管理</td> <td colspan="4" height="19">rm</td><td colspan="8" height="19">rm-rf非空目录名</td><td colspan="8" height="19">递归删除一个非空目录下的一切，不让提式-f</td></tr><tr><td colspan="4" height="19">4</td><td colspan="4" height="19">文件管理</td> <td colspan="4" height="19">cat</td><td colspan="8" height="19">cat文件名</td><td colspan="8" height="19">一屏查看文件内容</td></tr><tr><td colspan="4" height="19">5</td><td colspan="4" height="19">文件管理</td> <td colspan="4" height="19">more</td><td colspan="8" height="19">more文件名</td><td colspan="8" height="19">分页查看文件内容</td></tr><tr><td colspan="4" height="19">6</td><td colspan="4" height="19">文件管理</td> <td colspan="4" height="19">less</td><td colspan="8" height="19">less文件名</td><td colspan="8" height="19">可控分页查看文件内容</td></tr><tr><td colspan="4" height="19">7</td><td colspan="4" height="19">文件管理</td> <td colspan="4" height="19">grep</td><td colspan="8" height="19">grep字符文件名</td><td colspan="8" height="19">根据字符匹配来查看文件部分内容</td></tr><tr><td colspan="4" height="19">8</td><td colspan="4" height="19">文件管理</td> <td colspan="4" height="19">mv</td><td colspan="8" height="19">mv路经/文件/经/文件</td><td colspan="8" height="19">移动相对路经下的文件到绝对路经下</td></tr><tr><td colspan="4" height="19"></td><td colspan="4" height="19">文件管理</td> <td colspan="4" height="19">mv</td><td colspan="8" height="19">mv文件名新名称</td><td colspan="8" height="19">在当前目录下改名</td></tr><tr><td colspan="4" height="19">9</td><td colspan="4" height="19">文件管理</td> <td colspan="4" height="19">cp</td><td colspan="8" height="19">cp/路经/文件./</td><td colspan="8" height="19">移动绝对路经下的文件到当前目录下</td></tr><tr><td colspan="4" height="19">10</td><td colspan="4" height="19">文件管理</td> <td colspan="4" height="19">find</td><td colspan="8" height="19">find路经-name“字符串”</td><td colspan="8" height="19">查找路经所在范围内满足字符串匹配的文件和目录</td></tr><tr><td colspan="4" height="19">11</td><td colspan="4" height="19">文件管理</td> <td colspan="4" height="19">ln</td><td colspan="8" height="19">ln源文件链接名</td><td colspan="8" height="19">创建当前目录源文件的硬链接</td></tr><tr><td colspan="4" height="19"></td><td colspan="4" height="19"></td><td colspan="4" height="19"></td><td colspan="8" height="19">ln/home/test/usr/test1</td><td colspan="8" height="19">在/usr下建立/home/test的硬链接</td></tr><tr><td colspan="4" height="19">12</td><td colspan="4" height="19">文件管理</td> <td colspan="4" height="19">ln</td><td colspan="8" height="19">Ln-sab</td><td colspan="8" height="19">创建当前目录下a的符号链接b</td></tr><tr><td colspan="4" height="19">13</td><td colspan="4" height="19">文件管理</td> <td colspan="4" height="19">touch</td><td colspan="8" height="19">touchfile1file2</td><td colspan="8" height="19">创建两个空文件</td></tr><tr><td colspan="4" height="19">14</td><td colspan="4" height="19">磁盘管理</td> <td colspan="4" height="19">df</td><td colspan="8" height="19">df</td><td colspan="8" height="19">用于报告文件系统的总容量，使用量，剩余容量。</td></tr><tr><td colspan="4" height="19">15</td><td colspan="4" height="19">磁盘管理</td> <td colspan="4" height="19">du</td><td colspan="8" height="19">du-b/home</td><td colspan="8" height="19">查看目前/HOME目录的容量(k)及子目录的容量(k)。</td></tr><tr><td colspan="4" height="19">16</td><td colspan="4" height="19">磁盘管理</td> <td colspan="4" height="19">fdisk</td><td colspan="8" height="19">fdisk-l</td><td colspan="8" height="19">查看系统分区信息</td></tr><tr><td colspan="4" height="19">17</td><td colspan="4" height="19">磁盘管理</td> <td colspan="4" height="19">fdisk</td><td colspan="8" height="19">fdisk/dev/sdb</td><td colspan="8" height="19">为一块新的SCSI硬盘进行分区</td></tr><tr><td rowspan="2" colspan="4" height="38">18</td><td rowspan="2" colspan="4" height="38">磁盘管理</td><td rowspan="2" colspan="4" height="38">mkfs.ext3</td><td rowspan="2" colspan="8" height="38">Mkfs.ext3/dev/sdb1</td><td colspan="8" height="19">为第一块SCSI硬盘的第一主分区格式化成</td></tr><tr><td class="et16" colspan="8" height="19">ext3的文件系统</td></tr><tr><td colspan="4" height="19"></td><td colspan="4" height="19"></td><td colspan="4" height="19">mkfs.ext2</td><td colspan="8" height="19">Mkfs.ext2/dev/sdb2</td><td colspan="10" height="19">格式化成ext2文件系统</td></tr><tr><td colspan="4" height="19"></td><td colspan="4" height="19">磁盘管理</td><td colspan="4" height="19"></td><td colspan="8" height="19">vfat</td><td colspan="8" height="19">Fat文件系统(windows)</td></tr><tr><td colspan="4" height="19"></td><td colspan="4" height="19">挂载光驱</td> <td colspan="20"  height="19">mount–tiso9660/dev/cdrom/mnt/cdrom</td></tr><tr><td colspan="4" height="19"></td><td colspan="4" height="19">挂载FAT</td> <td colspan="14 height="19">mount–tvfat/dev/hda5/mnt/cdrom</td><td colspan="8" height="19">挂第一个ide的第五个逻辑分区</td></tr><tr><td colspan="4" height="19">17</td><td colspan="4" height="19">磁盘管理</td> <td colspan="8" height="19">Umount/mnt/cdrom</td><td colspan="12" height="19">卸载/mnt/cdrom为空</td></tr><tr><td colspan="4" height="19">18</td><td colspan="4" height="19">文件权限</td> <td colspan="5" height="19">chmod</td><td colspan="7" height="19">chmodu+sfile</td><td colspan="8" height="19">为file的属主加上特殊权限</td></tr><tr><td colspan="4" height="19"></td><td colspan="4" height="19"></td><td colspan="12" height="19">chmodg+rfile</td><td colspan="12" height="19">为file的属组加上读权限</td></tr><tr><td colspan="4" height="19"></td><td colspan="4" height="19"></td><td colspan="12" height="19">chmodo+wfile</td><td colspan="12" height="19">为file的其它用户加上写权限</td></tr><tr><td colspan="4" height="19"></td><td colspan="4" height="19"></td><td colspan="12" height="19">chmoda-xfile</td><td colspan="12" height="19">为file的所有用户减去执行权限</td></tr><tr><td colspan="4" height="19"></td><td colspan="4" height="19"></td><td colspan="12" height="19">chmod 765 file</td><td colspan="10">为file的属主设为完全权限，属组设成读写权，其它用户具有读和执心权限</td></tr><tr><td colspan="4" height="19">19</td><td colspan="4" height="19">文件权限</td><td colspan="6" height="19">chown</td><td colspan="7" height="19">chownroot/home</td><td colspan="7" height="19">把/home的属主改成root用户</td></tr><tr><td colspan="4" height="19">20</td><td colspan="4" height="19">文件权限</td><td colspan="6" height="19">chgrp</td><td colspan="7" height="19">chgrproot/home</td><td colspan="6" height="19">把/home的属组改成root组</td></tr><tr><td colspan="4" height="19">21</td><td colspan="4" height="19">打印管理</td><td colspan="13"  height="19">redhat-config-printer-tui</td><td colspan="6" height="19">进入安装打印机界面</td></tr><tr><td colspan="4" height="19">22</td><td colspan="4" height="19">打印管理</td><td colspan="6" height="19">lp</td><td colspan="7" height="19">lp–dhptrfile</td><td colspan="6" height="19">打印file到hptr的打印机上</td></tr><tr><td colspan="4" height="19">23</td><td colspan="4" height="19">打印管理</td><td colspan="6" height="19">lpq</td><td colspan="7" height="19">Lpq–P打印机名</td><td colspan="6" height="19">查看打印机的状态</td></tr><tr><td colspan="4" height="19">24</td><td colspan="4" height="19">打印管理</td><td colspan="6" height="19">lprm</td><td colspan="7" height="19">Lprm–P打印机名a</td><td colspan="6" height="19">删除打印机内的打印作业</td></tr><tr><td colspan="4" height="19">25</td><td colspan="4" height="19">打印管理</td><td class="et8" colspan="4" height="19">disable</td><td colspan="8" height="19">Disable–r“changingpaper”HPtr</td><td colspan="9" height="19">禁用打印机并提示原因</td></tr><tr><td colspan="4" height="19">26</td><td colspan="4" height="19">打印管理</td><td colspan="6" height="19">enable</td><td colspan="5" height="19">EnableHPtr</td><td colspan="9" height="19">重新启用被禁用的</td></tr><tr><td colspan="4" height="19">27</td><td colspan="4" height="19">用户管理</td><td colspan="6" height="19">useradd</td><td colspan="5" height="19">Useradd</td><td colspan="7" height="19">创建一个新的用户</td><td colspan="2" height="19"></td></tr><tr><td colspan="4" height="19">28</td><td colspan="4" height="19">用户管理</td><td colspan="6" height="19">groupadd</td><td colspan="5" height="19">Groupadd组名</td><td colspan="7" height="19">创建一个新的组</td><td colspan="2" height="19"></td></tr><tr><td colspan="4" height="19">29</td><td colspan="4" height="19">用户管理</td><td colspan="6" height="19">passwd</td><td colspan="5" height="19">Passwd用户名</td><td colspan="7" height="19">为用户创建密码</td><td colspan="2" height="19"></td></tr><tr><td colspan="4" height="19">30</td><td colspan="4" height="19">用户管理</td><td colspan="6" height="19">Passwd-d</td><td colspan="5" height="19">Passwd-d用户名</td><td colspan="7" height="19">删除用户密码也能登陆</td><td colspan="2" height="19"></td></tr><tr><td colspan="4" height="19">31</td><td colspan="4" height="19">用户管理</td><td colspan="6" height="19">Passwd-l</td><td colspan="5" height="19">Passwd-l用户名</td><td colspan="7" height="19">锁定账号密码</td><td colspan="2" height="19"></td></tr><tr><td colspan="4" height="19">32</td><td colspan="4" height="19">用户管理</td><td colspan="6" height="19">Passwd-u</td><td colspan="5" height="19">Passwd-u用户名</td><td colspan="7" height="19">解锁账号密码</td><td colspan="2" height="19"></td></tr><tr><td colspan="4" height="19">33</td><td colspan="4" height="19">用户管理</td><td colspan="6" height="19">Passwd-S</td><td colspan="5" height="19">Passwd-S用户名</td><td colspan="7" height="19">查询账号密码</td><td colspan="2" height="19"></td></tr><tr><td colspan="4" height="19">34</td><td colspan="4" height="19">用户管理</td><td colspan="6" height="19">Usermod-l</td><td colspan="10" height="19">Usermod-l新用户名老用户名</td><td colspan="2" height="19">为用户改名</td><td colspan="2" height="19"></td></tr><tr><td colspan="4" height="19">35</td><td colspan="4" height="19">用户管理</td><td colspan="6" height="19">Usermod-L</td><td colspan="10" height="19">Usermod-L要锁定用户名</td><td colspan="2" height="19">锁定用户登陆</td><td colspan="2" height="19"></td></tr><tr><td colspan="4" height="19">36</td><td colspan="4" height="19">用户管理</td><td colspan="6" height="19">Usermod-U</td><td colspan="10" height="19">Usermod–U解锁用户名</td><td colspan="2" height="19">解锁用户登陆</td><td colspan="2" height="19"></td></tr><tr><td colspan="4" height="19">37</td><td colspan="4" height="19">用户管理</td><td colspan="6" height="19">Usermod-u</td><td colspan="10" height="19">Usermod–u501用户名</td><td colspan="2" height="19">改变用户UID</td><td colspan="2" height="19"></td></tr><tr><td colspan="4" height="19">38</td><td colspan="4" height="19">用户管理</td><td colspan="6" height="19">Userdel</td><td colspan="10" height="19">Userdel–r用户名</td><td colspan="2" height="19">删除用户一切</td><td colspan="2" height="19"></td></tr><tr><td colspan="4" height="19">39</td><td colspan="4" height="19">用户管理</td><td colspan="6" height="19">Groupmod-n</td><td colspan="10" height="19">Groupmod–n新用户名老用户名</td><td colspan="2" height="19">为组改名</td><td colspan="2" height="19"></td></tr><tr><td colspan="4" height="19">40</td><td colspan="4" height="19">用户管理</td><td colspan="6" height="19">Groupmod-g</td><td colspan="10" height="19">Groupmod–g501组名</td><td colspan="2" height="19">改变组GID</td><td colspan="2" height="19"></td></tr><tr><td colspan="4" height="19">41</td><td colspan="4" height="19">用户管理</td><td colspan="6" height="19">groupdel</td><td colspan="10" height="19">Groupdel组名先应删它的用户</td><td colspan="2" height="19">删除组</td><td colspan="2" height="19"></td></tr><tr><td colspan="4" height="19">42</td><td colspan="4" height="19">用户管理</td><td colspan="6" height="19">gpasswd-a</td><td colspan="10" height="19">gpasswd-a用户名组名</td><td colspan="2" height="19">增加用户到组</td><td colspan="2" height="19"></td></tr><tr><td colspan="4" height="19">43</td><td colspan="4" height="19">用户管理</td><td colspan="6" height="19">Id</td><td colspan="10" height="19">id用户名</td><td colspan="2" height="19">查用户信息</td><td colspan="2" height="19"></td></tr><tr><td colspan="4" height="19">44</td><td colspan="4" height="19">软件管理</td><td colspan="6" height="19">rpm-qa</td><td colspan="10" height="19">rpm–qa|less</td><td colspan="2" height="19">查询已安装RPM</td><td colspan="2" height="19"></td></tr><tr><td colspan="4" height="19">45</td><td colspan="4" height="19">软件管理</td><td colspan="6" height="19"></td><td colspan="10" height="19">rpm–qa|grepftp</td><td colspan="2" height="19">查询指定RPM</td><td colspan="2" height="19"></td></tr><tr><td colspan="4" height="19">46</td><td colspan="4" height="19">软件管理</td><td colspan="6" height="19">rpm-q</td><td colspan="10" height="19">rpm-q已安装的RPM包</td><td colspan="2" height="19">查是否安装</td><td colspan="2" height="19"></td></tr><tr><td colspan="4" height="19">47</td><td colspan="4" height="19">软件管理</td><td colspan="6" height="19"></td><td colspan="10" height="19">rpm-qtelnet-server</td><td colspan="4" height="19">查看telnet服务器包</td></tr><tr><td colspan="4" height="19">48</td><td colspan="4" height="19">软件管理</td><td colspan="6" height="19">rpm-qi</td><td colspan="10" height="19">rpm–qi软件包名称</td><td colspan="4" height="19">查看软件的描述信息</td></tr><tr><td colspan="4" height="19">49</td><td colspan="4" height="19">软件管理</td><td colspan="6" height="19">rpm-ql</td><td colspan="10" height="19">rpm–ql软件包名称</td><td colspan="4" height="19">查询软件包的文件列表</td></tr><tr><td colspan="4" height="19">50</td><td colspan="4" height="19">软件管理</td><td colspan="6" height="19">rpm-qf</td><td colspan="10" height="19">rpm–qf软件包名称</td><td colspan="4" height="19">查询某个文件所属的软件包</td></tr><tr><td colspan="4" height="19">51</td><td colspan="4" height="19">软件管理</td><td colspan="6" height="19">rpm-qp</td><td colspan="10" height="19">rpm–qp软件包全名</td><td colspan="4" height="19">查询未安装的软件包信息</td></tr><tr><td colspan="4" height="19">52</td><td colspan="4" height="19">软件管理</td><td colspan="6" height="19">rpm-e</td><td colspan="10" height="19">rpm–e软件包名称</td><td colspan="4" height="19">删除具体的软件包</td></tr><tr><td colspan="4" height="19">53</td><td colspan="4" height="19">软件管理</td><td colspan="6" height="19">rpm-U</td><td colspan="10" height="19">rpm–Uvh软件包全名</td><td colspan="4" height="19">升级软件包并显示过程</td></tr><tr><td colspan="4" height="19">54</td><td colspan="4" height="19">软件管理</td><td colspan="6" height="19">rpm-ivh</td><td colspan="10" height="19">rpm–ivh软件包全名</td><td colspan="4" height="19">安装软件包并显示过程</td></tr><tr><td colspan="4" height="19">55</td><td colspan="4" height="19">软件管理</td><td colspan="6" height="19">rpm-V</td><td colspan="10" height="19">rpm–V软件包名称</td><td colspan="4" height="19">验证软件包的大小，类型等</td></tr><tr><td colspan="4" height="19">56</td><td colspan="4" height="19">软件管理</td><td colspan="6" height="19">tar</td><td colspan="14" height="19">-c创建包–x释放包-v显示命令过程–z代表压缩包</td></tr><tr><td colspan="4" height="19">57</td><td colspan="4" height="19">软件管理</td><td colspan="6" height="19">tar-cf</td><td colspan="10" height="19">tar–cvfbenet.tar/home/benet</td><td colspan="4" height="19">把/home/benet目录打包</td></tr><tr><td colspan="4" height="19">58</td><td colspan="4" height="19">软件管理</td><td colspan="6" height="19">tar-czf</td><td colspan="10" height="19">tar–zcvfbenet.tar.gz/mnt</td><td colspan="4" height="19">把目录打包并压缩</td></tr><tr><td colspan="4" height="19">59</td><td colspan="4" height="19">软件管理</td><td colspan="6" height="19">tar–tf</td><td colspan="10" height="19">tar–tfbenet.tar</td><td colspan="4" height="19">看非压缩包的文件列表</td></tr><tr><td colspan="4" height="19">60</td><td colspan="4" height="19">软件管理</td><td colspan="6" height="19">tar–tzf</td><td colspan="10" height="19">tar–tfbenet.tar.gz</td><td colspan="4" height="19">看压缩包的文件列表</td></tr><tr><td colspan="4" height="19">61</td><td colspan="4" height="19">软件管理</td><td colspan="6" height="19">tar–xf</td><td colspan="10" height="19">tar–xfbenet.tar</td><td colspan="4" height="19">非压缩包的文件恢复</td></tr><tr><td colspan="4" height="19">62</td><td colspan="4" height="19">软件管理</td><td colspan="6" height="19">tar–zxvf</td><td colspan="10" height="19">tar–zxvfbenet.tar.gz</td><td colspan="4" height="19">压缩包的文件解压恢复</td></tr><tr><td colspan="4" height="19">63</td><td colspan="4" height="19">软件管理</td><td colspan="6" height="19">tar-jxvf</td><td colspan="10" height="19">tar–jxvfbenet.tar.bz2</td><td colspan="4" height="19"></td></tr><tr><td colspan="4" height="19">64</td><td colspan="4" height="19">软件管理</td><td colspan="6" height="19">diff</td><td colspan="10" height="19">difffile1file2补丁名.patch</td><td colspan="4" height="19">为新旧文件生成补丁文件</td></tr><tr><td colspan="4" height="19">65</td><td colspan="4" height="19">软件管理</td><td colspan="6" height="19">diff</td><td colspan="10" height="19">difffile1file2</td><td colspan="4" height="19">比较两个文件的区别</td></tr><tr><td colspan="4" height="19">66</td><td colspan="4" height="19">软件管理</td><td colspan="6" height="19">Patch</td><td colspan="10" height="19">Patchfile补丁名.patch</td><td colspan="4" height="19">打补丁</td></tr><tr><td colspan="4" height="19">67</td><td colspan="4" height="19">软件管理</td><td colspan="16" height="19">./configure--prefix=/usr/l数据库专家认证l/</td><td colspan="4" height="19">编译前配置</td></tr><tr><td colspan="4" height="19">68</td><td colspan="4" height="19">软件管理</td><td colspan="16" height="19">make</td><td colspan="4" height="19">编译</td></tr><tr><td colspan="4" height="19">69</td><td colspan="4" height="19">软件管理</td><td colspan="16" height="19">makeinstall</td><td colspan="4" height="19">安装编译好的源码包</td></tr><tr><td colspan="4" height="19">70</td><td colspan="4" height="19">启动管理</td><td colspan="8" height="19">reboot</td><td colspan="8" height="19">Init6</td><td colspan="4" height="19">重启LINUX系统</td></tr><tr><td colspan="4" height="19">71</td><td colspan="4" height="19">启动管理</td><td colspan="3" height="19">Halt</td><td colspan="6" height="19">Init0</td><td colspan="7" height="19">Shutdown–hnow</td><td colspan="4" height="19">关闭LINUX系统</td></tr><tr><td colspan="4" height="19">72</td><td colspan="4" height="19">启动管理</td><td colspan="8" height="19">runlevel</td><td colspan="8" height="19"></td><td colspan="4" height="19">显示系统运行级</td></tr><tr><td colspan="4" height="19">73</td><td colspan="4" height="19">启动管理</td><td colspan="8" height="19">Init[0123456]</td><td colspan="8" height="19"></td><td colspan="4" height="19">改变系统运行级,7种</td></tr><tr><td colspan="4" height="19">74</td><td colspan="4" height="19">启动管理</td><td colspan="16" height="19">Chkconfig–-list[服务名称]</td><td colspan="4" height="19">查看服务的状态</td></tr><tr><td colspan="4" height="19">75</td><td colspan="4" height="19">启动管理</td><td colspan="17"  height="19">Chkconfig–-level 运行级 服务名on|off|set</td><td colspan="3"  height="19">设置服务的启动状态</td></tr><tr><td colspan="4" height="19">76</td><td colspan="4" height="19">启动管理</td><td colspan="17" height="19">Chkconfig 服务名on|off|set</td><td colspan="3" height="19">设置非独立服务启状态</td></tr><tr><td colspan="4" height="19">77</td><td colspan="4" height="19">进程管理</td><td colspan="4" height="19">Top动态</td><td colspan="6" height="19">Ps-aux静态</td><td colspan="7" height="19">进程树pstree</td><td colspan="3" height="19">查看系统进程</td></tr><tr><td colspan="4" height="19">78</td><td colspan="4" height="19">进程管理</td><td colspan="7" height="19">程序名</td><td colspan="10" height="19">后台运行程序</td><td colspan="3"  height="19"></td></tr><tr><td colspan="4" height="19">79</td><td colspan="4" height="19">进程管理</td><td colspan="7" height="19">fg</td><td colspan="10" height="19">把后台运行的进程调回前台</td><td colspan="3"  height="19"></td></tr><tr><td colspan="4" height="19">80</td><td colspan="4" height="19">进程管理</td><td colspan="7" height="19">bg</td><td colspan="10" height="19">把前台运行进程调到后台</td><td colspan="3"  height="19"></td></tr><tr><td colspan="4" height="19">81</td><td colspan="4" height="19">进程管理</td><td colspan="7" height="19">renice</td><td colspan="7" height="19">Renice+1180</td><td colspan="6" height="19">把180号进程的优先级加1</td></tr><tr><td colspan="4" height="19">82</td><td colspan="4" height="19">进程管理</td><td colspan="7" height="19">kill</td><td colspan="7" height="19">KillPID</td><td colspan="6" height="19">终止某个PID进程</td></tr><tr><td rowspan="2" colspan="4" height="38">83</td><td rowspan="2" colspan="4" height="38">进程管理</td><td class="et8" rowspan="2" colspan="4" height="38">#</td><td rowspan="2" colspan="7" height="38">at</td><td colspan="7" height="19">at5pm+3days</td><td rowspan="2" colspan="6" height="38">指定三天后下午5:00执行/bin/ls</td></tr><tr><td class="et16" colspan="7" height="19">/bin/ls</td></tr><tr><td colspan="4" height="19">84</td><td colspan="4" height="19">进程管理</td><td colspan="7" height="19">crontab</td><td colspan="7" height="19">Crontab-e</td><td colspan="6" height="19">用VI的形式来编辑自动周期性任务</td></tr><tr><td colspan="4" height="19">85</td><td colspan="4" height="19">进程管理</td><td colspan="7" height="19">crontab</td><td colspan="7" height="19">Crontab-l</td><td colspan="6" height="19">查看自动周期性任务</td></tr><tr><td colspan="4" height="19">86</td><td colspan="4" height="19">进程管理</td><td colspan="7" height="19">crontab</td><td colspan="7" height="19">Crontab-r</td><td colspan="6" height="19">删除自动周期性任务</td></tr><tr><td colspan="4" height="19">87</td><td colspan="4" height="19">进程管理</td><td colspan="7" height="19">crond</td><td colspan="13"  height="19">Servicecrond start|stop|restart|status</td></tr><tr><td colspan="4" height="19"></td><td colspan="12" height="19">马上启动自动周期性服务</td><td colspan="13"  height="19">Servicecrond 启动|停止|重启|状态</td></tr><tr><td colspan="4" height="19"></td><td colspan="12" height="19"></td><td colspan="13"  height="19"></td></tr><tr><td rowspan="20" colspan="4" height="380"></td><td rowspan="20" colspan="4" height="380">实现磁盘配额</td><td colspan="22" height="19">(注安装LINUX时建立/home分区）</td></tr><tr><td  colspan="22"  height="19">目标：对用户zhao在/home目录上实现softlimit为5k,hardlimit为10k的磁盘配额</td></tr><tr><td  colspan="22"  height="19">实现步骤：</td></tr><tr><td  colspan="22"  height="19">1.修改包含/home的行，#vi/etc/fstab，改为：defaults,usrquota。也就是增加usrquota项。然后保存退出。</td></tr><tr><td  colspan="22"  height="19">2、卸载/home目录#umount/home</td></tr><tr><td  colspan="22"  height="19">3.挂接/home目录#mount/home</td></tr><tr><td  colspan="22"  height="19">4、增加用户zhao#useraddzhao</td></tr><tr><td  colspan="22"  height="19">5、修改密码#passwdzhao</td></tr><tr><td  colspan="22"  height="19">6、生成关于/home目录的quota信息#quotacheck-cmug/home</td></tr><tr><td  colspan="22"  height="19">#quotacheck-vu/home</td></tr><tr><td  colspan="22"  height="19">7、查看所有用户的信息#repquota-au</td></tr><tr><td  colspan="22"  height="19">8、设置配额#edquota-uzhao</td></tr><tr><td  colspan="22"  height="19">将soft和hard分别改为5和10</td></tr><tr><td  colspan="22"  height="19">9、保存并退出#wq!</td></tr><tr><td  colspan="22"  height="19">10、修改时间#edquota-t</td></tr><tr><td  colspan="22"  height="19">11、#wq!</td></tr><tr><td  colspan="22"  height="19">12.开启/home上的磁盘配额功能#quotaon/home</td></tr><tr><td  colspan="22"  height="19">13.查询配额#quota-uzhao</td></tr><tr><td  colspan="22"  height="19">14.验证配额#su-zhao</td></tr><tr><td colspan="22"  height="19">$touchmyfile</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS篇-计算机操作系统</title>
    <link href="/2018/01/18/os/OS%E7%AF%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2018/01/18/os/OS%E7%AF%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="第一章-操作系统引论"><a href="#第一章-操作系统引论" class="headerlink" title="第一章    操作系统引论"></a>第一章    操作系统引论</h1><h2 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h2><ol><li> OS作为用户与计算机硬件系统之间的接口</li></ol><blockquote><p>OS作为用户与计算机硬件系统之间接口的含义是：OS处于用户与计算机硬件系统之间，用户通过OS来使用计算机系统。或者说，用户在OS帮助下能够方便、快捷、可靠地操纵计算机硬件和运行自己的程序。 </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-1.png" alt="OS作为接口的示意图"></p><ol start="2"><li> OS作为计算机系统资源的管理者</li></ol><blockquote><p>在一个计算机系统中，通常都含有多种硬件和软件资源。归纳起来可将这些资源分为四类：处理机、存储器、I/O设备以及文件(数据和程序)。相应地，OS的主要功能也正是对这四类资源进行有效的管理。处理机管理是用于分配和控制处理机；存储器管理主要负责内存的分配与回收；I/O设备管理是负责I/O设备的分配(回收)与操纵；文件管理是用于实现对文件的存取、共享和保护。可见，OS的确是计算机系统资源的管理者。</p></blockquote><ol start="3"><li> OS实现了对计算机资源的抽象</li></ol><blockquote><p>对于一台完全无软件的计算机系统(即裸机)，由于它向用户提供的仅是硬件接口(物理接口)，因此，用户必须对物理接口的实现细节有充分的了解，这就致使该物理机器难于广泛使用。为了方便用户使用I/O设备，人们在裸机上覆盖上一层I/O设备管理软件，如下图所示，由它来实现对I/O设备操作的细节，并向上将I/O设备抽象为一组数据结构以及一组I/O操作命令，如read和write命令，这样用户即可利用这些数据结构及操作命令来进行数据输入或输出，而无需关心I/O是如何具体实现的。 </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-1.png" alt="I/O设备管理软件"></p><h2 id="未配置操作系统的计算机系统"><a href="#未配置操作系统的计算机系统" class="headerlink" title="未配置操作系统的计算机系统"></a>未配置操作系统的计算机系统</h2><ol><li><p>人工操作方式:　　早期的操作方式是由程序员将事先已穿孔的纸带(或卡片)，装入纸带输入机(或卡片输入机)，再启动它们将纸带(或卡片)上的程序和数据输入计算机，然后启动计算机运行。仅当程序运行完毕并取走计算结果后，才允许下一个用户上机。这种人工操作方式有以下两方面的缺点：<br>　　(1)  用户独占全机，即一台计算机的全部资源由上机用户所独占。<br>　　(2)  CPU等待人工操作。当用户进行装带(卡)、卸带(卡)等人工操作时，CPU及内存等资源是空闲的。</p></li><li><p>脱机输入/输出(Off-Line I/O)方式:<br>　　为了解决人机矛盾及CPU和I/O设备之间速度不匹配的矛盾，20世纪50年代末出现了脱机I/O技术。该技术是事先将装有用户程序和数据的纸带装入纸带输入机，在一台外围机的控制下，把纸带(卡片)上的数据(程序)输入到磁带上。当CPU需要这些程序和数据时，再从磁带上高速地调入内存。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-3.png" alt="脱机I/O示意图"></p><h2 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h2><ol><li>单道批处理系统(Simple Batch Processing System)的处理过程为实现对作业的连续处理，需要先把一批作业以脱机方式输入到磁带上，并在系统中配上监督程序(Monitor)，在它的控制下，使这批作业能一个接一个地连续处理。 </li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-4.png" alt="单道批处理系统的处理流程"></p><p>单道批处理系统的缺点</p><blockquote><p>系统中的资源得不到充分的利用。这是因为在内存中仅有一道程序，每逢该程序在运行中发出I/O请求后，CPU便处于等待状态，必须在其I/O完成后才继续运行。又因I/O设备的低速性，更使CPU的利用率显著降低。图1-5示出了单道程序的运行情况，从图可以看出：在t2～t3、t6～t7时间间隔内CPU空闲。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-5.png" alt="单道程序的运行情况"></p><h2 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h2><p>多道程序设计的基本概念:为了进一步提高资源的利用率和系统吞吐量，在20世纪60年代中期引入了多道程序设计技术，由此形成了多道批处理系统。图1-6示出了四道程序时的运行情况。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-6.png" alt="多道程序的运行情况"></p><p class="note note-primary">多道批处理系统的优缺点如下</p>(1) 资源利用率高。引入多道批处理能使多道程序交替运行，以保持CPU处于忙碌状态；在内存中装入多道程序可提高内存的利用率；此外还可以提高I/O设备的利用率。(2) 系统吞吐量大。能提高系统吞吐量的主要原因可归结为：    ① CPU和其它资源保持“忙碌”状态；    ② 仅当作业完成时或运行不下去时才进行切换，系统开销小。　　(3) 平均周转时间长。由于作业要排队依次进行处理，因而作业的周转时间较长，通常需几个小时，甚至几天。(4) 无交互能力。用户一旦把作业提交给系统后，直至作业完成，用户都不能与自己的作业进行交互，修改和调试程序极不方便。<h3 id="多道批处理系统需要解决的问题"><a href="#多道批处理系统需要解决的问题" class="headerlink" title="多道批处理系统需要解决的问题"></a>多道批处理系统需要解决的问题</h3><p>多道批处理系统是一种十分有效，但又非常复杂的系统，为使系统中的多道程序间能协调地运行，系统必须解决下述一系列问题：</p><p>(1) 处理机争用问题。既要能满足各道程序运行的需要，又要能提高处理机的利用率。<br>(2) 内存分配和保护问题。系统应能为每道程序分配必要的内存空间，使它们“各得其所”，且不会因某道程序出现异常情况而破坏其它程序。<br>(3)  I/O设备分配问题。系统应采取适当的策略来分配系统中的I/O设备，以达到既能方便用户对设备的使用，又能提高设备利用率的目的。<br>(4) 文件的组织和管理问题。系统应能有效地组织存放在系统中的大量的程序和数据，使它们既便于用户使用，又能保证数据的安全性。<br>(5) 作业管理问题。系统中存在着各种作业(应用程序)，系统应能对系统中所有的作业进行合理的组织，以满足这些作业用户的不同要求。　<br>(6) 用户与系统的接口问题。为使用户能方便的使用操作系统，OS还应提供用户与OS之间的接口。</p><h3 id="分时系统-Time-Sharing-System"><a href="#分时系统-Time-Sharing-System" class="headerlink" title="分时系统(Time Sharing System)"></a>分时系统(Time Sharing System)</h3><p>分时系统的引入如果说推动多道批处理系统形成和发展的主要动力是提高资源利用率和系统吞吐量，那么，推动分时系统形成和发展的主要动力，则是为了满足用户对人—机交互的需求，由此形成了一种新型OS。用户的需求具体表现在以下几个方面:</p><p>(1) 人—机交互。<br>(2) 共享主机。 </p><h3 id="分时系统实现中的关键问题"><a href="#分时系统实现中的关键问题" class="headerlink" title="分时系统实现中的关键问题"></a>分时系统实现中的关键问题</h3><blockquote><p>在多道批处理系统中，用户无法与自己的作业进行交互的主要原因是：作业都先驻留在外存上，即使以后被调入内存，也要经过较长时间的等待后方能运行，用户无法与自己的作业进行交互。<br>　　1) 及时接收<br>　　2) 及时处理</p></blockquote><p>分时系统的特征</p><p>(1) 多路性。<br>(2) 独立性。　　<br>(3) 及时性。　　<br>(4) 交互性。 </p><h3 id="实时任务的类型"><a href="#实时任务的类型" class="headerlink" title="实时任务的类型"></a>实时任务的类型</h3><p>(1) 周期性实时任务和非周期性实时任务。<br>(2) 硬实时任务和软实时任务。  </p><h3 id="实时系统与分时系统特征的比较"><a href="#实时系统与分时系统特征的比较" class="headerlink" title="实时系统与分时系统特征的比较"></a>实时系统与分时系统特征的比较</h3><p>(1) 多路性。<br>(2) 独立性。<br>(3) 及时性。<br>(4) 交互性。<br>(5) 可靠性。 </p><h2 id="操作系统的基本特性"><a href="#操作系统的基本特性" class="headerlink" title="操作系统的基本特性"></a>操作系统的基本特性</h2><p>多道批处理系统、分时系统和实时系统这三种基本操作系统都具有各自不同的特征，如批处理系统有着高的资源利用率和系统吞吐量；分时系统能获得及时响应；实时系统具有实时特征。除此之外，它们还共同具有并发、共享、虚拟和异步四个基本特征。</p><h3 id="并发-Concurrence"><a href="#并发-Concurrence" class="headerlink" title="并发(Concurrence)"></a>并发(Concurrence)</h3><blockquote><p>正是系统中的程序能并发执行这一特征，才使得OS能有效地提高系统中的资源利用率，增加系统的吞吐量。　</p></blockquote><ol><li>并行与并发</li></ol><blockquote><p>并行性和并发性是既相似又有区别的两个概念。并行性是指两个或多个事件在同一时刻发生。而并发性是指两个或多个事件在同一时间间隔内发生。 </p></blockquote><h3 id="共享-Sharing"><a href="#共享-Sharing" class="headerlink" title="共享(Sharing)"></a>共享(Sharing)</h3><blockquote><p>一般情况下的共享与操作系统环境下的共享其含义并不完全相同。 </p></blockquote><ol><li>互斥共享方式  </li></ol><blockquote><p>系统中的某些资源，如打印机、磁带机等，虽然可以提供给多个进程(线程)使用，但应规定在一段时间内，只允许一个进程访问该资源。为此，在系统中应建立一种机制，以保证多个进程对这类资源的互斥访问。</p></blockquote><ol start="2"><li>同时访问方式</li></ol><blockquote><p>系统中还有另一类资源，允许在一段时间内由多个进程“同时”对它们进行访问。这里所谓的“同时”，在单处理机环境下是宏观意义上的，而在微观上，这些进程对该资源的访问是交替进行的。典型的可供多个进程“同时”访问的资源是磁盘设备。一些用重入码编写的文件也可以被“同时”共享，即允许若干个用户同时访问该文件。</p></blockquote><h3 id="虚拟-Virtual"><a href="#虚拟-Virtual" class="headerlink" title="虚拟(Virtual)"></a>虚拟(Virtual)</h3><ol><li>时分复用技术<br>　　(1) 虚拟处理机技术。<br>　　(2) 虚拟设备技术。 </li><li>空分复用技术</li></ol><blockquote><p>　20世纪初，电信业中就已使用频分复用技术来提高信道的利用率。它是指将一个频率范围比较宽的信道划分成多个频率范围较窄的信道(称为频带)，其中的任何一个频带都仅供一对用户通话。早期的频分复用技术只能将一条物理信道划分为几条到几十条话路，后来又很快发展到成千上万条话路，每条话路供一对用户通话。再后来在计算机中也把空分复用技术用于对存储空间的管理，用以提高存储空间的利用率。 </p></blockquote><h3 id="异步-Asynchronism"><a href="#异步-Asynchronism" class="headerlink" title="异步(Asynchronism)"></a>异步(Asynchronism)</h3><blockquote><p>在多道程序环境下，系统允许多个进程并发执行。在单处理机环境下，由于系统中只有一台处理机，因而每次只允许一个进程执行，其余进程只能等待。当正在执行的进程提出某种资源要求时，如打印请求，而此时打印机正在为其它进程打印，由于打印机属于临界资源，因此正在执行的进程必须等待，并释放出处理机，直到打印机空闲，并再次获得处理机时，该进程方能继续执行。可见，由于资源等因素的限制，使进程的执行通常都不可能“一气呵成”，而是以“停停走走”的方式运行。</p></blockquote><h2 id="操作系统的主要功能"><a href="#操作系统的主要功能" class="headerlink" title="操作系统的主要功能"></a>操作系统的主要功能</h2><blockquote><p>引入OS的主要目的是，为多道程序的运行提供良好的运行环境，以保证多道程序能有条不紊地、高效地运行，并能最大程度地提高系统中各种资源的利用率，方便用户的使用。为此，在传统的OS中应具有处理机管理、存储器管理、设备管理和文件管理等基本功能。此外，为了方便用户使用OS，还需向用户提供方便的用户接口。</p></blockquote><ul><li>处理机管理功能 </li></ul><p>　　1. 进程控制<br>　　2. 进程同步<br>　　3. 进程通信<br>　　4. 调度<br>　　(1) 作业调度。<br>　　(2) 进程调度。</p><ul><li>存储器管理功能 </li></ul><ol><li>内存分配<br>　　内存分配的主要任务是：<br>　　(1) 为每道程序分配内存空间，使它们“各得其所”。<br>　　(2) 提高存储器的利用率，尽量减少不可用的内存空间(碎片)。<br>　　(3) 允许正在运行的程序申请附加的内存空间，以适应程序和数据动态增长的需要。</li></ol><p>OS在实现内存分配时，可采取静态和动态两种方式：<br>　　(1) <code>静态分配方式</code>。每个作业的内存空间是在作业装入时确定的，在作业装入后的整个运行期间不允许该作业再申请新的内存空间，也不允许作业在内存中“移动”。<br>　　(2) <code>动态分配方式</code>。每个作业所要求的基本内存空间虽然也是在装入时确定的，但允许作业在运行过程中继续申请新的附加内存空间，以适应程序和数据的动态增长，也允许作业在内存中“移动”。</p><ol start="2"><li><p>内存保护<br>　　内存保护的主要任务是：</p><pre><code> ① 确保每道用户程序都仅在自己的内存空间内运行，彼此互不干扰。 ② 绝不允许用户程序访问操作系统的程序和数据，也不允许用户程序转移到非共享的其它用户程序中去执行。</code></pre></li><li><p>地址映射</p></li></ol><blockquote><p>在多道程序环境下，由于每道程序经编译和链接后所形成的可装入程序其地址都是从0开始的，但不可能将它们从“0”地址(物理)开始装入内存，致使(各程序段的)地址空间内的逻辑地址与其在内存空间中的物理地址并不相一致。为保证程序能正确运行，存储器管理必须提供地址映射功能，即能够将地址空间中的逻辑地址转换为内存空间中与之对应的物理地址。该功能应在硬件的支持下完成。</p></blockquote><ol start="4"><li>内存扩充</li></ol><blockquote><p>内存扩充并非是从物理上去扩大内存的容量，而是借助于虚拟存储技术，从逻辑上扩充内存容量，使用户所感觉到的内存容量比实际内存容量大得多，以便让更多的用户程序能并发运行。这样既满足了用户的需要，又改善了系统的性能。为了能在逻辑上扩充内存，系统必须设置内存扩充机制(包含少量的硬件)，用于实现下述各功能：　　(1) 请求调入功能。　　(2) 置换功能。</p></blockquote><h3 id="设备管理功能"><a href="#设备管理功能" class="headerlink" title="设备管理功能"></a>设备管理功能</h3><p>设备管理的主要任务如下：<br>　　(1) 完成用户进程提出的I/O请求，为用户进程分配所需的I/O设备，并完成指定的I/O操作。<br>　　(2) 提高CPU和I/O设备的利用率，提高I/O速度，方便用户使用I/O设备。<br>为实现上述任务，设备管理应具有缓冲管理、设备分配和设备处理以及虚拟设备等功能。　<br>    1. 缓冲管理　　<br>    2. 设备分配　　<br>    3. 设备处理</p><p>文件管理功能<br>　　1. 文件存储空间的管理<br>　　2. 目录管理<br>　　3. 文件的读/写管理和保护<br>　　(1) 文件的读/写管理。<br>　　(2) 文件保护。</p><p>操作系统与用户之间的接口<br>　1. 用户接口<br>　　(1) 联机用户接口。<br>　　(2) 脱机用户接口。<br>　　(3) 图形用户接口。<br>  2. 程序接口</p><blockquote><p>程序接口是为用户程序在执行中访问系统资源而设置的，是用户程序取得操作系统服务的唯一途径。它是由一组系统调用组成的，每一个系统调用都是一个能完成特定功能的子程序。每当应用程序要求OS提供某种服务(功能)时，便调用具有相应功能的系统调用(子程序)。早期的系统调用都是用汇编语言提供的，只有在用汇编语言书写的程序中才能直接使用系统调用。 </p></blockquote><h2 id="OS结构设计"><a href="#OS结构设计" class="headerlink" title="OS结构设计"></a>OS结构设计</h2><h3 id="传统操作系统结构"><a href="#传统操作系统结构" class="headerlink" title="传统操作系统结构"></a>传统操作系统结构</h3><ol><li>无结构操作系统</li></ol><blockquote><p>在早期开发操作系统时，设计者只是把他的注意力放在功能的实现和获得高的效率上，缺乏首尾一致的设计思想。此时的OS是为数众多的一组过程的集合，每个过程可以任意地相互调用其它过程，致使操作系统内部既复杂又混乱，因此，这种OS是无结构的，也有人把它称为整体系统结构。</p></blockquote><ol start="2"><li>模块化结构OS</li></ol><p>　　1) 模块化程序设计技术的基本概念</p><blockquote><p>　　模块化程序设计技术是20世纪60年代出现的一种结构化程序设计技术。该技术基于“分解”和“模块化”的原则来控制大型软件的复杂度。为使OS具有较清晰的结构，OS不再是由众多的过程直接构成的，而是按其功能精心地划分为若干个具有一定独立性和大小的模块。图1-7示出了由模块、子模块等组成的模块化OS结构。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-7.png" alt="模块化结构的操作系统"></p><ol start="2"><li>模块独立性</li></ol><blockquote><p>　　在模块-接口法中，关键问题是模块的划分和规定好模块之间的接口。如果我们在划分模块时将模块划分得太小，虽然可以降低模块本身的复杂性，但会引起模块之间的联系过多，从而会造成系统比较混乱；如果将模块划分得过大，又会增加模块内部的复杂性，使内部的联系增加，因此在划分模块时，应在两者间进行权衡。</p></blockquote><ol start="3"><li>模块接口法的优缺点</li></ol><p>　　  利用模块-接口法开发的OS，较之无结构OS具有以下明显的优点：<br>　　  (1) 提高OS设计的正确性、可理解性和可维护性。<br>　　  (2) 增强OS的可适应性。<br>　　  (3) 加速OS的开发过程。</p><p> 模块化结构设计仍存在下述问题：</p><p> (1) 在OS设计时，对各模块间的接口规定很难满足在模块设计完成后对接口的实际需求。　　<br> (2) 在OS设计阶段，设计者必须做出一系列的决定(决策)，每一个决定必须建立在上一个决定的基础上，但模块化结构设计中，各模块的设计齐头并进，无法寻找一个可靠的决定顺序，造成各种决定的“无序性”，这将使程序人员很难做到“设计中的每一步决定”都是建立在可靠的基础上，因此模块-接口法又被称为“无序模块法”。 </p><ol start="3"><li>分层式结构OS</li></ol><p>　　1) 分层式结构的基本概念</p><blockquote><p>　　为了将模块-接口法中“决定顺序”的无序性变为有序性，引入了有序分层法，分层法的设计任务是，在目标系统An和裸机系统(又称宿主系统)A0之间，铺设若干个层次的软件A1、A2、A3、…、An-1，使An通过An-1、An-2、…、A2、A1层，最终能在A0上运行。在操作系统中，常采用自底向上法来铺设这些中间层。</p></blockquote><p>　　2) 分层结构的优缺点</p><p>　　分层结构的主要优点：　　(1) 易保证系统的正确性。　　(2) 易扩充和易维护性。</p><p>　　分层结构的主要缺点: 系统效率降低。由于层次结构是分层单向依赖的，必须在每层之间都建立层次间的通信机制，OS每执行一个功能，通常要自上而下地穿越多个层次，这无疑会增加系统的通信开销，从而导致系统效率的降低。</p><h3 id="客户-服务器模式-Client-Server-Model"><a href="#客户-服务器模式-Client-Server-Model" class="headerlink" title="客户/服务器模式(Client/Server Model)"></a>客户/服务器模式(Client/Server Model)</h3><p>  简介　　</p><ol><li>客户/服务器模式的由来、组成和类型<br>　　客户/服务器系统主要由三部分组成。<br>　　(1) 客户机：<br>　　(2) 服务器：<br>　　(3) 网络系统：</li><li>客户/服务器之间的交互<br>　　(1) 客户发送请求消息。<br>　　(2) 服务器接收消息。<br>　　(3) 服务器回送消息。<br>　　(4) 客户机接收消息。<br>　3. 客户/服务器模式的优点<br>(1) 数据的分布处理和存储。　　<br>(2) 便于集中管理。<br>(3) 灵活性和可扩充性。 　　<br>(4) 易于改编应用软件。 </li></ol><h3 id="面向对象的程序设计-Object-Orientated-Programming"><a href="#面向对象的程序设计-Object-Orientated-Programming" class="headerlink" title="面向对象的程序设计(Object-Orientated Programming)"></a>面向对象的程序设计(Object-Orientated Programming)</h3><p>技术简介</p><ol><li>面向对象技术的基本概念 </li></ol><blockquote><p>面向对象技术是20世纪80年代初提出并很快流行起来的。 </p></blockquote><ol><li>对象</li></ol><blockquote><p>在面向对象的技术中，是利用被封装的数据结构(变量)和一组对它进行操作的过程(方法)来表示系统中的某个对象的，如下图所示。对象中的变量(数据)也称为属性，它可以是单个标量或一张表。面向对象中的方法是用于执行某种功能的过程，它可以改变对象的状态，更新对象中的某些数据值或作用于对象所要访问的外部资源。如果把一个文件作为一个对象(见图1-9)，该对象的变量便是文件类型、文件大小、文件的创建者等。对象中的方法包含对文件的操作，如创建文件、打开文件、读文件、写文件、关闭文件等。</p></blockquote><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-8.png" alt="一个对象的示意图"></div><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-9.png" alt="类和对象的关系"></div></div></div><ol start="2"><li>对象类</li></ol><blockquote><p>在实践中，有许多对象可能表示的是同一类事物，每个对象具有自己的变量集合，而它们所具有的方法是相同的。如果为每一个相似的对象都定义一组变量和方法，显然是低效的，由此产生了“对象类”的概念，利用“对象类”来定义一组大体相似的对象。一个类同样定义了一组变量和针对该变量的一组方法，用它们来描述一组对象的共同属性和行为。类是在对象上的抽象，对象则是类的实例。对象类中所定义的变量在实例中均有具体的值。</p></blockquote><ol start="3"><li>继承</li></ol><blockquote><p>在面向对象的技术中，可以根据已有类来定义一个新的类，新类被称为子类(B)，原来的类被称为父类(A)，见下图所示。 </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-10.png" alt="类的继承关系"></p><ol start="2"><li>面向对象技术的优点<br>　　在操作系统设计时，将计算机中的实体作为对象来处理，可带来如下好处：<br>　　(1) 通过“重用”提高产品质量和生产率。<br>　　(2) 使系统具有更好的易修改性和易扩展性。<br>　　(3) 更易于保证系统的“正确性”和“可靠性”。</li></ol><h3 id="微内核OS结构"><a href="#微内核OS结构" class="headerlink" title="微内核OS结构"></a>微内核OS结构</h3><p>　　1. 微内核操作系统的基本概念</p><p>　　1) 足够小的内核</p><blockquote><p>　　在微内核操作系统中，内核是指精心设计的、能实现现代OS最基本核心功能的小型内核，微内核并非是一个完整的OS，而只是将操作系统中最基本的部分放入微内核，通常包含有：</p></blockquote><p>① 与硬件处理紧密相关的部分；<br>② 一些较基本的功能；<br>③ 客户和服务器之间的通信。</p><p>　　2) 基于客户/服务器模式</p><blockquote><p>　　由于客户/服务器模式具有非常多的优点，故在单机微内核操作系统中几乎无一例外地都采用客户/服务器模式，将操作系统中最基本的部分放入内核中，而把操作系统的绝大部分功能都放在微内核外面的一组服务器(进程)中实现，如用于提供对进程(线程)进行管理的进程(线程)服务器、提供虚拟存储器管理功能的虚拟存储器服务器、提供I/O设备管理的I/O设备管理服务器等，它们都是被作为进程来实现的，运行在用户态，客户与服务器之间是借助微内核提供的消息传递机制来实现信息交互的。图示出了在单机环境下的客户/服务器模式。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-11.png" alt="类的继承关系"></p><p>　　3) 应用“机制与策略分离”原理</p><blockquote><p>　　在现在操作系统的结构设计中，经常利用“机制与策略分离”的原理来构造OS结构。所谓机制，是指实现某一功能的具体执行机构。而策略，则是在机制的基础上借助于某些参数和算法来实现该功能的优化，或达到不同的功能目标。 </p></blockquote><p>　　4) 采用面向对象技术</p><blockquote><p>　　操作系统是一个极其复杂的大型软件系统，我们不仅可以通过结构设计来分解操作系统的复杂度，还可以基于面向对象技术中的“抽象”和“隐蔽”原则控制系统的复杂性，再进一步利用“对象”、“封装”和“继承”等概念来确保操作系统的“正确性”、“可靠性”、“易修改性”、“易扩展性”等，并提高操作系统的设计速度。正因为面向对象技术能带来如此多的好处，故面向对象技术被广泛应用于现代操作系统的设计中。</p></blockquote><p>　　2. 微内核的基本功能</p><blockquote><p>　　微内核应具有哪些功能，或者说哪些功能应放在微内核内，哪些应放在微内核外，目前尚无明确的规定。现在一般都采用“机制与策略分离”的原理，将机制部分以及与硬件紧密相关的部分放入微内核中。由此可知微内核通常具有如下几方面的功能：</p></blockquote><p>　　1) 进程(线程)管理<br>　　2) 低级存储器管理<br>　　3) 中断和陷入处理</p><p>　　3. 微内核操作系统的优点</p><blockquote><p>　　由于微内核OS结构是建立在模块化、层次化结构的基础上的，并采用了客户/服务器模式和面向对象的程序设计技术，因此，微内核结构的操作系统是集各种技术优点之大成，因而使之具有如下优点：</p></blockquote><p>　　(1) 提高了系统的可扩展性。<br>　　(2) 增强了系统的可靠性。<br>　　(3) 可移植性强。<br>　　(4) 提供了对分布式系统的支持。<br>　　(5) 融入了面向对象技术。 </p><p>　　4. 微内核操作系统存在的问题</p><blockquote><p>　　应当指出，在微内核操作系统中，由于采用了非常小的内核，客户/服务器模式和消息传递机制虽给微内核操作系统带来了许多优点，但由此也使微内核OS存在着潜在缺点，其中最主要的是，较之早期的操作系统，微内核操作系统的运行效率有所降低。<br>　　实际情况是往往还会引起更多的上下文切换。例如，当某个服务器自身尚无能力完成客户请求而需要其它服务器的帮助时，如图1-12所示，其中的文件服务器还需要磁盘服务器的帮助，这时就需要进行8次上下文的切换。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-12.png" alt="在传统OS和微内核OS中的上下文切换"></p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><ol><li>设计现代OS的主要目标是什么? </li><li> OS的作用可表现在哪几个方面? </li><li>为什么说操作系统实现了对计算机资源的抽象? </li><li>试说明推动多道批处理系统形成和发展的主要动力是什么。　　</li><li>何谓脱机I/O和联机I/O? </li><li>试说明推动分时系统形成和发展的主要动力是什么。　　</li><li>实现分时系统的关键问题是什么? 应如何解决? </li><li>为什么要引入实时操作系统? </li><li>什么是硬实时任务和软实时任务? 试举例说明。</li><li>试从交互性、及时性以及可靠性方面将分时系统与实时系统进行比较。</li><li> OS有哪几大特征? 其最基本的特征是什么? </li><li>在多道程序技术的OS环境下的资源共享与一般情况下的资源共享有何不同? 对独占资源应采取何种共享方式? </li><li>什么是时分复用技术? 举例说明它能提高资源利用率的根本原因是什么。</li><li>是什么原因使操作系统具有异步性特征?</li><li>处理机管理有哪些主要功能? 其主要任务是什么?　　</li><li>内存管理有哪些主要功能? 其主要任务是什么? </li><li>设备管理有哪些主要功能? 其主要任务是什么?　　</li><li>文件管理有哪些主要功能? 其主要任务是什么? </li><li>试说明推动传统OS演变为现代OS的主要因素是什么? </li><li>什么是微内核OS?</li><li>微内核操作系统具有哪些优点? 它为何能有这些优点?　</li><li>现代操作系统较之传统操作系统又增加了哪些功能和特征? 　　</li><li>在微内核OS中，为什么要采用客户/服务器模式?　　</li><li>在基于微内核结构的OS中，应用了哪些新技术? </li><li>何谓微内核技术? 在微内核中通常提供了哪些功能? </li></ol><h1 id="第二章-进程的描述与控制"><a href="#第二章-进程的描述与控制" class="headerlink" title="第二章 进程的描述与控制"></a>第二章 进程的描述与控制</h1><h2 id="1-前趋图和程序执行"><a href="#1-前趋图和程序执行" class="headerlink" title="1 前趋图和程序执行"></a>1 前趋图和程序执行</h2><blockquote><p>在早期未配置O S的系统和单道批处理系统中,程序的执<br> 行方式是顺序执行,即在内存中仅装入一道用户程序,由它<br> 独占系统中的所有资源,只有在一个用户程序执行完成后,<br> 才允许装入另一个程序并执行。可见,这种方式浪费资源、<br> 系统运行效率低等缺点。</p></blockquote><h3 id="前趋图"><a href="#前趋图" class="headerlink" title="前趋图"></a>前趋图</h3><blockquote><p>为了能更好地描述程序的顺序和并发执行情况，我们先介绍用于描述程序执行先后顺序的前趋图。所谓前趋图(Precedence Graph)，是指一个有向无循环图，可记为DAG(Directed Acyclic Graph)，它用于描述进程之间执行的先后顺序。图中的每个结点可用来表示一个进程或程序段，乃至一条语句，结点间的有向边则表示两个结点之间存在的偏序(Partial Order)或前趋关系(Precedence Relation)。</p></blockquote><blockquote><p>进程(或程序)之间的前趋关系可用“→”来表示，如果进程Pi和Pj存在着前趋关系，可表示为(Pi，Pj)∈→，也可写成Pi→Pj，表示在Pj开始执行之前Pi 必须完成。此时称Pi是Pj的直接前趋，而称Pj是Pi的直接后继。在前趋图中，把没有前趋的结点称为初始结点(Initial Node)，把没有后继的结点称为终止结点(Final Node)。此外，每个结点还具有一个重量(Weight)，用于表示该结点所含有的程序量或程序的执行时间。 </p></blockquote><blockquote><p>在图2-1(a)所示的前趋图中，存在着如下前趋关系：　　P1→P2，P1→P3，P1→P4，P2→P5，P3→P5，P4→P6，P4→P7，P5→P8，P6→P8，P7→P9，P8→P9或表示为：　P={P1, P2, P3, P4, P5, P6, P7, P8, P9} ={(P1, P2), (P1, P3), (P1, P4), (P2, P5), (P3, P5), (P4, P6), (P4, P7), (P5, P8), (P6, P8), (P7, P9), (P8, P9)}</p></blockquote><blockquote><p>应当注意，前趋图中是不允许有循环的，否则必然会产生不可能实现的前趋关系。如图2-1(b)所示的前趋关系中就存在着循环。它一方面要求在S3开始执行之前，S2必须完成，另一方面又要求在S2开始执行之前，S3必须完成。显然，这种关系是不可能实现的。S2→S3，S3→S2</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-2-1.png" alt="前趋图"></p><h3 id="程序顺序执行"><a href="#程序顺序执行" class="headerlink" title="程序顺序执行"></a>程序顺序执行</h3><h4 id="程序的顺序执行"><a href="#程序的顺序执行" class="headerlink" title="程序的顺序执行"></a>程序的顺序执行</h4><blockquote><p>通常，一个应用程序由若干个程序段组成，每一个程序段完成特定的功能，它们在执行时，都需要按照某种先后次序顺序执行，仅当前一程序段执行完后，才运行后一程序段。例如，在进行计算时，应先运行输入程序，用于输入用户的程序和数据；然后运行计算程序，对所输入的数据进行计算；最后才是运行打印程序，打印计算结果。我们用结点(Node)代表各程序段的操作(在图2-1中用圆圈表示)，其中I代表输入操作，C代表计算操作，P为打印操作，用箭头指示操作的先后次序。</p></blockquote><blockquote><p>这样，上述的三个程序段间就存在着这样的前趋关系：Ii→Ci→Pi，其执行的顺序可用前趋图2-2(a)描述。　　即使是一个程序段，也可能存在着执行顺序问题，下面示出了一个包含了三条语句的程序段：<br>　　S1: a :=x+y；<br>　　S2: b :=a-5；<br>　　S3: c :=b+1；<br>其中，语句S2必须在语句S1后(即a被赋值)才能执行，语句S3也只能在b被赋值后才能执行，因此，三条语句存在着这样的前趋关系：S1→S2→S3，应按前趋图2-2(b)所示的顺序执行。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-2-2.png" alt="程序顺序执行的前趋图"></p><h4 id="程序顺序执行时的特征"><a href="#程序顺序执行时的特征" class="headerlink" title="程序顺序执行时的特征"></a>程序顺序执行时的特征</h4><blockquote><p>由上所述可以得知，在程序顺序执行时，具有这样三个特征：</p></blockquote><p>① 顺序性：指处理机严格地按照程序所规定的顺序执行，即每一操作必须在下一个操作开始之前结束；<br>② 封闭性：指程序在封闭的环境下运行，即程序运行时独占全机资源，资源的状态(除初始状态外)只有本程序才能改变它，程序一旦开始执行，其执行结果不受外界因素影响；<br>③ 可再现性：指只要程序执行时的环境和初始条件相同，当程序重复执行时，不论它是从头到尾不停顿地执行，还是“停停走走”地执行，都可获得相同的结果。程序顺序执行时的这种特性，为程序员检测和校正程序的错误带来了很大的方便。</p><h4 id="程序并发执行"><a href="#程序并发执行" class="headerlink" title="程序并发执行"></a>程序并发执行</h4><p>　　1. 程序的并发执行<br>　　我们通过一个常见的例子来说明程序的顺序执行和并发执行。在图2-2中的输入程序、计算程序和打印程序三者之间，存在着Ii→Ci→Pi这样的前趋关系，以至对一个作业的输入、计算和打印三个程序段必须顺序执行。但若是对一批作业进行处理时，每道作业的输入、计算和打印程序段的执行情况如图2-3所示。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-2-3.png" alt="程序并发执行时的前趋图"></p><p>由图2-3可以看出，存在前趋关系Ii→Ci，Ii→Ii+1，Ci→Pi，Ci→Ci+1，Pi→Pi+1，而Ii+1和Ci及Pi-1是重叠的，即在Pi-1和Ci以及Ii+1之间，不存在前趋关系，可以并发执行。<br>　　对于具有下述四条语句的程序段：<br>　　S1: a :=x+2<br>　　S2: b :=y+4<br>　　S3: c :=a+b<br>　　S4: d :=c+b<br>可画出图2-4所示的前趋关系。可以看出：S3必须在a和b被赋值后方能执行；S4必须在S3之后执行；但S1和S2则可以并发执行，因为它们彼此互不依赖。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-2-4.png" alt="程序并发执行时的前趋图"></p><h4 id="程序并发执行时的特征"><a href="#程序并发执行时的特征" class="headerlink" title="程序并发执行时的特征"></a>程序并发执行时的特征</h4><p>　　在引入了程序间的并发执行功能后，虽然提高了系统的吞吐量和资源利用率，但由于它们共享系统资源，以及它们为完成同一项任务而相互合作，致使在这些并发执行的程序之间必将形成相互制约的关系，由此会给程序并发执行带来新的特征。<br>　　(1) 间断性。<br>　　(2) 失去封闭性。<br>　　(3) 不可再现性。</p><h2 id="2-进程的描述"><a href="#2-进程的描述" class="headerlink" title="2 进程的描述"></a>2 进程的描述</h2><h3 id="进程的定义和特征"><a href="#进程的定义和特征" class="headerlink" title="进程的定义和特征"></a>进程的定义和特征</h3><h4 id="1-进程的定义"><a href="#1-进程的定义" class="headerlink" title="1. 进程的定义"></a>1. 进程的定义</h4><blockquote><p>　　在多道程序环境下，程序的执行属于并发执行，此时它们将失去其封闭性，并具有间断性，以及其运行结果不可再现性的特征。由此，决定了通常的程序是不能参与并发执行的，否则，程序的运行也就失去了意义。为了能使程序并发执行，并且可以对并发执行的程序加以描述和控制，人们引入了“进程”的概念。</p></blockquote><p>对于进程的定义，从不同的角度可以有不同的定义，其中较典型的定义有：<br>　　(1) 进程是程序的一次执行。<br>　　(2) 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。<br>　　(3) 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</p><h4 id="2-进程的特征"><a href="#2-进程的特征" class="headerlink" title="2. 进程的特征"></a>2. 进程的特征</h4><p>　　进程和程序是两个截然不同的概念，除了进程具有程序所没有的PCB结构外，还具有下面一些特征：<br>　　(1) 动态性。<br>　　(2) 并发性。<br>　　(3) 独立性。<br>　　(4) 异步性。</p><h4 id="三种基本状态的转换"><a href="#三种基本状态的转换" class="headerlink" title="三种基本状态的转换"></a>三种基本状态的转换</h4><p>　　</p><blockquote><p>进程在运行过程中会经常发生状态的转换。例如，处于就绪状态的进程，在调度程序为之分配了处理机之后便可执行，相应地，其状态就由就绪态转变为执行态；正在执行的进程(当前进程)如果因分配给它的时间片已完而被剥夺处理机暂停执行时，其状态便由执行转为就绪；如果因发生某事件，致使当前进程的执行受阻(例如进程访问某临界资源，而该资源正被其它进程访问时)，使之无法继续执行，则该进程状态将由执行转变为阻塞。图2-5示出了进程的三种基本状态，以及各状态之间的转换关系。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-2-5.png" alt="进程的三种基本状态及其转换"></p><h4 id="创建状态和终止状态"><a href="#创建状态和终止状态" class="headerlink" title="创建状态和终止状态"></a>创建状态和终止状态</h4><p>　　1) 创建状态<br>　　如前所述，进程是由创建而产生。创建一个进程是个很复杂的过程，一般要通过多个步骤才能完成：如首先由进程申请一个空白PCB，并向PCB中填写用于控制和管理进程的信息；然后为该进程分配运行时所必须的资源；最后，把该进程转入就绪状态并插入就绪队列之中。但如果进程所需的资源尚不能得到满足，比如系统尚无足够的内存使进程无法装入其中，此时创建工作尚未完成，进程不能被调度运行，于是把此时进程所处的状态称为创建状态。<br>    2) 终止状态<br>　　进程的终止也要通过两个步骤：首先，是等待操作系统进行善后处理，最后将其PCB清零，并将PCB空间返还系统。当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结，它将进入终止状态。进入终止态的进程以后不能再执行，但在操作系统中依然保留一个记录，其中保存状态码和一些计时统计数据，供其他进程收集。一旦其他进程完成了对其信息的提取之后，操作系统将删除该进程，即将其PCB清零，并将该空白PCB返还系统。图2-6示出了增加了创建状态和终止状态后进程的五种状态及转换关系图。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-2-6.png" alt="进程的五种基本状态及转换"></p><h4 id="挂起操作和进程状态的转换"><a href="#挂起操作和进程状态的转换" class="headerlink" title="挂起操作和进程状态的转换"></a>挂起操作和进程状态的转换</h4><p>　1. 挂起操作的引入</p><p>　　引入挂起操作的原因，是基于系统和用户的如下需要：</p><p>　　(1) 终端用户的需要。<br>　　(2) 父进程请求。<br>　　(3) 负荷调节的需要。<br>　　(4) 操作系统的需要。</p><ol start="2"><li>引入挂起原语操作后三个进程状态的转换<br>　　在引入挂起原语Suspend和激活原语Active后，在它们的作用下，进程将可能发生以下几种状态的转换：<br>　　(1) 活动就绪→静止就绪。<br>　　(2) 活动阻塞→静止阻塞。<br>　　(3) 静止就绪→活动就绪。<br>　　(4) 静止阻塞→活动阻塞</li><li>引入挂起操作后五个进程状态的转换<br>　　如图2-8示出了增加了创建状态和终止状态后具有挂起状态的进程状态及转换图。<br>　　如图2-8所示，引进创建和终止状态后，在进程状态转换时，与图2-7所示的进程五状态转换相比较，要增加考虑下面的几种情况：<br>　　(1)  NULL→创建：<br>　　(2) 创建→活动就绪：<br>　　(3) 创建→静止就绪：<br>　　(4) 执行→终止：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-2-7.png" alt="具有挂起状态的进程状态图"><br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-2-8.png" alt="具有创建、终止和挂起状态的进程状态图"></p><h3 id="1-进程管理中的数据结构"><a href="#1-进程管理中的数据结构" class="headerlink" title="1. 进程管理中的数据结构"></a>1. 进程管理中的数据结构</h3><ol><li>操作系统中用于管理控制的数据结构</li></ol><blockquote><p>在计算机系统中，对于每个资源和每个进程都设置了一个数据结构，用于表征其实体，我们称之为资源信息表或进程信息表，其中包含了资源或进程的标识、描述、状态等信息以及一批指针。通过这些指针，可以将同类资源或进程的信息表，或者同一进程所占用的资源信息表分类链接成不同的队列，便于操作系统进行查找。如图2-9所示，OS管理的这些数据结构一般分为以下四类：<code>内存表</code>、<code>设备表</code>、<code>文件表</code>和<code>用于进程管理的进程表</code>，通常进程表又被称为进程控制块PCB。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-2-9.png" alt="操作系统控制表的一般结构"></p><h3 id="2-进程控制块PCB的作用"><a href="#2-进程控制块PCB的作用" class="headerlink" title="2. 进程控制块PCB的作用"></a>2. 进程控制块PCB的作用</h3><pre><code>(1) 作为独立运行基本单位的标志。(2) 能实现间断性运行方式。 (3) 提供进程管理所需要的信息。(4) 提供进程调度所需要的信息。(5) 实现与其它进程的同步与通信。</code></pre><h3 id="3-进程控制块中的信息"><a href="#3-进程控制块中的信息" class="headerlink" title="3. 进程控制块中的信息"></a>3. 进程控制块中的信息</h3><p>　　在进程控制块中，主要包括下述四个方面的信息。<br>　1) 进程标识符<br>　　  进程标识符用于唯一地标识一个进程。一个进程通常有两种标识符：<br>　　(1) 外部标识符。<br>　  (2) 内部标识符。<br>  2) 处理机状态<br>  　　处理机状态信息也称为处理机的上下文，主要是由处理机的各种寄存器中的内容组成的。<br>  3) 进程调度信息<br>  　　在OS进行调度时，必须了解进程的状态及有关进程调度的信息，这些信息包括：<br>  ① 进程状态，指明进程的当前状态，它是作为进程调度和对换时的依据；<br>  ② 进程优先级，是用于描述进程使用处理机的优先级别的一个整数，优先级高的进程应优先获得处理机；<br>  ③ 进程调度所需的其它信息，它们与所采用的进程调度算法有关，比如，进程已等待CPU的时间总和、进程已执行的时间总和等；<br>  ④ 事件，是指进程由执行状态转变为阻塞状态所等待发生的事件，即阻塞原因。</p><ol start="4"><li>进程控制信息<br>　　是指用于进程控制所必须的信息，它包括：<br>   ① 程序和数据的地址，进程实体中的程序和数据的内存或外存地(首)址，以便再调度到该进程执行时，能从PCB中找到其程序和数据；<br>   ② 进程同步和通信机制，这是实现进程同步和进程通信时必需的机制，如消息队列指针、信号量等，它们可能全部或部分地放在PCB中；<br>   ③ 资源清单，在该清单中列出了进程在运行期间所需的全部资源(除CPU以外)，另外还有一张已分配到该进程的资源的清单；<br>   ④ 链接指针，它给出了本进程(PCB)所在队列中的下一个进程的PCB的首地址。</li></ol><h3 id="4-进程控制块的组织方式"><a href="#4-进程控制块的组织方式" class="headerlink" title="4. 进程控制块的组织方式"></a>4. 进程控制块的组织方式</h3><p>在一个系统中，通常可拥有数十个、数百个乃至数千个PCB。为了能对它们加以有效的管理，应该用适当的方式将这些PCB组织起来。目前常用的组织方式有以下三种。</p><blockquote><p>(1) 线性方式，即将系统中所有的PCB都组织在一张线性表中，将该表的首址存放在内存的一个专用区域中。该方式实现简单、开销小，但每次查找时都需要扫描整张表，因此适合进程数目不多的系统。图2-10示出了线性表的PCB组织方式。 </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-2-10.png" alt="PCB线性表示意图"></p><blockquote><p>(2) 链接方式，即把具有相同状态进程的PCB分别通过PCB中的链接字链接成一个队列。这样，可以形成就绪队列、若干个阻塞队列和空白队列等。对就绪队列而言，往往按进程的优先级将PCB从高到低进行排列，将优先级高的进程PCB排在队列的前面。同样，也可把处于阻塞状态进程的PCB根据其阻塞原因的不同，排成多个阻塞队列，如等待I/O操作完成的队列和等待分配内存的队列等。图2-11示出了一种链接队列的组织方式。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-2-11.png" alt="PCB链接队列示意图"></p><blockquote><p>(3) 索引方式，即系统根据所有进程状态的不同，建立几张索引表，例如，就绪索引表、阻塞索引表等，并把各索引表在内存的首地址记录在内存的一些专用单元中。在每个索引表的表目中，记录具有相应状态的某个PCB在PCB表中的地址。图2-12示出了索引方式的PCB组织。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-2-12.png" alt="PCB链接队列示意图"></p><h2 id="3-进程控制"><a href="#3-进程控制" class="headerlink" title="3 进程控制"></a>3 进程控制</h2><blockquote><p>进程控制是进程管理中最基本的功能，主要包括创建新进程、终止已完成的进程、将因发生异常情况而无法继续运行的进程置于阻塞状态、负责进程运行中的状态转换等功能。如当一个正在执行的进程因等待某事件而暂时不能继续执行时，将其转变为阻塞状态，而在该进程所期待的事件出现后，又将该进程转换为就绪状态等。进程控制一般是由OS的内核中的原语来实现的。</p></blockquote><p>操作系统内核<br>　　1. 支撑功能<br>　　    (1) 中断处理。<br>　　    (2) 时钟管理。<br>　　    (3) 原语操作。<br>    2. 资源管理功能<br>    　　(1) 进程管理。<br>    　　(2) 存储器管理。<br>    　　(3) 设备管理。</p><p>进程的创建　</p><ol><li>进程的层次结构</li></ol><blockquote><p>在OS中，允许一个进程创建另一个进程，通常把创建进程的进程称为父进程，而把被创建的进程称为子进程。子进程可继续创建更多的孙进程，由此便形成了一个进程的层次结构。如在UNIX中，进程与其子孙进程共同组成一个进程家族(组)。</p></blockquote><ol start="2"><li>进程图<blockquote><p>为了形象地描述一个进程的家族关系而引入了进程图(Process Graph)。所谓进程图就是用于描述进程间关系的一棵有向树，如图2-13所示。</p></blockquote></li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-2-13.png" alt="进程树"></p><ol start="3"><li>引起创建进程的事件</li></ol><blockquote><p>为使程序之间能并发运行，应先为它们分别创建进程。导致一个进程去创建另一个进程的典型事件有四类：<br>　　(1) 用户登录。<br>　　(2) 作业调度。<br>　　(3) 提供服务。<br>　　(4) 应用请求。</p></blockquote><ol start="4"><li>进程的创建(Creation of Process)<br>　　在系统中每当出现了创建新进程的请求后，OS便调用进程创建原语Creat按下述步骤创建一个新进程：<br>　　(1) 申请空白PCB，为新进程申请获得唯一的数字标识符，并从PCB集合中索取一个空白PCB。<br>　　(2) 为新进程分配其运行所需的资源，包括各种物理和逻辑资源，如内存、文件、I/O设备和CPU时间等。<br>　　(3) 初始化进程控制块(PCB)。<br>　　(4) 如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列。</li></ol><p>进程的终止<br>　　1. 引起进程终止(Termination of Process)的事件<br>　　(1) 正常结束<br>　　(2) 异常结束<br>　　(3) 外界干预 </p><ol start="2"><li>进程的终止过程<br>　　如果系统中发生了要求终止进程的某事件，OS便调用进程终止原语，按下述过程去终止指定的进程：</li></ol><p>(1) 根据被终止进程的标识符，从PCB集合中检索出该进程的PCB，从中读出该进程的状态；<br>(2) 若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度；<br>(3) 若该进程还有子孙进程，还应将其所有子孙进程也都予以终止，以防它们成为不可控的进程；<br>(4) 将被终止进程所拥有的全部资源或者归还给其父进程，或者归还给系统；<br>(5) 将被终止进程(PCB)从所在队列(或链表)中移出，等待其它程序来搜集信息。</p><p>进程的阻塞与唤醒<br>　　1. 引起进程阻塞和唤醒的事件<br>　　有下述几类事件会引起进程阻塞或被唤醒：<br>　　(1) 向系统请求共享资源失败。<br>　　(2) 等待某种操作的完成。<br>　　(3) 新数据尚未到达。<br>　　(4) 等待新任务的到达。</p><p>进程阻塞过程</p><blockquote><p>正在执行的进程，如果发生了上述某事件，进程便通过调用阻塞原语block将自己阻塞。可见，阻塞是进程自身的一种主动行为。进入block过程后，由于该进程还处于执行状态，所以应先立即停止执行，把进程控制块中的现行状态由“执行”改为阻塞，并将PCB插入阻塞队列。如果系统中设置了因不同事件而阻塞的多个阻塞队列，则应将本进程插入到具有相同事件的阻塞队列。最后，转调度程序进行重新调度，将处理机分配给另一就绪进程，并进行切换，亦即，保留被阻塞进程的处理机状态，按新进程的PCB中的处理机状态设置CPU的环境。 </p></blockquote><p>进程唤醒过程</p><blockquote><p>当被阻塞进程所期待的事件发生时，比如它所启动的I/O操作已完成，或其所期待的数据已经到达，则由有关进程(比如提供数据的进程)调用唤醒原语wakeup，将等待该事件的进程唤醒。wakeup执行的过程是：首先把被阻塞的进程从等待该事件的阻塞队列中移出，将其PCB中的现行状态由阻塞改为就绪，然后再将该PCB插入到就绪队列中。</p></blockquote><p>进程的挂起与激活<br>　　1. 进程的挂起<br>　　2. 进程的激活过程</p><h2 id="4-进程同步"><a href="#4-进程同步" class="headerlink" title="4 进程同步"></a>4 进程同步</h2><blockquote><p>在OS中引入进程后，一方面可以使系统中的多道程序并发执行，这不仅能有效地改善资源利用率，还可显著地提高系统的吞吐量，但另一方面却使系统变得更加复杂。如果不能采取有效的措施，对多个进程的运行进行妥善的管理，必然会因为这些进程对系统资源的无序争夺给系统造成混乱。致使每次处理的结果存在着不确定性，即显现出其不可再现性。</p></blockquote><p>进程同步的基本概念<br>　　1. 两种形式的制约关系<br>　　1) 间接相互制约关系<br>　　2) 直接相互制约关系</p><p>临界资源(Critical Resouce)</p><blockquote><p>在第一章中我们曾经介绍过，许多硬件资源如打印机、 磁带机等，都属于临界资源，诸进程间应采取互斥方式，实现对这种资源的共享。</p></blockquote><p>临界区(critical section)</p><blockquote><p>由前所述可知，不论是硬件临界资源还是软件临界资源，多个进程必须互斥地对它进行访问。人们把在每个进程中访问临界资源的那段代码称为临界区(critical section)。</p></blockquote><p>同步机制应遵循的规则</p><blockquote><p>为实现进程互斥地进入自己的临界区，可用软件方法，更多的是在系统中设置专门的同步机构来协调各进程间的运行。所有同步机制都应遵循下述四条准则：<br>　　(1) 空闲让进<br>　　(2) 忙则等待<br>　　(3) 有限等待<br>　　(4) 让权等待</p></blockquote><p>同步机制应遵循的规则</p><blockquote><p>为实现进程互斥地进入自己的临界区，可用软件方法，更多的是在系统中设置专门的同步机构来协调各进程间的运行。所有同步机制都应遵循下述四条准则：<br>　　(1) <code>空闲让进</code><br>　　(2) <code>忙则等待</code><br>　　(3) <code>有限等待</code><br>　　(4) <code>让权等待</code></p></blockquote><p>硬件同步机制</p><blockquote><p>虽然可以利用软件方法解决诸进程互斥进入临界区的问题，但有一定难度，并且存在很大的局限性，因而现在已很少采用。相应地，目前许多计算机已提供了一些特殊的硬件指令，允许对一个字中的内容进行检测和修正，或者是对两个字的内容进行交换等。可利用这些特殊的指令来解决临界区问题。 </p></blockquote><ol><li>关中断</li></ol><blockquote><p>关中断是实现互斥的最简单的方法之一。在进入锁测试之前关闭中断，直到完成锁测试并上锁之后才能打开中断。这样，进程在临界区执行期间，计算机系统不响应中断，从而不会引发调度，也就不会发生进程或线程切换。由此，保证了对锁的测试和关锁操作的连续性和完整性，有效地保证了互斥。但是，关中断的方法存在许多缺点：① 滥用关中断权力可能导致严重后果；② 关中断时间过长，会影响系统效率，限制了处理器交叉执行程序的能力；③ 关中断方法也不适用于多CPU 系统，因为在一个处理器上关中断并不能防止进程在其它处理器上执行相同的临界段代码。</p></blockquote><ol start="2"><li>利用Test-and-Set指令实现互斥</li></ol><blockquote><p>这是一种借助一条硬件指令——“测试并建立”指令TS(Test-and-Set)以实现互斥的方法。在许多计算机中都提供了这种指令。</p></blockquote><ol start="3"><li>利用Swap指令实现进程互斥</li></ol><blockquote><p>该指令称为对换指令，在Intel 80x86中又称为XCHG指令，用于交换两个字的内容。 </p></blockquote><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><ol><li>整型信号量</li></ol><blockquote><p>最初由Dijkstra把整型信号量定义为一个用于表示资源数目的整型量S，它与一般整型量不同，除初始化外，仅能通过两个标准的原子操作(Atomic Operation) wait(S)和signal(S)来访问。很长时间以来，这两个操作一直被分别称为P、V操作。</p></blockquote><ol start="2"><li>记录型信号量</li></ol><blockquote><p>在整型信号量机制中的wait操作，只要是信号量S≤0，就会不断地测试。因此，该机制并未遵循“让权等待”的准则，而是使进程处于“忙等”的状态。记录型信号量机制则是一种不存在“忙等”现象的进程同步机制。但在采取了“让权等待”的策略后，又会出现多个进程等待访问同一临界资源的情况。为此，在信号量机制中，除了需要一个用于代表资源数目的整型变量value外，还应增加一个进程链表指针list，用于链接上述的所有等待进程。</p></blockquote><ol start="3"><li> AND型信号量</li></ol><blockquote><p>前面所述的进程互斥问题针对的是多个并发进程仅共享一个临界资源的情况。在有些应用场合，是一个进程往往需要获得两个或更多的共享资源后方能执行其任务。假定现有两个进程A和B，它们都要求访问共享数据D和E，当然，共享数据都应作为临界资源。</p></blockquote><ol start="4"><li>信号量集</li></ol><blockquote><p>在前面所述的记录型信号量机制中，wait(S)或signal(S)操作仅能对信号量施以加1或减1操作，意味着每次只能对某类临界资源进行一个单位的申请或释放。当一次需要N个单位时，便要进行N次wait(S)操作，这显然是低效的，甚至会增加死锁的概率。此外，在有些情况下，为确保系统的安全性，当所申请的资源数量低于某一下限值时，还必须进行管制，不予以分配。因此，当进程申请某类临界资源时，在每次分配之前，都必须测试资源的数量，判断是否大于可分配的下限值，决定是否予以分配。</p></blockquote><p>信号量的应用</p><ol><li>利用信号量实现进程互斥</li></ol><blockquote><p>为使多个进程能互斥地访问某临界资源，只需为该资源设置一互斥信号量mutex，并设其初始值为1，然后将各进程访问该资源的临界区CS置于wait(mutex)和signal(mutex)操作之间即可。</p></blockquote><ol start="2"><li>利用信号量实现前趋关系</li></ol><blockquote><p>还可利用信号量来描述程序或语句之间的前趋关系。设有两个并发执行的进程P1和P2。P1中有语句S1；P2中有语句S2。我们希望在S1执行后再执行S2。为实现这种前趋关系，只需使进程P1和P2共享一个公用信号量S，并赋予其初值为0，将signal(S)操作放在语句S1后面，而在S2语句前面插入wait(S)操作，即　　在进程P1中，用S1；signal(S)；　　在进程P2中，用wait(S)；S2；由于S被初始化为0，这样，若P2先执行必定阻塞，只有在进程P1执行完S1； signal(S)；操作后使S增为1时，P2进程方能成功执行语句S2。同样，我们可以利用信号量按照语句间的前趋关系(见图2-14)，写出一个更为复杂的可并发执行的程序。 </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-2-14.png" alt="前趋图举例"></p><h3 id="管程机制"><a href="#管程机制" class="headerlink" title="管程机制　　"></a>管程机制　　</h3><p>1．管程的定义</p><blockquote><p>系统中的各种硬件资源和软件资源均可用数据结构抽象地描述其资源特性，即用少量信息和对该资源所执行的操作来表征该资源，而忽略它们的内部结构和实现细节。由上述的定义可知，管程由四部分组成：<br>① 管程的名称；<br>② 局部于管程的共享数据结构说明；<br>③ 对该数据结构进行操作的一组过程；<br>④ 对局部于管程的共享数据设置初始值的语句。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-2-15.png" alt="前趋图举例"></p><ol start="2"><li>条件变量</li></ol><blockquote><p>在利用管程实现进程同步时，必须设置同步工具，如两个同步操作原语wait和signal。当某进程通过管程请求获得临界资源而未能满足时，管程便调用wait原语使该进程等待，并将其排在等待队列上，如图2-13所示。仅当另一进程访问完成并释放该资源之后，管程才又调用signal原语，唤醒等待队列中的队首进程。</p></blockquote><h2 id="5-经典进程的同步问题"><a href="#5-经典进程的同步问题" class="headerlink" title="5 经典进程的同步问题"></a>5 经典进程的同步问题</h2><blockquote><p>在多道程序环境下，进程同步问题十分重要，也是相当有趣的问题，因而吸引了不少学者对它进行研究，由此而产生了一系列经典的进程同步问题，其中较有代表性的是“生产者—消费者”问题、“读者—写者问题”、“哲学家进餐问题”等等。通过对这些问题的研究和学习，可以帮助我们更好地理解进程同步的概念及实现方法。</p></blockquote><h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3><ol><li>利用记录型信号量解决生产者-消费者问题</li></ol><blockquote><p>假定在生产者和消费者之间的公用缓冲池中具有n个缓冲区，这时可利用互斥信号量mutex实现诸进程对缓冲池的互斥使用；利用信号量empty和full分别表示缓冲池中空缓冲区和满缓冲区的数量。又假定这些生产者和消费者相互等效，只要缓冲池未满，生产者便可将消息送入缓冲池；只要缓冲池未空，消费者便可从缓冲池中取走一个消息。</p></blockquote><ol start="2"><li>利用AND信号量解决生产者-消费者问题</li></ol><blockquote><p>对于生产者-消费者问题，也可利用AND信号量来解决，即用Swait(empty，mutex)来代替wait(empty)和wait(mutex)；用Ssignal(mutex，full)来代替signal(mutex)和signal(full)；用Swait(full，mutex)代替wait(full)和wait(mutex)，以及用Ssignal(mutex，empty)代替Signal(mutex)和Signal(empty)。 </p></blockquote><ol start="3"><li>利用管程解决生产者-消费者问题</li></ol><blockquote><p>在利用管程方法来解决生产者-消费者问题时，首先便是为它们建立一个管程，并命名为procducerconsumer，或简称为PC。其中包括两个过程：<br>　　(1)  put(x)过程。<br>　　(2)  get(x)过程。</p></blockquote><blockquote><p>对于条件变量notfull和notempty，分别有两个过程cwait和csignal对它们进行操作：<br>　　(1)  cwait(condition)过程：当管程被一个进程占用时，其他进程调用该过程时阻塞，并挂在条件condition的队列上。<br>　　(2)  csignal(condition)过程：唤醒在cwait执行后阻塞在条件condition队列上的进程，如果这样的进程不止一个，则选择其中一个实施唤醒操作；如果队列为空，则无操作而返回。</p></blockquote><h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><ol><li>利用记录型信号量解决哲学家进餐问题</li></ol><blockquote><p>经分析可知，放在桌子上的筷子是临界资源，在一段时间内只允许一位哲学家使用。为了实现对筷子的互斥使用，可以用一个信号量表示一只筷子，由这五个信号量构成信号量数组。</p></blockquote><ol start="2"><li>利用AND信号量机制解决哲学家进餐问题</li></ol><blockquote><p>在哲学家进餐问题中，要求每个哲学家先获得两个临界资源(筷子)后方能进餐，这在本质上就是前面所介绍的AND同步问题，故用AND信号量机制可获得最简洁的解法。</p></blockquote><h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h3><ol><li>利用记录型信号量解决读者-写者问题</li></ol><blockquote><p>为实现Reader与Writer进程间在读或写时的互斥而设置了一个互斥信号量Wmutex。另外，再设置一个整型变量Readcount表示正在读的进程数目。由于只要有一个Reader进程在读，便不允许Writer进程去写。因此，仅当Readcount=0，表示尚无Reader进程在读时，Reader进程才需要执行Wait(Wmutex)操作。若wait(Wmutex)操作成功，Reader进程便可去读，相应地，做Readcount+1操作。</p></blockquote><ol start="2"><li>利用信号量集机制解决读者-写者问题</li></ol><blockquote><p>这里的读者—写者问题，与前面的略有不同，它增加了一个限制，即最多只允许RN个读者同时读。为此，又引入了一个信号量L，并赋予其初值为RN，通过执行wait(L, 1, 1)操作来控制读者的数目，每当有一个读者进入时，就要先执行wait(L, 1, 1)操作，使L的值减1。当有RN个读者进入读后，L便减为0，第RN + 1个读者要进入读时，必然会因wait(L, 1, 1)操作失败而阻塞。 </p></blockquote><h2 id="6-进程通信"><a href="#6-进程通信" class="headerlink" title="6 进程通信"></a>6 进程通信</h2><blockquote><p>进程通信是指进程之间的信息交换。由于进程的互斥与同步，需要在进程间交换一定的信息，故不少学者将它们也归为进程通信，但只能把它们称为低级进程通信。我们以信号量机制为例来说明，它们之所以低级的原因在于：① 效率低，生产者每次只能向缓冲池投放一个产品(消息)，消费者每次只能从缓冲区中取得一个消息；② 通信对用户不透明，OS只为进程之间的通信提供了共享存储器。</p></blockquote><p>在进程之间要传送大量数据时，应当利用OS提供的高级通信工具，该工具最主要的特点是：</p><blockquote><p>　(1) 使用方便。OS隐藏了实现进程通信的具体细节，向用户提供了一组用于实现高级通信的命令(原语)，用户可方便地直接利用它实现进程之间的通信。或者说，通信过程对用户是透明的。这样就大大减少了通信程序编制上的复杂性。<br>　 (2) 高效地传送大量数据。用户可直接利用高级通信命令(原语)高效地传送大量的数据。</p></blockquote><h4 id="进程通信的类型"><a href="#进程通信的类型" class="headerlink" title="进程通信的类型"></a>进程通信的类型</h4><ol><li><p>共享存储器系统(Shared-Memory System)</p><blockquote><p>在共享存储器系统中，相互通信的进程共享某些数据结构或共享存储区，进程之间能够通过这些空间进行通信。据此，又可把它们分成以下两种类型：<br>　　(1) 基于共享数据结构的通信方式。<br>　　(2) 基于共享存储区的通信方式。</p></blockquote></li><li><p>管道(pipe)通信系统</p><blockquote><p>所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。向管道(共享文件)提供输入的发送进程(即写进程)以字符流形式将大量的数据送入管道；而接受管道输出的接收进程(即读进程)则从管道中接收(读)数据。由于发送进程和接收进程是利用管道进行通信的，故又称为管道通信。这种方式首创于UNIX系统，由于它能有效地传送大量数据，因而又被引入到许多其它操作系统中。为了协调双方的通信，管道机制必须提供以下三方面的协调能力：<br>① 互斥，即当一个进程正在对pipe执行读/写操作时，其它(另一)进程必须等待。<br>② 同步，指当写(输入)进程把一定数量(如4 KB)的数据写入pipe，便去睡眠等待，直到读(输出)进程取走数据后再把它唤醒。当读进程读一空pipe时，也应睡眠等待，直至写进程将数据写入管道后才将之唤醒。<br>③ 确定对方是否存在，只有确定了对方已存在时才能进行通信。</p></blockquote></li><li><p>消息传递系统(Message passing system)</p><blockquote><p>在该机制中，进程不必借助任何共享存储区或数据结构，而是以格式化的消息 (message)为单位，将通信的数据封装在消息中，并利用操作系统提供的一组通信命令(原语)，在进程间进行消息传递，完成进程间的数据交换。　　基于消息传递系统的通信方式属于高级通信方式，因其实现方式的不同，可进一步分成两类：　　(1) 直接通信方式　　(2) 间接通信方式 </p></blockquote></li><li><p>客户机-服务器系统(Client-Server system)<br>　　1) 套接字(Socket)</p><blockquote><p>　　套接字起源于20世纪70年代加州大学伯克利分校版本的UNIX(即BSD Unix)，是UNIX 操作系统下的网络通信接口。一开始，套接字被设计用在同一台主机上多个应用程序之间的通信(即进程间的通信)，主要是为了解决多对进程同时通信时端口和物理线路的多路复用问题。随着计算机网络技术的发展以及UNIX 操作系统的广泛使用，套接字已逐渐成为最流行的网络通信程序接口之一。</p></blockquote></li></ol><p>　　2) 远程过程调用和远程方法调用</p><blockquote><p>　　远程过程(函数)调用RPC(Remote Procedure Call)，是一个通信协议，用于通过网络连接的系统。该协议允许运行于一台主机(本地)系统上的进程调用另一台主机(远程)系统上的进程，而对程序员表现为常规的过程调用，无需额外地为此编程。如果涉及的软件采用面向对象编程，那么远程过程调用亦可称做远程方法调用。</p></blockquote><p>实际上，远程过程调用的主要步骤是：<br>　　(1) 本地过程调用者以一般方式调用远程过程在本地关联的客户存根，传递相应的参数，然后将控制权转移给客户存根；<br>　　(2) 客户存根执行，完成包括过程名和调用参数等信息的消息建立，将控制权转移给本地客户进程；<br>　　(3) 本地客户进程完成与服务器的消息传递，将消息发送到远程服务器进程；<br>　　(4) 远程服务器进程接收消息后转入执行，并根据其中的远程过程名找到对应的服务器存根，将消息转给该存根；<br>　　(5) 该服务器存根接到消息后，由阻塞状态转入执行状态，拆开消息从中取出过程调用的参数，然后以一般方式调用服务器上关联的过程；<br>　　(6) 在服务器端的远程过程运行完毕后，将结果返回给与之关联的服务器存根；<br>　　(7) 该服务器存根获得控制权运行，将结果打包为消息，并将控制权转移给远程服务器进程；<br>　　(8) 远程服务器进程将消息发送回客户端；<br>　　(9) 本地客户进程接收到消息后，根据其中的过程名将消息存入关联的客户存根，再将控制权转移给客户存根；<br>　　(10) 客户存根从消息中取出结果，返回给本地调用者进程，并完成控制权的转移。</p><p>消息传递通信的实现方式<br>　　1. 直接消息传递系统</p><blockquote><p>　　在直接消息传递系统中采用直接通信方式，即发送进程利用OS所提供的发送命令(原语)，直接把消息发送给目标进程。</p></blockquote><ol><li><p>直接通信原语<br>　　(1) 对称寻址方式。<br>　　(2) 非对称寻址方式</p></li><li><p>消息的格式</p></li></ol><blockquote><p>在消息传递系统中所传递的消息，必须具有一定的消息格式。在单机系统环境中，由于发送进程和接收进程处于同一台机器中，有着相同的环境，所以消息的格式比较简单，可采用比较短的定长消息格式，以减少对消息的处理和存储开销。该方式可用于办公自动化系统中，为用户提供快速的便笺式通信。但这种方式对于需要发送较长消息的用户是不方便的。为此，可采用变长的消息格式，即进程所发送消息的长度是可变的。对于变长消息，系统无论在处理方面还是存储方面，都可能会付出更多的开销，但其优点在于方便了用户。</p></blockquote><ol start="3"><li>进程的同步方式</li></ol><blockquote><p>在进程之间进行通信时，同样需要有进程同步机制，以使诸进程间能协调通信。不论是发送进程还是接收进程，在完成消息的发送或接收后，都存在两种可能性，即进程或者继续发送(或接收)或者阻塞。 </p></blockquote><ol start="4"><li>通信链路</li></ol><blockquote><p>为使在发送进程和接收进程之间能进行通信，必须在两者之间建立一条通信链路。有两种方式建立通信链路。第一种方式是：由发送进程在通信之前用显式的“建立连接”命令(原语)请求系统为之建立一条通信链路，在链路使用完后拆除链路。</p></blockquote><ol start="2"><li>信箱通信<br>　　1) 信箱的结构<br>　　信箱定义为一种数据结构。在逻辑上，可以将其分为两个部分：<br>　　(1) 信箱头<br>　　(2) 信箱体</li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-2-16.png" alt="双向信箱示意图"></p><p>　　2) 信箱通信原语<br>　　系统为邮箱通信提供了若干条原语，分别用于：<br>　　(1) 邮箱的创建和撤消。<br>　　(2) 消息的发送和接收。</p><p>　　3) 信箱的类型<br>　　邮箱可由操作系统创建，也可由用户进程创建，创建者是邮箱的拥有者。据此，可把邮箱分为以下三类：<br>　　(1) 私用邮箱。<br>　　(2) 公用邮箱。<br>　　(3) 共享邮箱。 </p><p>直接消息传递系统实例</p><blockquote><p>消息缓冲队列通信机制首先由美国的Hansan提出，并在RC 4000系统上实现，后来被广泛应用于本地进程之间的通信中。在这种通信机制中，发送进程利用Send原语将消息直接发送给接收进程；接收进程则利用Receive原语接收消息。</p></blockquote><p>消息缓冲队列通信机制中的数据结构<br>　　(1) 消息缓冲区。<br>　　(2) PCB中有关通信的数据项。</p><ol start="2"><li>发送原语</li></ol><blockquote><p>发送进程在利用发送原语发送消息之前，应先在自己的内存空间设置一发送区a，如图2-17所示，把待发送的消息正文、发送进程标识符、消息长度等信息填入其中，然后调用发送原语，把消息发送给目标(接收)进程。发送原语首先根据发送区a中所设置的消息长度a.size来申请一缓冲区i，接着，把发送区a中的信息复制到缓冲区i中。为了能将i挂在接收进程的消息队列mq上，应先获得接收进程的内部标识符j，然后将i挂在j.mq上。由于该队列属于临界资源，故在执行insert操作的前后都要执行wait和signal操作。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-2-17.png" alt="消息缓冲通信"></p><ol start="3"><li>接收原语<br>　　接收进程调用接收原语receive(b)，从自己的消息缓冲队列mq中摘下第一个消息缓冲区i，并将其中的数据复制到以b为首址的指定消息接收区内。</li></ol><h2 id="7-线程-Threads-的基本概念"><a href="#7-线程-Threads-的基本概念" class="headerlink" title="7 线程(Threads) 的基本概念"></a>7 线程(Threads) 的基本概念</h2><blockquote><p>如果说，在OS中引入进程的目的是为了使多个程序能并发执行，以提高资源利用率和系统吞吐量，那么，在操作系统中再引入线程，则是为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性。</p></blockquote><p><code>进程</code>的两个基本属性<br>　　首先让我们来回顾进程的两个基本属性：<br>① 进程是一个可拥有资源的独立单位，一个进程要能独立运行，它必须拥有一定的资源，包括用于存放程序正文、数据的磁盘和内存地址空间，以及它在运行时所需要的I/O设备、已打开的文件、信号量等；<br>② 进程同时又是一个可独立调度和分派的基本单位，一个进程要能独立运行，它还必须是一个可独立调度和分派的基本单位。每个进程在系统中有唯一的PCB，系统可根据其PCB感知进程的存在，也可以根据其PCB中的信息，对进程进行调度，还可将断点信息保存在其PCB中。反之，再利用进程PCB中的信息来恢复进程运行的现场。正是由于进程有这两个基本属性，才使进程成为一个能独立运行的基本单位，从而也就构成了进程并发执行的基础。</p><p>程序并发执行所需付出的时空开销</p><p>　　为使程序能并发执行，系统必须进行以下的一系列操作：<br>　　(1) 创建进程，系统在创建一个进程时，必须为它分配其所必需的、除处理机以外的所有资源，如内存空间、I/O设备，以及建立相应的PCB；<br>　　(2) 撤消进程，系统在撤消进程时，又必须先对其所占有的资源执行回收操作，然后再撤消PCB；<br>　　(3) 进程切换，对进程进行上下文切换时，需要保留当前进程的CPU环境，设置新选中进程的CPU环境，因而须花费不少的处理机时间。</p><h3 id="线程——作为调度和分派的基本单位"><a href="#线程——作为调度和分派的基本单位" class="headerlink" title="线程——作为调度和分派的基本单位"></a>线程——作为调度和分派的基本单位</h3><blockquote><p>如何能使多个程序更好地并发执行，同时又尽量减少系统的开销，已成为近年来设计操作系统时所追求的重要目标。有不少研究操作系统的学者们想到，要设法将进程的上述两个属性分开，由OS分开处理，亦即并不把作为调度和分派的基本单位也同时作为拥有资源的单位，以做到“轻装上阵”；而对于拥有资源的基本单位，又不对之施以频繁的切换。正是在这种思想的指导下，形成了线程的概念。</p></blockquote><p>线程与进程的比较<br>　　1. 调度的基本单位<br>　　2. 并发性<br>　　3. 拥有资源<br>　　4. 独立性<br>　　5. 系统开销<br>　　6. 支持多处理机系统</p><p>线程的状态和线程控制块<br>　　1. 线程运行的三个状态<br>　　与传统的进程一样，在各线程之间也存在着共享资源和相互合作的制约关系，致使线程在运行时也具有间断性。相应地，线程在运行时也具有下述三种基本状态：<br>　　(1) 执行状态，表示线程已获得处理机而正在运行；<br>　　(2) 就绪状态，指线程已具备了各种执行条件，只须再获得CPU便可立即执行；<br>　　(3) 阻塞状态，指线程在执行中因某事件受阻而处于暂停状态，例如，当一个线程执行从键盘读入数据的系统调用时，该线程就被阻塞。</p><h3 id="线程控制块TCB"><a href="#线程控制块TCB" class="headerlink" title="线程控制块TCB"></a>线程控制块TCB</h3><blockquote><p>如同每个进程有一个进程控制块一样，系统也为每个线程配置了一个线程控制块TCB，将所有用于控制和管理线程的信息记录在线程控制块中。 </p></blockquote><p>多线程OS中的进程属性<br>　　通常在多线程OS中的进程都包含了多个线程，并为它们提供资源。OS支持在一个进程中的多个线程能并发执行，但此时的进程就不再作为一个执行的实体。多线程OS中的进程有以下属性：<br>　　(1) 进程是一个可拥有资源的基本单位。<br>　　(2) 多个线程可并发执行。<br>　　(3) 进程已不是可执行的实体。</p><h2 id="8-线程的实现"><a href="#8-线程的实现" class="headerlink" title="8 线程的实现"></a>8 线程的实现</h2><p>线程的实现方式</p><blockquote><p>线程已在许多系统中实现，但各系统的实现方式并不完全相同。在有的系统中，特别是一些数据库管理系统，如infomix所实现的是用户级线程； 而另一些系统(如Macintosh和OS/2操作系统)所实现的是内核支持线程；还有一些系统如Solaris操作系统，则同时实现了这两种类型的线程。</p></blockquote><ol><li>内核支持线程KST(Kernel Supported Threads)</li></ol><blockquote><p>在OS中的所有进程，无论是系统进程还是用户进程，都是在操作系统内核的支持下运行的，是与内核紧密相关的。而内核支持线程KST同样也是在内核的支持下运行的，它们的创建、阻塞、撤消和切换等，也都是在内核空间实现的。为了对内核线程进行控制和管理，在内核空间也为每一个内核线程设置了一个线程控制块，内核根据该控制块而感知某线程的存在，并对其加以控制。当前大多数OS都支持内核支持线程。</p></blockquote><p>这种线程实现方式主要有四个主要优点：<br>　　(1) 在多处理器系统中，内核能够同时调度同一进程中的多个线程并行执行；<br>　　(2) 如果进程中的一个线程被阻塞了，内核可以调度该进程中的其它线程占有处理器运行，也可以运行其它进程中的线程；<br>　　(3) 内核支持线程具有很小的数据结构和堆栈，线程的切换比较快，切换开销小；<br>　　(4) 内核本身也可以采用多线程技术，可以提高系统的执行速度和效率。</p><ol start="2"><li>用户级线程ULT(User Level Threads)</li></ol><blockquote><p>用户级线程是在用户空间中实现的。对线程的创建、 撤消、同步与通信等功能，都无需内核的支持，即用户级线程是与内核无关的。在一个系统中的用户级线程的数目可以达到数百个至数千个。由于这些线程的任务控制块都是设置在用户空间，而线程所执行的操作也无需内核的帮助，因而内核完全不知道用户级线程的存在。</p></blockquote><p>使用用户级线程方式有许多优点：</p><p>　　(1) 线程切换不需要转换到内核空间。<br>　　(2) 调度算法可以是进程专用的。<br>　　(3) 用户级线程的实现与OS平台无关，因为对于线程管理的代码是属于用户程序的一部分，所有的应用程序都可以对之进行共享。</p><p>而用户级线程方式的主要缺点则在于：<br>　　(1) 系统调用的阻塞问题。在基于进程机制的OS中，大多数系统调用将使进程阻塞，因此，当线程执行一个系统调用时，不仅该线程被阻塞，而且，进程内的所有线程会被阻塞。而在内核支持线程方式中，则进程中的其它线程仍然可以运行。<br>　　(2) 在单纯的用户级线程实现方式中，多线程应用不能利用多处理机进行多重处理的优点，内核每次分配给一个进程的仅有一个CPU，因此，进程中仅有一个线程能执行，在该线程放弃CPU之前，其它线程只能等待。</p><ol start="3"><li>组合方式　　<blockquote><p>有些OS把用户级线程和内核支持线程两种方式进行组合，提供了组合方式ULT/KST 线程。在组合方式线程系统中，内核支持多个内核支持线程的建立、调度和管理，同时，也允许用户应用程序建立、调度和管理用户级线程。</p></blockquote></li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-2-18.png" alt="多线程模型"></p><h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>　　1. 内核支持线程的实现</p><blockquote><p>在仅设置了内核支持线程的OS中，一种可能的线程控制方法是，系统在创建一个新进程时，便为它分配一个任务数据区PTDA(Per Task Data Area)，其中包括若干个线程控制块TCB空间，如图2-19所示。 </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-2-19.png" alt="任务数据区空间"></p><ol start="2"><li>用户级线程的实现<br>　　1) 运行时系统(Runtime System)</li></ol><blockquote><p>　　所谓“运行时系统”，实质上是用于管理和控制线程的函数(过程)的集合，其中包括用于创建和撤消线程的函数、线程同步和通信的函数，以及实现线程调度的函数等。正因为有这些函数，才能使用户级线程与内核无关。运行时系统中的所有函数都驻留在用户空间，并作为用户级线程与内核之间的接口。</p></blockquote><ol start="2"><li>内核控制线程</li></ol><blockquote><p>　　这种线程又称为轻型进程LWP(Light Weight Process)。每一个进程都可拥有多个LWP，同用户级线程一样，每个LWP都有自己的数据结构(如TCB)，其中包括线程标识符、优先级、状态，另外还有栈和局部存储区等。LWP也可以共享进程所拥有的资源。LWP可通过系统调用来获得内核提供的服务，这样，当一个用户级线程运行时，只须将它连接到一个LWP上，此时它便具有了内核支持线程的所有属性。这种线程实现方式就是组合方式。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-2-20.png" alt="利用轻型进程作为中间系统"></p><p>线程的创建和终止</p><ol><li><p>线程的创建</p><blockquote><p>　　应用程序在启动时，通常仅有一个线程在执行，人们把线程称为“初始化线程”，它的主要功能是用于创建新线程。在创建新线程时，需要利用一个线程创建函数(或系统调用)，并提供相应的参数，如指向线程主程序的入口指针、堆栈的大小，以及用于调度的优先级等。在线程的创建函数执行完后，将返回一个线程标识符供以后使用。</p></blockquote></li><li><p>线程的终止</p><blockquote><p>　　当一个线程完成了自己的任务(工作)后，或是线程在运行中出现异常情况而须被强行终止时，由终止线程通过调用相应的函数(或系统调用)对它执行终止操作。但有些线程(主要是系统线程)，它们一旦被建立起来之后，便一直运行下去而不被终止。在大多数的OS中，线程被中止后并不立即释放它所占有的资源，只有当进程中的其它线程执行了分离函数后，被终止的线程才与资源分离，此时的资源才能被其它线程利用。</p></blockquote></li></ol><h2 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h2><p>　　1. 什么是前趋图? 为什么要引入前趋图?<br>　　2. 试画出下面四条语句的前趋图：S1: a = x+y；S2: b = z+1；S3: c = a-b；S4: w = c+1；<br>　　3. 为什么程序并发执行会产生间断性特征?<br>　　4. 程序并发执行时为什么会失去封闭性和可再现性?<br>　　5. 在操作系统中为什么要引入进程的概念? 它会产生什么样的影响?<br>　　6. 试从动态性、并发性和独立性上比较进程和程序。<br>　　7. 试说明PCB的作用具体表现在哪几个方面，为什么说PCB是进程存在的唯一标志?<br>　　8.  PCB提供了进程管理和进程调度所需要的哪些信息?<br>　　9. 进程控制块的组织方式有哪几种?<br>　　10. 何谓操作系统内核? 内核的主要功能是什么?<br>　　11. 试说明进程在三个基本状态之间转换的典型原因。<br>　　12. 为什么要引入挂起状态? 该状态有哪些性质?<br>　　13. 在进行进程切换时，所要保存的处理机状态信息有哪些?<br>　　14. 试说明引起进程创建的主要事件。<br>　　15. 试说明引起进程被撤消的主要事件。<br>　　16. 在创建一个进程时所要完成的主要工作是什么?<br>　　17. 在撤消一个进程时所要完成的主要工作是什么?<br>　　18. 试说明引起进程阻塞或被唤醒的主要事件是什么?<br>　　19. 为什么要在OS中引入线程?<br>　　20. 试说明线程具有哪些属性?<br>　　21. 试从调度性、并发性、拥有资源及系统开销方面对进程和线程进行比较。<br>　　22. 线程控制块TCB中包含了哪些内容?<br>　　23. 何谓用户级线程和内核支持线程?<br>　　24. 试说明用户级线程的实现方法。<br>　　25. 试说明内核支持线程的实现方法。<br>　　26. 多线程模型有哪几种类型? 多对一模型有何优缺点? </p><h1 id="第三章-处理机调度与死锁"><a href="#第三章-处理机调度与死锁" class="headerlink" title="第三章    处理机调度与死锁"></a>第三章    处理机调度与死锁</h1><h2 id="3-1-调度算法"><a href="#3-1-调度算法" class="headerlink" title="3.1  调度算法"></a>3.1  调度算法</h2><blockquote><p>在多道程序系统中，调度的实质是一种资源分配，处理机调度是对处理机资源进行分配。处理机调度算法是指根据处理机分配策略所规定的处理机分配算法。在多道批处理系统中，一个作业从提交到获得处理机执行，直至作业运行完毕，可能需要经历多级处理机调度，下面先来了解处理机调度的层次。</p></blockquote><p>处理机调度的层次</p><p>　　1. 高级调度(High Level Scheduling)<br>　　2. 低级调度(Low Level Scheduling)<br>　　3. 中级调度(Intermediate Scheduling)</p><p>处理机调度算法的目标<br>　　(1) 资源利用率。<br>　　(2) 公平性。　<br>　　(3) 平衡性。<br>　　(4) 策略强制执行。</p><p>批处理系统的目标<br>　　(1) 平均周转时间短。<br>　　(2) 系统吞吐量高。</p><p>分时系统的目标<br>　　(1) 响应时间快。<br>　　(2) 均衡性。</p><p>实时系统的目标<br>　　(1) 截止时间的保证。<br>　　(2) 可预测性。</p><h2 id="3-2-作业调度"><a href="#3-2-作业调度" class="headerlink" title="3.2  作业调度"></a>3.2  作业调度</h2><blockquote><p>在多道批处理系统中，作业是用户提交给系统的一项相对独立的工作。操作员把用户提交的作业通过相应的输入设备输入到磁盘存储器，并保存在一个后备作业队列中。再由作业调度程序将其从外存调入内存。</p></blockquote><p>批处理系统中的作业<br>　　1. 作业和作业步<br>　　(1) 作业(Job)。<br>　　(2) 作业步(Job Step)。</p><p>作业控制块(Job Control Block，JCB)</p><blockquote><p>　　为了管理和调度作业，在多道批处理系统中，为每个作业设置了一个作业控制块JCB，它是作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息。通常在JCB中包含的内容有：作业标识、用户名称、用户账号、作业类型(CPU 繁忙型、I/O 繁忙型、批量型、终端型)、作业状态、调度信息(优先级、作业运行时间)、资源需求(预计运行时间、要求内存大小等)、资源使用情况等。</p></blockquote><p>作业运行的三个阶段和三种状态<br>　　作业从进入系统到运行结束，通常需要经历收容、运行和完成三个阶段。相应的作业也就有“后备状态”、“运行状态”和“完成状态”。<br>　　(1) 收容阶段。<br>　　(2) 运行阶段。　　<br>　　(3) 完成阶段。</p><p>作业调度的主要任务   </p><blockquote><p>作业调度的主要任务是，根据JCB中的信息，检查系统中的资源能否满足作业对资源的需求，以及按照一定的调度算法，从外存的后备队列中选取某些作业调入内存，并为它们创建进程、分配必要的资源。然后再将新创建的进程排在就绪队列上等待调度。因此，也把作业调度称为接纳调度(Admission Scheduling)。在每次执行作业调度时，都需做出以下两个决定。 　　1. 接纳多少个作业　　2. 接纳哪些作业</p></blockquote><p>先来先服务(FCFS)和短作业优先(SJF)调度算法  　　</p><ol><li>先来先服务(first-come first-served，FCFS)调度算法</li></ol><blockquote><p>FCFS是最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，系统将按照作业到达的先后次序来进行调度，或者说它是优先考虑在系统中等待时间最长的作业，而不管该作业所需执行时间的长短，从后备作业队列中选择几个最先进入该队列的作业，将它们调入内存，为它们分配资源和创建进程。然后把它放入就绪队列。</p></blockquote><ol start="2"><li>短作业优先(short job first，SJF)的调度算法 </li></ol><blockquote><p>由于在实际情况中，短作业(进程)占有很大比例，为了能使它们能比长作业优先执行，而产生了短作业优先调度算法。　　</p></blockquote><ol><li><p>短作业优先算法<br>　　SJF算法是以作业的长短来计算优先级，作业越短，其优先级越高。作业的长短是以作业所要求的运行时间来衡量的。SJF算法可以分别用于作业调度和进程调度。在把短作业优先调度算法用于作业调度时，它将从外存的作业后备队列中选择若干个估计运行时间最短的作业，优先将它们调入内存运行。</p></li><li><p>短作业优先算法的缺点<br>　　SJF调度算法较之FCFS算法有了明显的改进，但仍然存在不容忽视的缺点：<br>　　(1) 必须预知作业的运行时间。在采用这种算法时，要先知道每个作业的运行时间。即使是程序员也很难准确估计作业的运行时间，如果估计过低，系统就可能按估计的时间终止作业的运行，但此时作业并未完成，故一般都会偏长估计。<br>　　(2) 对长作业非常不利，长作业的周转时间会明显地增长。更严重的是，该算法完全忽视作业的等待时间，可能使作业等待时间过长，出现饥饿现象。<br>　　(3) 在采用FCFS算法时，人—机无法实现交互。<br>　　(4) 该调度算法完全未考虑作业的紧迫程度，故不能保证紧迫性作业能得到及时处理。</p></li></ol><p>优先级调度算法和高响应比优先调度算法</p><ol><li>优先级调度算法(priority-scheduling algorithm，PSA)</li></ol><blockquote><p>我们可以这样来看作业的优先级，对于先来先服务调度算法，作业的等待时间就是作业的优先级，等待时间越长，其优先级越高。对于短作业优先调度算法，作业的长短就是作业的优先级，作业所需运行的时间越短，其优先级越高。但上述两种优先级都不能反映作业的紧迫程度。</p></blockquote><ol start="2"><li>高响应比优先调度算法(Highest Response Ratio Next，HRRN)  </li></ol><blockquote><p>在批处理系统中，FCFS算法所考虑的只是作业的等待时间，而忽视了作业的运行时间。而SJF算法正好与之相反，只考虑作业的运行时间，而忽视了作业的等待时间。高响应比优先调度算法则是既考虑了作业的等待时间，又考虑作业运行时间的调度算法，因此既照顾了短作业，又不致使长作业的等待时间过长，从而改善了处理机调度的性能。</p></blockquote><p>高响应比优先算法是如何实现的呢? 如果我们能为每个作业引入一个动态优先级，即优先级是可以改变的，令它随等待时间延长而增加，这将使长作业的优先级在等待期间不断地增加，等到足够的时间后，必然有机会获得处理机。该优先级的变化规律可描述为：</p><p>$$<br>优先权=\frac{等待时间+要求服务时间}{要求服务时间}<br>$$</p><p>由于等待时间与服务时间之和就是系统对该作业的响应时间，故该优先级又相当于响应比RP。据此，优先又可表示为：</p><p>$$<br>优先权=\frac{等待时间+要求服务时间}{要求服务时间}=\frac{响应时间}{要求服务时间}<br>$$</p><h2 id="3-3-进程调度"><a href="#3-3-进程调度" class="headerlink" title="3.3  进程调度"></a>3.3  进程调度</h2><blockquote><p>进程调度是OS中必不可少的一种调度。因此在三种类型的OS中，都无一例外地配置了进程调度。此外它也是对系统性能影响最大的一种处理机调度，相应的，有关进程调度的算法也较多。</p></blockquote><p>进程调度的任务、机制和方式   </p><ol><li>进程调度的任务</li></ol><p>　　进程调度的任务主要有三：<br>　　(1) 保存处理机的现场信息。<br>　　(2) 按某种算法选取进程。<br>　　(3) 把处理器分配给进程。</p><ol start="2"><li>进程调度机制<br>　　为了实现进程调度，在进程调度机制中，应具有如下三个基本部分，如图所示。<br>　　(1) 排队器。<br>　　(2) 分派器。<br>　　(3) 上下文切换器。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-3-1.png" alt="进程调度机制"></p><ol start="3"><li>进程调度方式</li></ol><ol><li><p>非抢占方式(Nonpreemptive Mode)</p><blockquote><p>　在采用这种调度方式时，一旦把处理机分配给某进程后，就一直让它运行下去，决不会因为时钟中断或任何其它原因去抢占当前正在运行进程的处理机，直至该进程完成，或发生某事件而被阻塞时，才把处理机分配给其它进程。</p></blockquote></li><li><p>抢占方式(Preemptive Mode)</p><blockquote><p>　这种调度方式允许调度程序根据某种原则，去暂停某个正在执行的进程，将已分配给该进程的处理机重新分配给另一进程。在现代OS中广泛采用抢占方式，这是因为：对于批处理机系统，可以防止一个长进程长时间地占用处理机，以确保处理机能为所有进程提供更为公平的服务。在分时系统中，只有采用抢占方式才有可能实现人—机交互。在实时系统中，抢占方式能满足实时任务的需求。但抢占方式比较复杂，所需付出的系统开销也较大。</p></blockquote></li></ol><p class="note note-primary">轮转调度算法</p><ol><li>轮转法的基本原理</li></ol><blockquote><p>在轮转(RR)法中，系统将所有的就绪进程按FCFS策略排成一个就绪队列。系统可设置每隔一定时间(如30 ms)便产生一次中断，去激活进程调度程序进行调度，把CPU分配给队首进程，并令其执行一个时间片。当它运行完毕后，又把处理机分配给就绪队列中新的队首进程，也让它执行一个时间片。这样，就可以保证就绪队列中的所有进程在确定的时间段内，都能获得一个时间片的处理机时间。</p></blockquote><ol start="2"><li>进程切换时机</li></ol><blockquote><p>在RR调度算法中，应在何时进行进程的切换，可分为两种情况：① 若一个时间片尚未用完，正在运行的进程便已经完成，就立即激活调度程序，将它从就绪队列中删除，再调度就绪队列中队首的进程运行，并启动一个新的时间片。② 在一个时间片用完时，计时器中断处理程序被激活。如果进程尚未运行完毕，调度程序将把它送往就绪队列的末尾。</p></blockquote><ol start="3"><li>时间片大小的确定<br>　　在轮转算法中，时间片的大小对系统性能有很大的影响。 下图示出了时间片大小对响应时间的影响，其中图(a)是时间片略大于典型交互的时间，而图(b)是时间片小于典型交互的时间。图3-3示出了时间片分别为q = 1和q = 4时对平均周转时间的影响。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-3-2.png" alt="时间片大小对响应时间的影响"><br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-3-3.png" alt="q = 1和q = 4时进程的周转时间"></p><p>优先级调度算法</p><p>　　1. 优先级调度算法的类型<br>　　优先级进程调度算法，是把处理机分配给就绪队列中优先级最高的进程。这时，又可进一步把该算法分成如下两种。<br>　　(1) 非抢占式优先级调度算法。<br>　　(2) 抢占式优先级调度算法。</p><p>　　2. 优先级的类型<br>　　1) 静态优先级</p><blockquote><p>静态优先级是在创建进程时确定的，在进程的整个运行期间保持不变。优先级是利用某一范围内的一个整数来表示的，例如0～255中的某一整数，又把该整数称为优先数。确定进程优先级大小的依据有如下三个：</p></blockquote><p>　　(1) 进程类型。<br>　　(2) 进程对资源的需求。<br>　　(3) 用户要求。<br>    2) 动态优先级</p><blockquote><p>动态优先级是指在创建进程之初，先赋予其一个优先级，然后其值随进程的推进或等待时间的增加而改变，以便获得更好的调度性能。</p></blockquote><h2 id="3-4-实时调度"><a href="#3-4-实时调度" class="headerlink" title="3.4  实时调度"></a>3.4  实时调度</h2><blockquote><p>在实时系统中，可能存在着两类不同性质的实时任务，即HRT任务和SRT任务，它们都联系着一个截止时间。为保证系统能正常工作，实时调度必须能满足实时任务对截止时间的要求。为此，实现实时调度应具备一定的条件。</p></blockquote><ul><li>提供必要的信息</li><li>系统处理能力强</li><li>采用抢占式调度机制</li><li>具有快速切换机制</li></ul><p>实时调度算法的分类      </p><p>① 根据实时任务性质，可将实时调度的算法分为硬实时调度算法和软实时调度算法；<br>② 按调度方式，则可分为非抢占调度算法和抢占调度算法。 </p><p><code>非抢占式调度算法</code>　　(1) 非抢占式轮转调度算法。　　(2) 非抢占式优先调度算法。<br><code>抢占式调度算法</code>    (1) 基于时钟中断的抢占式优先级调度算法。　　(2) 立即抢占(Immediate Preemption)的优先级调度算法。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-3-4.png" alt="实时进程调度"></p><p class="note note-primary">最早截止时间优先EDF(Earliest Deadline First)算法</p><ol><li>非抢占式调度方式用于非周期实时任务</li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-3-5.png" alt="EDF算法用于非抢占调度方式"></p><ol start="2"><li>抢占式调度方式用于周期实时任务</li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-3-6.png" alt="最早截止时间优先算法用于抢占调度方式之例"></p><p class="note note-primary">最低松弛度优先LLF(Least Laxity First)算法</p><blockquote><p>该算法在确定任务的优先级时，根据的是任务的紧急(或松弛)程度。任务紧急程度愈高，赋予该任务的优先级就愈高，以使之优先执行。 该算法主要用于可抢占调度方式中。假如在一个实时系统中有两个周期性实时任务A和B，任务A要求每20 ms执行一次，执行时间为10 ms，任务B要求每50 ms执行一次，执行时间为25 ms。由此可知，任务A和B每次必须完成的时间分别为：A1、A2、A3、…和B1、B2、B3、…</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-3-7.png" alt="A和B任务每次必须完成的时间"><br><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-3-8.png" alt="利用ELLF算法进行调度的情况"></p><p class="note note-primary">优先级倒置(priority inversion problem) </p><blockquote><p>当前OS广泛采用优先级调度算法和抢占方式，然而在系统中存在着影响进程运行的资源而可能产生“优先级倒置”的现象，即高优先级进程(或线程)被低优先级进程(或线程)延迟或阻塞。我们通过一个例子来说明该问题。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-3-9.png" alt="优先级倒置示意图"></p><p>假如P3最先执行，在执行了P(mutex)操作后，进入到临界区CS-3。在时刻a，P2就绪，因为它比P3的优先级高，P2抢占了P3的处理机而运行</p><p><code>优先级倒置的解决方法</code>　　一种简单的解决方法是规定：假如进程P3在进入临界区后P3所占用的处理机就不允许被抢占。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-3-10.png" alt="采用了动态优先级继承方法的运行情况"></p><h2 id="3-5-死锁概述"><a href="#3-5-死锁概述" class="headerlink" title="3.5  死锁概述"></a>3.5  死锁概述</h2><blockquote><p>在系统中有许多不同类型的资源，其中可以引起死锁的主要是，需要采用互斥访问方法的、不可以被抢占的资源，即在前面介绍的临界资源。系统中这类资源有很多，如打印机、数据文件、队列、信号量等。</p></blockquote><p>死锁的定义: <code>在一组进程发生死锁的情况下，这组死锁进程中的每一个进程，都在等待另一个死锁进程所占有的资源。</code></p><p class="note note-primary">资源分类</p><ol><li><p>可抢占性资源　　可把系统中的资源分成两类，一类是可抢占性资源，是指某进程在获得这类资源后，该资源可以再被其它进程或系统抢占。</p></li><li><p>不可抢占性资源　　另一类资源是不可抢占性资源，即一旦系统把某资源分配给该进程后，就不能将它强行收回，只能在进程用完后自行释放。 </p></li></ol><p class="note note-primary">死锁原因</p><ul><li><ol><li>竞争不可抢占性资源引起死锁</li></ol></li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-3-11.png" alt="共享文件时的死锁情况"></p><blockquote><p>通常系统中所拥有的不可抢占性资源其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局。</p></blockquote><ul><li><ol start="2"><li>竞争可消耗资源引起死锁</li></ol></li></ul><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-3-12.png" alt="进程之间通信时的死锁"></p><blockquote><p>现在进一步介绍竞争可消耗资源所引起的死锁。图3-13示出了在三个进程之间，在利用消息通信机制进行通信时所形成的死锁情况。 </p></blockquote><ol start="3"><li>进程推进顺序不当引起死锁</li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-3-13.png" alt="进程推进顺序对死锁的影响"></p><blockquote><p>除了系统中多个进程对资源的竞争会引发死锁外，进程在运行过程中，对资源进行申请和释放的顺序是否合法，也是在系统中是否会产生死锁的一个重要因素。</p></blockquote><p class="note note-primary">死锁的必要条件</p><p>　　(1) 互斥条件。<br>　　(2) 请求和保持条件。<br>　　(3) 不可抢占条件。<br>　　(4) 循环等待条件。</p><h2 id="3-6-预防死锁"><a href="#3-6-预防死锁" class="headerlink" title="3.6  预防死锁"></a>3.6  预防死锁</h2><blockquote><p>预防死锁的方法是通过破坏产生死锁的四个必要条件中的一个或几个，以避免发生死锁。由于互斥条件是非共享设备所必须的，不仅不能改变，还应加以保证，因此主要是破坏产生死锁的后三个条件。</p></blockquote><p class="note note-primary">破坏“请求和保持”条件</p><blockquote><p>为了能破坏“请求和保持”条件，系统必须保证做到：当一个进程在请求资源时，它不能持有不可抢占资源。该保证可通过如下两个不同的协议实现：</p></blockquote><ol><li>第一种协议</li></ol><blockquote><p>该协议规定，所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源。 </p></blockquote><ol start="2"><li>第二种协议</li></ol><blockquote><p>该协议是对第一种协议的改进，它允许一个进程只获得运行初期所需的资源后，便开始运行。</p></blockquote><p class="note note-primary">破坏“不可抢占”条件</p><blockquote><p>为了能破坏“不可抢占”条件，协议中规定，当一个已经保持了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这意味着进程已占有的资源会被暂时地释放，或者说是被抢占了，从而破坏了“不可抢占”条件。</p></blockquote><p class="note note-primary">破坏“循环等待”条件</p><blockquote><p>一个能保证“循环等待”条件不成立的方法是，对系统所有资源类型进行线性排序，并赋予不同的序号。 </p></blockquote><h2 id="3-7-避免死锁"><a href="#3-7-避免死锁" class="headerlink" title="3.7  避免死锁"></a>3.7  避免死锁</h2><p class="note note-primary">系统安全状态</p><blockquote><p>在死锁避免方法中，把系统的状态分为安全状态和不安全状态。当系统处于安全状态时，可避免发生死锁。反之，当系统处于不安全状态时，则可能进入到死锁状态。</p></blockquote><p class="note note-primary">利用银行家算法避免死锁</p><p>最有代表性的避免死锁的算法是Dijkstra的银行家算法。起这样的名字是由于该算法原本是为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。在OS中也可用它来实现避免死锁。</p><ol><li>银行家算法中的数据结构</li></ol><blockquote><p>为了实现银行家算法，在系统中必须设置这样四个数据结构，分别用来描述系统中可利用的资源、所有进程对资源的最大需求、系统中的资源分配，以及所有进程还需要多少资源的情况。<br>　　(1) 可利用资源向量Available。<br>　　(2) 最大需求矩阵Max。<br>　　(3) 分配矩阵Allocation。<br>　　(4) 需求矩阵Need。</p></blockquote><ol start="2"><li>银行家算法</li></ol><blockquote><p>设Requesti是进程Pi的请求向量，如果Request i[j]=K，表示进程Pi需要K个Rj类型的资源。当Pi发出资源请求后，系统按下述步骤进行检查：<br>　　(1) 如果Request i[j]≤Need[i, j]，便转向步骤(2)； 否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。<br>　　(2) 如果Request i[j]≤Available[j]，便转向步骤(3)； 否则，表示尚无足够资源，Pi须等待。<br>　　(3) 系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值：<br>      　Available[j] = Available[j] - Request i[j];<br>      　Allocation[i, j] = Allocation[i, j] + Request i[j];<br>        Need[i, j] = Need[i, j] - Request i[j];<br>　　(4) 系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。</p></blockquote><p class="note note-primary">安全性算法</p><p>系统所执行的安全性算法可描述如下：</p><p>　　(1) 设置两个向量：<br>    ① 工作向量Work，它表示系统可提供给进程继续运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时，Work := Available；<br>    ② Finish：它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做Finish[i] := false；当有足够资源分配给进程时，再令Finish[i] := true。</p><p>　　(2) 从进程集合中找到一个能满足下述条件的进程：<br>　　① Finish[i]=false;<br>　　② Need[i, j]≤Work[j];<br>　　若找到，执行步骤(3)，否则，执行步骤(4)。</p><p>　　(3) 当进程Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：<br>　　　　Work[j] = Work[j]+Allocation[i, j];<br>　　　　Finish[i] =true;<br>　　　　go to step 2;<br>　　(4) 如果所有进程的Finish[i]=true都满足，则表示系统处于安全状态；否则，系统处于不安全状态。</p><p class="note note-primary">银行家算法之例</p><blockquote><p>假定系统中有五个进程{P0, P1, P2, P3, P4}和三类资源{A, B, C}，各种资源的数量分别为10、5、7，在T0时刻的资源分配情况如图3-15所示。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-3-14.png" alt="T0时刻的资源分配表"></p><p>(1)  T0时刻的安全性：利用安全性算法对T0时刻的资源分配情况进行分析(如图3-16所示)可知，在T0时刻存在着一个安全序列{P1, P3, P4, P2, P0}，故系统是安全的。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-3-15.png" alt="T0时刻的安全序列"></p><p>(2)  P1请求资源：P1发出请求向量Request1(1, 0, 2)，系统按银行家算法进行检查：</p><p>　　① Request1(1, 0, 2)≤Need1(1, 2, 2)；<br>　　② Request1(1, 0, 2)≤Available1(3, 3, 2)；<br>　　③ 系统先假定可为P1分配资源，并修改Available，Allocation1和Need1向量，由此形成的资源变化情况如图3-15中的圆括号所示；<br>　　④ 再利用安全性算法检查此时系统是否安全，如图3-17所示。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-3-16.png" alt="P1申请资源时的安全性检查"></p><p>(3)  P4请求资源：P4发出请求向量Request4(3，3，0)，系统按银行家算法进行检查：<br>　　① Request4(3，3，0)≤Need4(4，3，1)；<br>　　② Request4(3，3，0)＞Available(2，3，0)，让P4等待。<br>　　(4)  P0请求资源：P0发出请求向量Request0(0，2，0)，系统按银行家算法进行检查：<br>　　① Request0(0，2，0)≤Need0(7，4，3)；<br>　　② Request0(0，2，0)≤Available(2，3，0)；<br>　　③ 系统暂时先假定可为P0分配资源，并修改有关数据，如图3-18所示。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-3-17.png" alt="为P0分配资源后的有关资源数据"></p><p>(5) 进行安全性检查：可用资源Available(2，1，0)已不能满足任何进程的需要，故系统进入不安全状态，此时系统不分配资源。</p><h2 id="3-8-死锁检测"><a href="#3-8-死锁检测" class="headerlink" title="3.8  死锁检测"></a>3.8  死锁检测</h2><blockquote><p>如果在系统中，既不采取死锁预防措施，也未配有死锁避免算法，系统很可能会发生死锁。在这种情况下，系统应当提供两个算法：<br>　　① 死锁检测算法。该方法用于检测系统状态，以确定系统中是否发生了死锁。<br>　　② 死锁解除算法。当认定系统中已发生了死锁，利用该算法可将系统从死锁状态中解脱出来。</p></blockquote><h3 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h3><blockquote><p>为了能对系统中是否已发生了死锁进行检测，在系统中必须：<br>① 保存有关资源的请求和分配信息；<br>② 提供一种算法，它利用这些信息来检测系统是否已进入死锁状态。</p></blockquote><p>　　1. 资源分配图(Resource Allocation Graph)</p><p>　　系统死锁，可利用资源分配图来描述。</p><blockquote><p>该图是由一组结点N和一组边E所组成的一个对偶G = (N, E)，它具有下述形式的定义和限制：<br>　　(1) 把N分为两个互斥的子集，即一组进程结点P={P1, P2, …, Pn}和一组资源结点R={R1, R2, …, Rn}，N = P∪R。在图3-19所示的例子中，P = {P1, P2}，R = {R1, R2}，N = {R1, R2}∪{P1, P2}。<br>　　(2) 凡属于E中的一个边e∈E，都连接着P中的一个结点和R中的一个结点，e = {Pi, Rj}是资源请求边，由进程Pi指向资源Rj，它表示进程Pi请求一个单位的Rj资源。E = {Rj, Pi}是资源分配边，由资源Rj指向进程Pi，它表示把一个单位的资源Rj分配给进程Pi。图3-19中示出了两个请求边和两个分配边，即E = {(P1, R2), (R2, P2), (P2, R1), (R1, P1)}。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-3-18.png" alt="每类资源有多个时的情况"></p><h3 id="死锁定理"><a href="#死锁定理" class="headerlink" title="死锁定理"></a>死锁定理</h3><p>我们可以利用把资源分配图加以简化的方法下图，来检测当系统处于S状态时，是否为死锁状态。简化方法如下：</p><p>　　(1) 在资源分配图中，找出一个既不阻塞又非独立的进程结点Pi。在顺利的情况下，Pi可获得所需资源而继续运行，直至运行完毕，再释放其所占有的全部资源，这相当于消去Pi的请求边和分配边，使之成为孤立的结点。在图(a)中，将P1的两个分配边和一个请求边消去，便形成图(b)所示的情况。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-3-19.png" alt="资源分配图的简化"></p><p>　　(2)  P1释放资源后，便可使P2获得资源而继续运行，直至P2完成后又释放出它所占有的全部资源，形成图(c)所示的情况，即将P2的两条请求边和一条分配边消去。<br>　　(3) 在进行一系列的简化后，若能消去图中所有的边，使所有的进程结点都成为孤立结点，则称该图是可完全简化的；若不能通过任何过程使该图完全简化，则称该图是不可完全简化的。</p><p>3．死锁检测中的数据结构<br>　　死锁检测中的数据结构类似于银行家算法中的数据结构：<br>　　(1) 可利用资源向量Available，它表示了m类资源中每一类资源的可用数目。<br>　　(2) 把不占用资源的进程(向量Allocation=0)记入L表中，即Li∪L。<br>　　(3) 从进程集合中找到一个Requesti≤Work的进程，做如下处理：① 将其资源分配图简化，释放出资源，增加工作向量Work =Work + Allocation i。② 将它记入L表中。<br>　　(4) 若不能把所有进程都记入L表中，便表明系统状态S的资源分配图是不可完全简化的。因此，该系统状态将发生死锁。</p><h3 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h3><p>　　1. 终止进程的方法<br>　　1) 终止所有死锁进程</p><blockquote><p>　　这是一种最简单的方法，即是终止所有的死锁进程，死锁自然也就解除了，但所付出的代价可能会很大。因为其中有些进程可能已经运行了很长时间，已接近结束，一旦被终止真可谓“功亏一篑”，以后还得从头再来。还可能会有其它方面的代价，在此不再一一列举。</p></blockquote><p>　　2) 逐个终止进程</p><blockquote><p>　　稍微温和的方法是，按照某种顺序，逐个地终止进程，直至有足够的资源，以打破循环等待，把系统从死锁状态解脱出来为止。但该方法所付出的代价也可能很大。因为每终止一个进程，都需要用死锁检测算法确定系统死锁是否已经被解除，若未解除还需再终止另一个进程。另外，在采取逐个终止进程策略时，还涉及到应采用什么策略选择一个要终止的进程。选择策略最主要的依据是，为死锁解除所付出的“代价最小”。但怎么样才算是“代价最小”，很难有一个精确的度量。</p></blockquote><ol start="2"><li>付出代价最小的死锁解除算法:　　一种付出代价最小的死锁解除算法如图</li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-3-20.png" alt="付出代价最小的死锁解除算法"></p><h2 id="3-9-章节习题"><a href="#3-9-章节习题" class="headerlink" title="3.9  章节习题"></a>3.9  章节习题</h2><ol><li>高级调度与低级调度的主要任务是什么? 为什么要引入中级调度? </li><li>处理机调度算法的共同目标是什么? 批处理系统的调度目标又是什么?</li><li>何谓作业、作业步和作业流? </li><li>在什么情况下需要使用作业控制块JCB，其中包含了哪些内容? </li><li>在作业调度中应如何确定接纳多少个作业和接纳哪些作业?</li><li>为什么要引入高响应比优先调度算法? 它有何优点? </li><li>试说明低级调度的主要功能。</li><li>在抢占调度方式中，抢占的原则是什么? </li><li>在选择调度方式和调度算法时，应遵循的准则是什么? </li><li>在批处理系统、分时系统和实时系统中，各采用哪几种进程(作业)调度算法? </li><li>何谓静态和动态优先级? 确定静态优先级的依据是什么? </li><li>试比较FCFS和SJF两种进程调度算法。</li><li>在时间片轮转法中，应如何确定时间片的大小?</li><li>通过一个例子来说明通常的优先级调度算法为什么不能适用于实时系统? </li><li>为什么说多级反馈队列调度算法能较好地满足各方面用户的需要? </li><li>为什么说传统的几种调度算法都不能算是公平调度算法? </li><li>保证调度算法是如何做到调度的公平性的? </li><li>公平分享调度算法又是如何做到调度的公平性的? </li><li>为什么在实时系统中，要求系统(尤其是CPU)具有较强的处理能力? </li><li>按调度方式可将实时调度算法分为哪几种?</li><li>什么是最早截止时间优先调度算法? 举例说明之。</li><li>什么是最低松弛度优先调度算法? 举例说明之。</li><li>何谓“优先级倒置”现象，可采取什么方法来解决? </li><li>试分别说明可重用资源和可消耗资源的性质。</li><li>试举例说明竞争不可抢占资源所引起的死锁。</li><li>为了破坏“请求和保持”条件而提出了两种协议，试比较这两种协议。</li><li>何谓死锁? 产生死锁的原因和必要条件是什么? </li><li>在解决死锁问题的几个方法中，哪种方法最易于实现? 哪种方法使资源利用率最高? </li><li>请详细说明可通过哪些途径预防死锁。</li></ol><h1 id="第四章-存储器管理"><a href="#第四章-存储器管理" class="headerlink" title="第四章 存储器管理"></a>第四章 存储器管理</h1><p>4.1  存储器的层次结构</p><blockquote><p>对于通用计算机而言，存储层次至少应具有三级：最高层为CPU寄存器，中间为主存，最底层是辅存。在较高档的计算机中，还可以根据具体的功能细分为寄存器、高速缓存、主存储器、磁盘缓存、固定磁盘、可移动存储介质等6层。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-4-1.png" alt="计算机系统存储层次示意"></p><ol><li><p><code>主存储器</code>:主存储器简称内存或主存，是计算机系统中的主要部件，用于保存进程运行时的程序和数据，也称可执行存储器。</p></li><li><p><code>寄存器</code>:寄存器具有与处理机相同的速度，故对寄存器的访问速度最快，完全能与CPU协调工作，但价格却十分昂贵，因此容量不可能做得很大。</p></li><li><p><code>高速缓存</code>:高速缓存是现代计算机结构中的一个重要部件，它是介于寄存器和存储器之间的存储器，主要用于备份主存中较常用的数据，以减少处理机对主存储器的访问次数，这样可大幅度地提高程序执行速度。高速缓存容量远大于寄存器，而比内存约小两到三个数量级左右，从几十KB到几MB，访问速度快于主存储器。 </p></li><li><p><code>磁盘缓存</code>:由于目前磁盘的I/O速度远低于对主存的访问速度，为了缓和两者之间在速度上的不匹配，而设置了磁盘缓存，主要用于暂时存放频繁使用的一部分磁盘数据和信息，以减少访问磁盘的次数。但磁盘缓存与高速缓存不同，它本身并不是一种实际存在的存储器，而是利用主存中的部分存储空间暂时存放从磁盘中读出(或写入)的信息。主存也可以看作是辅存的高速缓存，因为，辅存中的数据必须复制到主存方能使用，反之，数据也必须先存在主存中，才能输出到辅存。</p></li></ol><p>4.2  程序的装入和链接</p><p>用户程序要在系统中运行，必须先将它装入内存，然后再将其转变为一个可以执行的程序，通常都要经过以下几个步骤：</p><p>　　(1) 编译，由编译程序(Compiler)对用户源程序进行编译，形成若干个目标模块(Object Module)；<br>　　(2) 链接，由链接程序(Linker)将编译后形成的一组目标模块以及它们所需要的库函数链接在一起，形成一个完整的装入模块(Load Module)；<br>　　(3) 装入，由装入程序(Loader)将装入模块装入内存。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-4-2.png" alt="对用户程序的处理步骤"></p><p>4.3  连续分配存储管理方式</p><p>单一连续分配</p><blockquote><p>在单道程序环境下，当时的存储器管理方式是把内存分为系统区和用户区两部分，系统区仅提供给OS使用，它通常是放在内存的低址部分。而在用户区内存中，仅装有一道用户程序，即整个内存的用户空间由该程序独占。这样的存储器分配方式被称为单一连续分配方式。</p></blockquote><p>固定分区分配</p><blockquote><p>(1) 分区大小相等(指所有的内存分区大小相等)。(2) 分区大小不等。</p></blockquote><p>内存分配</p><blockquote><p>为了便于内存分配，通常将分区按其大小进行排队，并为之建立一张分区使用表，其中各表项包括每个分区的起始地址、大小及状态(是否已分配)</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-4-3.png" alt="固定分区使用表"></p><ol><li>动态分区分配中的数据结构: 常用的数据结构有以下两种形式：</li></ol><p>① 空闲分区表，在系统中设置一张空闲分区表，用于记录每个空闲分区的情况。每个空闲分区占一个表目，表目中包括分区号、分区大小和分区始址等数据项。<br>② 空闲分区链。为了实现对空闲分区的分配和链接，在每个分区的起始部分设置一些用于控制分区分配的信息，以及用于链接各分区所用的前向指针，在分区尾部则设置一后向指针。通过前、后向链接指针，可将所有的空闲分区链接成一个双向链，</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-4-4.png" alt="空闲分区表"></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-4-5.png" alt="空闲链结构"></p><ol start="2"><li>动态分区分配算法</li></ol><blockquote><p>为把一个新作业装入内存，须按照一定的分配算法，从空闲分区表或空闲分区链中选出一分区分配给该作业。由于内存分配算法对系统性能有很大的影响，故人们对它进行了较为广泛而深入的研究，于是产生了许多动态分区分配算法。</p></blockquote><ol start="3"><li>分区分配操作</li></ol><p>　　1) 分配内存</p><blockquote><p>系统应利用某种分配算法，从空闲分区链(表)中找到所需大小的分区。设请求的分区大小为u.size，表中每个空闲分区的大小可表示为m.size。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-4-6.png" alt="内存分配流程"></p><p>基于顺序搜索的动态分区分配算法</p><ul><li>首次适应(first fit，FF)算法</li><li>循环首次适应(next fit，NF)算法</li><li>最佳适应(best fit，BF)算法</li><li>最坏适应(worst fit，WF)算法</li></ul><p>基于索引搜索的动态分区分配算法</p><ul><li>快速适应(quick fit)算法</li><li>伙伴系统(buddy system)</li><li>哈希算法</li></ul><p>紧凑</p><blockquote><p>连续分配方式的一个重要特点是，一个系统或用户程序必须被装入一片连续的内存空间中。当一台计算机运行了一段时间后，它的内存空间将会被分割成许多小的分区，而缺乏大的空闲空间。即使这些分散的许多小分区的容量总和大于要装入的程序，但由于这些分区不相邻接，也无法把该程序装入内存。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-4-7.png" alt="紧凑的示意"></p><p>动态重定位</p><blockquote><p>作业装入内存后的所有地址仍然都是相对(逻辑)地址。而将相对地址转换为绝对(物理)地址的工作被推迟到程序指令要真正执行时进行。为使地址的转换不会影响到指令的执行速度，必须有硬件地址变换机构的支持，即须在系统中增设一个重定位寄存器，用它来存放程序(数据)在内存中的起始地址。程序在执行时，真正访问的内存地址是相对地址与重定位寄存器中的地址相加而形成的。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-4-7.png" alt="动态重定位示意图"></p><p>动态重定位分区分配算法</p><blockquote><p>动态重定位分区分配算法与动态分区分配算法基本上相同，差别仅在于：在这种分配算法中，增加了紧凑的功能。通常，当该算法不能找到一个足够大的空闲分区以满足用户需求时，如果所有的小的空闲分区的容量总和大于用户的要求，这时便须对内存进行“紧凑”，将经“紧凑”后所得到的大空闲分区分配给用户。如果所有的小的空闲分区的容量总和仍小于用户的要求，则返回分配失败信息。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-4-9.png" alt="动态分区分配算法流程图"></p><p>4.4  对换(Swapping)</p><blockquote><p>系统把所有的用户作业存放在磁盘上，每次只能调入一个作业进入内存，当该作业的一个时间片用完时，将它调至外存的后备队列上等待，再从后备队列上将另一个作业调入内存。这就是最早出现的分时系统中所用的对换技术。</p></blockquote><p>4.5  分页存储管理方式</p><p>(1) 分页存储管理方式。</p><ol><li><p>页面和物理块<br>　　(1) 页面。<br>　　(2) 页面大小。</p></li><li><p>地址结构<br>　　分页地址中的地址结构如下：</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-4-10.png" alt="动态分区分配算法流程图"></p><p>对某特定机器，其地址结构是一定的。若给定一个逻辑地址空间中的地址为A，页面的大小为L，则页号P和页内地址d可按下式求得：</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/czxt-4-11.png" alt="动态分区分配算法流程图"></p><ol start="3"><li>页表</li></ol><blockquote><p>在分页系统中，允许将进程的各个页离散地存储在内存的任一物理块中，为保证进程仍然能够正确地运行，即能在内存中找到每个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表。 </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216154051322.png" alt="页表的作用"></p><p>地址变换机构</p><ol><li><p>基本的地址变换机构</p><blockquote><p>进程在运行期间，需要对程序和数据的地址进行变换，即将用户地址空间中的逻辑地址变换为内存空间中的物理地址，由于它执行的频率非常高，每条指令的地址都需要进行变换，因此需要采用硬件来实现。页表功能是由一组专门的寄存器来实现的。一个页表项用一个寄存器。</p></blockquote></li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216154231564.png" alt="分页系统的地址变换机构"></p><ol start="2"><li><p>具有快表的地址变换机构</p><blockquote><p>由于页表是存放在内存中的，这使CPU在每存取一个数据时，都要两次访问内存。第一次是访问内存中的页表，从中找到指定页的物理块号，再将块号与页内偏移量W拼接，以形成物理地址。第二次访问内存时，才是从第一次所得地址中获得所需数据(或向此地址中写入数据)。因此，采用这种方式将使计算机的处理速度降低近1/2。可见，以此高昂代价来换取存储器空间利用率的提高，是得不偿失的。</p></blockquote></li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216154539325.png" alt="具有快表的地址变换机构"></p><blockquote><p>在引入快表的分页存储管理方式中，通过快表查询，可以直接得到逻辑页所对应的物理块号，由此拼接形成实际物理地址，减少了一次内存访问，缩短了进程访问内存的有效时间。但是，由于快表的容量限制，不可能将一个进程的整个页表全部装入快表，所以在快表中查找到所需表项存在着命中率的问题。所谓命中率，是指使用快表并在其中成功查找到所需页面的表项的比率。</p></blockquote><p>多级页表</p><blockquote><p>对于32位的机器，采用两级页表结构是合适的，但对于64位的机器，采用两级页表是否仍然合适，须做以下简单分析。如果页面大小仍采用4 KB即212 B，那么还剩下52位，假定仍按物理块的大小(212位)来划分页表，则将余下的42位用于外层页号。此时在外层页表中可能有4096 G个页表项，要占用16 384 GB的连续内存空间。</p></blockquote><p>(2) 分段存储管理方式。</p><blockquote><p>通常，用户把自己的作业按照逻辑关系划分为若干个段，每个段都从0开始编址，并有自己的名字和长度。因此，程序员们都迫切地需要访问的逻辑地址是由段名(段号)和段内偏移量(段内地址)决定的，这不仅可以方便程序员编程，也可使程序非常直观，更具可读性。例如，下述的两条指令便使用段名和段内地址：　  LOAD 1，[A] |〈D〉；　　　  STORE 1，[B] |〈C〉；</p></blockquote><p>动态链接</p><blockquote><p>为了提高内存的利用率，系统只将真正要运行的目标程序装入内存，也就是说，动态链接在作业运行之前，并不是把所有的目标程序段都链接起来。当程序要运行时，首先将主程序和它立即需要用到的目标程序装入内存，即启动运行。而在程序运行过程中，当需要调用某个目标程序时，才将该段(目标程序)调入内存并进行链接。</p></blockquote><p>分段系统的基本原理  </p><ol><li><p>分段</p><blockquote><p>在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。例如，有主程序段MAIN、子程序段X、数据段D及栈段S等。 </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216155618056.png" alt="image-20210216155618056"></p></li><li><p>段表</p><blockquote><p>在前面所介绍的动态分区分配方式中，系统为整个进程分配一个连续的内存空间。而在分段式存储管理系统中，则是为每个分段分配一个连续的分区。进程中的各个段，可以离散地装入内存中不同的分区中。为保证程序能正常运行，就必须能从物理内存中找出每个逻辑段所对应的位置。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216155650427.png" alt="image-20210216155650427"></p></li><li><p>地址变换机构</p><blockquote><p>为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了段表寄存器，用于存放段表始址和段表长度TL。在进行地址变换时，系统将逻辑地址中的段号与段表长度TL进行比较。若S&gt;TL，表示段号太大，是访问越界，于是产生越界中断信号。若未越界，则根据段表的始址和该段的段号，计算出该段对应段表项的位置，从中读出该段在内存的起始地址。然后，再检查段内地址d是否超过该段的段长SL。若超过，即d&gt;SL，同样发出越界中断信号。若未越界，则将该段的基址d与段内地址相加，即可得到要访问的内存物理地址。</p></blockquote></li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216155751415.png" alt="分段系统的地址变换过程"></p><p>分页和分段的主要区别</p><p>　　(1) 页是信息的物理单位。</p><p>　　(2) 页的大小固定且由系统决定。</p><p>　　(3) 分页的用户程序地址空间是一维的。</p><p>(3) 段页式存储管理方式。</p><blockquote><p>段页式系统的基本原理是分段和分页原理的结合，即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。图(a)示出了一个作业地址空间的结构。该作业有三个段：主程序段、子程序段和数据段；页面大小为 4 KB。在段页式系统中，其地址结构由段号、段内页号及页内地址三部分所组成，如图(b)所示。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216155943786.png" alt="作业地址空间和地址结构"></p><p>在段页式系统中，为了实现从逻辑地址到物理地址的变换，系统中需要同时配置段表和页表。段表的内容与分段系统略有不同，它不再是内存始址和段长，而是页表始址和页表长度。下图示出了利用段表和页表进行从用户地址空间到物理(内存)空间的映射。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216160010281.png" alt="利用段表和页表实现地址映射"></p><ol start="2"><li><p>地址变换过程</p><blockquote><p>在段页式系统中，为了便于实现地址变换，须配置一个段表寄存器，其中存放段表始址和段长TL。进行地址变换时，首先利用段号S，将它与段长TL进行比较。若S &lt; TL，表示未越界，于是利用段表始址和段号来求出该段所对应的段表项在段表中的位置，从中得到该段的页表始址，并利用逻辑地址中的段内页号P来获得对应页的页表项位置，从中读出该页所在的物理块号b，再利用块号b和页内地址来构成物理地址。图4-25示出了段页式系统中的地址变换机构。</p></blockquote></li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216160059784.png" alt="段页式系统中的地址变换机构"></p><ol><li><p>为什么要配置层次式存储器? </p></li><li><p>可采用哪几种方式将程序装入内存? 它们分别适用于何种场合? </p></li><li><p>何谓静态链接? 静态链接时需要解决两个什么问题? </p></li><li><p>何谓装入时动态链接? 装入时动态链接方式有何优点? </p></li><li><p>何谓运行时动态链接? 运行时动态链接方式有何优点?</p></li><li><p>在动态分区分配方式中，应如何将各空闲分区链接成空闲分区链? </p></li><li><p>为什么要引入动态重定位? 如何实现? </p></li><li><p>什么是基于顺序搜索的动态分区分配算法? 它可分为哪几种? </p></li><li><p>在采用首次适应算法回收内存时，可能出现哪几种情况? 应怎样处理这些情况? </p></li><li><p>什么是基于索引搜索的动态分区分配算法? 它可分为哪几种?</p></li><li><p>令buddyk(x)为大小为2k、地址为x的块的伙伴系统地址，试写出buddyk(x)的通用表达式。</p></li><li><p>分区存储管理中常用哪些分配策略? 比较它们的优缺点。</p></li><li><p>为什么要引入对换? 对换可分为哪几种类型? </p></li><li><p>对文件区管理的目标和对对换空间管理的目标有何不同? </p></li><li><p>为实现对换，系统应具备哪几方面的功能? </p></li><li><p>在以进程为单位进行对换时，每次是否都将整个进程换出? 为什么? </p></li><li><p>基于离散分配时所用的基本单位不同，可将离散分配分为哪几种? </p></li><li><p>什么是页面? 什么是物理块? 页面的大小应如何确定? </p></li><li><p>什么是页表? 页表的作用是什么? </p></li><li><p>为实现分页存储管理，需要哪些硬件支持? </p></li><li><p>在分页系统中是如何实现地址变换的? </p></li><li><p>具有快表时是如何实现地址变换的? </p></li><li><p>较详细地说明引入分段存储管理是为了满足用户哪几方面的需要。</p></li><li><p>在具有快表的段页式存储管理方式中，如何实现地址变换? </p></li><li><p>为什么说分段系统比分页系统更易于实现信息的共享和保护? </p></li><li><p>分页和分段存储管理有何区别? </p></li><li><p>试全面比较连续分配和离散分配方式。</p></li></ol><h1 id="第五章-虚拟存储器"><a href="#第五章-虚拟存储器" class="headerlink" title="第五章    虚拟存储器"></a>第五章    虚拟存储器</h1><h2 id="5-1-虚拟存储器概述"><a href="#5-1-虚拟存储器概述" class="headerlink" title="5.1  虚拟存储器概述"></a>5.1  虚拟存储器概述</h2><p>虚拟存储器的定义</p><blockquote><p>当用户看到自己的程序能在系统中正常运行时，他会认为，该系统所具有的内存容量一定比自己的程序大，或者说，用户所感觉到的内存容量会比实际内存容量大得多。但用户所看到的大容量只是一种错觉，是虚的，故人们把这样的存储器称为虚拟存储器。</p></blockquote><p>背景</p><blockquote><p>存储器管理方式有一个共同的特点，即它们都要求将一个作业全部装入内存后方能运行。于是，出现了下面这样两种情况：</p><p>　　(1) 有的作业很大，其所要求的内存空间超过了内存总容量，作业不能全部被装入内存，致使该作业无法运行；</p><p>　　(2) 有大量作业要求运行，但由于内存容量不足以容纳所有这些作业，只能将少数作业装入内存让它们先运行，而将其它大量的作业留在外存上等待。</p></blockquote><blockquote><p>基于局部性原理可知，应用程序在运行之前没有必要将之全部装入内存，而仅须将那些当前要运行的少数页面或段先装入内存便可运行，其余部分暂留在盘上。 </p></blockquote><p>虚拟存储器的特征</p><p>(1) 多次性。</p><p>(2) 对换性。</p><p>(3) 虚拟性。</p><p>虚拟存储器的实现方法</p><ol><li><p>分页请求系统</p><ol><li>硬件支持</li></ol><p>　　主要的硬件支持有：(1) 请求分页的页表机制。(2) 缺页中断机构。(3) 地址变换机构。</p></li><li><p>请求分段系统</p></li></ol><p>　　1) 硬件支持</p><p>　　主要的硬件支持有：(1) 请求分段的段表机制。(2) 缺页中断机构。(3) 地址变换机构。</p><p>​        2) 软件支持</p><h2 id="5-2-请求分页存储管理方式"><a href="#5-2-请求分页存储管理方式" class="headerlink" title="5.2  请求分页存储管理方式"></a>5.2  请求分页存储管理方式</h2><blockquote><p>为了实现请求分页，系统必须提供一定的硬件支持。计算机系统除了要求一定容量的内存和外存外，还需要有请求页表机制、缺页中断机构以及地址变换机构。</p></blockquote><ol><li><p>请求页表机制</p><blockquote><p>在请求分页系统中需要的主要数据结构是请求页表，其基本作用仍然是将用户地址空间中的逻辑地址映射为内存空间中的物理地址。为了满足页面换进换出的需要，在请求页表中又增加了四个字段。这样，在请求分页系统中的每个页表应含以下诸项：</p></blockquote></li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216180800714.png" alt="image-20210216180800714"></p><ol start="2"><li><p>缺页中断机构</p><p>(1) 在指令执行期间产生和处理中断信号。</p><p> 　　(2) 一条指令在执行期间可能产生多次缺页中断。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216181249102.png" alt="涉及6次缺页中断的指令"></p><ol start="3"><li><p>地址变换机构</p><blockquote><p>请求分页系统中的地址变换机构是在分页系统地址变换机构的基础上，为实现虚拟存储器，再增加了某些功能所形成的，如产生和处理缺页中断，以及从内存中换出一页的功能等等。图示出了请求分页系统中的地址变换过程。</p></blockquote></li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216181345253.png" alt="请求分页中的地址变换过程"></p><h3 id="请求分页中的内存分配"><a href="#请求分页中的内存分配" class="headerlink" title="请求分页中的内存分配"></a>请求分页中的内存分配</h3><ol><li><p>最小物理块数的确定:</p><blockquote><p>一个显而易见的事实是，随着为每个进程所分配的物理块的减少，将使进程在执行中的缺页率上升，从而会降低进程的执行速度。为使进程能有效地工作，应为它分配一定数目的物理块，但这并不是最小物理块数的概念。</p></blockquote></li><li><p>内存分配策略</p><blockquote><p>在请求分页系统中，可采取两种内存分配策略，即固定和可变分配策略。在进行置换时，也可采取两种策略，即全局置换和局部置换。于是可组合出以下三种适用的策略。</p></blockquote></li></ol><ol><li><p>固定分配局部置换(Fixed Allocation，Local Replacement)</p></li><li><p>可变分配全局置换(Variable Allocation，Global Replacement)</p></li><li><p>可变分配局部置换(Variable Allocation，Local Replacement)</p></li></ol><ol start="3"><li><p>物理块分配算法</p><p>在采用固定分配策略时，如何将系统中可供分配的所有物理块分配给各个进程，可采用下述几种算法：</p><p>　　(1) 平均分配算法，即将系统中所有可供分配的物理块平均分配给各个进程。 </p><p>　　(2) 按比例分配算法，即根据进程的大小按比例分配物理块。如果系统中共有n个进程，每个进程的页面数为Si，</p></li></ol><h2 id="5-3-页面置换算法"><a href="#5-3-页面置换算法" class="headerlink" title="5.3  页面置换算法"></a>5.3  页面置换算法</h2><blockquote><p>在进程运行过程中，若其所要访问的页面不在内存，而需把它们调入内存，但内存已无空闲空间时，为了保证该进程能正常运行，系统必须从内存中调出一页程序或数据送到磁盘的对换区中。但应将哪个页面调出，须根据一定的算法来确定。通常，把选择换出页面的算法称为页面置换算法(Page-Replacement Algorithms)。置换算法的好坏将直接影响到系统的性能。</p></blockquote><p>1.最佳(Optimal)置换算法</p><blockquote><p>最佳置换算法是由Belady于1966年提出的一种理论上的算法。其所选择的被淘汰页面将是以后永不使用的，或许是在最长(未来)时间内不再被访问的页面。采用最佳置换算法通常可保证获得最低的缺页率。但由于人们目前还无法预知，一个进程在内存的若干个页面中，哪一个页面是未来最长时间内不再被访问的，因而该算法是无法实现的，但可以利用该算法去评价其它算法。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216190124261.png" alt="利用最佳页面置换算法时的置换图"></p><p>2.先进先出(FIFO)页面置换算法</p><blockquote><p>FIFO算法是最早出现的置换算法。该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。该算法实现简单，只需把一个进程已调入内存的页面按先后次序链接成一个队列，并设置一个指针，称为替换指针，使它总是指向最老的页面。但该算法与进程实际运行的规律不相适应，因为在进程中，有些页面经常被访问，比如，含有全局变量、常用函数、例程等的页面，FIFO算法并不能保证这些页面不被淘汰。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216190205572.png" alt="利用FIFO置换算法时的置换图"></p><p>3.LRU(Least Recently Used)置换算法的描述</p><blockquote><p>FIFO置换算法的性能之所以较差，是因为它所依据的条件是各个页面调入内存的时间，而页面调入的先后并不能反映页面的使用情况。最近最久未使用(LRU)的页面置换算法是根据页面调入内存后的使用情况做出决策的。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216190302531.png" alt="LRU页面置换算法"></p><p>4.最少使用(Least Frequently Used，LFU)置换算法</p><blockquote><p>在采用LFU算法时，应为在内存中的每个页面设置一个移位寄存器，用来记录该页面被访问的频率。该置换算法选择在最近时期使用最少的页面作为淘汰页。</p></blockquote><p>5.Clock置换算法</p><blockquote><p>简单的Clock置换算法:当利用简单Clock算法时，只需为每页设置一位访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216190520014.png" alt="简单Clock置换算法的流程和示例"></p><blockquote><p>改进型Clock置换算法:在将一个页面换出时，如果该页已被修改过，便须将该页重新写回到磁盘上；但如果该页未被修改过，则不必将它拷回磁盘。换而言之，对于修改过的页面，在换出时所付出的开销比未修改过的页面大，或者说，置换代价大。在改进型Clock算法中，除须考虑页面的使用情况外，还须再增加一个因素——置换代价。</p></blockquote><p>6.页面缓冲算法(Page Buffering Algorithm，PBA)</p><blockquote><p>PBA算法的主要特点是：① 显著地降低了页面换进、换出的频率，使磁盘I/O的操作次数大为减少，因而减少了页面换进、换出的开销；② 正是由于换入换出的开销大幅度减小，才能使其采用一种较简单的置换策略，如先进先出(FIFO)算法，它不需要特殊硬件的支持，实现起来非常简单。 </p><p>　　1) 空闲页面链表</p><p>　　2) 修改页面链表</p></blockquote><h2 id="5-4-“抖动”与工作集"><a href="#5-4-“抖动”与工作集" class="headerlink" title="5.4  “抖动”与工作集"></a>5.4  “抖动”与工作集</h2><blockquote><p>由于请求分页式虚拟存储器系统的性能优越，在正常运行情况下，它能有效地减少内存碎片，提高处理机的利用率和吞吐量，故是目前最常用的一种系统。但如果在系统中运行的进程太多，进程在运行中会频繁地发生缺页情况，这又会对系统的性能产生很大的影响，故还须对请求分页系统的性能做简单的分析。</p></blockquote><p>产生“抖动”的原因</p><blockquote><p>发生“抖动”的根本原因是，同时在系统中运行的进程太多，由此分配给每一个进程的物理块太少，不能满足进程正常运行的基本要求，致使每个进程在运行时，频繁地出现缺页，必须请求系统将所缺之页调入内存。这会使得在系统中排队等待页面调进/调出的进程数目增加。显然，对磁盘的有效访问时间也随之急剧增加，造成每个进程的大部分时间都用于页面的换进/换出，而几乎不能再去做任何有效的工作，从而导致发生处理机的利用率急剧下降并趋于0的情况。我们称此时的进程是处于“抖动”状态。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216190833631.png" alt="缺页率与物理块数之间的关系"></p><p>工作集的定义</p><blockquote><p>所谓工作集，是指在某段时间间隔Δ里，进程实际所要访问页面的集合。Denning指出，虽然程序只需要少量的几页在内存便可运行，但为了较少地产生缺页，应将程序的全部工作集装入内存中。然而我们无法事先预知程序在不同时刻将访问哪些页面，故仍只有像置换算法那样，用程序的过去某段时间内的行为作为程序在将来某段时间内行为的近似</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216190902846.png" alt="窗口为3、4、5时进程的工作集"></p><p>“抖动”的预防方法</p><ul><li>采取局部置换策略</li><li>把工作集算法融入到处理机调度中</li><li>利用“L=S”准则调节缺页率</li><li>选择暂停的进程</li></ul><h2 id="5-5-请求分段存储管理方式"><a href="#5-5-请求分段存储管理方式" class="headerlink" title="5.5  请求分段存储管理方式"></a>5.5  请求分段存储管理方式</h2><blockquote><p>为了实现请求分段式存储管理，应在系统中配置多种硬件机构，以支持快速地完成请求分段功能。与请求分页系统相似，在请求分段系统中所需的硬件支持有段表机制、缺段中断机构，以及地址变换机构。</p></blockquote><ol><li><p>请求段表机制</p><blockquote><p>　　在请求分段式管理中所需的主要数据结构是请求段表。在该表中除了具有请求分页机制中有的访问字段A、修改位M、存在位P和外存始址四个字段外，还增加了存取方式字段和增补位。这些字段供程序在调进、调出时参考。下面给出请求分段的段表项。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216191114871.png" alt="image-20210216191114871"></p></li><li><p>缺段中断机构</p><blockquote><p>在请求分段系统中采用的是请求调段策略。每当发现运行进程所要访问的段尚未调入内存时，便由缺段中断机构产生一缺段中断信号，进入OS后，由缺段中断处理程序将所需的段调入内存。与缺页中断机构类似，缺段中断机构同样需要在一条指令的执行期间产生和处理中断，以及在一条指令执行期间，可能产生多次缺段中断。但由于分段是信息的逻辑单位，因而不可能出现一条指令被分割在两个分段中，和一组信息被分割在两个分段中的情况。缺段中断的处理过程如图</p></blockquote></li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216191143359.png" alt="请求分段系统中的中断处理过程"></p><ol start="3"><li><p>地址变换机构</p><blockquote><p>请求分段系统中的地址变换机构是在分段系统地址变换机构的基础上形成的。因为被访问的段并非全在内存，所以在地址变换时，若发现所要访问的段不在内存，必须先将所缺的段调入内存，并修改段表，然后才能再利用段表进行地址变换。为此，在地址变换机构中又增加了某些功能，如缺段中断的请求及处理等。</p></blockquote></li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216191219598.png" alt="请求分段系统的地址变换过程"></p><h4 id="分段的共享与保护"><a href="#分段的共享与保护" class="headerlink" title="分段的共享与保护"></a>分段的共享与保护</h4><ol><li><p>共享段表</p><p>(1) 共享进程计数count。</p><p> 　　(2) 存取控制字段。</p><p> 　　(3) 段号。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216191323027.png" alt="共享段表项"></p></li><li><p>共享段的分配与回收　1) 共享段的分配　　2) 共享段的回收</p></li><li><p>分段保护</p><blockquote><p>在分段系统中，由于每个分段在逻辑上是相对独立的，因而比较容易实现信息保护。目前，常采用以下几种措施来确保信息的安全。</p></blockquote></li></ol><ol><li><p>越界检查 2) 存取控制检查 3) 环保护机构</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216191519431.png" alt="环保护机构"></p></li></ol><h2 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h2><ol><li><p>常规存储器管理方式具有哪两大特征? 它对系统性能有何影响? </p></li><li><p>什么是程序运行时的时间局限性和空间局限性? </p></li><li><p>虚拟存储器有哪些特征? 其中最本质的特征是什么? </p></li><li><p>实现虚拟存储器需要哪些硬件支持? </p></li><li><p>实现虚拟存储器需要哪几个关键技术?</p></li><li><p>在请求分页系统中，页表应包括哪些数据项? 每项的作用是什么? </p></li><li><p>试比较缺页中断机构与一般的中断，它们之间有何明显的区别? </p></li><li><p>试说明请求分页系统中的地址变换过程。</p></li><li><p>何谓固定分配局部置换和可变分配全局置换的内存分配策略?</p></li><li><p>在请求分页系统中，应从何处将所需页面调入内存? </p></li><li><p>试说明在请求分页系统中页面的调入过程。</p></li><li><p>在请求分页系统中，常采用哪几种页面置换算法?</p></li><li><p>在一个请求分页系统中，采用FIFO页面置换算法时，假如一个作业的页面走向为4、3、2、1、4、3、5、4、3、2、1、5，当分配给该作业的物理块数M分别为3和4时，试计算在访问过程中所发生的缺页次数和缺页率，并比较所得结果。</p></li><li><p>实现LRU算法所需的硬件支持是什么? </p></li><li><p>试说明改进型Clock置换算法的基本原理。</p></li><li><p>影响页面换进换出效率的若干因素是什么? </p></li><li><p>页面缓冲算法的主要特点是什么? 它是如何降低页面换进、换出的频率的?</p></li><li><p>在请求分页系统中，产生“抖动”的原因是什么?</p></li><li><p>何谓工作集? 它是基于什么原理确定的? </p></li><li><p>当前可以利用哪几种方法来防止“抖动”? </p></li><li><p>试说明如何利用“L=S”准则来调节缺页率，以避免“抖动”的发生。</p></li><li><p>为了实现请求分段式存储管理，应在系统中增加配置哪些硬件机构?</p></li><li><p>在请求段表机制中，应设置哪些段表项? </p></li><li><p>说明请求分段系统中的缺页中断处理过程。</p></li><li><p>请对共享段表中的各项作简要说明。</p></li><li><p>如何实现共享分段的分配和回收? </p></li></ol><h1 id="第六章-输入输出系统"><a href="#第六章-输入输出系统" class="headerlink" title="第六章    输入输出系统"></a>第六章    输入输出系统</h1><h2 id="6-1-I-O系统的功能、模型和接口"><a href="#6-1-I-O系统的功能、模型和接口" class="headerlink" title="6.1  I/O系统的功能、模型和接口"></a>6.1  I/O系统的功能、模型和接口</h2><h3 id="对I-O设备进行控制"><a href="#对I-O设备进行控制" class="headerlink" title="对I/O设备进行控制"></a>对I/O设备进行控制</h3><blockquote><p>对I/O设备进行控制是驱动程序的功能。目前对I/O设备有四种控制方式：</p></blockquote><p>① 采用轮询的可编程I/O方式；</p><p>② 采用中断的可编程I/O方式；</p><p>③ 直接存储器访问方式；</p><p>④ I/O通道方式。 </p><h3 id="设备类型"><a href="#设备类型" class="headerlink" title="设备类型"></a>设备类型</h3><p>(1) 独占设备，进程应互斥地访问这类设备，即系统一旦把这类设备分配给了某进程后，便由该进程独占，直至用完释放。典型的独占设备有打印机、磁带机等。系统在对独占设备进行分配时，还应考虑到分配的安全性。</p><p>(2) 共享设备，是指在一段时间内允许多个进程同时访问的设备。典型的共享设备是磁盘，当有多个进程需对磁盘执行读、写操作时，可以交叉进行，不会影响到读、写的正确性。</p><h3 id="I-O系统的层次结构和模型"><a href="#I-O系统的层次结构和模型" class="headerlink" title="I/O系统的层次结构和模型"></a>I/O系统的层次结构和模型</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216192229518.png" alt="I/O系统的层次结构"></p><h3 id="I-O系统中各种模块之间的层次视图"><a href="#I-O系统中各种模块之间的层次视图" class="headerlink" title="I/O系统中各种模块之间的层次视图"></a>I/O系统中各种模块之间的层次视图</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216192335333.png" alt="I/O系统中各种模块之间的层次视图"></p><h2 id="6-2-I-O设备和设备控制器"><a href="#6-2-I-O设备和设备控制器" class="headerlink" title="6.2  I/O设备和设备控制器"></a>6.2  I/O设备和设备控制器</h2><blockquote><p>I/O设备一般是由执行I/O操作的机械部分和执行控制I/O的电子部件组成。通常将这两部分分开，执行I/O操作的机械部分就是一般的I/O设备，而执行控制I/O的电子部件则称为设备控制器或适配器(adapter)。在微型机和小型机中的控制器常做成印刷电路卡形式，因而也常称为控制卡、接口卡或网卡，可将它插入计算机的扩展槽中。在有的大、中型计算机系统中，还配置了I/O通道或I/O处理机。</p></blockquote><h2 id="6-3-中断机构和中断处理程序"><a href="#6-3-中断机构和中断处理程序" class="headerlink" title="6.3　中断机构和中断处理程序"></a>6.3　中断机构和中断处理程序</h2><blockquote><p>中断在操作系统中有着特殊重要的地位，它是多道程序得以实现的基础，没有中断，就不可能实现多道程序，因为进程之间的切换是通过中断来完成的。另一方面，中断也是设备管理的基础，为了提高处理机的利用率和实现CPU与I/O设备并行执行，也必需有中断的支持。中断处理程序是I/O系统中最低的一层，它是整个I/O系统的基础。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216192547626.png" alt="对多中断的处理方式"></p><h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><blockquote><p>当一个进程请求I/O 操作时，该进程将被挂起，直到I/O设备完成I/O操作后，设备控制器便向CPU发送一个中断请求，CPU响应后便转向中断处理程序，中断处理程序执行相应的处理，处理完后解除相应进程的阻塞状态。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216192624664.png" alt="中断现场保护示意图"></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216192638516.png" alt="中断处理流程"></p><h2 id="6-4-设备驱动程序"><a href="#6-4-设备驱动程序" class="headerlink" title="6.4  设备驱动程序"></a>6.4  设备驱动程序</h2><blockquote><p>设备处理程序通常又称为设备驱动程序，它是I/O系统的高层与设备控制器之间的通信程序，其主要任务是接收上层软件发来的抽象I/O要求，如read或write命令，再把它转换为具体要求后，发送给设备控制器，启动设备去执行；反之，它也将由设备控制器发来的信号传送给上层软件。由于驱动程序与硬件密切相关，故通常应为每一类设备配置一种驱动程序。例如，打印机和显示器需要不同的驱动程序。</p></blockquote><h3 id="设备驱动程序的特点"><a href="#设备驱动程序的特点" class="headerlink" title="设备驱动程序的特点"></a>设备驱动程序的特点</h3><blockquote><p>设备驱动程序属于低级的系统例程，它与一般的应用程序及系统程序之间有下述明显差异：</p><p>　　(1) 驱动程序是实现在与设备无关的软件和设备控制器之间通信和转换的程序，具体说，它将抽象的I/O请求转换成具体的I/O操作后传送给控制器。又把控制器中所记录的设备状态和I/O操作完成情况，及时地反映给请求I/O的进程。</p><p>　　(2) 驱动程序与设备控制器以及I/O设备的硬件特性紧密相关，对于不同类型的设备，应配置不同的驱动程序。但可以为相同的多个终端设置一个终端驱动程序。</p><p>​        (3) 驱动程序与I/O设备所采用的I/O控制方式紧密相关，常用的I/O控制方式是中断驱动和DMA方式。</p><p>　　(4) 由于驱动程序与硬件紧密相关，因而其中的一部分必须用汇编语言书写。目前有很多驱动程序的基本部分已经固化在ROM中。</p><p>　　(5) 驱动程序应允许可重入。一个正在运行的驱动程序常会在一次调用完成前被再次调用。</p></blockquote><h2 id="6-5-与设备无关的I-O软件"><a href="#6-5-与设备无关的I-O软件" class="headerlink" title="6.5  与设备无关的I/O软件"></a>6.5  与设备无关的I/O软件</h2><blockquote><p>为了方便用户和提高OS的可适应性与可扩展性，在现代OS的I/O系统中，都无一例外地增加了与设备无关的I/O软件，以实现设备独立性，也称为设备无关性。其基本含义是：应用程序中所用的设备，不局限于使用某个具体的物理设备。为每个设备所配置的设备驱动程序是与硬件紧密相关的软件。</p></blockquote><h2 id="6-6-用户层的I-O软件"><a href="#6-6-用户层的I-O软件" class="headerlink" title="6.6  用户层的I/O软件"></a>6.6  用户层的I/O软件</h2><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><blockquote><p>一方面，为使诸进程能有条不紊地使用I/O设备，且能保护设备的安全性，不允许运行在用户态的应用进程去直接调用运行在核心态(系统态)的OS过程。但另一方面，应用进程在运行时，又必须取得OS所提供的服务，否则，应用程序几乎无法运行。为了解决此矛盾，OS在用户层中引入了一个中介过程——系统调用，应用程序可以通过它间接调用OS中的I/O过程，对I/O设备进行操作。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216193002999.png" alt="系统调用的执行过程"></p><h3 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h3><blockquote><p>在C语言以及UNIX系统中，系统调用(如read)与各系统调用所使用的库函数(如read)之间几乎是一一对应的。而微软定义了一套过程，称为Win32 API的应用程序接口(Application Program Interface)，程序员利用它们取得OS服务，该接口与实际的系统调用并不一一对应。用户程序通过调用对应的库函数使用系统调用，这些库函数与调用程序连接在一起，被嵌入在运行时装入内存的二进制程序中。</p></blockquote><h3 id="守护进程-daemon"><a href="#守护进程-daemon" class="headerlink" title="守护进程(daemon)"></a>守护进程(daemon)</h3><blockquote><p>前面是利用假脱机系统来实现打印机共享的一种方案，人们对该方案进行了某些修改，如取消该方案中的假脱机管理进程，为打印机建立一个守护进程，由它执行一部分原来由假脱机管理进程实现的功能，如为用户在磁盘缓冲区中申请一个空闲盘块，并将要打印的数据送入其中，将该盘块的首址返回给请求进程。另一部分由请求进程自己完成，每个要求打印的进程首先生成一份要求打印的文件，其中包含对打印的要求和指向装有打印输出数据盘块的指针等信息，然后将用户请求打印文件放入假脱机文件队列(目录)中。</p></blockquote><h2 id="6-7-缓冲区管理"><a href="#6-7-缓冲区管理" class="headerlink" title="6.7  缓冲区管理"></a>6.7  缓冲区管理</h2><blockquote><p>在现代操作系统中，几乎所有的I/O设备在与处理机交换数据时都用了缓冲区。缓冲区是一个存储区域，它可以由专门的硬件寄存器组成，但由于硬件的成本较高，容量也较小，一般仅用在对速度要求非常高的场合，如存储器管理中所用的联想存储器；设备控制器中用的数据缓冲区等。</p></blockquote><h3 id="缓冲的引入"><a href="#缓冲的引入" class="headerlink" title="缓冲的引入"></a>缓冲的引入</h3><blockquote><p>​        (1) 缓和CPU与I/O设备间速度不匹配的矛盾。</p><p>　　(2) 减少对CPU的中断频率，放宽对CPU中断响应时间的限制。</p><p>　　(3) 解决数据粒度不匹配的问题。</p><p>　　(4) 提高CPU和I/O设备之间的并行性。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216193400166.png" alt="利用缓冲寄存器实现缓冲"></p><h3 id="缓冲池-Buffer-Pool"><a href="#缓冲池-Buffer-Pool" class="headerlink" title="缓冲池(Buffer Pool)"></a>缓冲池(Buffer Pool)</h3><ol><li><p>缓冲池的组成</p><p>缓冲池管理着多个缓冲区，每个缓冲区由用于标识和管理的缓冲首部以及用于存放数据的缓冲体两部分组成。缓冲首部一般包括缓冲区号、设备号、设备上的数据块号、同步信号量以及队列链接指针等。为了管理上的方便，一般将缓冲池中具有相同类型的缓冲区链接成一个队列，于是可形成以下三个队列：</p><p>   　　(1) 空白缓冲队列emq。</p><p>   　　(2) 输入队列inq。</p><p>   　　(3) 输出队列outq。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216193634018.png" alt="缓冲区的工作方式"></p><h2 id="6-8-磁盘存储器的性能和调度"><a href="#6-8-磁盘存储器的性能和调度" class="headerlink" title="6.8  磁盘存储器的性能和调度"></a>6.8  磁盘存储器的性能和调度</h2><blockquote><p>磁盘设备可包括一个或多个物理盘片，每个磁盘片分一个或两个存储面(Surface)(见图(a))，每个盘面上有若干个磁道(Track)，磁道之间留有必要的间隙(Gap)。为使处理简单起见，在每条磁道上可存储相同数目的二进制位。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216193712780.png" alt="磁盘的结构和布局"></p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216193730650.png" alt="磁盘的格式化"></p><h3 id="早期的磁盘调度算法"><a href="#早期的磁盘调度算法" class="headerlink" title="早期的磁盘调度算法"></a>早期的磁盘调度算法</h3><ol><li>先来先服务(FCFS)</li><li>最短寻道时间优先(SSTF)</li><li>基于扫描的磁盘调度算法</li><li>NStepSCAN和FSCAN调度算法</li><li>FSCAN算法</li></ol><h2 id="习题-3"><a href="#习题-3" class="headerlink" title="习题"></a>习题</h2><ol><li><p>试说明I/O系统的基本功能。</p></li><li><p>简要说明I/O软件的四个层次的基本功能。</p></li><li><p>I/O系统接口与软件/硬件(RW/HW)接口分别是什么接口?</p></li><li><p>与设备无关性的基本含义是什么? 为什么要设置该层?</p></li><li><p>试说明设备控制器的组成。</p></li><li><p>为了实现CPU与设备控制器间的通信，设备控制器应具备哪些功能?</p></li><li><p>什么是内存映像I/O? 它是如何实现的?</p></li><li><p>为什么说中断是OS赖以生存的基础?</p></li><li><p>对多中断源的两种处理方式分别用于何种场合?</p></li><li><p>设备中断处理程序通常需完成哪些工作?</p></li><li><p>简要说明中断处理程序对中断进行处理的几个步骤。</p></li><li><p>试说明设备驱动程序具有哪些特点。</p></li><li><p>设备驱动程序通常要完成哪些工作?</p></li><li><p>简要说明设备驱动程序的处理过程可分为哪几步。</p></li><li><p>试说明推动I/O控制发展的主要因素是什么。</p></li><li><p>有哪几种I/O控制方式? 各适用于何种场合?</p></li><li><p>试说明DMA的工作流程。</p></li><li><p>为何要引入与设备的无关性? 如何实现设备的独立性?</p></li><li><p>与设备的无关的软件中，包括了哪些公有操作的软件?</p></li><li><p>在考虑到设备的独立性时，应如何分配独占设备?</p></li><li><p>何谓设备虚拟? 实现设备虚拟时所依赖的关键技术是什么?</p></li><li><p>在实现后台打印时，SPOOLing系统应为请求I/O的进程提供哪些服务?</p></li><li><p>假脱机系统向用户提供共享打印机的基本思想是什么?</p></li><li><p>引入缓冲的主要原因是什么?</p></li><li><p>在单缓冲情况下，为什么系统对一块数据的处理时间为max(C, T) + M?</p></li><li><p>为什么在双缓冲情况下，系统对一块数据的处理时间为max(T, C)?</p></li><li><p>试绘图说明把多缓冲用于输出时的情况。</p></li><li><p>试说明收容输入工作缓冲区和提取输出工作缓冲区的工作情况。</p></li><li><p>何谓安全分配方式和不安全分配方式?</p></li><li><p>磁盘访问时间由哪几部分组成? 每部分时间应如何计算?</p></li><li><p>目前常用的磁盘调度算法有哪几种? 每种算法优先考虑的问题是什么?</p></li></ol><h1 id="第七章-文-件-管-理"><a href="#第七章-文-件-管-理" class="headerlink" title="第七章    文  件  管  理"></a>第七章    文  件  管  理</h1><h2 id="7-1-文件和文件系统"><a href="#7-1-文件和文件系统" class="headerlink" title="7.1  文件和文件系统"></a>7.1  文件和文件系统</h2><blockquote><p>文件系统的管理功能是将其管理的程序和数据通过组织为一系列文件的方式实现的。而文件则是指具有文件名的若干相关元素的集合。元素通常是记录，而记录又是一组有意义的数据项的集合。可见，基于文件系统的概念，可以把数据组成分为数据项、记录和文件三级</p></blockquote><h3 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h3><blockquote><p>记录是一组相关数据项的集合，用于描述一个对象在某方面的属性。一个记录应包含哪些数据项，取决于需要描述对象的哪个方面。由于对象所处的环境不同可把他作为不同的对象。</p></blockquote><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><blockquote><p>文件是指由创建者所定义的、具有文件名的一组相关元素的集合，可分为有结构文件和无结构文件两种。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216194307922.png" alt="文件、记录和数据项之间的层次关系"></p><h3 id="文件系统的层次结构"><a href="#文件系统的层次结构" class="headerlink" title="文件系统的层次结构"></a>文件系统的层次结构</h3><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216194340682.png" alt="文件系统模型"></p><h2 id="7-2-文件的逻辑结构"><a href="#7-2-文件的逻辑结构" class="headerlink" title="7.2  文件的逻辑结构"></a>7.2  文件的逻辑结构</h2><p>(1) 顺序文件。</p><blockquote><p>顺序文件的最佳应用场合是在对文件中的记录进行批量存取时(即每次要读或写一大批记录)。所有逻辑文件中顺序文件的存取效率是最高的。此外，对于顺序存储设备(如磁带)，也只有顺序文件才能被存储并能有效地工作。</p></blockquote><p>(2) 索引文件。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216194453326.png" alt="具有单个和多个索引表的索引文件"></p><p>(3) 索引顺序文件。</p><blockquote><p>索引顺序文件是对顺序文件的一种改进，它基本上克服了变长记录的顺序文件不能随机访问，以及不便于记录的删除和插入的缺点。但它仍保留了顺序文件的关键特征，即记录是按关键字的顺序组织起来的。它又增加了两个新特征：一个是引入了文件索引表，通过该表可以实现对索引顺序文件的随机访问；另一个是增加了溢出(overflow)文件，用它来记录新增加的、删除的和修改的记录。 </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216194546037.png" alt="索引顺序文件"></p><h2 id="7-3-文件目录"><a href="#7-3-文件目录" class="headerlink" title="7.3  文件目录"></a>7.3  文件目录</h2><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><p>(1) 创建目录。</p><p>(2) 删除目录。</p><p>​    ① 不删除非空目录。</p><p>​    ② 可删除非空目录。</p><p>(3) 改变目录。</p><p>(4) 移动目录。</p><p>(5) 链接(Link)操作。</p><p>(6) 查找。</p><h2 id="7-4-文件共享"><a href="#7-4-文件共享" class="headerlink" title="7.4  文件共享"></a>7.4  文件共享</h2><h2 id="7-5-文件保护"><a href="#7-5-文件保护" class="headerlink" title="7.5  文件保护"></a>7.5  文件保护</h2><p>(1) 通过存取控制机制，防止由人为因素所造成的文件不安全性。</p><p>(2) 采取系统容错技术，防止系统部分的故障所造成的文件的不安全性。</p><p>(3) 建立后备系统，防止由自然因素所造成的不安全性。</p><h2 id="习题-4"><a href="#习题-4" class="headerlink" title="习题"></a>习题</h2><ol><li><p>何谓数据项、记录和文件? </p></li><li><p>文件系统的模型可分为三层，试说明其每一层所包含的基本内容。</p></li><li><p>与文件系统有关的软件可分为哪几个层次?</p></li><li><p>试说明用户可以对文件施加的主要操作有哪些。</p></li><li><p>为什么在大多数OS中都引入了“打开”这一文件系统调用? 打开的含意是什么? </p></li><li><p>何谓文件的逻辑结构? 何谓文件的物理结构? </p></li><li><p>按文件的组织方式可将文件分为哪几种类型? </p></li><li><p>如何提高对变长记录顺序文件的检索速度?</p></li><li><p>通过哪两种方式来对固定长记录实现随机访问? </p></li><li><p>可以采取什么方法来实现对变长记录文件进行随机检索? </p></li><li><p>试说明索引顺序文件的几个主要特征。</p></li><li><p>试说明对索引文件和索引顺序文件的检索方法。</p></li><li><p>试从检索速度和存储费用两方面来比较两级索引文件和索引顺序文件。</p></li><li><p>对目录管理的主要要求是什么? </p></li><li><p>采用单级目录能否满足对目录管理的主要要求? 为什么?</p></li><li><p>目前广泛采用的目录结构形式是哪种? 它有什么优点? </p></li><li><p>何谓路径名和当前目录? </p></li><li><p>Hash检索法有何优点? 又有何局限性? </p></li><li><p>在Hash检索法中，如何解决“冲突”问题? </p></li><li><p>试说明在树形目录结构中线性检索法的检索过程，并给出相应的流程图。</p></li><li><p>基于索引结点的文件共享方式有何优点? </p></li><li><p>什么是主父目录和链接父目录? 如何利用符号链实现共享?</p></li><li><p>基于符号链的文件共享方式有何优点? </p><pre><code> 　　24. 什么是保护域? 进程与保护域之间存在着的动态联系是什么? 　　25. 试举例说明具有域切换权的访问控制矩阵。          　　26. 如何利用拷贝权来扩散某种访问权?             　　27. 如何利用拥有权来增、删某种访问权?         　　28.  增加控制权的主要目的是什么? 试举例说明控制权的应用。                   　　29. 什么是访问控制表? 什么是访问权限表?                     　　30. 系统如何利用访问控制表和访问权限表来实现对文件的保护? </code></pre></li></ol><h1 id="第八章-磁盘存储器的管理"><a href="#第八章-磁盘存储器的管理" class="headerlink" title="第八章    磁盘存储器的管理"></a>第八章    磁盘存储器的管理</h1><h2 id="8-1-外存的组织方式"><a href="#8-1-外存的组织方式" class="headerlink" title="8.1  外存的组织方式"></a>8.1  外存的组织方式</h2><p>外存组织方式有：</p><p>(1) 连续组织方式。</p><blockquote><p>连续组织方式又称连续分配方式，要求为每一个文件分配一组相邻接的盘块。例如，第一个盘块的地址为b，则第二个盘块的地址为b+1，第三个盘块的地址为b+2，…。通常，它们都位于一条磁道上，在进行读/写时，不必移动磁头。在采用连续组织方式时，可把逻辑文件中的记录顺序地存储到邻接的各物理盘块中，这样所形成的文件结构称为顺序文件结构，此时的物理文件称为顺序文件。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216195218801.png" alt="磁盘空间的连续组织方式"></p><p>连续组织方式的主要优点有：(1) 顺序访问容易。(2) 顺序访问速度快。 </p><p>(2) 链接组织方式。</p><blockquote><p>如果可以将文件装到多个离散的盘块中，就可消除连续组织方式的上述缺点。在采用链接组织方式时，可为文件分配多个不连续的盘块，再通过每个盘块上的链接指针，将同属于一个文件的多个离散的盘块链接成一个链表，由此所形成的物理文件称为链接文件。</p></blockquote><p>链接组织方式的主要优点是：</p><p>　　(1) 消除了磁盘的外部碎片，提高了外存的利用率。</p><p>　　(2) 对插入、删除和修改记录都非常容易。</p><p>　　(3) 能适应文件的动态增长，无需事先知道文件的大小。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216195408226.png" alt="磁盘空间的链接式分配"></p><p>(3) 索引组织方式。 </p><h2 id="8-2-文件存储空间的管理"><a href="#8-2-文件存储空间的管理" class="headerlink" title="8.2  文件存储空间的管理"></a>8.2  文件存储空间的管理</h2><p>FAT技术</p><ol><li><p>FAT12 </p><ol><li>早期的FAT12文件系统 </li></ol><blockquote><p>FAT12是以盘块为基本分配单位的。由于FAT是文件系统中最重要的数据结构，为了安全起见，在每个分区中都配有两张相同的文件分配表FAT1和FAT2。在FAT的每个表项中存放下一个盘块号，它实际上是用于盘块之间的链接的指针，通过它可以将一个文件的所有的盘块链接起来，而将文件的第一个盘块号放在自己的FCB中。</p></blockquote></li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216210627798.png" alt="MS-DOS的文件物理结构"></p><p>​        2) 以簇为单位的FAT12文件系统 </p><blockquote><p>　　　　稍加分析便可看出，如果把每个盘块(扇区)的容量增大n倍，则磁盘的最大容量便可增加n倍。但要增加盘块的容量是不方便和不灵活的。为此，引入了簇(cluster)的概念。</p></blockquote><ol start="2"><li><p>FAT16   </p><blockquote><p>FAT12对磁盘容量限制的原因在于， FAT12表中的表项有限制，亦即最多只允许4096个。这样，随着磁盘容量的增加，必定会引起簇的大小和簇内碎片也随之增加。</p></blockquote></li><li><p>FAT32</p><blockquote><p>由于FAT16表的长度只有65 535项，随着磁盘容量的增加，簇的大小也必然会随之增加，为了减少簇内零，也就应当增加FAT表的长度，为此需要再增加FAT表的宽度，这样也就由FAT16演变为FAT32。</p></blockquote></li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216210802006.png" alt="FAT中簇的大小与最大分区的对应关系"></p><h3 id="NTFS的文件组织方式"><a href="#NTFS的文件组织方式" class="headerlink" title="NTFS的文件组织方式"></a>NTFS的文件组织方式</h3><ol><li><p>NTFS新特征</p><blockquote><p>NTFS(New Technology File System)是一个专门为Windows NT开发的、全新的文件系统，并适用于Windows 2000/XP及后续的Windows OS。</p></blockquote></li><li><p>磁盘组织</p><blockquote><p>NTFS是以簇作为磁盘空间分配和回收的基本单位的。一个文件占用若干个簇，一个簇只属于一个文件。这样，在为文件分配磁盘空间时，就无须知道盘块的大小，只要根据不同的磁盘容量，选择相应大小的簇，即使NTFS具有了与磁盘物理块大小无关的独立性。</p></blockquote></li><li><p>文件的组织</p><blockquote><p>在NTFS中，以卷为单位，将一个卷中的所有文件信息、目录信息以及可用的未分配空间信息，都以文件记录的方式记录在一张主控文件表MFT(Master File Table)中，该表是NTFS卷结构的中心，从逻辑上讲，卷中的每个文件作为一条记录，在MFT表中占有一行，其中还包括MFT自己的这一行。每行大小固定为1 KB，每行称为该行所对应文件的元数据(metadata)，也称为文件控制字。</p></blockquote></li></ol><h3 id="索引组织方式"><a href="#索引组织方式" class="headerlink" title="索引组织方式"></a>索引组织方式</h3><ol><li><p>单级索引组织方式</p><blockquote><p>链接组织方式虽然解决了连续组织方式所存在的问题(即不便于随机访问)，但又出现了另外两个问题，即：① 不能支持高效的直接存取，要对一个较大的文件进行存取，须在FAT中顺序地查找许多盘块号；② FAT需占用较大的内存空间，由于一个文件所占用盘块的盘块号是随机地分布在FAT中的，因而只有将整个FAT调入内存，才能保证在FAT中找到一个文件的所有盘块号。 </p></blockquote></li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216212054965.png" alt="索引分配方式"></p><ol start="2"><li><p>多级索引组织方式</p><blockquote><p>在为一个大文件分配磁盘空间时，如果所分配出去的盘块的盘块号已经装满一个索引块时，OS须再为该文件分配另一个索引块，用于将以后继续为之分配的盘块号记录于其中。依此类推，再通过链指针将各索引块按序链接起来。</p></blockquote></li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216212325421.png" alt="两级索引分配"></p><ol start="3"><li><p>增量式索引组织方式</p><ol><li>增量式索引组织方式的基本思想</li></ol><blockquote><p>为了能较全面地照顾到小、中、大及特大型作业，可以采取多种组织方式来构成文件的物理结构。如果盘块的大小为1 KB或4 KB，对于小文件(如1 KB～10 KB或4 KB～40 KB)而言，最多只会占用10个盘块，为了能提高对数量众多的小型作业的访问速度，最好能将它们的每一个盘块地址都直接放入文件控制块FCB(或索引结点)中，这样就可以直接从FCB中获得该文件的盘块地址。</p></blockquote></li></ol><h2 id="8-3-提高磁盘I-O速度的途径"><a href="#8-3-提高磁盘I-O速度的途径" class="headerlink" title="8.3  提高磁盘I/O速度的途径"></a>8.3  提高磁盘I/O速度的途径</h2><p>(1) 改进文件的目录结构以及检索目录的方法来减少对目录的查找时间；</p><p>(2) 选取好的文件存储结构，以提高对文件的访问速度；</p><p>(3) 提高磁盘的I/O速度，能将文件中的数据快速地从磁盘传送到内存中，或者相反。</p><p>提高磁盘I/O速度的其它方法</p><ol><li>提前读</li><li>延迟写</li><li>优化物理块的分布</li></ol><h3 id="虚拟盘"><a href="#虚拟盘" class="headerlink" title="虚拟盘"></a>虚拟盘</h3><blockquote><p>由于访问内存的速度远高于访问磁盘的速度，于是有人试图利用内存空间去仿真磁盘，形成所谓虚拟盘，又称为RAM盘。该盘的设备驱动程序也可以接受所有标准的磁盘操作，但这些操作的执行不是在磁盘上而是在内存中。这对用户都是透明的。 </p></blockquote><h2 id="8-4-提高磁盘可靠性的技术"><a href="#8-4-提高磁盘可靠性的技术" class="headerlink" title="8.4  提高磁盘可靠性的技术"></a>8.4  提高磁盘可靠性的技术</h2><h3 id="第一级容错技术SFT-Ⅰ"><a href="#第一级容错技术SFT-Ⅰ" class="headerlink" title="第一级容错技术SFT-Ⅰ"></a>第一级容错技术SFT-Ⅰ</h3><blockquote><p>第一级容错技术(SFT-Ⅰ)是最基本的一种磁盘容错技术，主要用于防止因磁盘表面缺陷所造成的数据丢失。它包含双份目录、双份文件分配表及写后读校验等措施。</p></blockquote><ol><li><p>双份目录和双份文件分配表</p></li><li><p>热修复重定向和写后读校验</p></li></ol><h3 id="第二级容错技术SFT-Ⅱ"><a href="#第二级容错技术SFT-Ⅱ" class="headerlink" title="第二级容错技术SFT-Ⅱ"></a>第二级容错技术SFT-Ⅱ</h3><ol><li><p>磁盘镜像(Disk Mirroring)</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216213337506.png" alt="磁盘镜像示意图"></p></li><li><p>磁盘双工(Disk Duplexing)</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216213409701.png" alt="磁盘双工示意图"></p></li></ol><h2 id="8-5-数据一致性控制"><a href="#8-5-数据一致性控制" class="headerlink" title="8.5  数据一致性控制"></a>8.5  数据一致性控制</h2><blockquote><p>在实际应用中，经常会在多个文件中都含有同一个数据。所谓数据一致性问题是指，保存在多个文件中的同一数据，在任何情况下都必需能保证相同。</p></blockquote><h3 id="事务的定义"><a href="#事务的定义" class="headerlink" title="事务的定义"></a>事务的定义</h3><blockquote><p>事务是用于访问和修改各种数据项的一个程序单位。事务也可以被看做是一系列相关读和写操作。</p></blockquote><h3 id="恢复算法"><a href="#恢复算法" class="headerlink" title="恢复算法"></a>恢复算法</h3><blockquote><p>由于一组被事务Ti修改的数据以及它们被修改前和修改后的值都能在事务记录表中找到，因此，利用事务记录表系统能处理任何故障而不致使故障造成非易失性存储器中信息的丢失。恢复算法可利用以下两个过程：</p><p>　　(1)  undo〈Ti〉。该过程把所有被事务Ti修改过的数据恢复为修改前的值。</p><p>　　(2)  redo〈Ti〉。该过程能把所有被事务Ti修改过的数据设置为新值。</p></blockquote><h3 id="检查点"><a href="#检查点" class="headerlink" title="检查点"></a>检查点</h3><p>检查点(Check Points)的作用</p><blockquote><p>如前所述，当系统发生故障时，必须去检查整个Log表，以确定哪些事务需要利用redo〈Ti〉过程去设置新值，而哪些事务又需要利用undo〈Ti〉过程去恢复数据的旧值。由于在系统中可能存在着许多并发执行的事务，因而在事务记录表中就会有许多事务执行操作的记录。随着时间的推移，记录的数据也会愈来愈多。因此，一旦系统发生故障，在事务记录表中的记录清理起来就非常费时。</p></blockquote><h2 id="习题-5"><a href="#习题-5" class="headerlink" title="习题"></a>习题</h2><ol><li><p>目前常用的外存有哪几种组织方式? </p></li><li><p>由连续组织方式所形成的顺序文件的主要优缺点是什么? 它主要应用于何种场合? </p></li><li><p>在链接式文件中常用哪种链接方式? 为什么? </p></li><li><p>在文件分配表中为什么要引入“簇”的概念? 以“簇”为基本的分配单位有什么好处? </p></li><li><p>简要说明为什么要从FAT12发展为FAT16? 又进一步要发展为FAT32? </p></li><li><p>试解释逻辑簇号和虚拟簇号这两个名词，NTFS是如何将它们映射到文件的物理地址上的? </p></li><li><p>在MS-DOS中有两个文件A和B，A占用11、12、16和14四个盘块；B占用13、18和20三个盘块。试画出在文件A和B中各盘块间的链接情况及FAT的情况。</p></li><li><p>NTFS文件系统中的文件所采用的是什么样的物理结构? </p></li><li><p>假定一个文件系统的组织方式与MS-DOS相似，在FAT中可有64 K个指针，磁盘的盘块大小为512 B，试问该文件系统能否指引一个512 MB的磁盘? </p></li><li><p>为了快速访问，又易于更新，当数据为以下形式时，应选用何种文件组织方式? (1) 不经常更新，经常随机访问；(2) 经常更新，经常按一定顺序访问；(3) 经常更新，经常随机访问。</p></li><li><p>在UNIX 中，如果一个盘块的大小为1 KB，每个盘块号占4 个字节，即每块可放256个地址。请转换下列文件的字节偏移量为物理地址：(1)  9999；(2)  18000；(3)  420000。</p></li><li><p>什么是索引文件? 为什么要引入多级索引? </p></li><li><p>试说明增量式索引组织方式。</p></li><li><p>有一计算机系统利用图8-19所示的位示图来管理空闲盘块。盘块的大小为1 KB，现要为某文件分配两个盘块，试说明盘块的具体分配过程。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216213925504.png" alt="image-20210216213925504"></p><ol start="15"><li><p>某操作系统的磁盘文件空间共有500块，若用字长为32位的位示图管理盘空间，试问：</p><p>(1) 位示图需多少个字?</p><p>(2) 第i字第j位对应的块号是多少? </p><p>(3) 给出申请/归还一块的工作流程。</p></li><li><p>对空闲磁盘空间的管理常采用哪几种分配方式? 在UNIX系统中是采用何种分配方式?</p></li><li><p>可从哪几方面来提高对文件的访问速度?</p></li><li><p>何谓磁盘高速缓存? 在设计磁盘高速缓存时需要考虑哪些问题? </p></li><li><p>可以采取哪几种方式将磁盘高速缓存中的数据传送给请求者进程? </p></li><li><p>何谓提前读和延迟写?</p></li><li><p>试说明廉价磁盘冗余阵列RAID的主要优点。</p></li><li><p>在第一级系统容错技术中，包括哪些容错措施? 什么是写后读校验? </p></li><li><p>在第二级系统容错技术中，包括哪些容错措施? 请画图说明之。</p></li><li><p>具有容错功能的集群系统的主要工作模式有哪几种? 请简要说明之。</p></li><li><p>为什么要在系统中配置后备系统? 目前常用做后备系统的设备有哪几种? </p></li><li><p>何谓事务? 如何保证事务的原子性?</p></li><li><p>引入检查点的目的是什么? 引入检查点后又如何进行恢复处理? </p></li><li><p>为何引入共享锁? 如何用互斥锁或共享锁来实现事务的顺序性? </p></li><li><p>当系统中有重复文件时，如何保证它们的一致性?</p></li><li><p>如何检查盘块号的一致性? 检查时可能出现哪几种情况? </p></li></ol><h1 id="第九章-操作系统接口"><a href="#第九章-操作系统接口" class="headerlink" title="第九章    操作系统接口"></a>第九章    操作系统接口</h1><h2 id="9-1-用户接口"><a href="#9-1-用户接口" class="headerlink" title="9.1  用户接口"></a>9.1  用户接口</h2><blockquote><p>不同的OS，其联机用户接口是不同的，即它们的命令形式和用法各不相同，甚至在同一系统中，命令的不同形式构成了不同的用户界面，一般可分为字符显示式联机用户接口和图形化联机用户接口两类。</p></blockquote><ul><li>命令行方式</li><li>批命令方式</li></ul><h3 id="图形化联机用户接口"><a href="#图形化联机用户接口" class="headerlink" title="图形化联机用户接口"></a>图形化联机用户接口</h3><ol><li><p>图形用户接口GUI(Graphics User Interface)的引入</p><blockquote><p>虽然用户可以通过命令行方式和批命令方式，取得操作系统的服务，并控制自己的作业运行，但却要牢记各种命令的动词和参数，必须严格按规定的格式输入命令，而且不同操作系统所提供的命令语言的词法、语法、语义及表达形式是不一样的，这样既不方便又花费时间。于是，图形化用户接口GUI(Graphics User Interface)便应运而生。</p></blockquote></li><li><p>使用WIMP技术</p><blockquote><p>GUI采用了图形化的操作界面，使用WIMP 技术，该技术将窗口(Window)、图标(Icon)、菜单(Menu)、鼠标(Pointing device)和面向对象技术等集成在一起，引入形象的各种图标，将系统的各项功能、各种应用程序和文件直观、逼真地表示出来，形成一个图文并茂的视窗操作环境。</p></blockquote></li></ol><h2 id="9-2-Shell-命令语言"><a href="#9-2-Shell-命令语言" class="headerlink" title="9.2  Shell 命令语言"></a>9.2  Shell 命令语言</h2><blockquote><p>在Shell命令语言中提供了许多不同形式的命令，并允许在一条命令行中有多个命令。如果在一条命令行中仅有一个命令，就把它称为简单命令。实际上，一条简单命令便是一个能完成某种功能的目标程序的名字。</p></blockquote><h3 id="Shell的种类"><a href="#Shell的种类" class="headerlink" title="Shell的种类"></a>Shell的种类</h3><p>现在流行的Shell有多种类型，下面简单介绍几种流行的Shell：</p><p>　　(1)  Bourne Shell。</p><p>　　(2)  C Shell。C Shell是一种比B Shell更适于编程的Shell，是标准BSD(Berkeley System Distribution)命令解释。</p><p>　　(3)  Korn Shell。Korn Shell集合了C Shell和B Shell的优点，并且和B Shell完全兼容，它的名字是K Sh。</p><h2 id="9-3-联机命令接口的实现"><a href="#9-3-联机命令接口的实现" class="headerlink" title="9.3  联机命令接口的实现"></a>9.3  联机命令接口的实现</h2><h3 id="MS-DOS解释程序"><a href="#MS-DOS解释程序" class="headerlink" title="MS-DOS解释程序"></a>MS-DOS解释程序</h3><blockquote><p>命令解释程序的作用　　在联机操作方式下，终端处理程序把用户键入的信息送键盘缓冲区中保存。一旦用户键入回车符，便立即把控制权交给命令解释程序。显然，对于不同的命令，应有能完成特定功能的命令处理程序与之对应。可见，命令解释程序的主要作用是在屏幕上给出提示符，请用户键入命令，然后读入该命令，识别命令，再转到相应命令处理程序的入口地址，把控制权交给该处理程序去执行，并将处理结果送屏幕上显示。若用户键入的命令有错，而命令解释程序未能予以识别，或在执行中间出现问题时，则应显示出某一出错信息。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216223155031.png" alt="image-20210216223155031"></p><h3 id="二叉树结构的命令行树"><a href="#二叉树结构的命令行树" class="headerlink" title="二叉树结构的命令行树"></a>二叉树结构的命令行树</h3><ol><li>命令表型结点</li></ol><blockquote><p>Shell命令解释程序按命令行语句的结构顺序进行检查，每当遇到“；”及“&amp;”分隔符时便为之建立一个命令表型结点，将分隔符左面部分构成该结点的左子树，右面部分构成右子树。例如下面的命令行所构成的命令树如图9-3所示：　　　Command 1；Command 2；&amp; Command 3</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216223316742.png" alt="命令表型结点及其左、右子树"></p><ol start="2"><li>管道文件型结点</li></ol><blockquote><p>当Shell命令解释程序遇到管道算符“Ι”时，先为之建立一个管道文件型结点，再将分隔符左面部分构成该结点的左子树，右面部分构成右子树。例如对下面的命令行所构成的命令树如图9-4所示：　　　　Command 1 Ι Command 2 Ι  Command 3</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216223408163.png" alt="管道文件型结点及其左、右子树"></p><h3 id="Linux命令解释程序的工作流程"><a href="#Linux命令解释程序的工作流程" class="headerlink" title="Linux命令解释程序的工作流程"></a>Linux命令解释程序的工作流程</h3><blockquote><p>在Linux系统中，系统初启后，内核为每个终端用户建立一个进程，去执行Shell解释程序。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216223450326.png" alt="Shell基本执行过程及父子进程之间的关系"></p><h2 id="9-4-系统调用的概念和类型"><a href="#9-4-系统调用的概念和类型" class="headerlink" title="9.4  系统调用的概念和类型"></a>9.4  系统调用的概念和类型</h2><p>主要用于对进程控制的系统调用有：(1) 创建和终止进程的系统调用。(2) 获得和设置进程属性的系统调用。(3) 等待某事件出现的系统调用。</p><h3 id="进程通信类系统调用"><a href="#进程通信类系统调用" class="headerlink" title="进程通信类系统调用"></a>进程通信类系统调用</h3><blockquote><p>在单处理机系统中，OS经常采用消息传递方式和共享存储区方式。当采用消息传递方式时，在通信前需先打开一个连接。为此，应由源进程发出一条打开连接的系统调用，而目标进程则应利用接受连接的系统调用表示同意进行通信；然后，在源和目标进程之间便可开始通信。可以利用发送消息的系统调用或者用接收消息的系统调用来交换信息。通信结束后，还须再利用关闭连接的系统调用结束通信。</p></blockquote><h3 id="POSIX标准"><a href="#POSIX标准" class="headerlink" title="POSIX标准"></a>POSIX标准</h3><p>目前许多操作系统都提供了上面所介绍的各种类型的系统调用，实现的功能也相类似，但在实现的细节和形式方面却相差很大，这种差异给实现应用程序与操作系统平台的无关性带来了很大的困难。为解决这一问题，国际标准化组织ISO给出的有关系统调用的国际标准POSIX1003.1(Portable Operating System IX)，也称为“基于UNIX的可移植操作系统接口”。</p><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216223851342.png" alt="UNIX/Linux系统程序、库函数、系统调用的分层关系"></p><h2 id="9-5-UNIX系统调用"><a href="#9-5-UNIX系统调用" class="headerlink" title="9.5  UNIX系统调用"></a>9.5  UNIX系统调用</h2><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><blockquote><p>该类系统调用包括创建进程的系统调用fork、终止进程的系统调用exit、等待子进程结束的系统调用wait等十多条。</p></blockquote><p>(1) 创建进程(fork)。　　(2) 终止进程(exit)。</p><p>(1) 执行一个文件(exec)。　　(2) 等待子进程结束(wait)。</p><p>(1) 获得进程ID。　　(2) 获得用户ID。　　(3) 进程暂停(pause)。</p><p>(1) 创建文件(creat)。 　　(2) 删除文件。</p><p>(1) 打开文件(open)。　　(2) 关闭文件(close)。</p><p>(1) 连接(link)。 　　(2) 去连接(unlink)。</p><h2 id="9-6-系统调用的实现"><a href="#9-6-系统调用的实现" class="headerlink" title="9.6  系统调用的实现"></a>9.6  系统调用的实现</h2><blockquote><p>系统调用的实现与一般过程调用的实现相比，两者间有很大差异。对于系统调用，控制是由原来的用户态转换为系统态，这是借助于陷入机制来完成的，在该机制中包括陷入硬件机构及陷入处理程序两部分。 </p></blockquote><h3 id="UNIX系统调用的实现"><a href="#UNIX系统调用的实现" class="headerlink" title="UNIX系统调用的实现"></a>UNIX系统调用的实现</h3><ol><li><p>CPU环境保护</p><blockquote><p>当用户程序处在用户态，且在执行系统调用命令(即CHMK命令)之前，应在用户空间提供系统调用所需的参数表，并将该参数表的地址送入R0寄存器。在执行CHMK命令后，处理机将由用户态转为核心态，并由硬件自动地将处理机状态长字(PSL)、程序计数器(PC)和代码操作数(code)压入用户核心栈，继而从中断和陷入向量表中取出trap.S的入口地址，然后便转入中断和陷入总控程序trap.S中执行。 </p></blockquote></li><li><p>AP和FP指针</p><blockquote><p>为了实现系统调用的嵌套使用，在系统中还设置了两个指针，其一是系统调用参数表指针AP，用于指示正在执行的系统调用所需参数表的地址，通常是把该地址放在某个寄存器中，例如放在R12中；再者，还须设置一个调用栈帧指针。所谓调用栈帧(或简称栈帧)，是指每个系统调用需要保存而被压入用户核心栈的所有数据项；而栈帧指针FP则是用于指示本次系统调用所保存的数据项。每当出现新的系统调用时，还须将AP和FP303压入栈中，图9-9示出了在trap.S总控程序执行后用户核心栈的情况。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216224322686.png" alt="用户核心栈"></p></li></ol><h3 id="Linux系统调用"><a href="#Linux系统调用" class="headerlink" title="Linux系统调用"></a>Linux系统调用</h3><blockquote><p>与UNIX相似，Linux采用类似技术实现系统调用。Linux系统在CPU的保护模式下提供了四个特权级别，目前内核都只用到了其中的两个特权级别，分别为“特权级0”(即内核态)和“特权级3”(即用户态)。用户对系统调用不能任意拦截和修改，以保证内核的安全性。Linux最多可以有190个系统调用。应用程序和Shell需要通过系统调用机制访问Linux内核(功能)。</p></blockquote><h2 id="习题-6"><a href="#习题-6" class="headerlink" title="习题"></a>习题</h2><ol><li><p>操作系统用户接口中包括哪几种接口? 它们分别适用于哪种情况? </p></li><li><p>什么是WIMP 技术? 它被应用到何种场合? </p></li><li><p>联机命令通常有哪几种类型? 每种类型中包括哪些主要命令? </p></li><li><p>什么是输入输出重定向? 举例说明之。</p></li><li><p>何谓管道联接? 举例说明之。</p></li><li><p>为了将已存文件改名，应用什么UNIX命令? </p></li><li><p>要想将工作目录移到目录树的某指定结点上，应使用什么命令? </p></li><li><p>如果希望把file 1的内容附加到原有的文件file 2的末尾，应用什么命令?</p></li><li><p>试比较mail和write命令的作用有何不同。</p></li><li><p>联机命令接口由哪几部分组成? </p></li><li><p>终端设备处理程序的主要作用是什么? 它具有哪些功能? </p></li><li><p>命令解释程序的主要功能是什么? </p></li><li><p>试说明MS-DOS的命令处理程序COMMAND.COM的工作流程。</p></li><li><p>Shell命令有何特点? 它对命令解释程序有何影响。</p></li><li><p>试举例说明如何建立二叉树结构的命令行树。</p></li><li><p>试比较一般的过程调用与系统调用。</p></li><li><p>系统调用有哪几种类型?</p></li><li><p>如何设置系统调用所需的参数? </p></li><li><p>试说明系统调用的处理步骤。</p></li><li><p>为什么在访问文件之前，要用open系统调用先打开该文件?</p></li><li><p>在UNIX系统中是否设置了专门用来删除文件的系统调用? 为什么? </p></li><li><p>在IPC软件包中包含哪几种通信机制? 在每种通信机制中设置了哪些系统调用? </p></li><li><p>trap.S是什么程序? 它完成哪些主要功能? </p></li><li><p>在UNIX系统内，被保护的CPU环境中包含哪些数据项? </p></li><li><p>trap.C是什么程序? 它将完成哪些处理? </p></li><li><p>为方便转入系统调用处理程序，在UNIX系统中配置了什么样的数据结构? </p></li></ol><h1 id="第十章-多处理机操作系统"><a href="#第十章-多处理机操作系统" class="headerlink" title="第十章    多处理机操作系统"></a>第十章    多处理机操作系统</h1><h2 id="10-1-多处理机系统的基本概念"><a href="#10-1-多处理机系统的基本概念" class="headerlink" title="10.1  多处理机系统的基本概念"></a>10.1  多处理机系统的基本概念</h2><blockquote><p>进入70年代后，已采用多处理机的系统结构从提高运行速度方面来增强系统性能。实际上，多处理机系统MPS就是采用并行技术，令多个单CPU同时运行，使总体的计算能力比单CPU计算机系统的强大得多。</p></blockquote><ol><li><p> CPU的时钟频率问题</p></li><li><p> 增加系统吞吐量</p></li><li><p> 节省投资</p></li><li><p> 提高系统可靠性</p></li></ol><h2 id="10-2-多处理机系统的结构"><a href="#10-2-多处理机系统的结构" class="headerlink" title="10.2  多处理机系统的结构"></a>10.2  多处理机系统的结构</h2><h3 id="UMA多处理机系统的结构"><a href="#UMA多处理机系统的结构" class="headerlink" title="UMA多处理机系统的结构"></a>UMA多处理机系统的结构</h3><blockquote><p>所谓UMA(Uniform Memory Access)，即统一内存访问(也称一致性内存访问)。在这种结构的多处理机系统中，各处理器单元(CPU)在功能和结构上都是相同的，在处理上没有主从之分(即属于SMP系统)，每个处理机可以访问不同模块中的存储器单元，并且对于每个存储器单元的读写速度是相同的。</p></blockquote><ol><li><p>基于单总线的SMP结构</p><blockquote><p>如图(a)所示，在这种结构的系统中，把多个处理器与一个集中的存储器相连，所有处理器都通过公用总线访问同一个系统的物理存储器，每个处理机可以访问不同存储器模块中的单元，以及与其它处理机进行通信。这就意味着该系统只需要运行操作系统的一个拷贝，因此，为单处理器系统编写的应用程序可以直接移植到这种系统中运行。</p></blockquote></li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216225515874.png" alt="基于总线的SMP结构"></p><ol start="2"><li><p>使用多层总线的SMP结构</p><blockquote><p>对于单总线结构中存在的总线瓶颈问题的另一个解决方法，就是使用多层总线结构。在这种结构中，系统中所有的CPU不仅共享一个高速缓存，还有一个本地私有的存储器，如图(c)所示。</p></blockquote></li><li><p>使用单级交叉开关的系统结构</p><blockquote><p>在这种结构中，利用电话交换系统中使用交叉开关(crossbar switch)的方法，如图10-2所示，将系统中所有的CPU与存储器结点，通过交叉开关阵列相互连接。每个交叉开关均为其中两个结点(CPU与存储器模块)之间提供一条专用连接通路，从而避免了在多个 CPU之间因为要访问存储器模块所形成的对链路的争夺。而且，在任意两个结点(CPU与CPU)之间也都能找到一个交叉开关，在它们之间建立专用连接通路，方便CPU之间的通信。</p></blockquote></li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216225640081.png" alt="使用交叉开关的UMA多处理机系统"></p><ol start="4"><li><p>使用多级交换网络的系统结构</p><blockquote><p>图(a)是一个最简单的2 × 2交叉开关，它有两个输入和两个输出。送入任一输入的信息可以交换到任一输出线上。可以将这样的多级小交换开关分级连接起来，形成多级交叉开关网络，如图10-3(b)所示，图中的1A、2A、…、1B、…、3C等都是一个交叉开关级，在相邻级别的交叉开关之间设置固定的物理连接。处理机和存储器模块分别位于网络的两侧，每台处理机通过网络访问存储器模块，而且所有处理机的访问方式都是一样的，机会均等。</p></blockquote></li></ol><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216225717796.png" alt="使用多级交换网络的SMP结构示意图"></p><h3 id="NUMA结构和特点"><a href="#NUMA结构和特点" class="headerlink" title="NUMA结构和特点"></a>NUMA结构和特点</h3><blockquote><p>所谓NUMA(Nonuniform-Memory- Access)，即非统一内存访问(也称非一致存储访问)。在这种结构的多处理机系统中，其访问时间随存储字的位置不同而变化，系统中的公共存储期和分布在所有处理机的本地存储器共同构成了系统的全局地址空间，可被所有的处理机访问。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216225818363.png" alt="NUMA结构的多处理机系统"></p><h3 id="CC-NUMA构造方法"><a href="#CC-NUMA构造方法" class="headerlink" title="CC-NUMA构造方法"></a>CC-NUMA构造方法</h3><blockquote><p>目前，对于构造大型的CC-NUMA多处理机系统，最常用的方法是采用基于目录的多处理机。其基本思想是：对于系统中每一个CPU所拥有的若干高速缓存单元，都以一定数量的单元为一组，构成一个高速缓存块，为每个CPU配置一张高速缓存块目录表(下简称目录表)，对每一个高速缓存块的位置和状态进行记录和维护。每个CPU的每条访问存储器单元的指令都必须首先查询这张表，从中判断该存储器单元是否在目录表中，即其内容是否已存在于某个高速缓存块中，并进行相应的操作。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mikeygithub/jsDeliver@master/resource/img/image-20210216225903018.png" alt="CC-NUMA构造方法"></p><h2 id="10-3-多处理机操作系统的特征与分类"><a href="#10-3-多处理机操作系统的特征与分类" class="headerlink" title="10.3  多处理机操作系统的特征与分类"></a>10.3  多处理机操作系统的特征与分类</h2><h3 id="1-并行性"><a href="#1-并行性" class="headerlink" title="1. 并行性"></a>1. 并行性</h3><blockquote><p>单机多道程序系统的主要目标是，为用户建立多个虚拟处理机以及模拟多处理机环境，使程序能并发执行，从而改善资源利用率并提高系统的吞吐量。而在多处理机系统中，由于存在着多个实处理机，已经可使多个进程并行执行，因此，多处理机操作系统的主要目标应是进一步增强程序执行的并行性程度，以获得更高的系统吞吐量及提高系统的运算速度。</p></blockquote><h3 id="2-分布性"><a href="#2-分布性" class="headerlink" title="2. 分布性"></a>2. 分布性</h3><p>在单处理机系统中，所有的任务都是在同一台处理机上执行的，所有的文件和资源也都处于操作系统的统一管理之下。然而对于多处理机系统而言，无论其结构如何，在任务、资源和对它们的控制等方面，都呈现出一定的分布性。这种情况，在松散耦合系统中表现尤其明显：</p><p>　　(1) 任务的分布</p><p>　　(2) 资源的分布</p><p>　　(3) 控制的分布</p><h3 id="3-机间的通信和同步性"><a href="#3-机间的通信和同步性" class="headerlink" title="3. 机间的通信和同步性"></a>3. 机间的通信和同步性</h3><blockquote><p>在多处理机系统中，不仅在同一处理机上并发执行的诸进程之间，由于资源共享和相互合作的需要，须实现同步和通信，而且在不同处理机上运行的不同进程之间，也需要进行同步和通信，除了它们之间也需要资源共享和相互合作外，这对于提高程序执行的并行性、改善系统的性能至关重要。 </p></blockquote><h3 id="4-可重构性"><a href="#4-可重构性" class="headerlink" title="4. 可重构性"></a>4. 可重构性</h3><blockquote><p>为提高系统的可靠性，在多处理机系统中，应使操作系统具有这样的能力：当系统中某个处理机或存储模块等资源发生故障时，系统能够自动切除故障资源，换上备份资源，并对系统进行重构，保证其能继续工作。</p></blockquote><h2 id="10-4-进程同步"><a href="#10-4-进程同步" class="headerlink" title="10.4  进程同步"></a>10.4  进程同步</h2><blockquote><p>在多处理机系统中，进程间的同步显得更加重要和复杂。在紧密耦合多处理机中，多个处理机是共享存储的，因此各处理机上的诸进程之间可通过该共享存储来实现同步，进程间的同步实现相对也比较简单。但对于松散耦合的多处理机，进程之间的同步可能采取的方式较多且复杂，可分为集中式和分布式两大类同步方式。</p></blockquote><h3 id="中心同步实体"><a href="#中心同步实体" class="headerlink" title="中心同步实体"></a>中心同步实体</h3><blockquote><p>为实现进程之间的同步，系统中必须有相应的同步实体(Synchronizing Entity)，如硬件锁、信号量以及进程等。如果该同步实体满足下述两个条件，则称之为中心同步实体：</p><p>　(1) 具有唯一的名字，并且为彼此必须同步的所有进程所知道。</p><p>　(2) 在任何时刻，这些进程中的任何一个都可以访问该同步实体。</p></blockquote><h3 id="集中式同步机构"><a href="#集中式同步机构" class="headerlink" title="集中式同步机构"></a>集中式同步机构</h3><blockquote><p>基于中心同步实体所构成的所有同步机构被称为集中式同步机构。相应的，其它同步机构则称为非集中式同步机构。 </p></blockquote><h3 id="自旋锁-spin-lock"><a href="#自旋锁-spin-lock" class="headerlink" title="自旋锁(spin lock)"></a>自旋锁(spin lock)</h3><ol><li><p>自旋锁的引入</p><blockquote><p>如前所述，在单CPU系统中，CPU在执行读—修改—写原语操作时，是具有原子性的，即在执行这些操作时不会被中断。保证原子性的基本方法是，在执行原语之前关中断，完成后再开中断。 </p></blockquote></li><li><p>实现对总线互斥访问的方法</p><blockquote><p>利用自旋锁实现对总线互斥访问的方法是：在总线上设置一个自旋锁，该锁最多只能被一个内核进程持有。 </p></blockquote></li><li><p>自旋锁与信号量的主要差别</p><blockquote><p>自旋锁与信号量的主要差别在于：<code>自旋锁可避免调用进程阻塞</code>。由于自旋锁使用者一般保持锁时间非常短，调用进程用“旋转”来取代进程切换。而我们知道进程切换需要花费一定开销，并且会使高速缓存失效，直接影响系统的性能，因此将自旋锁应用于对总线资源的竞争，其效率远高于信号量机制，且在多处理器环境中非常方便。</p></blockquote></li><li><p>自旋锁的类型</p><blockquote><p>使用自旋锁的基本形式为：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">spin_lock(&amp;lock)；<br><span class="hljs-comment">/*临界区代码；*/</span>　　　　<br>……<br>spin_unlock(&amp;lock)；<br></code></pre></td></tr></table></figure><h3 id="RCU-Read-Copy-Update-锁"><a href="#RCU-Read-Copy-Update-锁" class="headerlink" title="RCU(Read-Copy-Update)锁"></a>RCU(Read-Copy-Update)锁</h3><blockquote><p>RCU锁用来解决读者—写者问题。对于被RCU保护的共享文件(数据结构)，无论读者和写者，都是以读的方式对其进行访问的，对于读者而言，不需要获得任何锁就可以访问它，对于写者而言，在访问它时，先制作该文件的一个副本，只对副本上的内容进行修改，然后使用一个回调(callback)机制，即向系统中一个称为垃圾收集器的机构注册一个回调函数。最后，在适当的时机，由垃圾收集器调用写者注册的回调函数，把指向原来数据的指针重新指向新的被修改的数据，完成最后的数据释放或修改操作。</p></blockquote></li></ol><h2 id="10-5-多处理机系统的进程调度"><a href="#10-5-多处理机系统的进程调度" class="headerlink" title="10.5  多处理机系统的进程调度"></a>10.5  多处理机系统的进程调度</h2><blockquote><p>在多处理机系统中，进程的调度与系统结构有关。例如，在同构型系统中，由于所有的处理机都是相同的，因而可将进程分配到任一处理机上运行； 但对于非对称多处理机系统，则只能把进程分配到适合于它运行的处理机上去执行。</p></blockquote><h2 id="10-6-网络操作系统"><a href="#10-6-网络操作系统" class="headerlink" title="10.6  网络操作系统"></a>10.6  网络操作系统</h2><blockquote><p>计算机网络是指通过数据通信系统把地理上分散的自主计算机系统连接起来，以达到数据通信和资源共享目的的一种计算机系统。自主计算机是指具有独立处理能力的计算机。可见，计算机网络是在计算机技术和通信技术高度发展的基础上相结合的产物，是多个处理机通过通信线路互连而构成的松散耦合系统，通信系统为计算机之间的数据传送提供最重要的支持。</p></blockquote><p>计算机网络的组成</p><blockquote><p>计算机网络从构造的物理结构而言，是通过包括星形、树形、公用总线形、环形和网状形等不同的拓扑结构，将地理上分散的计算机连接起来的网络。而从逻辑结构而言，计算机网络是由三个部分组成：　　(1) 通信子网：　　(2) 资源子网：　　(3) 网络协议： </p></blockquote><h2 id="10-7-分布式文件系统"><a href="#10-7-分布式文件系统" class="headerlink" title="10.7  分布式文件系统"></a>10.7  分布式文件系统</h2><h3 id="分布式系统的特征"><a href="#分布式系统的特征" class="headerlink" title="分布式系统的特征"></a>分布式系统的特征</h3><blockquote><p>分布式系统(distributed system)，是基于软件实现的一种多处理机系统，是多个处理机通过通信线路互连而构成的松散耦合系统，系统的处理和控制功能分布在各个处理机上。换言之，是利用软件系统方式构建在计算机网络之上的一种多处理机系统。</p></blockquote><blockquote><p>与前面所述的多种多处理机系统(包括多处理机和多计算机等)相比，分布式系统的不同在于：① 分布式系统中的每个节点都是一台独立的计算机，并配置有完整的外部设备；② 分布式系统中节点的耦合程度更为分散，地理分布区域更加广阔；③ 分布式系统中的每个节点可以运行不同的操作系统，每个节点拥有自己的文件系统，除了本节点的管理外，还有其它多个机构对其实施管理。</p></blockquote><blockquote><p>　　对分布式系统有很多不同的定义，比如：“一个分布式系统是一些独立的计算机集合，但是对这个系统的用户来说，系统就像一台计算机一样”，或者，“分布式系统是能为用户自动管理资源的网络操作系统，由它调用完成用户任务所需要的资源，而整个网络像一个大的计算机系统一样对用户是透明的。”等等，归纳起来，分布式系统应具有以下几个主要特征：　　(1) 分布性。　　(2) 透明性。　　(3) 同一性。　　(4) 全局性。系 </p></blockquote><h3 id="分布式系统的优点"><a href="#分布式系统的优点" class="headerlink" title="分布式系统的优点"></a>分布式系统的优点</h3><p>(1) 计算能力强。(2) 易于实现共享。(3) 方便通信。(4) 可靠性高。(5) 可扩充性好。</p><h2 id="习题-7"><a href="#习题-7" class="headerlink" title="习题"></a>习题</h2><ol><li><p>为什么说依靠提高CPU时钟频率提高计算机运算速度的方法已接近了极限? </p></li><li><p>试说明引入多处理机系统的原因有哪些。</p></li><li><p>什么是紧密耦合MPS和松弛耦合MPS? </p></li><li><p> 何谓UMA多处理机结构? 它又可进一步分为哪几种结构? </p></li><li><p>试说明基于单总线的SMP结构和多层总线的SMP结构。</p></li><li><p>试说明使用单级交叉开关的系统结构和使用多级交换网络的系统结构。</p></li><li><p>什么是NUMA多处理机系统结构? 它有何特点? </p></li><li><p>为什么要为每个CPU配置高速缓冲区? CC-NUMA和NC-NUMA所代表的是什么? </p></li><li><p>试说明多处理机操作系统的特征。</p></li><li><p>试比较在单处理机OS和多处理机OS中的进程管理</p></li><li><p>试比较在单处理机OS和多处理机OS中的内存管理。</p></li><li><p>何谓中心同步实体、集中式同步机构和非集中式同步机构? </p></li><li><p> 集中式同步算法具有哪些特征和缺点? </p></li><li><p> 一个完全分布式同步算法应具有哪些特征? </p></li><li><p> 如何利用自旋锁来实现对总线的互斥访问? 它与信号量的主要差别是什么?</p></li><li><p>为什么要引入读—拷贝—修改锁(RCU)? 它对读者和写者分别有何影响? </p></li><li><p> 何谓二进制指数补偿算法? 它所存在的主要问题是什么?</p></li><li><p>时间邮戳定序机构和事件计数的作用是什么? </p></li><li><p>什么是任务流时间和调度流时间? 请举例说明之。</p></li><li><p>试比较多处理机系统中静态分配方式和动态分配方式。</p></li><li><p> 何谓自调度方式? 该方式有何优缺点? </p></li><li><p>何谓成组调度方式? 按进程平均分配处理器和按线程平均分配处理器时间的方法，哪个更有效?  </p></li><li><p>试说明采用专用处理器分配方式的理由。</p></li><li><p>在动态调度方式中，调度的主要责任是什么? 在调度时应遵循哪些原则? </p></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="">计算机操作系统(第4版)汤小丹</a></p><p><a href="">《《操作系统真象还原》》</a></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
